<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"jackhuang021.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"mac","show_result":true},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false,"trigger":"auto"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="cpufreq动态调频cpufreq概述Linux Kernel主要通过三类机制来实现SMP（Symmetric Multiprocessing，对称多核）系统CPU core的电源管理：  cpu hotplug: 根据应用场景来up&#x2F;down CPU cpuidle framework: 当cpu上没有可执行任务时，就会进入空闲状态 cpufreq framework: 根据使用场景">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux Cpufreq框架">
<meta property="og:url" content="https://jackhuang021.github.io/archives/fbf46cf3.html">
<meta property="og:site_name" content="Jack&#39;s Home">
<meta property="og:description" content="cpufreq动态调频cpufreq概述Linux Kernel主要通过三类机制来实现SMP（Symmetric Multiprocessing，对称多核）系统CPU core的电源管理：  cpu hotplug: 根据应用场景来up&#x2F;down CPU cpuidle framework: 当cpu上没有可执行任务时，就会进入空闲状态 cpufreq framework: 根据使用场景">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/JackHuang021/images/master/20221124110212.png">
<meta property="og:image" content="https://raw.githubusercontent.com/JackHuang021/images/master/20230103092146.png">
<meta property="og:image" content="https://raw.githubusercontent.com/JackHuang021/images/master/20230103094857.png">
<meta property="og:image" content="https://raw.githubusercontent.com/JackHuang021/images/master/20230105110139.png">
<meta property="og:image" content="https://raw.githubusercontent.com/JackHuang021/images/master/20230307162438.png">
<meta property="og:image" content="https://raw.githubusercontent.com/JackHuang021/images/master/20230222105334.png">
<meta property="og:image" content="https://raw.githubusercontent.com/JackHuang021/images/master/20230103174117.png">
<meta property="og:image" content="https://raw.githubusercontent.com/JackHuang021/images/master/20221216104706.png">
<meta property="og:image" content="https://raw.githubusercontent.com/JackHuang021/images/master/20230105152415.png">
<meta property="article:published_time" content="2022-11-24T02:23:01.000Z">
<meta property="article:modified_time" content="2023-12-01T07:21:24.844Z">
<meta property="article:author" content="Jack">
<meta property="article:tag" content="Linux">
<meta property="article:tag" content="Cpufreq">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/JackHuang021/images/master/20221124110212.png">


<link rel="canonical" href="https://jackhuang021.github.io/archives/fbf46cf3.html">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://jackhuang021.github.io/archives/fbf46cf3.html","path":"archives/fbf46cf3.html","title":"Linux Cpufreq框架"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Linux Cpufreq框架 | Jack's Home</title>
  

  <script src="/js/third-party/analytics/baidu-analytics.js"></script>
  <script async src="https://hm.baidu.com/hm.js?cf1cdec429059a964c53024129e34116"></script>







  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Jack's Home</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#cpufreq%E5%8A%A8%E6%80%81%E8%B0%83%E9%A2%91"><span class="nav-number">1.</span> <span class="nav-text">cpufreq动态调频</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#cpufreq%E6%A6%82%E8%BF%B0"><span class="nav-number">1.1.</span> <span class="nav-text">cpufreq概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#cpufreq%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84"><span class="nav-number">1.2.</span> <span class="nav-text">cpufreq软件架构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#cpufreq%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">1.3.</span> <span class="nav-text">cpufreq初始化</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E9%85%8D%E7%BD%AE"><span class="nav-number">1.3.1.</span> <span class="nav-text">内核配置</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#OPP%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">1.3.2.</span> <span class="nav-text">OPP表初始化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#cpufreq%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B"><span class="nav-number">1.3.3.</span> <span class="nav-text">cpufreq初始化过程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#cpufreq-drviver%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">1.3.4.</span> <span class="nav-text">cpufreq drviver初始化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#governor%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B"><span class="nav-number">1.3.5.</span> <span class="nav-text">governor初始化过程</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ondemand%E8%B0%83%E8%8A%82%E5%99%A8"><span class="nav-number">1.4.</span> <span class="nav-text">ondemand调节器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#schedutil%E8%B0%83%E8%8A%82%E5%99%A8"><span class="nav-number">1.5.</span> <span class="nav-text">schedutil调节器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#schedutil%E9%A2%91%E7%8E%87%E8%AE%A1%E7%AE%97%E8%BF%87%E7%A8%8B"><span class="nav-number">1.5.1.</span> <span class="nav-text">schedutil频率计算过程</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#EAS%E8%83%BD%E6%BA%90%E6%84%9F%E7%9F%A5%E8%B0%83%E5%BA%A6"><span class="nav-number">2.</span> <span class="nav-text">EAS能源感知调度</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#EAS%E6%95%B4%E4%BD%93%E6%A1%86%E6%9E%B6"><span class="nav-number">2.1.</span> <span class="nav-text">EAS整体框架</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CPU%E7%AE%97%E5%8A%9B%E5%BD%92%E4%B8%80%E5%8C%96%E8%BF%87%E7%A8%8B"><span class="nav-number">2.2.</span> <span class="nav-text">CPU算力归一化过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#EAS%E4%BB%A3%E7%A0%81%E7%9B%B8%E5%85%B3%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-number">2.3.</span> <span class="nav-text">EAS代码相关结构体</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#perf-domain%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">2.4.</span> <span class="nav-text">perf_domain初始化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#EAS%E8%83%BD%E9%87%8F%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95"><span class="nav-number">2.5.</span> <span class="nav-text">EAS能量计算方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#EAS%E7%9A%84%E8%B0%83%E5%BA%A6%E8%BF%87%E7%A8%8B"><span class="nav-number">2.6.</span> <span class="nav-text">EAS的调度过程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#EAS-Mainline"><span class="nav-number">3.</span> <span class="nav-text">EAS Mainline</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Jack"
      src="/images/favicon-32x32.png">
  <p class="site-author-name" itemprop="name">Jack</p>
  <div class="site-description" itemprop="description">build a better world</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">27</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">52</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/JackHuang021" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;JackHuang021" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:jackhuang021@gmail.com" title="E-Mail → mailto:jackhuang021@gmail.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jackhuang021.github.io/archives/fbf46cf3.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/favicon-32x32.png">
      <meta itemprop="name" content="Jack">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jack's Home">
      <meta itemprop="description" content="build a better world">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Linux Cpufreq框架 | Jack's Home">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Linux Cpufreq框架
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-11-24 10:23:01" itemprop="dateCreated datePublished" datetime="2022-11-24T10:23:01+08:00">2022-11-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-12-01 15:21:24" itemprop="dateModified" datetime="2023-12-01T15:21:24+08:00">2023-12-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>75k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1:08</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h3 id="cpufreq动态调频"><a href="#cpufreq动态调频" class="headerlink" title="cpufreq动态调频"></a>cpufreq动态调频</h3><h4 id="cpufreq概述"><a href="#cpufreq概述" class="headerlink" title="cpufreq概述"></a>cpufreq概述</h4><p>Linux Kernel主要通过三类机制来实现SMP（Symmetric Multiprocessing，对称多核）系统CPU core的电源管理：</p>
<ul>
<li>cpu hotplug: 根据应用场景来up&#x2F;down CPU</li>
<li>cpuidle framework: 当cpu上没有可执行任务时，就会进入空闲状态</li>
<li>cpufreq framework: 根据使用场景和系统负荷来调整CPU的电压和频率</li>
</ul>
<span id="more"></span>
<p>cpufreq framework的核心功能，是通过调整CPU core的电压或频率，兼顾系统的性能和功耗。在不需要高性能时，降低电压或频率，以降低功耗；在需要高性能时，提高电压或频率，以提高性能。</p>
<p>cpufreq framework中的几个重要概念：</p>
<ol>
<li>policy（策略）：同一个power domain CPU动态调频策略，包含了当前使用的governor和cpufreq driver</li>
<li>governor（调节器）：决定如何计算合适的频率或电压</li>
<li>cpufreq driver（调频驱动）：实现真正的调频执行工作（与平台相关）</li>
</ol>
<p>除此之外，cpufreq还包含cpufreq stats, cpufreq qos, cpufreq notifier等辅助模块，其主要功能如下：</p>
<ol>
<li>cpufreq stats：用于搜集cpufreq的一些统计数据，如CPU在每个频点下的运行时间，总的频率切换次数等</li>
<li>cpufreq qos：用于cpufreq频率限制值发生改变时，向cpufreq模块发送一个通知，将频率限制值调整到新的值</li>
<li>cpufreq notifer：对CPU频率切换或policy对应governor发生改变感兴趣的模块，可以向cpufreq注册一个通知，当以上事件发生时，cpufreq将会向其发送相关通知</li>
</ol>
<p>常用的governor类型</p>
<ol>
<li>Performance：总是将CPU置于最高性能的状态，即硬件所支持的最高频率、电压</li>
<li>Powersaving：总是将CPU置于最节能的状态，即硬件所支持的最低频率、电压</li>
<li>Ondemand：设置CPU负载的阈值T，当负载低于T时，调节至一个刚好能够满足当前负载需求的最低频&#x2F;最低压；当负载高于T时，立即提升到最高性能状态</li>
<li>Conservative：跟Ondemand策略类似，设置CPU负载的阈值T，当负载低于T时，调节至一个刚好能够满足当前负载需求的最低频&#x2F;最低压；但当负载高于T时，不是立即设置为最高性能状态，而是逐级升高主频&#x2F;电压</li>
<li>Userspace：将控制接口通过sysfs开放给用户，由用户进行自定义策略</li>
<li>Schedutil：这是从Linux-4.7版本开始才引入的策略，其原理是根据调度器所提供的CPU利用率信息进行电压&#x2F;频率调节，EAS使用schedutil进行调频</li>
</ol>
<p>sysfs用户层接口，目录位于<code>/sys/devices/system/cpu/cpufreq/policy</code><br><img src="https://raw.githubusercontent.com/JackHuang021/images/master/20221124110212.png"></p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">cpuinfo_max_freq</td>
<td align="left">硬件所支持的最高频率</td>
</tr>
<tr>
<td align="left">cpuinfo_min_freq</td>
<td align="left">硬件所支持的最低频率</td>
</tr>
<tr>
<td align="left">affected_cpus</td>
<td align="left">该policy影响到哪些cpu（没显示offline状态的cpu）</td>
</tr>
<tr>
<td align="left">related_cpus</td>
<td align="left">该policy影响到的所有cpu，包括offline状态的cpu</td>
</tr>
<tr>
<td align="left">scaling_max_freq</td>
<td align="left">该policy支持调整的最高频率</td>
</tr>
<tr>
<td align="left">scaling_min_freq</td>
<td align="left">该policy支持调整的最低频率</td>
</tr>
<tr>
<td align="left">scaling_cur_freq</td>
<td align="left">policy当前设置的频率</td>
</tr>
<tr>
<td align="left">scaling_available_governors</td>
<td align="left">当前系统支持的governor</td>
</tr>
<tr>
<td align="left">scaling_available_frequencies</td>
<td align="left">支持的调频频率</td>
</tr>
<tr>
<td align="left">scaling_driver</td>
<td align="left">当前使用的调频驱动</td>
</tr>
<tr>
<td align="left">scaling_governor</td>
<td align="left">当前使用的governor</td>
</tr>
<tr>
<td align="left">scaling_setspeed</td>
<td align="left">在userspace模式下才能使用，手动设置频率</td>
</tr>
</tbody></table>
<h4 id="cpufreq软件架构"><a href="#cpufreq软件架构" class="headerlink" title="cpufreq软件架构"></a>cpufreq软件架构</h4><p><img src="https://raw.githubusercontent.com/JackHuang021/images/master/20230103092146.png"><br>cpufreq core（可以理解为对policy的操作）：把一些公共的逻辑和接口代码抽象出来</p>
<ul>
<li><code>cpufreq</code>作为所有cpu设备的一个功能，注册到了<code>cpu_subsys</code>总线上</li>
<li>对上以sysfs的形式向用户空间提供统一的接口，以notifier的形式向其他driver提供频率变化的通知</li>
<li>对下提供CPU频率和电压控制的驱动框架，方便底层driver的开发，同时提供governor框架，用于实现不同的频率调整机制</li>
<li>内部封装各种逻辑，主要围绕<code>struct cpufreq_policy</code> <code>struct cpufreq_driver</code> <code>struct cpufreq_governor</code>三个数据结构进行</li>
</ul>
<p>kernel使用<code>struct cpufreq_policy</code>用来抽象cpufreq，它代表了一个CPU簇的cpufreq的属性</p>
<p><code>cpufreq_policy</code>结构体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cpufreq_cpuinfo</span> &#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		max_freq;			<span class="comment">// cpu最大频率</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		min_freq;			<span class="comment">// cpu最小频率</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* in 10^(-9) s = nanoseconds */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		transition_latency;	<span class="comment">// cpu频率转换时间 单位：ns</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cpufreq_policy</span> &#123;</span></span><br><span class="line">	<span class="comment">/* CPUs sharing clock, require sw coordination */</span></span><br><span class="line">	<span class="keyword">cpumask_var_t</span>		cpus;	<span class="comment">/* Online CPUs only */</span></span><br><span class="line">	<span class="keyword">cpumask_var_t</span>		related_cpus; <span class="comment">/* Online + Offline CPUs */</span></span><br><span class="line">	<span class="keyword">cpumask_var_t</span>		real_cpus; <span class="comment">/* Related and present */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		shared_type; <span class="comment">/* ACPI: ANY or ALL affected CPUs</span></span><br><span class="line"><span class="comment">						should set cpufreq */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		cpu;    <span class="comment">/* cpu managing this policy, must be online */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">clk</span>		*<span class="title">clk</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cpufreq_cpuinfo</span>	<span class="title">cpuinfo</span>;</span><span class="comment">/* see above */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		min;    <span class="comment">/* in kHz */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		max;    <span class="comment">/* in kHz */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		cur;    <span class="comment">/* in kHz, only needed if cpufreq</span></span><br><span class="line"><span class="comment">					 * governors are used */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cpufreq_governor</span>	*<span class="title">governor</span>;</span> <span class="comment">/* see below */</span></span><br><span class="line">	<span class="keyword">void</span>			*governor_data;</span><br><span class="line">	<span class="keyword">char</span>			last_governor[CPUFREQ_NAME_LEN]; <span class="comment">/* last governor used */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span>	<span class="title">update</span>;</span> <span class="comment">/* if update_policy() needs to be</span></span><br><span class="line"><span class="comment">					 * called, but you&#x27;re in IRQ context */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cpufreq_user_policy</span> <span class="title">user_policy</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cpufreq_frequency_table</span>	*<span class="title">freq_table</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">cpufreq_table_sorting</span> <span class="title">freq_table_sorted</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>        <span class="title">policy_list</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kobject</span>		<span class="title">kobj</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">completion</span>	<span class="title">kobj_unregister</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Preferred average time interval between consecutive invocations of</span></span><br><span class="line"><span class="comment">	 * the driver to set the frequency for this policy.  To be set by the</span></span><br><span class="line"><span class="comment">	 * scaling driver (0, which is the default, means no preference).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		transition_delay_us;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Remote DVFS flag (Not added to the driver structure as we don&#x27;t want</span></span><br><span class="line"><span class="comment">	 * to access another structure from scheduler hotpath).</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Should be set if CPUs can do DVFS on behalf of other CPUs from</span></span><br><span class="line"><span class="comment">	 * different cpufreq policies.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">bool</span>			dvfs_possible_from_any_cpu;</span><br><span class="line"></span><br><span class="line">	 <span class="comment">/* Cached frequency lookup from cpufreq_driver_resolve_freq. */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> cached_target_freq;</span><br><span class="line">	<span class="keyword">int</span> cached_resolved_idx;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* cpufreq-stats */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cpufreq_stats</span>	*<span class="title">stats</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* For cpufreq driver&#x27;s internal use */</span></span><br><span class="line">	<span class="keyword">void</span>			*driver_data;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>driver/cpufreq/cpufreq.c</code>中定义了一个全局的percpu变量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">DEFINE_PER_CPU</span><span class="params">(struct cpufreq_policy *, cpufreq_cpu_data)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这里对应E2000 sysfs中3个policy文件夹，两个小核使用1个policy，另外两个大核分别对应1个policy<br><img src="https://raw.githubusercontent.com/JackHuang021/images/master/20230103094857.png"></p>
<h4 id="cpufreq初始化"><a href="#cpufreq初始化" class="headerlink" title="cpufreq初始化"></a>cpufreq初始化</h4><h5 id="内核配置"><a href="#内核配置" class="headerlink" title="内核配置"></a>内核配置</h5><p>在kconfig中(CPU Power Management -&gt; CPU Frequency scaling)可以对cpufreq进行配置，可以配置支持的governor及系统默认的governor，以及cpufreq调频driver，例如Phytium E2000 5.10内核的配置如下，默认使用schedutil governor，根据调度器所提供的CPU利用率信息进行电压&#x2F;频率调节，EAS能源感知依赖该governor工作：<br><img src="https://raw.githubusercontent.com/JackHuang021/images/master/20230105110139.png"></p>
<h5 id="OPP表初始化"><a href="#OPP表初始化" class="headerlink" title="OPP表初始化"></a>OPP表初始化</h5><p>OPP表的定义：域中每个设备支持的电压和频率的离散元组的集合称为Operating Performance Points（OPP）,内核设备树opp文档<code>Documentation/devicetree/bindings/opp/opp.txt</code>  </p>
<p>假设一个CPU设备支持如下的电压和频率关系：<br>{300MHz at minimum voltage of 1V}<br>{800MHz at minimum voltage of 1.2V}<br>{1GHz at minimum voltage of 1.3V}<br>用OPP表示就可以用{Hz,  uV}方式表示如下:<br>{300000000, 1000000}<br>{800000000, 1200000}<br>{1000000000, 1300000}</p>
<p>Linux内核使用opp layer库来管理opp table，具体的结构如下：</p>
<p>Linux内核使用<code>struct dev_pm_opp</code>结构表示设备的一OPP</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// drivers/opp/opp.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dev_pm_opp</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">node</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kref</span> <span class="title">kref</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">bool</span> available;</span><br><span class="line">	<span class="keyword">bool</span> dynamic;</span><br><span class="line">	<span class="keyword">bool</span> turbo;</span><br><span class="line">	<span class="keyword">bool</span> suspend;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> pstate;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> rate;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> level;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dev_pm_opp_supply</span> *<span class="title">supplies</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dev_pm_opp_icc_bw</span> *<span class="title">bandwidth</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> clock_latency_ns;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dev_pm_opp</span> **<span class="title">required_opps</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">opp_table</span> *<span class="title">opp_table</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">np</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_FS</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">dentry</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Linux内核opp layer库的结构如下<br><img src="https://raw.githubusercontent.com/JackHuang021/images/master/20230307162438.png"></p>
<p>这里初始化的就是各个性能域（即不同cluster）的OPP表，在E2000平台中是通过SCMI的Performace domain management protocol协议获取PERFORMANCE_DESCRIBE_LEVELS这个参数表，具体的协议实现源码在<code>drivers/firmware/arm_scmi/perf.c</code>里面，<code>perf.c</code>实现了SCMI的Performance domain managment protocol，scmi cpufreq_drvier也是通过<code>perf_ops</code>函数集进行调频</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/linux/scmi_protocol.h</span></span><br><span class="line"><span class="comment">// 抽象描述scmi协议的结构体，相应的ops操作集对应scmi的一个协议</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">scmi_handle</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">scmi_revision_info</span> *<span class="title">version</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">scmi_perf_ops</span> *<span class="title">perf_ops</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">scmi_clk_ops</span> *<span class="title">clk_ops</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">scmi_power_ops</span> *<span class="title">power_ops</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">scmi_sensor_ops</span> *<span class="title">sensor_ops</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">scmi_reset_ops</span> *<span class="title">reset_ops</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">scmi_notify_ops</span> *<span class="title">notify_ops</span>;</span></span><br><span class="line">	<span class="comment">/* for protocol internal use */</span></span><br><span class="line">	<span class="comment">// perf_priv存放括performance domain数据，包含opp表等</span></span><br><span class="line">	<span class="keyword">void</span> *perf_priv;</span><br><span class="line">	<span class="keyword">void</span> *clk_priv;</span><br><span class="line">	<span class="keyword">void</span> *power_priv;</span><br><span class="line">	<span class="keyword">void</span> *sensor_priv;</span><br><span class="line">	<span class="keyword">void</span> *reset_priv;</span><br><span class="line">	<span class="keyword">void</span> *notify_priv;</span><br><span class="line">	<span class="keyword">void</span> *system_priv;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// include/linux/scmi_protocol.h</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct scmi_perf_ops - represents the various operations provided</span></span><br><span class="line"><span class="comment"> *	by SCMI Performance Protocol</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @limits_set: sets limits on the performance level of a domain</span></span><br><span class="line"><span class="comment"> * @limits_get: gets limits on the performance level of a domain</span></span><br><span class="line"><span class="comment"> * @level_set: sets the performance level of a domain</span></span><br><span class="line"><span class="comment"> * @level_get: gets the performance level of a domain</span></span><br><span class="line"><span class="comment"> * @device_domain_id: gets the scmi domain id for a given device</span></span><br><span class="line"><span class="comment"> * @transition_latency_get: gets the DVFS transition latency for a given device</span></span><br><span class="line"><span class="comment"> * @device_opps_add: adds all the OPPs for a given device</span></span><br><span class="line"><span class="comment"> * @freq_set: sets the frequency for a given device using sustained frequency</span></span><br><span class="line"><span class="comment"> *	to sustained performance level mapping</span></span><br><span class="line"><span class="comment"> * @freq_get: gets the frequency for a given device using sustained frequency</span></span><br><span class="line"><span class="comment"> *	to sustained performance level mapping</span></span><br><span class="line"><span class="comment"> * @est_power_get: gets the estimated power cost for a given performance domain</span></span><br><span class="line"><span class="comment"> *	at a given frequency</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">scmi_perf_ops</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> (*limits_set)(<span class="keyword">const</span> struct scmi_handle *handle, u32 domain,</span><br><span class="line">			  u32 max_perf, u32 min_perf);</span><br><span class="line">	<span class="keyword">int</span> (*limits_get)(<span class="keyword">const</span> struct scmi_handle *handle, u32 domain,</span><br><span class="line">			  u32 *max_perf, u32 *min_perf);</span><br><span class="line">	<span class="keyword">int</span> (*level_set)(<span class="keyword">const</span> struct scmi_handle *handle, u32 domain,</span><br><span class="line">			 u32 level, <span class="keyword">bool</span> poll);</span><br><span class="line">	<span class="keyword">int</span> (*level_get)(<span class="keyword">const</span> struct scmi_handle *handle, u32 domain,</span><br><span class="line">			 u32 *level, <span class="keyword">bool</span> poll);</span><br><span class="line">	<span class="keyword">int</span> (*device_domain_id)(struct device *dev);</span><br><span class="line">	<span class="keyword">int</span> (*transition_latency_get)(<span class="keyword">const</span> struct scmi_handle *handle,</span><br><span class="line">				      struct device *dev);</span><br><span class="line">	<span class="keyword">int</span> (*device_opps_add)(<span class="keyword">const</span> struct scmi_handle *handle,</span><br><span class="line">			       struct device *dev);</span><br><span class="line">	<span class="keyword">int</span> (*freq_set)(<span class="keyword">const</span> struct scmi_handle *handle, u32 domain,</span><br><span class="line">			<span class="keyword">unsigned</span> <span class="keyword">long</span> rate, <span class="keyword">bool</span> poll);</span><br><span class="line">	<span class="keyword">int</span> (*freq_get)(<span class="keyword">const</span> struct scmi_handle *handle, u32 domain,</span><br><span class="line">			<span class="keyword">unsigned</span> <span class="keyword">long</span> *rate, <span class="keyword">bool</span> poll);</span><br><span class="line">	<span class="keyword">int</span> (*est_power_get)(<span class="keyword">const</span> struct scmi_handle *handle, u32 domain,</span><br><span class="line">			     <span class="keyword">unsigned</span> <span class="keyword">long</span> *rate, <span class="keyword">unsigned</span> <span class="keyword">long</span> *power);</span><br><span class="line">	<span class="keyword">bool</span> (*fast_switch_possible)(<span class="keyword">const</span> struct scmi_handle *handle,</span><br><span class="line">				     struct device *dev);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// scmi performance domain management protocol(性能域管理相关协议 0x13), messageid: 0x03</span></span><br><span class="line"><span class="comment">// scmi opp结构体定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">scmi_opp</span> &#123;</span></span><br><span class="line">	u32 perf;		<span class="comment">// 性能级别，单位KHz</span></span><br><span class="line">	u32 power;		<span class="comment">// 当前性能级别的功耗</span></span><br><span class="line">	u32 trans_latency_us;	<span class="comment">// 切换延时</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// drivers/firmware/arm_scmi/perf.c</span></span><br><span class="line"><span class="comment">// scmi performance domain management protocol(性能域管理相关协议 0x13)对应操作函数集</span></span><br><span class="line"><span class="comment">// scmi cpufreq_driver 主要利用这个函数集进行调频相关操作</span></span><br><span class="line"><span class="comment">// 对应Performace domain management protocol各个message_id</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">scmi_perf_ops</span> <span class="title">perf_ops</span> =</span> &#123;</span><br><span class="line">	.limits_set = scmi_perf_limits_set,</span><br><span class="line">	.limits_get = scmi_perf_limits_get,</span><br><span class="line">	.level_set = scmi_perf_level_set,</span><br><span class="line">	.level_get = scmi_perf_level_get,</span><br><span class="line">	.device_domain_id = scmi_dev_domain_id,</span><br><span class="line">	.transition_latency_get = scmi_dvfs_transition_latency_get,</span><br><span class="line">	.device_opps_add = scmi_dvfs_device_opps_add,</span><br><span class="line">	.freq_set = scmi_dvfs_freq_set,</span><br><span class="line">	.freq_get = scmi_dvfs_freq_get,</span><br><span class="line">	.est_power_get = scmi_dvfs_est_power_get,</span><br><span class="line">	.fast_switch_possible = scmi_fast_switch_possible,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在这个宏进行SCMI performance domain management protocol协议的初始化</span></span><br><span class="line">DEFINE_SCMI_PROTOCOL_REGISTER_UNREGISTER(SCMI_PROTOCOL_PERF, perf)</span><br><span class="line"></span><br><span class="line"><span class="comment">// drivers/firmware/arm_scmi/common.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFINE_SCMI_PROTOCOL_REGISTER_UNREGISTER(id, name) \</span></span><br><span class="line"><span class="meta">int __init scmi_##name##_register(void) \</span></span><br><span class="line"><span class="meta">&#123; \</span></span><br><span class="line"><span class="meta">	return scmi_protocol_register((id), &amp;scmi_##name##_protocol_init); \</span></span><br><span class="line"><span class="meta">&#125; \</span></span><br><span class="line"><span class="meta">\</span></span><br><span class="line"><span class="meta">void __exit scmi_##name##_unregister(void) \</span></span><br><span class="line"><span class="meta">&#123; \</span></span><br><span class="line"><span class="meta">	scmi_protocol_unregister((id)); \</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="comment">// 展开该宏</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> __init <span class="title">scmi_perf_register</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> scmi_protocol_register(SCMI_PROTOCOL_PER, &amp;scmi_perf_protocol_init);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化过程中调用了scmi_perf_protocol_init();</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">scmi_perf_protocol_init</span><span class="params">(struct scmi_handle *handle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> domain;</span><br><span class="line">	u32 version;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">scmi_perf_info</span> *<span class="title">pinfo</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取当前perf domain management协议版本</span></span><br><span class="line">	scmi_version_get(handle, SCMI_PROTOCOL_PERF, &amp;version);</span><br><span class="line"></span><br><span class="line">	dev_dbg(handle-&gt;dev, <span class="string">&quot;Performance Version %d.%d\n&quot;</span>,</span><br><span class="line">		PROTOCOL_REV_MAJOR(version), PROTOCOL_REV_MINOR(version));</span><br><span class="line"></span><br><span class="line">	pinfo = devm_kzalloc(handle-&gt;dev, <span class="keyword">sizeof</span>(*pinfo), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!pinfo)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	<span class="comment">// 通过PROTOCOL_ATTRIBUTES(0x01)这个命令获取domain id个数</span></span><br><span class="line">	<span class="comment">// 还有share memory的地址和长度</span></span><br><span class="line">	scmi_perf_attributes_get(handle, pinfo);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 分配perf_dom_info结构体内存，这里面的opp成员会存放OPP表</span></span><br><span class="line">	<span class="comment">// 对于E2000Q这里会分配3个大小的dom_info</span></span><br><span class="line">	pinfo-&gt;dom_info = devm_kcalloc(handle-&gt;dev, pinfo-&gt;num_domains,</span><br><span class="line">				       <span class="keyword">sizeof</span>(*pinfo-&gt;dom_info), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!pinfo-&gt;dom_info) </span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 遍历每个performance_domain，获取performance domain的属性和performance level参数</span></span><br><span class="line">	<span class="keyword">for</span> (domain = <span class="number">0</span>; domain &lt; pinfo-&gt;num_domains; domain++) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">perf_dom_info</span> *<span class="title">dom</span> =</span> pinfo-&gt;dom_info + domain;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 获取performance domain属性</span></span><br><span class="line">		scmi_perf_domain_attributes_get(handle, domain, dom);</span><br><span class="line">		<span class="comment">// 获取performance level参数即opp表</span></span><br><span class="line">		<span class="comment">// 填充perf_dom_info内的opp结构体</span></span><br><span class="line">		scmi_perf_describe_levels_get(handle, domain, dom);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (dom-&gt;perf_fastchannels)</span><br><span class="line">			scmi_perf_domain_init_fc(handle, domain, &amp;dom-&gt;fc_info);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	scmi_register_protocol_events(handle,</span><br><span class="line">				      SCMI_PROTOCOL_PERF, SCMI_PROTO_QUEUE_SZ,</span><br><span class="line">				      &amp;perf_event_ops, perf_events,</span><br><span class="line">				      ARRAY_SIZE(perf_events),</span><br><span class="line">				      pinfo-&gt;num_domains);</span><br><span class="line"></span><br><span class="line">	pinfo-&gt;version = version;</span><br><span class="line">	handle-&gt;perf_ops = &amp;perf_ops;</span><br><span class="line">	<span class="comment">// perf_priv保存performance domain信息，后续会用到perf_priv</span></span><br><span class="line">	handle-&gt;perf_priv = pinfo;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在初始化阶段，<code>scmi_perf_protocol_init</code>只会将固件里面的perf domains信息保存到handle-&gt;perf_priv里面，此时还并没有将opp表注册到cpu设备上</p>
<p>接下来在scmi调频驱动初始化的过程中，会调用scmi的device_opps_add()接口初始化，即调用<code>scmi_dvfs_device_opps_add()</code>，在这个里面才会生成cpu的opp_table</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">scmi_dvfs_device_opps_add</span><span class="params">(<span class="keyword">const</span> struct scmi_handle *handle,</span></span></span><br><span class="line"><span class="params"><span class="function">				     struct device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> idx, ret, domain;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> freq;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">scmi_opp</span> *<span class="title">opp</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">perf_dom_info</span> *<span class="title">dom</span>;</span></span><br><span class="line">	<span class="comment">// 获取pref_priv地址，在这里面取opp数据</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">scmi_perf_info</span> *<span class="title">pi</span> =</span> handle-&gt;perf_priv;</span><br><span class="line">	<span class="comment">// 这个domain是从设备树里面取到的，设备树cpu节点的clock属性会带一个domain编号</span></span><br><span class="line">	domain = scmi_dev_domain_id(dev);</span><br><span class="line">	<span class="keyword">if</span> (domain &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> domain;</span><br><span class="line">	<span class="comment">// 取当前CPU的perf domain信息</span></span><br><span class="line">	dom = pi-&gt;dom_info + domain;</span><br><span class="line">	<span class="comment">// struct perf_dom_info结构体里面一共16个opp表</span></span><br><span class="line">	<span class="comment">// 这里没对opp进行限制，可能有数组越界的问题</span></span><br><span class="line">	<span class="keyword">for</span> (opp = dom-&gt;opp, idx = <span class="number">0</span>; idx &lt; dom-&gt;opp_count; idx++, opp++) &#123;</span><br><span class="line">		freq = opp-&gt;perf * dom-&gt;mult_factor;</span><br><span class="line">		<span class="comment">// 这里面第一次会为opp_table分配内存，这里只将频率加进opp table里了</span></span><br><span class="line">		ret = dev_pm_opp_add(dev, freq, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">			dev_warn(dev, <span class="string">&quot;failed to add opp %luHz\n&quot;</span>, freq);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">while</span> (idx-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">				freq = (--opp)-&gt;perf * dom-&gt;mult_factor;</span><br><span class="line">				dev_pm_opp_remove(dev, freq);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> ret;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>详细看一下<code>dev_pm_opp_add()</code>的过程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// drviers/opp/opp.h</span></span><br><span class="line"><span class="comment">// opp_table结构体的定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">opp_table</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">node</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">blocking_notifier_head</span> <span class="title">head</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">dev_list</span>;</span>			<span class="comment">// 共享该opp表的设备链表</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">opp_list</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kref</span> <span class="title">kref</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">lock</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">np</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> clock_latency_ns_max;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* For backward compatibility with v1 bindings */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> voltage_tolerance_v1;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> parsed_static_opps;</span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">opp_table_access</span> <span class="title">shared_opp</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dev_pm_opp</span> *<span class="title">suspend_opp</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">genpd_virt_dev_lock</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> **<span class="title">genpd_virt_devs</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">opp_table</span> **<span class="title">required_opp_tables</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> required_opp_count;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> *supported_hw;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> supported_hw_count;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *prop_name;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">clk</span> *<span class="title">clk</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">regulator</span> **<span class="title">regulators</span>;</span></span><br><span class="line">	<span class="keyword">int</span> regulator_count;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">icc_path</span> **<span class="title">paths</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> path_count;</span><br><span class="line">	<span class="keyword">bool</span> enabled;</span><br><span class="line">	<span class="keyword">bool</span> genpd_performance_state;</span><br><span class="line">	<span class="keyword">bool</span> is_genpd;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> (*set_opp)(struct dev_pm_set_opp_data *data);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dev_pm_set_opp_data</span> *<span class="title">set_opp_data</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_FS</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">dentry</span>;</span></span><br><span class="line">	<span class="keyword">char</span> dentry_name[NAME_MAX];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// drivers/opp/core.c</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The root of the list of all opp-tables. All opp_table structures branch off</span></span><br><span class="line"><span class="comment"> * from here, with each opp_table containing the list of opps it supports in</span></span><br><span class="line"><span class="comment"> * various states of availability.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// opp_tables是opp_table链表的头节点</span></span><br><span class="line">LIST_HEAD(opp_tables);</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">opp_device</span> *_<span class="title">find_opp_dev</span>(<span class="title">const</span> <span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>,</span></span><br><span class="line"><span class="class">							<span class="keyword">struct</span> <span class="title">opp_table</span> *<span class="title">opp_table</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">opp_device</span> *<span class="title">opp_dev</span>;</span></span><br><span class="line">	<span class="comment">// 从opp_table的dev_list中的dev与当前dev进行对比</span></span><br><span class="line">	list_for_each_entry(opp_dev, &amp;opp_table-&gt;dev_list, node)</span><br><span class="line">		<span class="keyword">if</span> (opp_dev-&gt;dev == dev)</span><br><span class="line">			<span class="keyword">return</span> opp_dev;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">opp_table</span> *_<span class="title">find_opp_table_unlocked</span>(<span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">opp_table</span> *<span class="title">opp_table</span>;</span></span><br><span class="line">	<span class="keyword">bool</span> found;</span><br><span class="line">	<span class="comment">// 在opp_tables中进行遍历查找当前设备对应的opp_table</span></span><br><span class="line">	list_for_each_entry(opp_table, &amp;opp_tables, node) &#123;</span><br><span class="line">		mutex_lock(&amp;opp_table-&gt;lock);</span><br><span class="line">		found = !!_find_opp_dev(dev, opp_table);</span><br><span class="line">		mutex_unlock(&amp;opp_table-&gt;lock);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (found) &#123;</span><br><span class="line">			<span class="comment">// opp_table的引用计数加一</span></span><br><span class="line">			_get_opp_table_kref(opp_table);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> opp_table;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ERR_PTR(-ENODEV);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">opp_table</span> *_<span class="title">opp_get_opp_table</span>(<span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>, <span class="title">int</span> <span class="title">index</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">opp_table</span> *<span class="title">opp_table</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Hold our table modification lock here */</span></span><br><span class="line">	mutex_lock(&amp;opp_table_lock);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 第一次运行到这里的时候，应该是找不到opp_table的，需要进行创建</span></span><br><span class="line">	opp_table = _find_opp_table_unlocked(dev);</span><br><span class="line">	<span class="keyword">if</span> (!IS_ERR(opp_table))</span><br><span class="line">		<span class="keyword">goto</span> unlock;</span><br><span class="line"></span><br><span class="line">	opp_table = _managed_opp(dev, index);</span><br><span class="line">	<span class="keyword">if</span> (opp_table) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!_add_opp_dev_unlocked(dev, opp_table)) &#123;</span><br><span class="line">			dev_pm_opp_put_opp_table(opp_table);</span><br><span class="line">			opp_table = ERR_PTR(-ENOMEM);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">goto</span> unlock;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 对该设备创建opp表</span></span><br><span class="line">	opp_table = _allocate_opp_table(dev, index);</span><br><span class="line"></span><br><span class="line">unlock:</span><br><span class="line">	mutex_unlock(&amp;opp_table_lock);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> opp_table;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">struct opp_table *<span class="title">dev_pm_opp_get_opp_table</span><span class="params">(struct device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> _opp_get_opp_table(dev, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dev_pm_opp_add</span><span class="params">(struct device *dev, <span class="keyword">unsigned</span> <span class="keyword">long</span> freq, <span class="keyword">unsigned</span> <span class="keyword">long</span> u_volt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">opp_table</span> *<span class="title">opp_table</span>;</span></span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">	opp_table = dev_pm_opp_get_opp_table(dev);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(opp_table)) </span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(opp_table);</span><br><span class="line">	</span><br><span class="line">	opp_table-&gt;regulator_count = <span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">	ret = _opp_add_v1(opp_table, dev, freq, u_volt, <span class="literal">true</span>);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		dev_pm_opp_put_opp_table(opp_table);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终获取得到的OPP表如下<br><img src="https://raw.githubusercontent.com/JackHuang021/images/master/20230222105334.png"></p>
<h5 id="cpufreq初始化过程"><a href="#cpufreq初始化过程" class="headerlink" title="cpufreq初始化过程"></a>cpufreq初始化过程</h5><p>cpufreq被注册cpu_subsys总线上</p>
<p>cpufreq的初始化从cpufreq_drvier注册开始，<code>cpufreq_register_driver()</code>函数为cpufreq驱动注册的入口，驱动程序通过调用该函数进行初始化，传入相关的<code>struct cpufreq_driver</code>，<code>cpufreq_register_driver()</code>会调用<code>subsys_interface_register()</code>最终执行回调函数<code>cpufreq_add_dev</code>，然后调用<code>cpufreq_online()</code>走初始化流程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cpufreq_drvier结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cpufreq_driver</span> &#123;</span></span><br><span class="line">	<span class="keyword">char</span>		name[CPUFREQ_NAME_LEN];</span><br><span class="line">	u16		    flags;</span><br><span class="line">	<span class="keyword">void</span>		*driver_data;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* needed by all drivers */</span></span><br><span class="line">	<span class="keyword">int</span>		(*init)(struct cpufreq_policy *policy);</span><br><span class="line">	<span class="keyword">int</span>		(*verify)(struct cpufreq_policy_data *policy);</span><br><span class="line">	<span class="comment">// 调频接口</span></span><br><span class="line">	<span class="keyword">int</span>		(*target_index)(struct cpufreq_policy *policy,</span><br><span class="line">					<span class="keyword">unsigned</span> <span class="keyword">int</span> index);</span><br><span class="line">	<span class="function"><span class="keyword">unsigned</span> <span class="title">int</span>	<span class="params">(*fast_switch)</span><span class="params">(struct cpufreq_policy *policy,</span></span></span><br><span class="line"><span class="params"><span class="function">				       <span class="keyword">unsigned</span> <span class="keyword">int</span> target_freq)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* should be defined, if possible */</span></span><br><span class="line">	<span class="comment">// 获取频率接口</span></span><br><span class="line">	<span class="function"><span class="keyword">unsigned</span> <span class="title">int</span>	<span class="params">(*get)</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> cpu)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Called to update policy limits on firmware notifications. */</span></span><br><span class="line">	<span class="keyword">void</span>		(*update_limits)(<span class="keyword">unsigned</span> <span class="keyword">int</span> cpu);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span>		(*online)(struct cpufreq_policy *policy);</span><br><span class="line">	<span class="keyword">int</span>		(*offline)(struct cpufreq_policy *policy);</span><br><span class="line">	<span class="keyword">int</span>		(*<span class="built_in">exit</span>)(struct cpufreq_policy *policy);</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">freq_attr</span> **<span class="title">attr</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// driver/base/cpu.c</span></span><br><span class="line"><span class="comment">// cpu subsys总线，cpufreq就是以subsys_interface挂在该总线下</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> <span class="title">cpu_subsys</span> =</span> &#123;</span><br><span class="line">	.name = <span class="string">&quot;cpu&quot;</span>,</span><br><span class="line">	.dev_name = <span class="string">&quot;cpu&quot;</span>,</span><br><span class="line">	.match = cpu_subsys_match,</span><br><span class="line">	.online = cpu_subsys_online,</span><br><span class="line">	.offline = cpu_subsys_offline,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// driver/cpufreq/cpufreq.c</span></span><br><span class="line"><span class="comment">// 指向当前使用的cpufreq_driver</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">cpufreq_driver</span> *<span class="title">cpufreq_driver</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// cpufreq subsys接口，用来挂到CPU subsys总线上</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">subsys_interface</span> <span class="title">cpufreq_interface</span> =</span> &#123;</span><br><span class="line">	.name		= <span class="string">&quot;cpufreq&quot;</span>,</span><br><span class="line">	.subsys		= &amp;cpu_subsys,</span><br><span class="line">	.add_dev	= cpufreq_add_dev,</span><br><span class="line">	.remove_dev	= cpufreq_remove_dev,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// scmi cpufreq_driver结构体定义</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">cpufreq_driver</span> <span class="title">scmi_cpufreq_driver</span> =</span> &#123;</span><br><span class="line">	.name	= <span class="string">&quot;scmi&quot;</span>,</span><br><span class="line">	.flags	= CPUFREQ_STICKY | CPUFREQ_HAVE_GOVERNOR_PER_POLICY |</span><br><span class="line">		  CPUFREQ_NEED_INITIAL_FREQ_CHECK,</span><br><span class="line">	.verify	= cpufreq_generic_frequency_table_verify,</span><br><span class="line">	.attr	= cpufreq_generic_attr,</span><br><span class="line">	.target_index	= scmi_cpufreq_set_target,</span><br><span class="line">	.fast_switch	= scmi_cpufreq_fast_switch,</span><br><span class="line">	.get	= scmi_cpufreq_get_rate,</span><br><span class="line">	.init	= scmi_cpufreq_init,</span><br><span class="line">	.<span class="built_in">exit</span>	= scmi_cpufreq_exit,</span><br><span class="line">	.ready	= scmi_cpufreq_ready,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为每个cluster定义一个cpufreq_policy结构体，对每个cluster上的CPU进行调频管理</span></span><br><span class="line"><span class="comment">// 其中又分别进行cpufreq_driver的初始化和governor的初始化</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">DEFINE_PER_CPU</span><span class="params">(struct cpufreq_policy *, cpufreq_cpu_data)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指向当前注册的cpufreq driver</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">cpufreq_driver</span> *<span class="title">cpufreq_driver</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// cpufreq驱动框架初始化过程，整个过程都围绕着policy这个结构体进行，逐步进行初始化</span></span><br><span class="line">cpufreq_register_driver(&amp;scmi_cpufreq_driver);</span><br><span class="line">	subsys_interface_register(&amp;cpufreq_interface);</span><br><span class="line">		cpufreq_add_dev(dev, sif);</span><br><span class="line">			cpufreq_online(cpu);</span><br><span class="line">				<span class="comment">// 初步初始化policy</span></span><br><span class="line">				<span class="comment">// cpumask初始化</span></span><br><span class="line">				<span class="comment">// policy-&gt;kobj kobject初始化</span></span><br><span class="line">				<span class="comment">// policy-&gt;constraints 频率限制初始化</span></span><br><span class="line">				<span class="comment">// 注册频率限制通知接口，频率最大最小值变化时会调用接口</span></span><br><span class="line">				policy = cpufreq_policy_alloc(cpu);</span><br><span class="line">				<span class="comment">// 调用cpufreq_drvier init接口，完善policy结构体</span></span><br><span class="line">				<span class="comment">// 将opp表添加到对应的device，通过dev_pm_opp_add接口</span></span><br><span class="line">				<span class="comment">// 生成频率表 freq_table</span></span><br><span class="line">				cpufreq_driver-&gt;init(policy) -&gt; scmi_cpufreq_init(policy)</span><br><span class="line">				cpufreq_table_validate_and_sort(policy);</span><br><span class="line">				<span class="comment">// 创建/sys/device/system/cpu/cpux目录下的cpufreq符号链接</span></span><br><span class="line">				add_cpu_dev_symlink();</span><br><span class="line">				freq_qos_and_request();</span><br><span class="line">				blocking_notifier_call_chain();</span><br><span class="line">				<span class="comment">// CPU进行频率调整，使当前运行频率在频率表中</span></span><br><span class="line">				<span class="comment">// 初始化的时候会进行一次调整</span></span><br><span class="line">				__cpufreq_driver_target();</span><br><span class="line">				<span class="comment">// 创建sys节点，/sys/device/system/cpu/cpufreq/policyx目录下的一些可选属性</span></span><br><span class="line">				cpufreq_add_dev_interface(policy);</span><br><span class="line">				cpufreq_stats_create_table(policy);</span><br><span class="line">				list_add(&amp;policy-&gt;polic_list, &amp;cpufreq_policy_list);</span><br><span class="line">				<span class="comment">// 使用默认governor初始化policy</span></span><br><span class="line">				cpufreq_init_policy();</span><br></pre></td></tr></table></figure>

<p>来看一下<code>subsys_interface_register()</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// drivers/base/bus.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">subsys_interface_register</span><span class="params">(struct subsystem_interface *sif)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> *<span class="title">subsys</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">subsys_dev_iter</span> <span class="title">iter</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!sif || !sif-&gt;subsys)</span><br><span class="line">		<span class="keyword">return</span> -ENODEV;</span><br><span class="line"></span><br><span class="line">	subsys = bus_get(sif-&gt;subsys);</span><br><span class="line">	<span class="keyword">if</span> (!subsys)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	mutex_lock(&amp;subsys-&gt;p-&gt;mutex);</span><br><span class="line">	<span class="comment">// 将cpufreq_interface添加到cpu_subsys总线的interfaces上</span></span><br><span class="line">	<span class="comment">// interfaces是一个list_head链表</span></span><br><span class="line">	list_add_tail(&amp;sif-&gt;node, &amp;subsys-&gt;p-&gt;interfaces);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 遍历cpu_subsys总线</span></span><br><span class="line">	<span class="comment">// subsys_dev_iter是对klist 迭代器的一个封装</span></span><br><span class="line">	<span class="comment">// 这里遍历的对象是struct device私有数据的knode_bus</span></span><br><span class="line">	<span class="comment">// knode_bus节点是挂载到klist_device这个链表上</span></span><br><span class="line">	<span class="keyword">if</span> (sif-&gt;add_dev) &#123;</span><br><span class="line">		subsys_dev_iter_init(&amp;iter, subsys, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">		<span class="comment">// 从knode_bus取得device指针</span></span><br><span class="line">		<span class="keyword">while</span> ((dev = subsys_dev_iter_next(&amp;iter)))</span><br><span class="line">			sif-&gt;add_dev(dev, sif);</span><br><span class="line">		subsys_dev_iter_exit(&amp;iter);</span><br><span class="line">	&#125;</span><br><span class="line">	mutex_unlock(&amp;subsys-&gt;p-&gt;mutex);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再来看看cpufreq_online()</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">cpufreq_online</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> cpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cpufreq_policy</span> *<span class="title">policy</span>;</span></span><br><span class="line">	<span class="keyword">bool</span> new_policy;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> j;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">	pr_debug(<span class="string">&quot;%s: bringing CPU%u online\n&quot;</span>, __func__, cpu);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Check if this CPU already has a policy to manage it */</span></span><br><span class="line">	<span class="comment">// cpufreq_cpu_data是类型为policy指针的precpu变量</span></span><br><span class="line">	<span class="comment">// 这是是取得policy指针</span></span><br><span class="line">	policy = per_cpu(cpufreq_cpu_data, cpu);</span><br><span class="line">	<span class="keyword">if</span> (policy) &#123;</span><br><span class="line">		<span class="comment">// 假如该cpu不在该policy的related_cpus里面则是有问题的</span></span><br><span class="line">		WARN_ON(!cpumask_test_cpu(cpu, policy-&gt;related_cpus));</span><br><span class="line">		<span class="comment">// 判断当前policy还有没有online CPU</span></span><br><span class="line">		<span class="keyword">if</span> (!policy_is_inactive(policy))</span><br><span class="line">			<span class="comment">// 将当前cpu加入到policy-&gt;cpu online CPU里面</span></span><br><span class="line">			<span class="keyword">return</span> cpufreq_add_policy_cpu(policy, cpu);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* This is the only online CPU for the policy.  Start over. */</span></span><br><span class="line">		new_policy = <span class="literal">false</span>;</span><br><span class="line">		down_write(&amp;policy-&gt;rwsem);</span><br><span class="line">		policy-&gt;cpu = cpu;</span><br><span class="line">		policy-&gt;governor = <span class="literal">NULL</span>;</span><br><span class="line">		up_write(&amp;policy-&gt;rwsem);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 第一次开机的时候需要分配policy内存</span></span><br><span class="line">		new_policy = <span class="literal">true</span>;</span><br><span class="line">		policy = cpufreq_policy_alloc(cpu);</span><br><span class="line">		<span class="keyword">if</span> (!policy)</span><br><span class="line">			<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// scmi调频驱动没有实现online接口</span></span><br><span class="line">	<span class="keyword">if</span> (!new_policy &amp;&amp; cpufreq_driver-&gt;online) &#123;</span><br><span class="line">		ret = cpufreq_driver-&gt;online(policy);</span><br><span class="line">		<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">			pr_debug(<span class="string">&quot;%s: %d: initialization failed\n&quot;</span>, __func__,</span><br><span class="line">				 __LINE__);</span><br><span class="line">			<span class="keyword">goto</span> out_exit_policy;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Recover policy-&gt;cpus using related_cpus */</span></span><br><span class="line">		cpumask_copy(policy-&gt;cpus, policy-&gt;related_cpus);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		cpumask_copy(policy-&gt;cpus, cpumask_of(cpu));</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Call driver. From then on the cpufreq must be able</span></span><br><span class="line"><span class="comment">		 * to accept all calls to -&gt;verify and -&gt;setpolicy for this CPU.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="comment">// cpufreq_driver是在cpufreq_register_driver()中进行赋值的</span></span><br><span class="line">		<span class="comment">// 调频驱动初始化</span></span><br><span class="line">		ret = cpufreq_driver-&gt;init(policy);</span><br><span class="line">		<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">			pr_debug(<span class="string">&quot;%s: %d: initialization failed\n&quot;</span>, __func__,</span><br><span class="line">				 __LINE__);</span><br><span class="line">			<span class="keyword">goto</span> out_free_policy;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		ret = cpufreq_table_validate_and_sort(policy);</span><br><span class="line">		<span class="keyword">if</span> (ret)</span><br><span class="line">			<span class="keyword">goto</span> out_exit_policy;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* related_cpus should at least include policy-&gt;cpus. */</span></span><br><span class="line">		cpumask_copy(policy-&gt;related_cpus, policy-&gt;cpus);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	down_write(&amp;policy-&gt;rwsem);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * affected cpus must always be the one, which are online. We aren&#x27;t</span></span><br><span class="line"><span class="comment">	 * managing offline cpus here.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	cpumask_and(policy-&gt;cpus, policy-&gt;cpus, cpu_online_mask);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (new_policy) &#123;</span><br><span class="line">		for_each_cpu(j, policy-&gt;related_cpus) &#123;</span><br><span class="line">			per_cpu(cpufreq_cpu_data, j) = policy;</span><br><span class="line">			add_cpu_dev_symlink(policy, j);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		policy-&gt;min_freq_req = kzalloc(<span class="number">2</span> * <span class="keyword">sizeof</span>(*policy-&gt;min_freq_req),</span><br><span class="line">					       GFP_KERNEL);</span><br><span class="line">		<span class="keyword">if</span> (!policy-&gt;min_freq_req)</span><br><span class="line">			<span class="keyword">goto</span> out_destroy_policy;</span><br><span class="line"></span><br><span class="line">		ret = freq_qos_add_request(&amp;policy-&gt;constraints,</span><br><span class="line">					   policy-&gt;min_freq_req, FREQ_QOS_MIN,</span><br><span class="line">					   policy-&gt;min);</span><br><span class="line">		<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * So we don&#x27;t call freq_qos_remove_request() for an</span></span><br><span class="line"><span class="comment">			 * uninitialized request.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			kfree(policy-&gt;min_freq_req);</span><br><span class="line">			policy-&gt;min_freq_req = <span class="literal">NULL</span>;</span><br><span class="line">			<span class="keyword">goto</span> out_destroy_policy;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * This must be initialized right here to avoid calling</span></span><br><span class="line"><span class="comment">		 * freq_qos_remove_request() on uninitialized request in case</span></span><br><span class="line"><span class="comment">		 * of errors.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		policy-&gt;max_freq_req = policy-&gt;min_freq_req + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		ret = freq_qos_add_request(&amp;policy-&gt;constraints,</span><br><span class="line">					   policy-&gt;max_freq_req, FREQ_QOS_MAX,</span><br><span class="line">					   policy-&gt;max);</span><br><span class="line">		<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			policy-&gt;max_freq_req = <span class="literal">NULL</span>;</span><br><span class="line">			<span class="keyword">goto</span> out_destroy_policy;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		blocking_notifier_call_chain(&amp;cpufreq_policy_notifier_list,</span><br><span class="line">				CPUFREQ_CREATE_POLICY, policy);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (cpufreq_driver-&gt;get &amp;&amp; has_target()) &#123;</span><br><span class="line">		policy-&gt;cur = cpufreq_driver-&gt;get(policy-&gt;cpu);</span><br><span class="line">		<span class="keyword">if</span> (!policy-&gt;cur) &#123;</span><br><span class="line">			pr_err(<span class="string">&quot;%s: -&gt;get() failed\n&quot;</span>, __func__);</span><br><span class="line">			<span class="keyword">goto</span> out_destroy_policy;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Sometimes boot loaders set CPU frequency to a value outside of</span></span><br><span class="line"><span class="comment">	 * frequency table present with cpufreq core. In such cases CPU might be</span></span><br><span class="line"><span class="comment">	 * unstable if it has to run on that frequency for long duration of time</span></span><br><span class="line"><span class="comment">	 * and so its better to set it to a frequency which is specified in</span></span><br><span class="line"><span class="comment">	 * freq-table. This also makes cpufreq stats inconsistent as</span></span><br><span class="line"><span class="comment">	 * cpufreq-stats would fail to register because current frequency of CPU</span></span><br><span class="line"><span class="comment">	 * isn&#x27;t found in freq-table.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Because we don&#x27;t want this change to effect boot process badly, we go</span></span><br><span class="line"><span class="comment">	 * for the next freq which is &gt;= policy-&gt;cur (&#x27;cur&#x27; must be set by now,</span></span><br><span class="line"><span class="comment">	 * otherwise we will end up setting freq to lowest of the table as &#x27;cur&#x27;</span></span><br><span class="line"><span class="comment">	 * is initialized to zero).</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * We are passing target-freq as &quot;policy-&gt;cur - 1&quot; otherwise</span></span><br><span class="line"><span class="comment">	 * __cpufreq_driver_target() would simply fail, as policy-&gt;cur will be</span></span><br><span class="line"><span class="comment">	 * equal to target-freq.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> ((cpufreq_driver-&gt;flags &amp; CPUFREQ_NEED_INITIAL_FREQ_CHECK)</span><br><span class="line">	    &amp;&amp; has_target()) &#123;</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">int</span> old_freq = policy-&gt;cur;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Are we running at unknown frequency ? */</span></span><br><span class="line">		ret = cpufreq_frequency_table_get_index(policy, old_freq);</span><br><span class="line">		<span class="keyword">if</span> (ret == -EINVAL) &#123;</span><br><span class="line">			ret = __cpufreq_driver_target(policy, old_freq - <span class="number">1</span>,</span><br><span class="line">						      CPUFREQ_RELATION_L);</span><br><span class="line"></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * Reaching here after boot in a few seconds may not</span></span><br><span class="line"><span class="comment">			 * mean that system will remain stable at &quot;unknown&quot;</span></span><br><span class="line"><span class="comment">			 * frequency for longer duration. Hence, a BUG_ON().</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			BUG_ON(ret);</span><br><span class="line">			pr_info(<span class="string">&quot;%s: CPU%d: Running at unlisted initial frequency: %u KHz, changing to: %u KHz\n&quot;</span>,</span><br><span class="line">				__func__, policy-&gt;cpu, old_freq, policy-&gt;cur);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (new_policy) &#123;</span><br><span class="line">		ret = cpufreq_add_dev_interface(policy);</span><br><span class="line">		<span class="keyword">if</span> (ret)</span><br><span class="line">			<span class="keyword">goto</span> out_destroy_policy;</span><br><span class="line"></span><br><span class="line">		cpufreq_stats_create_table(policy);</span><br><span class="line"></span><br><span class="line">		write_lock_irqsave(&amp;cpufreq_driver_lock, flags);</span><br><span class="line">		list_add(&amp;policy-&gt;policy_list, &amp;cpufreq_policy_list);</span><br><span class="line">		write_unlock_irqrestore(&amp;cpufreq_driver_lock, flags);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ret = cpufreq_init_policy(policy);</span><br><span class="line">	<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">		pr_err(<span class="string">&quot;%s: Failed to initialize policy for cpu: %d (%d)\n&quot;</span>,</span><br><span class="line">		       __func__, cpu, ret);</span><br><span class="line">		<span class="keyword">goto</span> out_destroy_policy;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	up_write(&amp;policy-&gt;rwsem);</span><br><span class="line"></span><br><span class="line">	kobject_uevent(&amp;policy-&gt;kobj, KOBJ_ADD);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Callback for handling stuff after policy is ready */</span></span><br><span class="line">	<span class="keyword">if</span> (cpufreq_driver-&gt;ready)</span><br><span class="line">		cpufreq_driver-&gt;ready(policy);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (cpufreq_thermal_control_enabled(cpufreq_driver))</span><br><span class="line">		policy-&gt;cdev = of_cpufreq_cooling_register(policy);</span><br><span class="line"></span><br><span class="line">	pr_debug(<span class="string">&quot;initialization complete\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">out_destroy_policy:</span><br><span class="line">	for_each_cpu(j, policy-&gt;real_cpus)</span><br><span class="line">		remove_cpu_dev_symlink(policy, get_cpu_device(j));</span><br><span class="line"></span><br><span class="line">	up_write(&amp;policy-&gt;rwsem);</span><br><span class="line"></span><br><span class="line">out_exit_policy:</span><br><span class="line">	<span class="keyword">if</span> (cpufreq_driver-&gt;<span class="built_in">exit</span>)</span><br><span class="line">		cpufreq_driver-&gt;<span class="built_in">exit</span>(policy);</span><br><span class="line"></span><br><span class="line">out_free_policy:</span><br><span class="line">	cpufreq_policy_free(policy);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="cpufreq-drviver初始化"><a href="#cpufreq-drviver初始化" class="headerlink" title="cpufreq drviver初始化"></a>cpufreq drviver初始化</h5><p>在cpufreq_online()中调用全局变量cpufreq_driver-&gt;init(policy)进行调频驱动的初始化，下面是scmi调频驱动的初始化过程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">scmi_cpufreq_init</span><span class="params">(struct cpufreq_policy *policy)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret, nr_opp;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> latency;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">cpu_dev</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">scmi_data</span> *<span class="title">priv</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cpufreq_frequency_table</span> *<span class="title">freq_table</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">em_data_callback</span> <span class="title">em_cb</span> =</span> EM_DATA_CB(scmi_get_cpu_power);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取CPU device结构体即对应percpu变量cpu_sys_devices</span></span><br><span class="line">	cpu_dev = get_cpu_device(policy-&gt;cpu);</span><br><span class="line">	<span class="keyword">if</span> (!cpu_dev) &#123;</span><br><span class="line">		pr_err(<span class="string">&quot;failed to get cpu%d device\n&quot;</span>, policy-&gt;cpu);</span><br><span class="line">		<span class="keyword">return</span> -ENODEV;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 调用scmi_dvfs_device_opps_add()生成opp表</span></span><br><span class="line">	ret = handle-&gt;perf_ops-&gt;device_opps_add(handle, cpu_dev);</span><br><span class="line">	<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">		dev_warn(cpu_dev, <span class="string">&quot;failed to add opps to the device\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 遍历可用的cpu，对比cpu_dev的domain_id，若是相同的话加入到policy-&gt;cpus里面</span></span><br><span class="line">	ret = scmi_get_sharing_cpus(cpu_dev, policy-&gt;cpus);</span><br><span class="line">	<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">		dev_warn(cpu_dev, <span class="string">&quot;failed to get sharing cpumask\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 将opp表添加到sharing cpus里面</span></span><br><span class="line">	ret = dev_pm_opp_set_sharing_cpus(cpu_dev, policy-&gt;cpus);</span><br><span class="line">	<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">		dev_err(cpu_dev, <span class="string">&quot;%s: failed to mark OPPs as shared: %d\n&quot;</span>,</span><br><span class="line">			__func__, ret);</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	nr_opp = dev_pm_opp_get_opp_count(cpu_dev);</span><br><span class="line">	<span class="keyword">if</span> (nr_opp &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">		dev_dbg(cpu_dev, <span class="string">&quot;OPP table is not ready, deferring probe\n&quot;</span>);</span><br><span class="line">		ret = -EPROBE_DEFER;</span><br><span class="line">		<span class="keyword">goto</span> out_free_opp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	priv = kzalloc(<span class="keyword">sizeof</span>(*priv), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!priv) &#123;</span><br><span class="line">		ret = -ENOMEM;</span><br><span class="line">		<span class="keyword">goto</span> out_free_opp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// cpufreq</span></span><br><span class="line">	ret = dev_pm_opp_init_cpufreq_table(cpu_dev, &amp;freq_table);</span><br><span class="line">	<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">		dev_err(cpu_dev, <span class="string">&quot;failed to init cpufreq table: %d\n&quot;</span>, ret);</span><br><span class="line">		<span class="keyword">goto</span> out_free_priv;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	priv-&gt;cpu_dev = cpu_dev;</span><br><span class="line">	priv-&gt;domain_id = handle-&gt;perf_ops-&gt;device_domain_id(cpu_dev);</span><br><span class="line">	<span class="comment">// driver_data保存了调频驱动的一些数据，这里只有cpu编号和domain id号</span></span><br><span class="line">	policy-&gt;driver_data = priv;</span><br><span class="line">	policy-&gt;freq_table = freq_table;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* SCMI allows DVFS request for any domain from any CPU */</span></span><br><span class="line">	policy-&gt;dvfs_possible_from_any_cpu = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	latency = handle-&gt;perf_ops-&gt;transition_latency_get(handle, cpu_dev);</span><br><span class="line">	<span class="keyword">if</span> (!latency)</span><br><span class="line">		latency = CPUFREQ_ETERNAL;</span><br><span class="line"></span><br><span class="line">	policy-&gt;cpuinfo.transition_latency = latency;</span><br><span class="line"></span><br><span class="line">	policy-&gt;fast_switch_possible =</span><br><span class="line">		handle-&gt;perf_ops-&gt;fast_switch_possible(handle, cpu_dev);</span><br><span class="line"></span><br><span class="line">	em_dev_register_perf_domain(cpu_dev, nr_opp, &amp;em_cb, policy-&gt;cpus);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">out_free_priv:</span><br><span class="line">	kfree(priv);</span><br><span class="line">out_free_opp:</span><br><span class="line">	dev_pm_opp_remove_all_dynamic(cpu_dev);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>频率表初始化过程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cpufreq_frequency_table</span> &#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> flags;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> driver_data;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> frequency;		<span class="comment">/* KHz */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// drivers/opp/cpu.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dev_pm_opp_init_cpufreq_table</span><span class="params">(struct device *dev,</span></span></span><br><span class="line"><span class="params"><span class="function">				  struct cpufreq_frequency_table **table)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dev_pm_opp</span> *<span class="title">opp</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cpufreq_frequency_table</span> *<span class="title">freq_table</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">int</span> i, max_opps, ret = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> rate;</span><br><span class="line"></span><br><span class="line">	max_opps = dev_pm_opp_get_opp_count(dev);</span><br><span class="line">	<span class="keyword">if</span> (max_opps &lt;= <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> max_opps ? max_opps : -ENODATA;</span><br><span class="line"></span><br><span class="line">	freq_table = kcalloc((max_opps + <span class="number">1</span>), <span class="keyword">sizeof</span>(*freq_table), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!freq_table)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>, rate = <span class="number">0</span>; i &lt; max_opps; i++, rate++) &#123;</span><br><span class="line">		<span class="comment">/* find next rate */</span></span><br><span class="line">		opp = dev_pm_opp_find_freq_ceil(dev, &amp;rate);</span><br><span class="line">		<span class="keyword">if</span> (IS_ERR(opp)) &#123;</span><br><span class="line">			ret = PTR_ERR(opp);</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">		&#125;</span><br><span class="line">		freq_table[i].driver_data = i;</span><br><span class="line">		freq_table[i].frequency = rate / <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Is Boost/turbo opp ? */</span></span><br><span class="line">		<span class="keyword">if</span> (dev_pm_opp_is_turbo(opp))</span><br><span class="line">			freq_table[i].flags = CPUFREQ_BOOST_FREQ;</span><br><span class="line"></span><br><span class="line">		dev_pm_opp_put(opp);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	freq_table[i].driver_data = i;</span><br><span class="line">	freq_table[i].frequency = CPUFREQ_TABLE_END;</span><br><span class="line"></span><br><span class="line">	*table = &amp;freq_table[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		kfree(freq_table);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="governor初始化过程"><a href="#governor初始化过程" class="headerlink" title="governor初始化过程"></a>governor初始化过程</h5><p>cpufreq governor的初始化过程，在cpufreq_init_policy(policy)中进行，这里以ondemand为例进行分析</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/linux/cpufreq.h</span></span><br><span class="line"><span class="comment">// 内核governor描述结构体，形成链表</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cpufreq_governor</span> &#123;</span></span><br><span class="line">	<span class="keyword">char</span>	name[CPUFREQ_NAME_LEN];</span><br><span class="line">	<span class="keyword">int</span>	(*init)(struct cpufreq_policy *policy);</span><br><span class="line">	<span class="keyword">void</span>	(*<span class="built_in">exit</span>)(struct cpufreq_policy *policy);</span><br><span class="line">	<span class="keyword">int</span>	(*start)(struct cpufreq_policy *policy);</span><br><span class="line">	<span class="keyword">void</span>	(*stop)(struct cpufreq_policy *policy);</span><br><span class="line">	<span class="keyword">void</span>	(*limits)(struct cpufreq_policy *policy);</span><br><span class="line">	<span class="keyword">ssize_t</span>	(*show_setspeed)	(struct cpufreq_policy *policy,</span><br><span class="line">					 <span class="keyword">char</span> *buf);</span><br><span class="line">	<span class="keyword">int</span>	(*store_setspeed)	(struct cpufreq_policy *policy,</span><br><span class="line">					 <span class="keyword">unsigned</span> <span class="keyword">int</span> freq);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">governor_list</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">module</span>		*<span class="title">owner</span>;</span></span><br><span class="line">	u8			flags;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Common Governor data across policies */</span></span><br><span class="line"><span class="comment">// 抽象出的ondemand governor结构体</span></span><br><span class="line"><span class="comment">// drivers/cpufreq/cpufreq_governor.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dbs_governor</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cpufreq_governor</span> <span class="title">gov</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kobj_type</span> <span class="title">kobj_type</span>;</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Common data for platforms that don&#x27;t set</span></span><br><span class="line"><span class="comment">	 * CPUFREQ_HAVE_GOVERNOR_PER_POLICY</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dbs_data</span> *<span class="title">gdbs_data</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">unsigned</span> <span class="title">int</span> <span class="params">(*gov_dbs_update)</span><span class="params">(struct cpufreq_policy *policy)</span></span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">policy_dbs_info</span> *(*<span class="title">alloc</span>)(<span class="title">void</span>);</span></span><br><span class="line">	<span class="keyword">void</span> (*<span class="built_in">free</span>)(struct policy_dbs_info *policy_dbs);</span><br><span class="line">	<span class="keyword">int</span> (*init)(struct dbs_data *dbs_data);</span><br><span class="line">	<span class="keyword">void</span> (*<span class="built_in">exit</span>)(struct dbs_data *dbs_data);</span><br><span class="line">	<span class="keyword">void</span> (*start)(struct cpufreq_policy *policy);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Governor demand based switching data (per-policy or global). */</span></span><br><span class="line"><span class="comment">// ondemand计算频率使用的相关参数，包括阈值 采样率等，默认阈值是负载的80%</span></span><br><span class="line"><span class="comment">// dbs(demand based switching)按需切换</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dbs_data</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gov_attr_set</span> <span class="title">attr_set</span>;</span></span><br><span class="line">	<span class="keyword">void</span> *tuners;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> ignore_nice_load;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> sampling_rate;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> sampling_down_factor;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> up_threshold;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> io_is_busy;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Common to all CPUs of a policy */</span></span><br><span class="line"><span class="comment">// driver/cpufreq/cpufreq_governor.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">policy_dbs_info</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cpufreq_policy</span> *<span class="title">policy</span>;</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Per policy mutex that serializes load evaluation from limit-change</span></span><br><span class="line"><span class="comment">	 * and work-handler.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">update_mutex</span>;</span></span><br><span class="line"></span><br><span class="line">	u64 last_sample_time;</span><br><span class="line">	s64 sample_delay_ns;</span><br><span class="line">	<span class="keyword">atomic_t</span> work_count;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_work</span> <span class="title">irq_work</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">work</span>;</span></span><br><span class="line">	<span class="comment">/* dbs_data may be shared between multiple policy objects */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dbs_data</span> *<span class="title">dbs_data</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">	<span class="comment">/* Multiplier for increasing sample delay temporarily. */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> rate_mult;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> idle_periods;	<span class="comment">/* For conservative */</span></span><br><span class="line">	<span class="comment">/* Status indicators */</span></span><br><span class="line">	<span class="keyword">bool</span> is_shared;		<span class="comment">/* This object is used by multiple CPUs */</span></span><br><span class="line">	<span class="keyword">bool</span> work_in_progress;	<span class="comment">/* Work is being queued up or in progress */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// drivers/cpufreq/cpufreq_governor.h</span></span><br><span class="line"><span class="comment">// governor初始化宏</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CPUFREQ_DBS_GOVERNOR_INITIALIZER(_name_)			\</span></span><br><span class="line"><span class="meta">	&#123;								\</span></span><br><span class="line"><span class="meta">		.name = _name_,						\</span></span><br><span class="line"><span class="meta">		.flags = CPUFREQ_GOV_DYNAMIC_SWITCHING,			\</span></span><br><span class="line"><span class="meta">		.owner = THIS_MODULE,					\</span></span><br><span class="line"><span class="meta">		.init = cpufreq_dbs_governor_init,			\</span></span><br><span class="line"><span class="meta">		.exit = cpufreq_dbs_governor_exit,			\</span></span><br><span class="line"><span class="meta">		.start = cpufreq_dbs_governor_start,			\</span></span><br><span class="line"><span class="meta">		.stop = cpufreq_dbs_governor_stop,			\</span></span><br><span class="line"><span class="meta">		.limits = cpufreq_dbs_governor_limits,			\</span></span><br><span class="line"><span class="meta">	&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ondemand governor定义</span></span><br><span class="line"><span class="comment">// driver/cpufreq/cpufreq_ondemand.c</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">dbs_governor</span> <span class="title">od_dbs_gov</span> =</span> &#123;</span><br><span class="line">	.gov = CPUFREQ_DBS_GOVERNOR_INITIALIZER(<span class="string">&quot;ondemand&quot;</span>),</span><br><span class="line">	.kobj_type = &#123; .default_attrs = od_attributes &#125;,</span><br><span class="line">	.gov_dbs_update = od_dbs_update,</span><br><span class="line">	.alloc = od_alloc,</span><br><span class="line">	.<span class="built_in">free</span> = od_free,</span><br><span class="line">	.init = od_init,</span><br><span class="line">	.<span class="built_in">exit</span> = od_exit,</span><br><span class="line">	.start = od_start,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化governor</span></span><br><span class="line"><span class="comment">// 该函数会在governor模块驱动的入口函数调用</span></span><br><span class="line"><span class="comment">// 只要编译该模块，就会注册到cpufreq framework中</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CPU_FREQ_GOV_ONDEMAND	(od_dbs_gov.gov)</span></span><br><span class="line">cpufreq_governor_init(CPU_FREQ_GOV_ONDEMAND);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> cpufreq_governor_init(__governor)			\</span></span><br><span class="line"><span class="meta">static int __init __governor##_init(void)			\</span></span><br><span class="line"><span class="meta">&#123;								\</span></span><br><span class="line"><span class="meta">	return cpufreq_register_governor(&amp;__governor);	\</span></span><br><span class="line"><span class="meta">&#125;								\</span></span><br><span class="line"><span class="meta">core_initcall(__governor##_init)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在cpufreq_online()中调用默认governor对policy进行完善，启动当前governor</span></span><br><span class="line">cpufreq_init_policy(policy);</span><br><span class="line">	gov = get_governor(default_governor);</span><br><span class="line">	<span class="comment">// 设置新的governor</span></span><br><span class="line">	cpufreq_set_policy(policy, gov, pol);</span><br><span class="line">		cpufreq_init_governor(policy);</span><br><span class="line">			policy-&gt;governor-&gt;init();  -&gt; cpufreq_dbs_governor_init(policy);</span><br><span class="line">				gov-&gt;init(dbs_data); -&gt; odinit(dbs_data);</span><br><span class="line">		cpufreq_start_governor(policy);</span><br><span class="line">			policy-&gt;governor-&gt;start(); -&gt; cpufreq_dbs_governor_start(policy);</span><br><span class="line">				<span class="comment">// 设置governor回调函数， 以ondemand为例</span></span><br><span class="line">				gov_set_update_util(policy_dbs, sampling_rate);</span><br><span class="line">					cpufreq_add_update_util_hook(cpu, &amp;cdbs-&gt;updata_util,</span><br><span class="line">									dbs_update_util_handler);</span><br></pre></td></tr></table></figure>
<p>启动governor中比较重要的是设置调频回调函数,该函数是真正调频时计算合适频率的函数</p>
<h4 id="ondemand调节器"><a href="#ondemand调节器" class="headerlink" title="ondemand调节器"></a>ondemand调节器</h4><p>ondemand调节器也会根据当前的CPU负载来进行CPU频率计算，ondemand工作过程如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/linux/sched/cpufreq.h</span></span><br><span class="line"><span class="comment">// CPU利用率变化时会调用func重新计算频率</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">update_util_data</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> (*func)(struct update_util_data *data, u64 time, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// drivers/cpufreq/cpufreq_governor.c</span></span><br><span class="line"><span class="comment">// 设置governor回调函数update_util_data-&gt;func = dbs_update_util_handler</span></span><br><span class="line">cpufreq_dbs_governor_start()</span><br><span class="line">    gov_set_update_util(policy_dbs, sampling_rate);</span><br><span class="line">		cpufreq_add_update_util_hook(cpu, &amp;cdbs-&gt;update_util,</span><br><span class="line">                                    dbs_update_util_handler);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * cpufreq_update_util - Take a note about CPU utilization changes.</span></span><br><span class="line"><span class="comment"> * @rq: Runqueue to carry out the update for.</span></span><br><span class="line"><span class="comment"> * @flags: Update reason flags.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function is called by the scheduler on the CPU whose utilization is</span></span><br><span class="line"><span class="comment"> * being updated.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * It can only be called from RCU-sched read-side critical sections.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The way cpufreq is currently arranged requires it to evaluate the CPU</span></span><br><span class="line"><span class="comment"> * performance state (frequency/voltage) on a regular basis to prevent it from</span></span><br><span class="line"><span class="comment"> * being stuck in a completely inadequate performance level for too long.</span></span><br><span class="line"><span class="comment"> * That is not guaranteed to happen if the updates are only triggered from CFS</span></span><br><span class="line"><span class="comment"> * and DL, though, because they may not be coming in if only RT tasks are</span></span><br><span class="line"><span class="comment"> * active all the time (or there are RT tasks only).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * As a workaround for that issue, this function is called periodically by the</span></span><br><span class="line"><span class="comment"> * RT sched class to trigger extra cpufreq updates to prevent it from stalling,</span></span><br><span class="line"><span class="comment"> * but that really is a band-aid.  Going forward it should be replaced with</span></span><br><span class="line"><span class="comment"> * solutions targeted more specifically at RT tasks.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// kernel/sched/sched.h</span></span><br><span class="line"><span class="comment">// 当cpufreq_update_util()被调用时执行上面设置的回调函数update_util_data-&gt;func</span></span><br><span class="line"><span class="comment">// 为了考虑RT任务的影响，目前在RT调度中会周期性调用该函数，避免CPU频率更新不及时</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">cpufreq_update_util</span><span class="params">(struct rq *rq, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">update_util_data</span> *<span class="title">data</span>;</span></span><br><span class="line">    data = rcu_dereference_sched(*per_cpu_ptr(&amp;cpufreq_update_util_data,</span><br><span class="line">                                cpu_of(rq)));</span><br><span class="line">    <span class="keyword">if</span> (data)</span><br><span class="line">        data-&gt;func(data, rq_clock(rq), flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// drivers/cpufreq/cpufreq_governor.c</span></span><br><span class="line"><span class="comment">// data: 为了后续计算过程能够使用container_of取到cpu_dbs_info地址</span></span><br><span class="line"><span class="comment">// time: 运行队列更新的时间</span></span><br><span class="line"><span class="comment">// flags: 更新的原因标志</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dbs_update_util_handler</span><span class="params">(struct update_util_data *data, u64 time,</span></span></span><br><span class="line"><span class="params"><span class="function">				    <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cpu_dbs_info</span> *<span class="title">cdbs</span> =</span> container_of(data, struct cpu_dbs_info, update_util);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">policy_dbs_info</span> *<span class="title">policy_dbs</span> =</span> cdbs-&gt;policy_dbs;</span><br><span class="line">	u64 delta_ns, lst;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查当前工作的CPU可否对该policy对应的CPU进行调频，E2000是支持的</span></span><br><span class="line">	<span class="keyword">if</span> (!cpufreq_this_cpu_can_update(policy_dbs-&gt;policy))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The work may not be allowed to be queued up right now.</span></span><br><span class="line"><span class="comment">	 * Possible reasons:</span></span><br><span class="line"><span class="comment">	 * - Work has already been queued up or is in progress.</span></span><br><span class="line"><span class="comment">	 * - It is too early (too little time from the previous sample).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (policy_dbs-&gt;work_in_progress)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If the reads below are reordered before the check above, the value</span></span><br><span class="line"><span class="comment">	 * of sample_delay_ns used in the computation may be stale.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">// 判断更新的时间间隔，假如小于smaple_delay_ns直接返回</span></span><br><span class="line">	smp_rmb();</span><br><span class="line">	lst = READ_ONCE(policy_dbs-&gt;last_sample_time);</span><br><span class="line">	delta_ns = time - lst;</span><br><span class="line">	<span class="keyword">if</span> ((s64)delta_ns &lt; policy_dbs-&gt;sample_delay_ns)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If the policy is not shared, the irq_work may be queued up right away</span></span><br><span class="line"><span class="comment">	 * at this point.  Otherwise, we need to ensure that only one of the</span></span><br><span class="line"><span class="comment">	 * CPUs sharing the policy will do that.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">// 若policy是被多个CPU共享的，那么要判断一下是不是已经有CPU对其进行处理过了</span></span><br><span class="line">	<span class="keyword">if</span> (policy_dbs-&gt;is_shared) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!atomic_add_unless(&amp;policy_dbs-&gt;work_count, <span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * If another CPU updated last_sample_time in the meantime, we</span></span><br><span class="line"><span class="comment">		 * shouldn&#x27;t be here, so clear the work counter and bail out.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (unlikely(lst != READ_ONCE(policy_dbs-&gt;last_sample_time))) &#123;</span><br><span class="line">			atomic_set(&amp;policy_dbs-&gt;work_count, <span class="number">0</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新标志位</span></span><br><span class="line">	policy_dbs-&gt;last_sample_time = time;</span><br><span class="line">	policy_dbs-&gt;work_in_progress = <span class="literal">true</span>;</span><br><span class="line">	irq_work_queue(&amp;policy_dbs-&gt;irq_work);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// drivers/cpufreq/cpufreq_governor.c</span></span><br><span class="line"><span class="comment">// init_irq_work(&amp;policy_dbs-&gt;irq_work, dbs_irq_work)</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dbs_irq_work</span><span class="params">(struct irq_work *irq_work)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">policy_dbs_info</span> *<span class="title">policy_dbs</span>;</span></span><br><span class="line"></span><br><span class="line">	policy_dbs = container_of(irq_work, struct policy_dbs_info, irq_work);</span><br><span class="line">    <span class="comment">// 调度policy_dbs-&gt;work执行</span></span><br><span class="line">	schedule_work_on(smp_processor_id(), &amp;policy_dbs-&gt;work);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// drivers/cpufreq/cpufreq_governor.c</span></span><br><span class="line"><span class="comment">// INIT_WORK(&amp;policy_dbs-&gt;work, dbs_work_handler)</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dbs_work_handler</span><span class="params">(struct work_struct *work)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">policy_dbs_info</span> *<span class="title">policy_dbs</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cpufreq_policy</span> *<span class="title">policy</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dbs_governor</span> *<span class="title">gov</span>;</span></span><br><span class="line"></span><br><span class="line">	policy_dbs = container_of(work, struct policy_dbs_info, work);</span><br><span class="line">	policy = policy_dbs-&gt;policy;</span><br><span class="line">	gov = dbs_governor_of(policy);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Make sure cpufreq_governor_limits() isn&#x27;t evaluating load or the</span></span><br><span class="line"><span class="comment">	 * ondemand governor isn&#x27;t updating the sampling rate in parallel.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">// 调用gov-&gt;gov_dbs_update()接口</span></span><br><span class="line">	mutex_lock(&amp;policy_dbs-&gt;update_mutex);</span><br><span class="line">	gov_update_sample_delay(policy_dbs, gov-&gt;gov_dbs_update(policy));</span><br><span class="line">	mutex_unlock(&amp;policy_dbs-&gt;update_mutex);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Allow the utilization update handler to queue up more work. */</span></span><br><span class="line">	atomic_set(&amp;policy_dbs-&gt;work_count, <span class="number">0</span>);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If the update below is reordered with respect to the sample delay</span></span><br><span class="line"><span class="comment">	 * modification, the utilization update handler may end up using a stale</span></span><br><span class="line"><span class="comment">	 * sample delay value.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	smp_wmb();</span><br><span class="line">	policy_dbs-&gt;work_in_progress = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// drivers/cpufreq/cpufreq_ondemand.c</span></span><br><span class="line"><span class="comment">// ondemand回调函数，按照CPU负载计算频率</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">od_dbs_update</span><span class="params">(struct cpufreq_policy *policy)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">policy_dbs_info</span> *<span class="title">policy_dbs</span> =</span> policy-&gt;governor_data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dbs_data</span> *<span class="title">dbs_data</span> =</span> policy_dbs-&gt;dbs_data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">od_policy_dbs_info</span> *<span class="title">dbs_info</span> =</span> to_dbs_info(policy_dbs);</span><br><span class="line">	<span class="keyword">int</span> sample_type = dbs_info-&gt;sample_type;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Common NORMAL_SAMPLE setup */</span></span><br><span class="line">	dbs_info-&gt;sample_type = OD_NORMAL_SAMPLE;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * OD_SUB_SAMPLE doesn&#x27;t make sense if sample_delay_ns is 0, so ignore</span></span><br><span class="line"><span class="comment">	 * it then.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (sample_type == OD_SUB_SAMPLE &amp;&amp; policy_dbs-&gt;sample_delay_ns &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		__cpufreq_driver_target(policy, dbs_info-&gt;freq_lo,</span><br><span class="line">					CPUFREQ_RELATION_H);</span><br><span class="line">		<span class="keyword">return</span> dbs_info-&gt;freq_lo_delay_us;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	od_update(policy);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dbs_info-&gt;freq_lo) &#123;</span><br><span class="line">		<span class="comment">/* Setup SUB_SAMPLE */</span></span><br><span class="line">		dbs_info-&gt;sample_type = OD_SUB_SAMPLE;</span><br><span class="line">		<span class="keyword">return</span> dbs_info-&gt;freq_hi_delay_us;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> dbs_data-&gt;sampling_rate * policy_dbs-&gt;rate_mult;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Every sampling_rate, we check, if current idle time is less than 20%</span></span><br><span class="line"><span class="comment"> * (default), then we try to increase frequency. Else, we adjust the frequency</span></span><br><span class="line"><span class="comment"> * proportional to load.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// drivers/cpufreq/cpufreq_ondemand.c</span></span><br><span class="line"><span class="comment">// 根据CPU负载，调整频率</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">od_update</span><span class="params">(struct cpufreq_policy *policy)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">policy_dbs_info</span> *<span class="title">policy_dbs</span> =</span> policy-&gt;governor_data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">od_policy_dbs_info</span> *<span class="title">dbs_info</span> =</span> to_dbs_info(policy_dbs);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dbs_data</span> *<span class="title">dbs_data</span> =</span> policy_dbs-&gt;dbs_data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">od_dbs_tuners</span> *<span class="title">od_tuners</span> =</span> dbs_data-&gt;tuners;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> load = dbs_update(policy);</span><br><span class="line"></span><br><span class="line">	dbs_info-&gt;freq_lo = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Check for frequency increase */</span></span><br><span class="line">    <span class="comment">// 检查当前的CPU负载，负载大于80%（也可以在sysfs中设置）</span></span><br><span class="line">	<span class="keyword">if</span> (load &gt; dbs_data-&gt;up_threshold) &#123;</span><br><span class="line">		<span class="comment">/* If switching to max speed, apply sampling_down_factor */</span></span><br><span class="line">		<span class="keyword">if</span> (policy-&gt;cur &lt; policy-&gt;max)</span><br><span class="line">			policy_dbs-&gt;rate_mult = dbs_data-&gt;sampling_down_factor;</span><br><span class="line">		dbs_freq_increase(policy, policy-&gt;max);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">/* Calculate the next frequency proportional to load */</span></span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">int</span> freq_next, min_f, max_f;</span><br><span class="line"></span><br><span class="line">		min_f = policy-&gt;cpuinfo.min_freq;</span><br><span class="line">		max_f = policy-&gt;cpuinfo.max_freq;</span><br><span class="line">        <span class="comment">// 按照CPU负载计算调频频率</span></span><br><span class="line">		freq_next = min_f + load * (max_f - min_f) / <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* No longer fully busy, reset rate_mult */</span></span><br><span class="line">		policy_dbs-&gt;rate_mult = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 为了进一步节省电力，在计算出的新频率上再乘以一个powersave_bias设定的百分比</span></span><br><span class="line">        <span class="comment">// powersave_bias的值从0-1000，每一步表示0.1%</span></span><br><span class="line">		<span class="keyword">if</span> (od_tuners-&gt;powersave_bias)</span><br><span class="line">			freq_next = od_ops.powersave_bias_target(policy,</span><br><span class="line">								 freq_next,</span><br><span class="line">								 CPUFREQ_RELATION_L);</span><br><span class="line">		<span class="comment">// 频率调整</span></span><br><span class="line">		__cpufreq_driver_target(policy, freq_next, CPUFREQ_RELATION_C);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// drivers/cpufreq/cpufreq_governor.c</span></span><br><span class="line"><span class="comment">// 计算当前域CPU负载 cpu_load = 100 * (time_elapsed - idle_time) / time_elapsed</span></span><br><span class="line"><span class="comment">// 返回当前域中最大的CPU负载</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">dbs_update</span><span class="params">(struct cpufreq_policy *policy)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">policy_dbs_info</span> *<span class="title">policy_dbs</span> =</span> policy-&gt;governor_data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dbs_data</span> *<span class="title">dbs_data</span> =</span> policy_dbs-&gt;dbs_data;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> ignore_nice = dbs_data-&gt;ignore_nice_load;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> max_load = <span class="number">0</span>, idle_periods = UINT_MAX;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> sampling_rate, io_busy, j;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Sometimes governors may use an additional multiplier to increase</span></span><br><span class="line"><span class="comment">	 * sample delays temporarily.  Apply that multiplier to sampling_rate</span></span><br><span class="line"><span class="comment">	 * so as to keep the wake-up-from-idle detection logic a bit</span></span><br><span class="line"><span class="comment">	 * conservative.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	sampling_rate = dbs_data-&gt;sampling_rate * policy_dbs-&gt;rate_mult;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * For the purpose of ondemand, waiting for disk IO is an indication</span></span><br><span class="line"><span class="comment">	 * that you&#x27;re performance critical, and not that the system is actually</span></span><br><span class="line"><span class="comment">	 * idle, so do not add the iowait time to the CPU idle time then.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	io_busy = dbs_data-&gt;io_is_busy;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Get Absolute Load */</span></span><br><span class="line">    <span class="comment">// 计算当前policy中CPU的最大负载</span></span><br><span class="line">	for_each_cpu(j, policy-&gt;cpus) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">cpu_dbs_info</span> *<span class="title">j_cdbs</span> =</span> &amp;per_cpu(cpu_dbs, j);</span><br><span class="line">		u64 update_time, cur_idle_time;</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">int</span> idle_time, time_elapsed;</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">int</span> load;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取当前idle时间</span></span><br><span class="line">		cur_idle_time = get_cpu_idle_time(j, &amp;update_time, io_busy);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// time_elapsed = 本次总运行时间 - 上次总运行时间</span></span><br><span class="line">		time_elapsed = update_time - j_cdbs-&gt;prev_update_time;</span><br><span class="line">		j_cdbs-&gt;prev_update_time = update_time;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 计算本次时间间隔内的idle_time</span></span><br><span class="line">        <span class="comment">// idle_time = 本次idle时间 - 上次idle时间</span></span><br><span class="line">		idle_time = cur_idle_time - j_cdbs-&gt;prev_cpu_idle;</span><br><span class="line">		j_cdbs-&gt;prev_cpu_idle = cur_idle_time;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (ignore_nice) &#123;</span><br><span class="line">			u64 cur_nice = kcpustat_field(&amp;kcpustat_cpu(j), CPUTIME_NICE, j);</span><br><span class="line"></span><br><span class="line">			idle_time += div_u64(cur_nice - j_cdbs-&gt;prev_cpu_nice, NSEC_PER_USEC);</span><br><span class="line">			j_cdbs-&gt;prev_cpu_nice = cur_nice;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 这里主要是对各种比较罕见的情况进行临时处理</span></span><br><span class="line">		<span class="keyword">if</span> (unlikely(!time_elapsed)) &#123;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * That can only happen when this function is called</span></span><br><span class="line"><span class="comment">			 * twice in a row with a very short interval between the</span></span><br><span class="line"><span class="comment">			 * calls, so the previous load value can be used then.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			load = j_cdbs-&gt;prev_load;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (unlikely((<span class="keyword">int</span>)idle_time &gt; <span class="number">2</span> * sampling_rate &amp;&amp;</span><br><span class="line">				    j_cdbs-&gt;prev_load)) &#123;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * If the CPU had gone completely idle and a task has</span></span><br><span class="line"><span class="comment">			 * just woken up on this CPU now, it would be unfair to</span></span><br><span class="line"><span class="comment">			 * calculate &#x27;load&#x27; the usual way for this elapsed</span></span><br><span class="line"><span class="comment">			 * time-window, because it would show near-zero load,</span></span><br><span class="line"><span class="comment">			 * irrespective of how CPU intensive that task actually</span></span><br><span class="line"><span class="comment">			 * was. This is undesirable for latency-sensitive bursty</span></span><br><span class="line"><span class="comment">			 * workloads.</span></span><br><span class="line"><span class="comment">			 *</span></span><br><span class="line"><span class="comment">			 * To avoid this, reuse the &#x27;load&#x27; from the previous</span></span><br><span class="line"><span class="comment">			 * time-window and give this task a chance to start with</span></span><br><span class="line"><span class="comment">			 * a reasonably high CPU frequency. However, that</span></span><br><span class="line"><span class="comment">			 * shouldn&#x27;t be over-done, lest we get stuck at a high</span></span><br><span class="line"><span class="comment">			 * load (high frequency) for too long, even when the</span></span><br><span class="line"><span class="comment">			 * current system load has actually dropped down, so</span></span><br><span class="line"><span class="comment">			 * clear prev_load to guarantee that the load will be</span></span><br><span class="line"><span class="comment">			 * computed again next time.</span></span><br><span class="line"><span class="comment">			 *</span></span><br><span class="line"><span class="comment">			 * Detecting this situation is easy: an unusually large</span></span><br><span class="line"><span class="comment">			 * &#x27;idle_time&#x27; (as compared to the sampling rate)</span></span><br><span class="line"><span class="comment">			 * indicates this scenario.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			load = j_cdbs-&gt;prev_load;</span><br><span class="line">			j_cdbs-&gt;prev_load = <span class="number">0</span>;</span><br><span class="line">		<span class="comment">// 程序正常会运行到这里进行负载计算</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (time_elapsed &gt;= idle_time) &#123;</span><br><span class="line">				load = <span class="number">100</span> * (time_elapsed - idle_time) / time_elapsed;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">/*</span></span><br><span class="line"><span class="comment">				 * That can happen if idle_time is returned by</span></span><br><span class="line"><span class="comment">				 * get_cpu_idle_time_jiffy().  In that case</span></span><br><span class="line"><span class="comment">				 * idle_time is roughly equal to the difference</span></span><br><span class="line"><span class="comment">				 * between time_elapsed and &quot;busy time&quot; obtained</span></span><br><span class="line"><span class="comment">				 * from CPU statistics.  Then, the &quot;busy time&quot;</span></span><br><span class="line"><span class="comment">				 * can end up being greater than time_elapsed</span></span><br><span class="line"><span class="comment">				 * (for example, if jiffies_64 and the CPU</span></span><br><span class="line"><span class="comment">				 * statistics are updated by different CPUs),</span></span><br><span class="line"><span class="comment">				 * so idle_time may in fact be negative.  That</span></span><br><span class="line"><span class="comment">				 * means, though, that the CPU was busy all</span></span><br><span class="line"><span class="comment">				 * the time (on the rough average) during the</span></span><br><span class="line"><span class="comment">				 * last sampling interval and 100 can be</span></span><br><span class="line"><span class="comment">				 * returned as the load.</span></span><br><span class="line"><span class="comment">				 */</span></span><br><span class="line">				load = (<span class="keyword">int</span>)idle_time &lt; <span class="number">0</span> ? <span class="number">100</span> : <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			j_cdbs-&gt;prev_load = load;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (unlikely((<span class="keyword">int</span>)idle_time &gt; <span class="number">2</span> * sampling_rate)) &#123;</span><br><span class="line">			<span class="keyword">unsigned</span> <span class="keyword">int</span> periods = idle_time / sampling_rate;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (periods &lt; idle_periods)</span><br><span class="line">				idle_periods = periods;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 取当前policy中CPU负载最大的值</span></span><br><span class="line">		<span class="keyword">if</span> (load &gt; max_load)</span><br><span class="line">			max_load = load;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	policy_dbs-&gt;idle_periods = idle_periods;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> max_load;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="schedutil调节器"><a href="#schedutil调节器" class="headerlink" title="schedutil调节器"></a>schedutil调节器</h4><p><img src="https://raw.githubusercontent.com/JackHuang021/images/master/20230103174117.png"><br>sugov（schedutil governor）作为一种内核调频策略模块，它主要是根据当前CPU的利用率进行调频。因此，sugov会注册一个callback函数（sugov_update_shared&#x2F;sugov_update_single)到调度器负载跟踪模块，当CPU util发生变化的时候就会调用该callback函数，检查一下当前CPU频率是否和当前的CPU util匹配，如果不匹配，那么就进行升频或者降频。</p>
<p><code>sugov_tunables</code>结构体，用来描述sugov的可调参数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sugov_tunables结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sugov_tunables</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gov_attr_set</span> <span class="title">attr_set</span>;</span></span><br><span class="line">	<span class="comment">// 目前sugov只有这一个可调参数，该参数用来限制连续调频的间隔时间</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> rate_limit_us;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>sugov_policy</code>结构体，sugov为每个cluster构建了该数据结构，记录每个cluster的调频数据信息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sugov_policy结构体，为每个簇构建了该数据结构，记录每个簇的调频数据信息</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sugov_policy</span> &#123;</span></span><br><span class="line">	<span class="comment">// 指向cpufreq framework层的policy对象</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cpufreq_policy</span>	*<span class="title">policy</span>;</span></span><br><span class="line">	<span class="comment">// sugov的可调参数</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sugov_tunables</span>	*<span class="title">tunables</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">tunables_hook</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">raw_spinlock_t</span>		update_lock;	<span class="comment">/* For shared policies */</span></span><br><span class="line">	<span class="comment">// 记录上次进行频率调整的时间点</span></span><br><span class="line">	u64			last_freq_update_time;</span><br><span class="line">	<span class="comment">// 最小调频时间间隔</span></span><br><span class="line">	s64			freq_update_delay_ns;</span><br><span class="line">	<span class="comment">// 下一个需要调整到的频率值，回调函数主要是计算这个参数</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		next_freq;</span><br><span class="line">	<span class="comment">// 根据CPU util计算出来的原始频率，在频率表中向上找最接近的频率进行调整</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		cached_raw_freq;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* The next fields are only needed if fast switch cannot be used: */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span>			<span class="title">irq_work</span> <span class="title">irq_work</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span>			<span class="title">kthread_work</span> <span class="title">work</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span>			<span class="title">mutex</span> <span class="title">work_lock</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span>			<span class="title">kthread_worker</span> <span class="title">worker</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>	*<span class="title">thread</span>;</span></span><br><span class="line">	<span class="keyword">bool</span>			work_in_progress;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">bool</span>			limits_changed;</span><br><span class="line">	<span class="keyword">bool</span>			need_freq_update;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>sugov_cpu</code>结构体，sugov为每个cpu构建了该数据结构，记录每个CPU的调频数据信息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sugov_cpu</span> &#123;</span></span><br><span class="line">	<span class="comment">// 保存了cpu util变化后的回调函数</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">update_util_data</span>	<span class="title">update_util</span>;</span></span><br><span class="line">	<span class="comment">// 该sugov_cpu对应的sugov_policy对象</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sugov_policy</span>	*<span class="title">sg_policy</span>;</span></span><br><span class="line">	<span class="comment">// 对应的CPU id</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		cpu;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">bool</span>			iowait_boost_pending;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		iowait_boost;</span><br><span class="line">	<span class="comment">// 上一次cpu负载变化驱动调频的时间点，util更新的时间点</span></span><br><span class="line">	u64			last_update;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		bw_dl;</span><br><span class="line">	<span class="comment">// 该CPU的最大算力，即最大utilities，归一化到1024</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		max;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* The field below is for single-CPU policies only: */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NO_HZ_COMMON</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		saved_idle_calls;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>sugov初始化过程和ondemand初始化过程相似，当内核设定默认governor为sugov时，在<code>cpufreq_init_governor(policy);</code>中会调用<code>sugov_init()</code>初始化sugov，然后调用<code>sugov_start()</code>设置调频回调函数，每当CPU利用率发生变化的时候，调度器都会调用<code>cpufreq_update_util()</code>通知sugov，在<code>cpufreq_update_util()</code>被调用时，即任务调度后CPU当前的util发生变化，会调用sugov的回调函数进行调频，<code>sugov_update_shared()</code>当一个簇中有多个CPU调用该回调，遍历簇上的CPU找到当前最大util的CPU，然后根据该util映射到频率；<code>sugov_update_single()</code>即一个簇上单个CPU的情况直接根据该CPU util计算频率</p>
<p>调度事件的发生还是非常密集的，特别是在重载的情况下，很多任务可能执行若干个us就切换出去了。如果每次都计算CPU util看看是否需要调整频率，那么本身sugov就给系统带来较重的负荷，因此并非每次调频时机都会真正执行调频检查，sugov设置了一个最小调频间隔，小于这个间隔的调频请求会被过滤掉。</p>
<h5 id="schedutil频率计算过程"><a href="#schedutil频率计算过程" class="headerlink" title="schedutil频率计算过程"></a>schedutil频率计算过程</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sugov_start会遍历该sugov policy（cluster）中的所有cpu</span></span><br><span class="line"><span class="comment">// 调用cpufreq_add_update_util_hook为sugov cpu注册调频回调函数，代码逻辑如下：</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sugov_start</span><span class="params">(struct cpufreq_policy *policy)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	...</span><br><span class="line">	for_each_cpu(cpu, policy-&gt;cpus) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">sugov_cpu</span> *<span class="title">sg_cpu</span> =</span> &amp;per_cpu(sugov_cpu, cpu);</span><br><span class="line">		<span class="comment">// 设置governor 计算回调函数，cpufreq_update_util()被调用时</span></span><br><span class="line">		<span class="comment">// 即任务调度后CPU当前的util发生变化，会调用sugov的回调函数进行调频计算</span></span><br><span class="line">		cpufreq_add_update_util_hook(cpu, &amp;sg_cpu-&gt;update_util,</span><br><span class="line">					     policy_is_shared(policy) ?</span><br><span class="line">							sugov_update_shared :</span><br><span class="line">							sugov_update_single);</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// schedutil频率计算过程</span></span><br><span class="line">sugov_update_single();</span><br><span class="line">	<span class="comment">// 调频最小间隔时间检查，小于设定时间，直接返回</span></span><br><span class="line">	sugov_should_update_freq();</span><br><span class="line">	util = sugov_get_util(sg_cpuu);</span><br><span class="line">		schedutil_cpu_util(sg_cpu-&gt;cpu, util, max, FREQUENCY_UTIL, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="comment">// 根据当前CPU的util映射到具体的频率上</span></span><br><span class="line">	next_f = get_next_freq(sg_policy, util, max);</span><br><span class="line">	<span class="comment">// 调用cpufreq_driver进行调频</span></span><br><span class="line">	sugov_deferred_update(sg_policy, time, next_f);</span><br><span class="line">		__cpufreq_driver_target()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算cpu当前的utility</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">schedutil_cpu_util</span><span class="params">(<span class="keyword">int</span> cpu, <span class="keyword">unsigned</span> <span class="keyword">long</span> util_cfs,</span></span></span><br><span class="line"><span class="params"><span class="function">					<span class="keyword">unsigned</span> <span class="keyword">long</span> max, <span class="keyword">enum</span> schedutil_type type,</span></span></span><br><span class="line"><span class="params"><span class="function">					struct task_struct *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> dl_util, util, irq;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span> =</span> cpu_rq(cpu);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!uclamp_is_used() &amp;&amp;</span><br><span class="line">	    type == FREQUENCY_UTIL &amp;&amp; rt_rq_is_runnable(&amp;rq-&gt;rt)) &#123;</span><br><span class="line">		<span class="keyword">return</span> max;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果CPU处理了过多的中断服务函数，irq负载已经高过CPU最大算力，直接返回最大算力</span></span><br><span class="line">	irq = cpu_util_irq(rq);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(irq &gt;= max))</span><br><span class="line">		<span class="keyword">return</span> max;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 累加了cfs和rt任务的utility</span></span><br><span class="line">	util = util_cfs + cpu_util_rt(rq);</span><br><span class="line">	<span class="keyword">if</span> (type == FREQUENCY_UTIL)</span><br><span class="line">		util = uclamp_rq_util_with(rq, util, p);</span><br><span class="line"></span><br><span class="line">	dl_util = cpu_util_dl(rq);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (util + dl_util &gt;= max)</span><br><span class="line">		<span class="keyword">return</span> max;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * OTOH, for energy computation we need the estimated running time, so</span></span><br><span class="line"><span class="comment">	 * include util_dl and ignore dl_bw.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (type == ENERGY_UTIL)</span><br><span class="line">		util += dl_util;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * There is still idle time; further improve the number by using the</span></span><br><span class="line"><span class="comment">	 * irq metric. Because IRQ/steal time is hidden from the task clock we</span></span><br><span class="line"><span class="comment">	 * need to scale the task numbers:</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 *              max - irq</span></span><br><span class="line"><span class="comment">	 *   U&#x27; = irq + --------- * U</span></span><br><span class="line"><span class="comment">	 *                 max</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">// irq会偷走一部分的cpu算力，从而让其capacity没有那么大。</span></span><br><span class="line">	<span class="comment">// 这里通过scale_irq_capacity对任务的utility进行调整</span></span><br><span class="line">	util = scale_irq_capacity(util, irq, max);</span><br><span class="line">	util += irq;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Bandwidth required by DEADLINE must always be granted while, for</span></span><br><span class="line"><span class="comment">	 * FAIR and RT, we use blocked utilization of IDLE CPUs as a mechanism</span></span><br><span class="line"><span class="comment">	 * to gracefully reduce the frequency when no tasks show up for longer</span></span><br><span class="line"><span class="comment">	 * periods of time.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Ideally we would like to set bw_dl as min/guaranteed freq and util +</span></span><br><span class="line"><span class="comment">	 * bw_dl as requested freq. However, cpufreq is not yet ready for such</span></span><br><span class="line"><span class="comment">	 * an interface. So, we only do the latter for now.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (type == FREQUENCY_UTIL)</span><br><span class="line">		util += cpu_bw_dl(rq);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> min(max, util);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据当前CPU计算的util映射对应频率</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">get_next_freq</span><span class="params">(struct sugov_policy *sg_policy,</span></span></span><br><span class="line"><span class="params"><span class="function">				  <span class="keyword">unsigned</span> <span class="keyword">long</span> util, <span class="keyword">unsigned</span> <span class="keyword">long</span> max)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cpufreq_policy</span> *<span class="title">policy</span> =</span> sg_policy-&gt;policy;</span><br><span class="line">	<span class="comment">// 先取得当前CPU的最大频率</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> freq = arch_scale_freq_invariant() ?</span><br><span class="line">				policy-&gt;cpuinfo.max_freq : policy-&gt;cur;</span><br><span class="line">	<span class="comment">// 计算当前util对应频率，计算公式: freq = (1.25) * freq * util / max</span></span><br><span class="line">	<span class="comment">// 这里冗余了25%的算力余量</span></span><br><span class="line">	freq = map_util_freq(util, freq, max);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 若计算出的freq和上次缓存的一样，则实际调整的next_freq计算后肯定也是一样的，直接返回</span></span><br><span class="line">	<span class="comment">// 上次记录的频率值</span></span><br><span class="line">	<span class="keyword">if</span> (freq == sg_policy-&gt;cached_raw_freq &amp;&amp; !sg_policy-&gt;need_freq_update)</span><br><span class="line">		<span class="keyword">return</span> sg_policy-&gt;next_freq;</span><br><span class="line"></span><br><span class="line">	sg_policy-&gt;cached_raw_freq = freq;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 根据当前算的freq，在CPU频率表上查找对应的频率</span></span><br><span class="line">	freq = cpufreq_driver_resolve_freq(policy, freq);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> freq;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="EAS能源感知调度"><a href="#EAS能源感知调度" class="headerlink" title="EAS能源感知调度"></a>EAS能源感知调度</h3><h4 id="EAS整体框架"><a href="#EAS整体框架" class="headerlink" title="EAS整体框架"></a>EAS整体框架</h4><p><img src="https://raw.githubusercontent.com/JackHuang021/images/master/20221216104706.png"></p>
<p>完全公平调度（Completely Fair Scheduler CFS）实现了面向吞吐量的的任务调度策略，EAS为这个调度器添加了一个基于能耗的调度策略，在优化CPU算力冗余的同时实现了节能，EAS在系统中、低度负载情况下工作，CFS在系统满负载情况下工作。</p>
<p>EAS在CPU调度领域，在为任务选核是起作用，目的是保证性能的情况下尽可能节省功耗，EAS涉及内核的几个子系统（任务调度、能源管理、CPU动态调频），EAS代码主要位于<code>kernel/sched/fair.c</code>，能源感知的任务调度需要调度器评估各个任务在CPU上运行带来的能耗影响</p>
<p>EAS全局控制开关<code>/proc/sys/kernel/sched_energy_aware</code></p>
<h4 id="CPU算力归一化过程"><a href="#CPU算力归一化过程" class="headerlink" title="CPU算力归一化过程"></a>CPU算力归一化过程</h4><p>当前，Linux无法凭自身算出CPU算力，因此必须要有把这个信息传递给Linux的方式，它是从<code>capacity-dmips-mhz</code> CPU 设备树binding中衍生计算出来的</p>
<p>归一化CPU capacity，<code>topology_normalize_cpu_scale()</code>定义在<code>drivers/base/arch_topology()</code>，这个capacity在schedutil调度中被<code>sugov_get_util()</code>函数读取</p>
<p><code>topology_normalize_cpu_scale()</code>在CPU初始化<code>parse_dt_topology()</code>中被调用，capacity归一化的前提条件是需要在设备树中CPU节点设置<code>capacity-dmips-mhz</code>属性，该属性表示不同CPU的计算能力，内核读取该属性设置CPU的<code>raw_capacity</code>为<code>capacity-dmips-mhz</code>，参考内核文档<code>Documentation/devicetree/bindings/arm/cpu-capacity.txt</code></p>
<blockquote>
<p>ARM推荐的测试CPU的性能工具：Dhrystone 2.1以上版本，可以通过单核跑分成绩作为<code>capacity-dmips-mhz</code>属性的参考，DMIPS： Dhrystone Million Instructions executed Per Second，表示了在Dhrystone这样一种测试方法下的MIPS，Dhrystone是一种整数运算测试程序。MIPS&#x2F;MHz，就是说每MHz频率能产生多大的MIPS，CPU性能通常由每秒百万指令（Millions of Instructions Per Second，MIPS）表示，设备树里表示为dmips&#x2F;mhz</p>
</blockquote>
<p>CPU算力归一化公式，并不是简单的将capacity-dmips-mhz归一化到capacity，CPU的频率也参与到了计算中<br><code> capacity = (own(capacity-dmips-mhz) * own(max_freq)) / (max(capacity-dmips-mhz) * max(max_freq)) * 1024</code></p>
<p>根据测试部测试的E2000QCPU单核性能数据，E2000Q的<code>capacity-dmips-mhz</code>属性值可以设置为如下，放大1000倍：<br><img src="https://raw.githubusercontent.com/JackHuang021/images/master/20230105152415.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 小核</span></span><br><span class="line">cpu_l0: cpu@<span class="number">0</span> &#123;</span><br><span class="line">	...</span><br><span class="line">	capacity-dmips-mhz = &lt;<span class="number">2850</span>&gt;;</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 大核</span></span><br><span class="line">cpu_b0: cpu@<span class="number">0</span> &#123;</span><br><span class="line">	...</span><br><span class="line">	capacity-dmips-mhz = &lt;<span class="number">5660</span>&gt;;</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>实际经过CPU算力归一化到1024之后，对应的小核CPU算力为386，大核为1024</p>
<h4 id="EAS代码相关结构体"><a href="#EAS代码相关结构体" class="headerlink" title="EAS代码相关结构体"></a>EAS代码相关结构体</h4><p>perf_domain结构表示一个CPU性能域，perf_domain和cpufreq_policy是一一对应的，性能域之间形成链，链表头存放在root_domain中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/sched/sched.h</span></span><br><span class="line"><span class="comment">// perf_comain 结构表示一个CPU性能域，perf_domain和cpufreq_policy是一一对应的</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">perf_domain</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">em_perf_domain</span> *<span class="title">em_pd</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">perf_domain</span> *<span class="title">next</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// cpumask_var_t解析</span></span><br><span class="line"><span class="comment">// include/uapi/linux/kernel.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __KERNEL_DIV_ROUND_UP(n, d) ((((n) + (d)) - 1) / (d))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// include/linux/kernel.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DIV_ROUND_UP	__KERNEL_DIV_ROUND_UP</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// include/linux/bits.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BITS_PER_BYTE 	8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// include/linux/bitops.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BITS_PER_TYPE(type) (sizeof(type) * BITS_PER_BYTE)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BITS_TO_LONGS(nr)	DIV_ROUND_UP(nr, BITS_PER_TYPE(long))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// include/linux/types.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DECLARE_BITMAP(name, bits) \</span></span><br><span class="line"><span class="meta">	unsigned long name[BITS_TO_LONGS(bits)]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// include/linux/threads.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_NR_CPUS 256</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NR_CPUS		CONFIG_NR_CPUS</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// include/linux/cpumask.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">cpumask</span> &#123;</span> DECLARE_BITMAP(bits, NR_CPUS); &#125; <span class="keyword">cpumask_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">cpumask</span> <span class="title">cpumask_var_t</span>[1];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 展开cpumask</span></span><br><span class="line"><span class="comment">// 该结构体用来表示当前系统中CPU的状态，每个CPU对应其中一位</span></span><br><span class="line"><span class="comment">// 这里内核配置最大支持256个CPU，所以定义了一个长度为4的long数组</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">cpumask</span> &#123;</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	unsigned long bits[BITS_TO_LONGS(256)];</span></span><br><span class="line"><span class="comment">	unsigned long bits[DIV_ROUND_UP(256, 64)];</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> bits[<span class="number">4</span>];</span><br><span class="line">&#125; <span class="keyword">cpumask_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// root_domain代表CPU性能域的一个总体数据结构，管理这些性能域</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">root_domain</span> &#123;</span></span><br><span class="line">	<span class="keyword">atomic_t</span>		refcount;</span><br><span class="line">	<span class="keyword">atomic_t</span>		rto_count;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span>		<span class="title">rcu</span>;</span></span><br><span class="line">	<span class="keyword">cpumask_var_t</span>		span;</span><br><span class="line">	<span class="keyword">cpumask_var_t</span>		online;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 该root_domain是否处于overload状态</span></span><br><span class="line">	<span class="keyword">int</span>			overload;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 该root_domain是否处于overutilized状态</span></span><br><span class="line">	<span class="keyword">int</span>			overutilized;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The bit corresponding to a CPU gets set here if such CPU has more</span></span><br><span class="line"><span class="comment">	 * than one runnable -deadline task (as it is below for RT tasks).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">cpumask_var_t</span>		dlo_mask;</span><br><span class="line">	<span class="keyword">atomic_t</span>		dlo_count;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dl_bw</span>		<span class="title">dl_bw</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cpudl</span>		<span class="title">cpudl</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_RT_PUSH_IPI</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * For IPI pull requests, loop across the rto_mask.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_work</span>		<span class="title">rto_push_work</span>;</span></span><br><span class="line">	<span class="keyword">raw_spinlock_t</span>		rto_lock;</span><br><span class="line">	<span class="comment">/* These are only updated and read within rto_lock */</span></span><br><span class="line">	<span class="keyword">int</span>			rto_loop;</span><br><span class="line">	<span class="keyword">int</span>			rto_cpu;</span><br><span class="line">	<span class="comment">/* These atomics are updated outside of a lock */</span></span><br><span class="line">	<span class="keyword">atomic_t</span>		rto_loop_next;</span><br><span class="line">	<span class="keyword">atomic_t</span>		rto_loop_start;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The &quot;RT overload&quot; flag: it gets set if a CPU has more than</span></span><br><span class="line"><span class="comment">	 * one runnable RT task.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">cpumask_var_t</span>		rto_mask;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cpupri</span>		<span class="title">cpupri</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 系统中算力最大的CPU的算力</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		max_cpu_capacity;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * NULL-terminated list of performance domains intersecting with the</span></span><br><span class="line"><span class="comment">	 * CPUs of the rd. Protected by RCU.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">// perf_domain单链表的表头</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">perf_domain</span> __<span class="title">rcu</span> *<span class="title">pd</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// include/linux/energy_model.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">em_perf_state</span> &#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> frequency;	<span class="comment">// CPU频点，单位KHz</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> power;		<span class="comment">// 此频点下的功耗</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> cost;			<span class="comment">// 此频点下的成本系数，等于 power * max_freq / freq</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">em_perf_domain</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">em_perf_state</span> *<span class="title">table</span>;</span>	<span class="comment">// CPU频点表</span></span><br><span class="line">	<span class="keyword">int</span> nr_perf_states;				<span class="comment">// 频点表中元素的个数</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> cpus[];			<span class="comment">// 此性能域中包括哪些CPU</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="perf-domain初始化"><a href="#perf-domain初始化" class="headerlink" title="perf_domain初始化"></a>perf_domain初始化</h4><p>start_kernel() -&gt; sched_init() -&gt; init_defrootdomain()</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/sched/core.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> __init <span class="title">sched_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">	init_defrootdmain();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// kernel/sched/topology.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">build_perf_domains</span><span class="params">(<span class="keyword">const</span> struct cpumask *cpu_map)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 这里nr_cpus即统计cpu_map里面当前CPU的个数</span></span><br><span class="line">	<span class="keyword">int</span> i, nr_pd = <span class="number">0</span>, nr_ps = <span class="number">0</span>, nr_cpus = cpumask_weight(cpu_map);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">perf_domain</span> *<span class="title">pd</span> =</span> <span class="literal">NULL</span>, *tmp;</span><br><span class="line">	<span class="keyword">int</span> cpu = cpumask_first(cpu_map);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">root_domain</span> *<span class="title">rd</span> =</span> cpu_rq(cpu)-&gt;rd;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cpufreq_policy</span> *<span class="title">policy</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cpufreq_governor</span> *<span class="title">gov</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!sysctl_sched_energy_aware)</span><br><span class="line">		<span class="keyword">goto</span> <span class="built_in">free</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* EAS is enabled for asymmetric CPU capacity topologies. */</span></span><br><span class="line">	<span class="keyword">if</span> (!per_cpu(sd_asym_cpucapacity, cpu)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (sched_debug()) &#123;</span><br><span class="line">			pr_info(<span class="string">&quot;rd %*pbl: CPUs do not have asymmetric capacities\n&quot;</span>,</span><br><span class="line">					cpumask_pr_args(cpu_map));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">goto</span> <span class="built_in">free</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* EAS definitely does *not* handle SMT */</span></span><br><span class="line">	<span class="keyword">if</span> (sched_smt_active()) &#123;</span><br><span class="line">		pr_warn(<span class="string">&quot;rd %*pbl: Disabling EAS, SMT is not supported\n&quot;</span>,</span><br><span class="line">			cpumask_pr_args(cpu_map));</span><br><span class="line">		<span class="keyword">goto</span> <span class="built_in">free</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	for_each_cpu(i, cpu_map) &#123;</span><br><span class="line">		<span class="comment">/* Skip already covered CPUs. */</span></span><br><span class="line">		<span class="keyword">if</span> (find_pd(pd, i))</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Do not attempt EAS if schedutil is not being used. */</span></span><br><span class="line">		policy = cpufreq_cpu_get(i);</span><br><span class="line">		<span class="keyword">if</span> (!policy)</span><br><span class="line">			<span class="keyword">goto</span> <span class="built_in">free</span>;</span><br><span class="line">		gov = policy-&gt;governor;</span><br><span class="line">		cpufreq_cpu_put(policy);</span><br><span class="line">		<span class="keyword">if</span> (gov != &amp;schedutil_gov) &#123;</span><br><span class="line">			<span class="keyword">if</span> (rd-&gt;pd)</span><br><span class="line">				pr_warn(<span class="string">&quot;rd %*pbl: Disabling EAS, schedutil is mandatory\n&quot;</span>,</span><br><span class="line">						cpumask_pr_args(cpu_map));</span><br><span class="line">			<span class="keyword">goto</span> <span class="built_in">free</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Create the new pd and add it to the local list. */</span></span><br><span class="line">		tmp = pd_init(i);</span><br><span class="line">		<span class="keyword">if</span> (!tmp)</span><br><span class="line">			<span class="keyword">goto</span> <span class="built_in">free</span>;</span><br><span class="line">		tmp-&gt;next = pd;</span><br><span class="line">		pd = tmp;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Count performance domains and performance states for the</span></span><br><span class="line"><span class="comment">		 * complexity check.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		nr_pd++;</span><br><span class="line">		nr_ps += em_pd_nr_perf_states(pd-&gt;em_pd);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Bail out if the Energy Model complexity is too high. */</span></span><br><span class="line">	<span class="keyword">if</span> (nr_pd * (nr_ps + nr_cpus) &gt; EM_MAX_COMPLEXITY) &#123;</span><br><span class="line">		WARN(<span class="number">1</span>, <span class="string">&quot;rd %*pbl: Failed to start EAS, EM complexity is too high\n&quot;</span>,</span><br><span class="line">						cpumask_pr_args(cpu_map));</span><br><span class="line">		<span class="keyword">goto</span> <span class="built_in">free</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	perf_domain_debug(cpu_map, pd);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Attach the new list of performance domains to the root domain. */</span></span><br><span class="line">	tmp = rd-&gt;pd;</span><br><span class="line">	rcu_assign_pointer(rd-&gt;pd, pd);</span><br><span class="line">	<span class="keyword">if</span> (tmp)</span><br><span class="line">		call_rcu(&amp;tmp-&gt;rcu, destroy_perf_domain_rcu);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> !!pd;</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>:</span><br><span class="line">	free_pd(pd);</span><br><span class="line">	tmp = rd-&gt;pd;</span><br><span class="line">	rcu_assign_pointer(rd-&gt;pd, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (tmp)</span><br><span class="line">		call_rcu(&amp;tmp-&gt;rcu, destroy_perf_domain_rcu);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>E2000Q 5.10内核，perf_domain_debug 打印信息</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[    2.574534] root_domain 0-3: pd3:&#123; cpus=3 nr_pstate=4 &#125;</span><br><span class="line">[    2.574540] freq: 250000, power: 79, cost: 632</span><br><span class="line">[    2.579072] freq: 500000, power: 197, cost: 788</span><br><span class="line">[    2.583690] freq: 1000000, power: 409, cost: 818</span><br><span class="line">[    2.588390] freq: 2000000, power: 839, cost: 839</span><br><span class="line">[    2.593094]  pd2:&#123; cpus=2 nr_pstate=4 &#125;</span><br><span class="line">[    2.593096] freq: 250000, power: 79, cost: 632</span><br><span class="line">[    2.601445] freq: 500000, power: 197, cost: 788</span><br><span class="line">[    2.606054] freq: 1000000, power: 409, cost: 818</span><br><span class="line">[    2.610749] freq: 2000000, power: 839, cost: 839</span><br><span class="line">[    2.615445]  pd0:&#123; cpus=0-1 nr_pstate=4 &#125;</span><br><span class="line">[    2.615447] freq: 187500, power: 1, cost: 8</span><br><span class="line">[    2.623709] freq: 375000, power: 9, cost: 36</span><br><span class="line">[    2.628058] freq: 750000, power: 55, cost: 110</span><br><span class="line">[    2.632579] freq: 1500000, power: 125, cost: 125</span><br></pre></td></tr></table></figure>

<p>root_domain的overload和overutilized说明：</p>
<ul>
<li>对于一个 CPU 而言，其处于 overload 状态则说明其 rq 上有大于等于2个任务</li>
<li>对于一个 CPU 而言，其处于 overutilized 状态说明该 cpu 的 utility 超过其 capacity（缺省预留20%的算力，另外，这里的 capacity 是用于cfs任务的算力）</li>
<li>对于 root domain，overload 表示至少有一个 cpu 处于 overload 状态。overutilized 表示至少有一个 cpu 处于 overutilized 状态</li>
<li>overutilized 状态非常重要，它决定了调度器是否启用EAS，只有在系统没有 overutilized 的情况下EAS才会生效。overload和newidle balance的频次控制相关，当系统在overload的情况下，newidle balance才会启动进行均衡。</li>
</ul>
<h4 id="EAS能量计算方法"><a href="#EAS能量计算方法" class="headerlink" title="EAS能量计算方法"></a>EAS能量计算方法</h4><p>CPU在某个performance state(ps)下的计算能力：<br>ps-&gt;cap &#x3D; ps-&gt;freq * scale_cpu &#x2F; cpu_max_freq	（1）</p>
<p>CPU在该频点performace state(ps)下的能量消耗：<br>cpu_nrg &#x3D; ps-&gt;power * cpu_util &#x2F; ps-&gt;cap  （2）</p>
<p>结合(1) (2)可以得出CPU在该ps下的能量消耗<br>    cpu_nrg &#x3D; ps-&gt;power * cpu_max_freq * cpu_util &#x2F; ps-&gt;freq * scale_cpu (3)</p>
<p>其中 ps-&gt;power * cpu_max_freq &#x2F; ps-&gt;freq 是一个固定数据存放在频点表的cost成员中</p>
<p>一个pd内的CPU，拥有相同的cost，所以一个pd内所有CPU的能量消耗可以表示为<br>pd_nrg &#x3D; ps-&gt;cost * sum(cpu_util) &#x2F; scale_cpu</p>
<h4 id="EAS的调度过程"><a href="#EAS的调度过程" class="headerlink" title="EAS的调度过程"></a>EAS的调度过程</h4><p>在任务被重新唤醒或者fork新建时，会通过<code>select_task_rq_fair()</code>将任务进行balance，达到充分利用CPU的目的。在<code>select_task_rq_fair()</code>，若任务是被重新唤醒就会调用<code>find_energy_efficient_cpu()</code>进行选核执行</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Predicts what cpu_util(@cpu) would return if @p was migrated (and enqueued)</span></span><br><span class="line"><span class="comment"> * to @dst_cpu.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">cpu_util_next</span><span class="params">(<span class="keyword">int</span> cpu, struct task_struct *p, <span class="keyword">int</span> dst_cpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cfs_rq</span> *<span class="title">cfs_rq</span> =</span> &amp;cpu_rq(cpu)-&gt;cfs;</span><br><span class="line">	<span class="comment">// 计算cfs的util</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> util_est, util = READ_ONCE(cfs_rq-&gt;avg.util_avg);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If @p migrates from @cpu to another, remove its contribution. Or,</span></span><br><span class="line"><span class="comment">	 * if @p migrates from another CPU to @cpu, add its contribution. In</span></span><br><span class="line"><span class="comment">	 * the other cases, @cpu is not impacted by the migration, so the</span></span><br><span class="line"><span class="comment">	 * util_avg should already be correct.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">// 在dst_cpu为-1的情况下</span></span><br><span class="line">	<span class="comment">// 若任务p运行在传入的CPU util = cfs_util - task_util(p)</span></span><br><span class="line">	<span class="keyword">if</span> (task_cpu(p) == cpu &amp;&amp; dst_cpu != cpu)</span><br><span class="line">		sub_positive(&amp;util, task_util(p));</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (task_cpu(p) != cpu &amp;&amp; dst_cpu == cpu)</span><br><span class="line">		util += task_util(p);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (sched_feat(UTIL_EST)) &#123;</span><br><span class="line">		util_est = READ_ONCE(cfs_rq-&gt;avg.util_est.enqueued);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * During wake-up, the task isn&#x27;t enqueued yet and doesn&#x27;t</span></span><br><span class="line"><span class="comment">		 * appear in the cfs_rq-&gt;avg.util_est.enqueued of any rq,</span></span><br><span class="line"><span class="comment">		 * so just add it (if needed) to &quot;simulate&quot; what will be</span></span><br><span class="line"><span class="comment">		 * cpu_util() after the task has been enqueued.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (dst_cpu == cpu)</span><br><span class="line">			util_est += _task_util_est(p);</span><br><span class="line"></span><br><span class="line">		util = max(util, util_est);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> min(util, capacity_orig_of(cpu));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * compute_energy(): Estimates the energy that @pd would consume if @p was</span></span><br><span class="line"><span class="comment"> * migrated to @dst_cpu. compute_energy() predicts what will be the utilization</span></span><br><span class="line"><span class="comment"> * landscape of @pd&#x27;s CPUs after the task migration, and uses the Energy Model</span></span><br><span class="line"><span class="comment"> * to compute what would be the energy if we decided to actually migrate that</span></span><br><span class="line"><span class="comment"> * task.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 计算任务迁移到dst_cpu后，整个pd，即此cluster的energy</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span></span></span><br><span class="line"><span class="function"><span class="title">compute_energy</span><span class="params">(struct task_struct *p, <span class="keyword">int</span> dst_cpu, struct perf_domain *pd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cpumask</span> *<span class="title">pd_mask</span> =</span> perf_domain_span(pd);</span><br><span class="line">	<span class="comment">// 获取该CPU的算力，这里取得的是归一化到1024的算力</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> cpu_cap = arch_scale_cpu_capacity(cpumask_first(pd_mask));</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> max_util = <span class="number">0</span>, sum_util = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> cpu;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 对此pd中每个online cpu都执行计算</span></span><br><span class="line">	for_each_cpu_and(cpu, pd_mask, cpu_online_mask) &#123;</span><br><span class="line">		<span class="comment">// 这里计算util_cfs，当dst_cpu传入为-1时，这里是没将p的util计算进去的</span></span><br><span class="line">		<span class="comment">// 这个地方比较关键，p的util有没有算到cpu的util里面去是在这一步决定的</span></span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> cpu_util, util_cfs = cpu_util_next(cpu, p, dst_cpu);</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">tsk</span> =</span> cpu == dst_cpu ? p : <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 返回该CPU下cfs+irq+rt+dl使用掉的CPU算力总和</span></span><br><span class="line">		<span class="comment">// 这一步计算没将任务p的util加进去</span></span><br><span class="line">		sum_util += schedutil_cpu_util(cpu, util_cfs, cpu_cap,</span><br><span class="line">					       ENERGY_UTIL, <span class="literal">NULL</span>);</span><br><span class="line">		<span class="comment">// 这一步计算将任务p的util加进去了</span></span><br><span class="line">		<span class="comment">// 这里计算cpu_util的原因就是需要预测下一次该perf_domain的频率</span></span><br><span class="line">		<span class="comment">// 计算的cpu_util是略微放大了的，需要进一步分析这个放大的操作</span></span><br><span class="line">		cpu_util = schedutil_cpu_util(cpu, util_cfs, cpu_cap,</span><br><span class="line">					      FREQUENCY_UTIL, tsk);</span><br><span class="line">		max_util = max(max_util, cpu_util);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 计算该pd下所有CPU的功耗和</span></span><br><span class="line">	<span class="keyword">return</span> em_cpu_energy(pd-&gt;em_pd, max_util, sum_util);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算该pd下所有CPU的功耗和</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">em_cpu_energy</span><span class="params">(struct em_perf_domain *pd,</span></span></span><br><span class="line"><span class="params"><span class="function">				<span class="keyword">unsigned</span> <span class="keyword">long</span> max_util, <span class="keyword">unsigned</span> <span class="keyword">long</span> sum_util)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> freq, scale_cpu;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">em_perf_state</span> *<span class="title">ps</span>;</span></span><br><span class="line">	<span class="keyword">int</span> i, cpu;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * In order to predict the performance state, map the utilization of</span></span><br><span class="line"><span class="comment">	 * the most utilized CPU of the performance domain to a requested</span></span><br><span class="line"><span class="comment">	 * frequency, like schedutil.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	cpu = cpumask_first(to_cpumask(pd-&gt;cpus));</span><br><span class="line">	scale_cpu = arch_scale_cpu_capacity(cpu);</span><br><span class="line">	ps = &amp;pd-&gt;table[pd-&gt;nr_perf_states - <span class="number">1</span>];</span><br><span class="line">	<span class="comment">// 这里将perf_domai计算出来的最大的CPU利用率来推测CPU接下来需要调频的频率</span></span><br><span class="line">	<span class="comment">// 这里可以将freq称为推测频率</span></span><br><span class="line">	<span class="comment">// 计算公式 freq = 1.25 * max_f * max_util / scale_cpu</span></span><br><span class="line">	<span class="comment">// 这里是在最大频率1.25倍进行计算的</span></span><br><span class="line">	freq = map_util_freq(max_util, ps-&gt;frequency, scale_cpu);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Find the lowest performance state of the Energy Model above the</span></span><br><span class="line"><span class="comment">	 * requested frequency.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">// 将该频率映射到频率表上</span></span><br><span class="line">	<span class="comment">// 因为freq是在1.5倍最大频率计算的，算出来的推测频率可能大于最大频率</span></span><br><span class="line">	<span class="comment">// 假如大于最大频率的话，for循环执行后ps指向的就是最大频率了</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; pd-&gt;nr_perf_states; i++) &#123;</span><br><span class="line">		ps = &amp;pd-&gt;table[i];</span><br><span class="line">		<span class="keyword">if</span> (ps-&gt;frequency &gt;= freq)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The capacity of a CPU in the domain at the performance state (ps)</span></span><br><span class="line"><span class="comment">	 * can be computed as:</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 *             ps-&gt;freq * scale_cpu</span></span><br><span class="line"><span class="comment">	 *   ps-&gt;cap = --------------------                          (1)</span></span><br><span class="line"><span class="comment">	 *                 cpu_max_freq</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * So, ignoring the costs of idle states (which are not available in</span></span><br><span class="line"><span class="comment">	 * the EM), the energy consumed by this CPU at that performance state</span></span><br><span class="line"><span class="comment">	 * is estimated as:</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 *             ps-&gt;power * cpu_util</span></span><br><span class="line"><span class="comment">	 *   cpu_nrg = --------------------                          (2)</span></span><br><span class="line"><span class="comment">	 *                   ps-&gt;cap</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * since &#x27;cpu_util / ps-&gt;cap&#x27; represents its percentage of busy time.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 *   <span class="doctag">NOTE:</span> Although the result of this computation actually is in</span></span><br><span class="line"><span class="comment">	 *         units of power, it can be manipulated as an energy value</span></span><br><span class="line"><span class="comment">	 *         over a scheduling period, since it is assumed to be</span></span><br><span class="line"><span class="comment">	 *         constant during that interval.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * By injecting (1) in (2), &#x27;cpu_nrg&#x27; can be re-expressed as a product</span></span><br><span class="line"><span class="comment">	 * of two terms:</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 *             ps-&gt;power * cpu_max_freq   cpu_util</span></span><br><span class="line"><span class="comment">	 *   cpu_nrg = ------------------------ * ---------          (3)</span></span><br><span class="line"><span class="comment">	 *                    ps-&gt;freq            scale_cpu</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * The first term is static, and is stored in the em_perf_state struct</span></span><br><span class="line"><span class="comment">	 * as &#x27;ps-&gt;cost&#x27;.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Since all CPUs of the domain have the same micro-architecture, they</span></span><br><span class="line"><span class="comment">	 * share the same &#x27;ps-&gt;cost&#x27;, and the same CPU capacity. Hence, the</span></span><br><span class="line"><span class="comment">	 * total energy of the domain (which is the simple sum of the energy of</span></span><br><span class="line"><span class="comment">	 * all of its CPUs) can be factorized as:</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 *            ps-&gt;cost * \Sum cpu_util</span></span><br><span class="line"><span class="comment">	 *   pd_nrg = ------------------------                       (4)</span></span><br><span class="line"><span class="comment">	 *                  scale_cpu</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">// 根据推测频率在频点表上对应的cost来算energy</span></span><br><span class="line">	<span class="comment">// 不同频率的cost是常数，在初始化时就已经计算出来</span></span><br><span class="line">	<span class="comment">// 计算cost的时候需要将该perf_domain上的所有util拿出来进行计算</span></span><br><span class="line">	<span class="comment">// 一个perf_domain下的频率是一样的，所以这里计算能耗直接用了sum_util</span></span><br><span class="line">	<span class="keyword">return</span> ps-&gt;cost * sum_util / scale_cpu;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 寻找工作能耗最低的CPU</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">find_energy_efficient_cpu</span><span class="params">(struct task_struct *p, <span class="keyword">int</span> prev_cpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> prev_delta = ULONG_MAX, best_delta = ULONG_MAX;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">root_domain</span> *<span class="title">rd</span> =</span> cpu_rq(smp_processor_id())-&gt;rd;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> cpu_cap, util, base_energy = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> cpu, best_energy_cpu = prev_cpu;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sched_domain</span> *<span class="title">sd</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">perf_domain</span> *<span class="title">pd</span>;</span></span><br><span class="line"></span><br><span class="line">	rcu_read_lock();</span><br><span class="line">	<span class="comment">// 从rd取pd的指针</span></span><br><span class="line">	pd = rcu_dereference(rd-&gt;pd);</span><br><span class="line">	<span class="keyword">if</span> (!pd || READ_ONCE(rd-&gt;overutilized))</span><br><span class="line">		<span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Energy-aware wake-up happens on the lowest sched_domain starting</span></span><br><span class="line"><span class="comment">	 * from sd_asym_cpucapacity spanning over this_cpu and prev_cpu.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	sd = rcu_dereference(*this_cpu_ptr(&amp;sd_asym_cpucapacity));</span><br><span class="line">	<span class="keyword">while</span> (sd &amp;&amp; !cpumask_test_cpu(prev_cpu, sched_domain_span(sd)))</span><br><span class="line">		sd = sd-&gt;parent;</span><br><span class="line">	<span class="keyword">if</span> (!sd)</span><br><span class="line">		<span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">	sync_entity_load_avg(&amp;p-&gt;se);</span><br><span class="line">	<span class="comment">// p的util为0，直接返回prev_cpu</span></span><br><span class="line">	<span class="keyword">if</span> (!task_util_est(p))</span><br><span class="line">		<span class="keyword">goto</span> unlock;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 遍历整个pd链表，计算p在不同pd下的能耗</span></span><br><span class="line">	<span class="keyword">for</span> (; pd; pd = pd-&gt;next) &#123;</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> cur_delta, spare_cap, max_spare_cap = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> base_energy_pd;</span><br><span class="line">		<span class="keyword">int</span> max_spare_cap_cpu = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Compute the &#x27;base&#x27; energy of the pd, without @p */</span></span><br><span class="line">		<span class="comment">// 计算不包括p的情况下此pd当前的energy</span></span><br><span class="line">		<span class="comment">// 这里传入dst_cpu为-1，计算的就是该perf_domain不包括任务P的util</span></span><br><span class="line">		<span class="comment">// 来进行频率推测，然后用来计算能耗</span></span><br><span class="line">		base_energy_pd = compute_energy(p, <span class="number">-1</span>, pd);</span><br><span class="line">		<span class="comment">// 不包括p的情况下系统的总energy</span></span><br><span class="line">		base_energy += base_energy_pd;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 遍历整个pd中的CPU，计算p放在该CPU上的功耗</span></span><br><span class="line">		for_each_cpu_and(cpu, perf_domain_span(pd), sched_domain_span(sd)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!cpumask_test_cpu(cpu, p-&gt;cpus_ptr))</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="comment">// 计算p放到此CPU后该CPU总共消耗的算力</span></span><br><span class="line">			util = cpu_util_next(cpu, p, cpu);</span><br><span class="line">			<span class="comment">// 这里取的是归一化后的CPU算力</span></span><br><span class="line">			cpu_cap = capacity_of(cpu);</span><br><span class="line">			spare_cap = cpu_cap;</span><br><span class="line">			<span class="comment">// 计算p放到此CPU后剩余的算力</span></span><br><span class="line">			lsub_positive(&amp;spare_cap, util);</span><br><span class="line"></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * Skip CPUs that cannot satisfy the capacity request.</span></span><br><span class="line"><span class="comment">			 * IOW, placing the task there would make the CPU</span></span><br><span class="line"><span class="comment">			 * overutilized. Take uclamp into account to see how</span></span><br><span class="line"><span class="comment">			 * much capacity we can get out of the CPU; this is</span></span><br><span class="line"><span class="comment">			 * aligned with schedutil_cpu_util().</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			util = uclamp_rq_util_with(cpu_rq(cpu), util, p);</span><br><span class="line">			<span class="comment">// CPU需要保留20%左右的算力，不满足需求后进行下一个CPU的探测</span></span><br><span class="line">			<span class="keyword">if</span> (!fits_capacity(util, cpu_cap))</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* Always use prev_cpu as a candidate. */</span></span><br><span class="line">			<span class="comment">// 若对比的这个CPU就是任务之前运行的CPU</span></span><br><span class="line">			<span class="keyword">if</span> (cpu == prev_cpu) &#123;</span><br><span class="line">				<span class="comment">// 计算p放在该cpu后整个pd的能量消耗</span></span><br><span class="line">				<span class="comment">// 这里传入的dst_cpu为之前p运行的CPU</span></span><br><span class="line">				<span class="comment">// 推测频率是在之前运行CPU进行推测，同时把P的util也计算到了</span></span><br><span class="line">				prev_delta = compute_energy(p, prev_cpu, pd);</span><br><span class="line">				<span class="comment">// 计算p放在该CPU后整个pd增加的能量消耗</span></span><br><span class="line">				prev_delta -= base_energy_pd;</span><br><span class="line">				<span class="comment">// 更新best_delta，取最优能耗</span></span><br><span class="line">				best_delta = min(best_delta, prev_delta);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * Find the CPU with the maximum spare capacity in</span></span><br><span class="line"><span class="comment">			 * the performance domain</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="comment">// 记录p放上去后剩余算力最大的CPU和最大的剩余算力</span></span><br><span class="line">			<span class="keyword">if</span> (spare_cap &gt; max_spare_cap) &#123;</span><br><span class="line">				max_spare_cap = spare_cap;</span><br><span class="line">				max_spare_cap_cpu = cpu;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Evaluate the energy impact of using this CPU. */</span></span><br><span class="line">		<span class="comment">// 同一个簇上的CPU取最大余量算力的那个CPU与其他簇的CPU做能量消耗对比</span></span><br><span class="line">		<span class="keyword">if</span> (max_spare_cap_cpu &gt;= <span class="number">0</span> &amp;&amp; max_spare_cap_cpu != prev_cpu) &#123;</span><br><span class="line">			<span class="comment">// 计算p放在算力剩余最大的CPU后整个pd的能量消耗</span></span><br><span class="line">			<span class="comment">// 这里传进去的dst_cpu肯定不会和当前任务p运行的CPU相同</span></span><br><span class="line">			<span class="comment">// 所以在cpu_util_next()中会把p的util加到cpu util上</span></span><br><span class="line">			cur_delta = compute_energy(p, max_spare_cap_cpu, pd);</span><br><span class="line">			<span class="comment">// 计算能量消耗增量</span></span><br><span class="line">			cur_delta -= base_energy_pd;</span><br><span class="line">			<span class="comment">// 如果当前能量增量优于p放在prev_cpu运行的能量消耗，则取该cpu运行p</span></span><br><span class="line">			<span class="keyword">if</span> (cur_delta &lt; best_delta) &#123;</span><br><span class="line">				best_delta = cur_delta;</span><br><span class="line">				best_energy_cpu = max_spare_cap_cpu;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">unlock:</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Pick the best CPU if prev_cpu cannot be used, or if it saves at</span></span><br><span class="line"><span class="comment">	 * least 6% of the energy used by prev_cpu.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">// 若prev_cpu找不到，就直接返回最优能耗cpu</span></span><br><span class="line">	<span class="keyword">if</span> (prev_delta == ULONG_MAX)</span><br><span class="line">		<span class="keyword">return</span> best_energy_cpu;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 若最优能耗比放在prev_cpu上运行的能耗还要低6.25%以上，则取最优能耗cpu</span></span><br><span class="line">	<span class="keyword">if</span> ((prev_delta - best_delta) &gt; ((prev_delta + base_energy) &gt;&gt; <span class="number">4</span>))</span><br><span class="line">		<span class="keyword">return</span> best_energy_cpu;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 否则不做改变，直接使用prev_cpu运行p</span></span><br><span class="line">	<span class="keyword">return</span> prev_cpu;</span><br><span class="line"></span><br><span class="line">fail:</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="EAS-Mainline"><a href="#EAS-Mainline" class="headerlink" title="EAS Mainline"></a>EAS Mainline</h3><p><a target="_blank" rel="noopener" href="https://git.gitlab.arm.com/linux-arm/linux-power.git">https://git.gitlab.arm.com/linux-arm/linux-power.git</a></p>

    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>Jack
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://jackhuang021.github.io/archives/fbf46cf3.html" title="Linux Cpufreq框架">https://jackhuang021.github.io/archives/fbf46cf3.html</a>
  </li>
  <li class="post-copyright-license">
      <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/Linux/" rel="tag"># Linux</a>
              <a href="/tags/Cpufreq/" rel="tag"># Cpufreq</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/archives/21d76c15.html" rel="prev" title="git使用记录">
                  <i class="fa fa-angle-left"></i> git使用记录
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/archives/8c0c86d5.html" rel="next" title="Linux内核likely()和unlikely()">
                  Linux内核likely()和unlikely() <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2021 – 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-user"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Jack</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">295k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">4:28</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/JackHuang021" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  <script src="/js/third-party/pace.js"></script>


  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





</body>
</html>
