<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/all.min.css" integrity="sha256-AbA177XfpSnFEvgpYu1jMygiLabzPCJCRIBtR5jGc0k=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"jackhuang021.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.13.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"mac","show_result":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="Linux Kernel主要通过三类机制来实现SMP（Symmetric Multiprocessing，对称多核）系统CPU core的电源管理：  cpu hotplug: 根据应用场景来up&#x2F;down CPU cpuidle framework: 当cpu上没有可执行任务时，就会进入空闲状态 cpufreq framework: 根据使用场景和系统负荷来调整CPU的电压和频率">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux Cpufreq 框架">
<meta property="og:url" content="https://jackhuang021.github.io/archives/fbf46cf3.html">
<meta property="og:site_name" content="Jack&#39;s Home">
<meta property="og:description" content="Linux Kernel主要通过三类机制来实现SMP（Symmetric Multiprocessing，对称多核）系统CPU core的电源管理：  cpu hotplug: 根据应用场景来up&#x2F;down CPU cpuidle framework: 当cpu上没有可执行任务时，就会进入空闲状态 cpufreq framework: 根据使用场景和系统负荷来调整CPU的电压和频率">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/JackHuang021/images/master/20221124110212.png">
<meta property="og:image" content="https://raw.githubusercontent.com/JackHuang021/images/master/20230103092146.png">
<meta property="og:image" content="https://raw.githubusercontent.com/JackHuang021/images/master/20230103093856.png">
<meta property="og:image" content="https://raw.githubusercontent.com/JackHuang021/images/master/20230103094857.png">
<meta property="og:image" content="https://raw.githubusercontent.com/JackHuang021/images/master/20230103140116.png">
<meta property="og:image" content="https://raw.githubusercontent.com/JackHuang021/images/master/20230103174117.png">
<meta property="og:image" content="https://raw.githubusercontent.com/JackHuang021/images/master/20221216104706.png">
<meta property="article:published_time" content="2022-11-24T02:23:01.000Z">
<meta property="article:modified_time" content="2023-01-03T10:01:53.934Z">
<meta property="article:author" content="Jack">
<meta property="article:tag" content="Linux">
<meta property="article:tag" content="Cpufreq">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/JackHuang021/images/master/20221124110212.png">


<link rel="canonical" href="https://jackhuang021.github.io/archives/fbf46cf3.html">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://jackhuang021.github.io/archives/fbf46cf3.html","path":"archives/fbf46cf3.html","title":"Linux Cpufreq 框架"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Linux Cpufreq 框架 | Jack's Home</title>
  

  <script src="/js/third-party/analytics/baidu-analytics.js"></script>
  <script async src="https://hm.baidu.com/hm.js?cf1cdec429059a964c53024129e34116"></script>





  <script async defer data-website-id="" src=""></script>

  <script defer data-domain="" src=""></script>

  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Jack's Home</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#cpufreq%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84"><span class="nav-number">1.</span> <span class="nav-text">cpufreq软件架构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#cpufreq%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B"><span class="nav-number">2.</span> <span class="nav-text">cpufreq初始化过程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#cpufreq%E5%A4%A7%E6%A6%82%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B"><span class="nav-number">2.1.</span> <span class="nav-text">cpufreq大概的初始化流程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Performance-Domain-opp%EF%BC%88Operating-Performance-Points%EF%BC%89%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">2.2.</span> <span class="nav-text">Performance Domain opp（Operating Performance Points）表初始化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#cpufreq%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B-1"><span class="nav-number">2.3.</span> <span class="nav-text">cpufreq初始化过程</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#cpufreq-governor%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B"><span class="nav-number">3.</span> <span class="nav-text">cpufreq_governor的初始化过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#schedutil%E8%B0%83%E5%BA%A6%E5%99%A8%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-number">4.</span> <span class="nav-text">schedutil调度器代码分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#EAS%E7%9B%B8%E5%85%B3"><span class="nav-number">5.</span> <span class="nav-text">EAS相关</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#CPU%E7%AE%97%E5%8A%9B%E5%BD%92%E4%B8%80%E5%8C%96%E8%BF%87%E7%A8%8B"><span class="nav-number">5.1.</span> <span class="nav-text">CPU算力归一化过程</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Jack"
      src="/images/favicon-32x32.png">
  <p class="site-author-name" itemprop="name">Jack</p>
  <div class="site-description" itemprop="description">build a better world</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">21</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">27</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/JackHuang021" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;JackHuang021" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:jackhuang021@gmail.com" title="E-Mail → mailto:jackhuang021@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jackhuang021.github.io/archives/fbf46cf3.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/favicon-32x32.png">
      <meta itemprop="name" content="Jack">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jack's Home">
      <meta itemprop="description" content="build a better world">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Linux Cpufreq 框架 | Jack's Home">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Linux Cpufreq 框架
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-11-24 10:23:01" itemprop="dateCreated datePublished" datetime="2022-11-24T10:23:01+08:00">2022-11-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-01-03 18:01:53" itemprop="dateModified" datetime="2023-01-03T18:01:53+08:00">2023-01-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>36k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>32 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>Linux Kernel主要通过三类机制来实现SMP（Symmetric Multiprocessing，对称多核）系统CPU core的电源管理：</p>
<ul>
<li>cpu hotplug: 根据应用场景来up&#x2F;down CPU</li>
<li>cpuidle framework: 当cpu上没有可执行任务时，就会进入空闲状态</li>
<li>cpufreq framework: 根据使用场景和系统负荷来调整CPU的电压和频率</li>
</ul>
<span id="more"></span>
<p>cpufreq framework的核心功能，是通过调整CPU core的电压或频率，兼顾系统的性能和功耗。在不需要高性能时，降低电压或频率，以降低功耗；在需要高性能时，提高电压或频率，以提高性能。</p>
<p>cpufreq framework中的几个重要概念：</p>
<ol>
<li>policy（策略）：同一个簇的CPU动态调频的一个集合结构体，包含了当前使用的governor和cpufreq driver</li>
<li>governor（调节器）：决定如何计算合适的频率或电压</li>
<li>cpufreq driver：来实现真正的调频执行工作（与平台相关）</li>
</ol>
<p>常用的governor类型</p>
<ol>
<li>Performance：总是将CPU置于最高性能的状态，即硬件所支持的最高频率、电压</li>
<li>Powersaving：总是将CPU置于最节能的状态，即硬件所支持的最低频率、电压</li>
<li>Ondemand：设置CPU负载的阈值T，当负载低于T时，调节至一个刚好能够满足当前负载需求的最低频&#x2F;最低压；当负载高于T时，立即提升到最高性能状态</li>
<li>Conservative：跟Ondemand策略类似，设置CPU负载的阈值T，当负载低于T时，调节至一个刚好能够满足当前负载需求的最低频&#x2F;最低压；但当负载高于T时，不是立即设置为最高性能状态，而是逐级升高主频&#x2F;电压</li>
<li>Userspace：将控制接口通过sysfs开放给用户，由用户进行自定义策略</li>
<li>Schedutil：这是从Linux-4.7版本开始才引入的策略，其原理是根据调度器所提供的CPU利用率信息进行电压&#x2F;频率调节，EAS使用schedutil进行调频</li>
</ol>
<p>sysfs用户层接口，目录位于<code>/sys/devices/system/cpu/cpufreq/policy</code><br><img src="https://raw.githubusercontent.com/JackHuang021/images/master/20221124110212.png"></p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">cpuinfo_max_freq</td>
<td align="left">硬件所支持的最高频率</td>
</tr>
<tr>
<td align="left">cpuinfo_min_freq</td>
<td align="left">硬件所支持的最低频率</td>
</tr>
<tr>
<td align="left">affected_cpus</td>
<td align="left">该policy影响到哪些cpu（没显示offline状态的cpu）</td>
</tr>
<tr>
<td align="left">related_cpus</td>
<td align="left">该policy影响到的所有cpu，包括offline状态的cpu</td>
</tr>
<tr>
<td align="left">scaling_max_freq</td>
<td align="left">该policy支持调整的最高频率</td>
</tr>
<tr>
<td align="left">scaling_min_freq</td>
<td align="left">该policy支持调整的最低频率</td>
</tr>
<tr>
<td align="left">scaling_cur_freq</td>
<td align="left">policy当前设置的频率</td>
</tr>
<tr>
<td align="left">scaling_available_governors</td>
<td align="left">当前系统支持的governor</td>
</tr>
<tr>
<td align="left">scaling_available_frequencies</td>
<td align="left">支持的调频频率</td>
</tr>
<tr>
<td align="left">scaling_driver</td>
<td align="left">当前使用的调频驱动</td>
</tr>
<tr>
<td align="left">scaling_governor</td>
<td align="left">当前使用的governor</td>
</tr>
<tr>
<td align="left">scaling_setspeed</td>
<td align="left">在userspace模式下才能使用，手动设置频率</td>
</tr>
</tbody></table>
<h4 id="cpufreq软件架构"><a href="#cpufreq软件架构" class="headerlink" title="cpufreq软件架构"></a>cpufreq软件架构</h4><p><img src="https://raw.githubusercontent.com/JackHuang021/images/master/20230103092146.png"><br>cpufreq core（可以理解为对policy的操作）：把一些公共的逻辑和接口代码抽象出来</p>
<ul>
<li><code>cpufreq</code>作为所有cpu设备的一个功能，注册到了<code>cpu_subsys</code>总线上</li>
<li>对上以sysfs的形式向用户空间提供统一的接口，以notifier的形式向其他driver提供频率变化的通知</li>
<li>对下提供CPU频率和电压控制的驱动框架，方便底层driver的开发，同时提供governor框架，用于实现不同的频率调整机制</li>
<li>内部封装各种逻辑，主要围绕<code>struct cpufreq_policy</code> <code>struct cpufreq_driver</code> <code>struct cpufreq_governor</code>三个数据结构进行</li>
</ul>
<p>kernel使用<code>struct cpufreq_policy</code>用来抽象cpufreq，它从一定程度上代表了一个簇CPU的cpufreq的属性<br><img src="https://raw.githubusercontent.com/JackHuang021/images/master/20230103093856.png"></p>
<p><code>cpufreq_policy</code>结构体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cpufreq_cpuinfo</span> &#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		max_freq;			<span class="comment">// cpu最大频率</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		min_freq;			<span class="comment">// cpu最小频率</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* in 10^(-9) s = nanoseconds */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		transition_latency;	<span class="comment">// cpu频率转换时间 单位：ns</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cpufreq_policy</span> &#123;</span></span><br><span class="line">	<span class="comment">/* CPUs sharing clock, require sw coordination */</span></span><br><span class="line">	<span class="keyword">cpumask_var_t</span>		cpus;	<span class="comment">/* Online CPUs only */</span></span><br><span class="line">	<span class="keyword">cpumask_var_t</span>		related_cpus; <span class="comment">/* Online + Offline CPUs */</span></span><br><span class="line">	<span class="keyword">cpumask_var_t</span>		real_cpus; <span class="comment">/* Related and present */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		shared_type; <span class="comment">/* ACPI: ANY or ALL affected CPUs</span></span><br><span class="line"><span class="comment">						should set cpufreq */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		cpu;    <span class="comment">/* cpu managing this policy, must be online */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">clk</span>		*<span class="title">clk</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cpufreq_cpuinfo</span>	<span class="title">cpuinfo</span>;</span><span class="comment">/* see above */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		min;    <span class="comment">/* in kHz */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		max;    <span class="comment">/* in kHz */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		cur;    <span class="comment">/* in kHz, only needed if cpufreq</span></span><br><span class="line"><span class="comment">					 * governors are used */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cpufreq_governor</span>	*<span class="title">governor</span>;</span> <span class="comment">/* see below */</span></span><br><span class="line">	<span class="keyword">void</span>			*governor_data;</span><br><span class="line">	<span class="keyword">char</span>			last_governor[CPUFREQ_NAME_LEN]; <span class="comment">/* last governor used */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span>	<span class="title">update</span>;</span> <span class="comment">/* if update_policy() needs to be</span></span><br><span class="line"><span class="comment">					 * called, but you&#x27;re in IRQ context */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cpufreq_user_policy</span> <span class="title">user_policy</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cpufreq_frequency_table</span>	*<span class="title">freq_table</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">cpufreq_table_sorting</span> <span class="title">freq_table_sorted</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>        <span class="title">policy_list</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kobject</span>		<span class="title">kobj</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">completion</span>	<span class="title">kobj_unregister</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Preferred average time interval between consecutive invocations of</span></span><br><span class="line"><span class="comment">	 * the driver to set the frequency for this policy.  To be set by the</span></span><br><span class="line"><span class="comment">	 * scaling driver (0, which is the default, means no preference).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		transition_delay_us;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Remote DVFS flag (Not added to the driver structure as we don&#x27;t want</span></span><br><span class="line"><span class="comment">	 * to access another structure from scheduler hotpath).</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Should be set if CPUs can do DVFS on behalf of other CPUs from</span></span><br><span class="line"><span class="comment">	 * different cpufreq policies.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">bool</span>			dvfs_possible_from_any_cpu;</span><br><span class="line"></span><br><span class="line">	 <span class="comment">/* Cached frequency lookup from cpufreq_driver_resolve_freq. */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> cached_target_freq;</span><br><span class="line">	<span class="keyword">int</span> cached_resolved_idx;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* cpufreq-stats */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cpufreq_stats</span>	*<span class="title">stats</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* For cpufreq driver&#x27;s internal use */</span></span><br><span class="line">	<span class="keyword">void</span>			*driver_data;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>driver/cpufreq/cpufreq.c</code>中定义了一个全局的percpu变量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">DEFINE_PER_CPU</span><span class="params">(struct cpufreq_policy *, cpufreq_cpu_data)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这里对应E2000 sysfs中3个policy文件夹，两个小核在一个簇中，使用1个policy，另外两个大核分别对应1个policy<br><img src="https://raw.githubusercontent.com/JackHuang021/images/master/20230103094857.png"></p>
<blockquote>
<p>per-CPU变量是linux系统一个非常重要的特性，它为系统中的每个处理器都分配了该变量的副本。这样做的好处是，在多处理器系统中，当处理器操作属于它的变量副本时，不需要考虑与其他处理器的竞争的问题，同时该副本还可以充分利用处理器本地的硬件缓冲cache来提供访问速度</p>
</blockquote>
<h4 id="cpufreq初始化过程"><a href="#cpufreq初始化过程" class="headerlink" title="cpufreq初始化过程"></a>cpufreq初始化过程</h4><p><code>cpufreq_driver</code>结构体如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cpufreq_driver</span> &#123;</span></span><br><span class="line">	<span class="keyword">char</span>		name[CPUFREQ_NAME_LEN];</span><br><span class="line">	u16		    flags;</span><br><span class="line">	<span class="keyword">void</span>		*driver_data;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* needed by all drivers */</span></span><br><span class="line">	<span class="keyword">int</span>		(*init)(struct cpufreq_policy *policy);</span><br><span class="line">	<span class="keyword">int</span>		(*verify)(struct cpufreq_policy_data *policy);</span><br><span class="line">	<span class="keyword">int</span>		(*target_index)(struct cpufreq_policy *policy,</span><br><span class="line">					<span class="keyword">unsigned</span> <span class="keyword">int</span> index);</span><br><span class="line">	<span class="function"><span class="keyword">unsigned</span> <span class="title">int</span>	<span class="params">(*fast_switch)</span><span class="params">(struct cpufreq_policy *policy,</span></span></span><br><span class="line"><span class="params"><span class="function">				       <span class="keyword">unsigned</span> <span class="keyword">int</span> target_freq)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* should be defined, if possible */</span></span><br><span class="line">	<span class="function"><span class="keyword">unsigned</span> <span class="title">int</span>	<span class="params">(*get)</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> cpu)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Called to update policy limits on firmware notifications. */</span></span><br><span class="line">	<span class="keyword">void</span>		(*update_limits)(<span class="keyword">unsigned</span> <span class="keyword">int</span> cpu);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span>		(*online)(struct cpufreq_policy *policy);</span><br><span class="line">	<span class="keyword">int</span>		(*offline)(struct cpufreq_policy *policy);</span><br><span class="line">	<span class="keyword">int</span>		(*<span class="built_in">exit</span>)(struct cpufreq_policy *policy);</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">freq_attr</span> **<span class="title">attr</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="cpufreq大概的初始化流程"><a href="#cpufreq大概的初始化流程" class="headerlink" title="cpufreq大概的初始化流程"></a>cpufreq大概的初始化流程</h5><p><code>cpufreq_register_driver()</code>函数为cpufreq驱动注册的入口，驱动程序通过调用该函数进行初始化，传入相关的<code>struct cpufreq_driver</code>，<code>cpufreq_register_driver()</code>会调用<code>subsys_interface_register()</code>最终执行回调函数<code>cpufreq_add_dev</code>，然后调用<code>cpufreq_online()</code>走初始化流程</p>
<h5 id="Performance-Domain-opp（Operating-Performance-Points）表初始化"><a href="#Performance-Domain-opp（Operating-Performance-Points）表初始化" class="headerlink" title="Performance Domain opp（Operating Performance Points）表初始化"></a>Performance Domain opp（Operating Performance Points）表初始化</h5><p>OPP表的定义：域中每个设备支持的电压和频率的离散元组的集合称为Operating Performance Points（OPP）,内核设备树opp文档<code>Documentation/devicetree/bindings/opp/opp.txt</code>  </p>
<p>假设一个CPU设备支持如下的电压和频率关系：<br>{300MHz at minimum voltage of 1V}<br>{800MHz at minimum voltage of 1.2V}<br>{1GHz at minimum voltage of 1.3V}<br>用OPP表示就可以用{Hz,  uV}方式表示如下:<br>{300000000, 1000000}<br>{800000000, 1200000}<br>{1000000000, 1300000}</p>
<p>这里初始化的就是各个性能域（即不同CPU簇）的OPP表，在E2000平台中是通过SCMI的Performace domain management protocol协议获取PERFORMANCE_DESCRIBE_LEVELS这个参数表，具体的数据交互源码在<code>drivers/firmware/arm_scmi/perf.c</code>里面，<code>perf.c</code>实现了SCMI的Performance domain managment protocol，scmi cpufreq_drvier也是通过<code>perf_ops</code>函数集进行调频</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/linux/scmi_protocol.h</span></span><br><span class="line"><span class="comment">// 抽象描述scmi协议的结构体，相应的ops操作集对应scmi的一个协议</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">scmi_handle</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">scmi_revision_info</span> *<span class="title">version</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">scmi_perf_ops</span> *<span class="title">perf_ops</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">scmi_clk_ops</span> *<span class="title">clk_ops</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">scmi_power_ops</span> *<span class="title">power_ops</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">scmi_sensor_ops</span> *<span class="title">sensor_ops</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">scmi_reset_ops</span> *<span class="title">reset_ops</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">scmi_notify_ops</span> *<span class="title">notify_ops</span>;</span></span><br><span class="line">	<span class="comment">/* for protocol internal use */</span></span><br><span class="line">	<span class="keyword">void</span> *perf_priv;</span><br><span class="line">	<span class="keyword">void</span> *clk_priv;</span><br><span class="line">	<span class="keyword">void</span> *power_priv;</span><br><span class="line">	<span class="keyword">void</span> *sensor_priv;</span><br><span class="line">	<span class="keyword">void</span> *reset_priv;</span><br><span class="line">	<span class="keyword">void</span> *notify_priv;</span><br><span class="line">	<span class="keyword">void</span> *system_priv;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// scmi_handle这个结构体实现的就是scmi整个协议的处理</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">scmi_handle</span> *<span class="title">handle</span>;</span>	</span><br><span class="line"></span><br><span class="line"><span class="comment">// include/linux/scmi_protocol.h</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct scmi_perf_ops - represents the various operations provided</span></span><br><span class="line"><span class="comment"> *	by SCMI Performance Protocol</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @limits_set: sets limits on the performance level of a domain</span></span><br><span class="line"><span class="comment"> * @limits_get: gets limits on the performance level of a domain</span></span><br><span class="line"><span class="comment"> * @level_set: sets the performance level of a domain</span></span><br><span class="line"><span class="comment"> * @level_get: gets the performance level of a domain</span></span><br><span class="line"><span class="comment"> * @device_domain_id: gets the scmi domain id for a given device</span></span><br><span class="line"><span class="comment"> * @transition_latency_get: gets the DVFS transition latency for a given device</span></span><br><span class="line"><span class="comment"> * @device_opps_add: adds all the OPPs for a given device</span></span><br><span class="line"><span class="comment"> * @freq_set: sets the frequency for a given device using sustained frequency</span></span><br><span class="line"><span class="comment"> *	to sustained performance level mapping</span></span><br><span class="line"><span class="comment"> * @freq_get: gets the frequency for a given device using sustained frequency</span></span><br><span class="line"><span class="comment"> *	to sustained performance level mapping</span></span><br><span class="line"><span class="comment"> * @est_power_get: gets the estimated power cost for a given performance domain</span></span><br><span class="line"><span class="comment"> *	at a given frequency</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">scmi_perf_ops</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> (*limits_set)(<span class="keyword">const</span> struct scmi_handle *handle, u32 domain,</span><br><span class="line">			  u32 max_perf, u32 min_perf);</span><br><span class="line">	<span class="keyword">int</span> (*limits_get)(<span class="keyword">const</span> struct scmi_handle *handle, u32 domain,</span><br><span class="line">			  u32 *max_perf, u32 *min_perf);</span><br><span class="line">	<span class="keyword">int</span> (*level_set)(<span class="keyword">const</span> struct scmi_handle *handle, u32 domain,</span><br><span class="line">			 u32 level, <span class="keyword">bool</span> poll);</span><br><span class="line">	<span class="keyword">int</span> (*level_get)(<span class="keyword">const</span> struct scmi_handle *handle, u32 domain,</span><br><span class="line">			 u32 *level, <span class="keyword">bool</span> poll);</span><br><span class="line">	<span class="keyword">int</span> (*device_domain_id)(struct device *dev);</span><br><span class="line">	<span class="keyword">int</span> (*transition_latency_get)(<span class="keyword">const</span> struct scmi_handle *handle,</span><br><span class="line">				      struct device *dev);</span><br><span class="line">	<span class="keyword">int</span> (*device_opps_add)(<span class="keyword">const</span> struct scmi_handle *handle,</span><br><span class="line">			       struct device *dev);</span><br><span class="line">	<span class="keyword">int</span> (*freq_set)(<span class="keyword">const</span> struct scmi_handle *handle, u32 domain,</span><br><span class="line">			<span class="keyword">unsigned</span> <span class="keyword">long</span> rate, <span class="keyword">bool</span> poll);</span><br><span class="line">	<span class="keyword">int</span> (*freq_get)(<span class="keyword">const</span> struct scmi_handle *handle, u32 domain,</span><br><span class="line">			<span class="keyword">unsigned</span> <span class="keyword">long</span> *rate, <span class="keyword">bool</span> poll);</span><br><span class="line">	<span class="keyword">int</span> (*est_power_get)(<span class="keyword">const</span> struct scmi_handle *handle, u32 domain,</span><br><span class="line">			     <span class="keyword">unsigned</span> <span class="keyword">long</span> *rate, <span class="keyword">unsigned</span> <span class="keyword">long</span> *power);</span><br><span class="line">	<span class="keyword">bool</span> (*fast_switch_possible)(<span class="keyword">const</span> struct scmi_handle *handle,</span><br><span class="line">				     struct device *dev);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// scmi performance domain management protocol(性能域管理相关协议 0x13), messageid: 0x03</span></span><br><span class="line"><span class="comment">// scmi opp结构体定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">scmi_opp</span> &#123;</span></span><br><span class="line">	u32 perf;		<span class="comment">// 性能级别，单位KHz</span></span><br><span class="line">	u32 power;		<span class="comment">// 当前性能级别的功耗</span></span><br><span class="line">	u32 trans_latency_us;	<span class="comment">// 切换延时</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// scmi performance domain management protocol(性能域管理相关协议 0x13)对应操作函数集</span></span><br><span class="line"><span class="comment">// scmi cpufreq_driver 主要利用这个函数集进行调频相关操作</span></span><br><span class="line"><span class="comment">// 对应Performace domain management protocol各个message_id</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">scmi_perf_ops</span> <span class="title">perf_ops</span> =</span> &#123;</span><br><span class="line">	.limits_set = scmi_perf_limits_set,</span><br><span class="line">	.limits_get = scmi_perf_limits_get,</span><br><span class="line">	.level_set = scmi_perf_level_set,</span><br><span class="line">	.level_get = scmi_perf_level_get,</span><br><span class="line">	.device_domain_id = scmi_dev_domain_id,</span><br><span class="line">	.transition_latency_get = scmi_dvfs_transition_latency_get,</span><br><span class="line">	.device_opps_add = scmi_dvfs_device_opps_add,</span><br><span class="line">	.freq_set = scmi_dvfs_freq_set,</span><br><span class="line">	.freq_get = scmi_dvfs_freq_get,</span><br><span class="line">	.est_power_get = scmi_dvfs_est_power_get,</span><br><span class="line">	.fast_switch_possible = scmi_fast_switch_possible,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在这个宏进行SCMI performance domain management protocol协议的初始化</span></span><br><span class="line">DEFINE_SCMI_PROTOCOL_REGISTER_UNREGISTER(SCMI_PROTOCOL_PERF, perf)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFINE_SCMI_PROTOCOL_REGISTER_UNREGISTER(id, name) \</span></span><br><span class="line"><span class="meta">int __init scmi_##name##_register(void) \</span></span><br><span class="line"><span class="meta">&#123; \</span></span><br><span class="line"><span class="meta">	return scmi_protocol_register((id), &amp;scmi_##name##_protocol_init); \</span></span><br><span class="line"><span class="meta">&#125; \</span></span><br><span class="line"><span class="meta">\</span></span><br><span class="line"><span class="meta">void __exit scmi_##name##_unregister(void) \</span></span><br><span class="line"><span class="meta">&#123; \</span></span><br><span class="line"><span class="meta">	scmi_protocol_unregister((id)); \</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="comment">// 展开该宏</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> __init <span class="title">scmi_perf_register</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> scmi_protocol_register(SCMI_PROTOCOL_PER, &amp;scmi_perf_protocol_init);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化过程中调用了scmi_perf_protocol_init();</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">scmi_perf_protocol_init</span><span class="params">(struct scmi_handle *handle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> domain;</span><br><span class="line">	u32 version;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">scmi_perf_info</span> *<span class="title">pinfo</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取当前perf domain management协议版本</span></span><br><span class="line">	scmi_version_get(handle, SCMI_PROTOCOL_PERF, &amp;version);</span><br><span class="line"></span><br><span class="line">	dev_dbg(handle-&gt;dev, <span class="string">&quot;Performance Version %d.%d\n&quot;</span>,</span><br><span class="line">		PROTOCOL_REV_MAJOR(version), PROTOCOL_REV_MINOR(version));</span><br><span class="line"></span><br><span class="line">	pinfo = devm_kzalloc(handle-&gt;dev, <span class="keyword">sizeof</span>(*pinfo), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!pinfo)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	scmi_perf_attributes_get(handle, pinfo);</span><br><span class="line"></span><br><span class="line">	pinfo-&gt;dom_info = devm_kcalloc(handle-&gt;dev, pinfo-&gt;num_domains,</span><br><span class="line">				       <span class="keyword">sizeof</span>(*pinfo-&gt;dom_info), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!pinfo-&gt;dom_info)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 遍历每个performance_domain，获取performance domain的属性和performance level参数</span></span><br><span class="line">	<span class="keyword">for</span> (domain = <span class="number">0</span>; domain &lt; pinfo-&gt;num_domains; domain++) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">perf_dom_info</span> *<span class="title">dom</span> =</span> pinfo-&gt;dom_info + domain;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 获取performance domain属性</span></span><br><span class="line">		scmi_perf_domain_attributes_get(handle, domain, dom);</span><br><span class="line">		<span class="comment">// 获取performance level参数即opp表</span></span><br><span class="line">		scmi_perf_describe_levels_get(handle, domain, dom);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (dom-&gt;perf_fastchannels)</span><br><span class="line">			scmi_perf_domain_init_fc(handle, domain, &amp;dom-&gt;fc_info);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	scmi_register_protocol_events(handle,</span><br><span class="line">				      SCMI_PROTOCOL_PERF, SCMI_PROTO_QUEUE_SZ,</span><br><span class="line">				      &amp;perf_event_ops, perf_events,</span><br><span class="line">				      ARRAY_SIZE(perf_events),</span><br><span class="line">				      pinfo-&gt;num_domains);</span><br><span class="line"></span><br><span class="line">	pinfo-&gt;version = version;</span><br><span class="line">	handle-&gt;perf_ops = &amp;perf_ops;</span><br><span class="line">	handle-&gt;perf_priv = pinfo;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终获取得到的OPP表如下<br><img src="https://raw.githubusercontent.com/JackHuang021/images/master/20230103140116.png"></p>
<h5 id="cpufreq初始化过程-1"><a href="#cpufreq初始化过程-1" class="headerlink" title="cpufreq初始化过程"></a>cpufreq初始化过程</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// driver/base/cpu.c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> <span class="title">cpu_subsys</span> =</span> &#123;</span><br><span class="line">	.name = <span class="string">&quot;cpu&quot;</span>,</span><br><span class="line">	.dev_name = <span class="string">&quot;cpu&quot;</span>,</span><br><span class="line">	.match = cpu_subsys_match,</span><br><span class="line">	.online = cpu_subsys_online,</span><br><span class="line">	.offline = cpu_subsys_offline,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// driver/cpufreq/cpufreq.c</span></span><br><span class="line"><span class="comment">// 指向当前使用的cpufreq_driver</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">cpufreq_driver</span> *<span class="title">cpufreq_driver</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// cpufreq subsys接口，用来挂到CPU subsys总线上</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">subsys_interface</span> <span class="title">cpufreq_interface</span> =</span> &#123;</span><br><span class="line">	.name		= <span class="string">&quot;cpufreq&quot;</span>,</span><br><span class="line">	.subsys		= &amp;cpu_subsys,</span><br><span class="line">	.add_dev	= cpufreq_add_dev,</span><br><span class="line">	.remove_dev	= cpufreq_remove_dev,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// scmi cpufreq_driver结构体定义</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">cpufreq_driver</span> <span class="title">scmi_cpufreq_driver</span> =</span> &#123;</span><br><span class="line">	.name	= <span class="string">&quot;scmi&quot;</span>,</span><br><span class="line">	.flags	= CPUFREQ_STICKY | CPUFREQ_HAVE_GOVERNOR_PER_POLICY |</span><br><span class="line">		  CPUFREQ_NEED_INITIAL_FREQ_CHECK,</span><br><span class="line">	.verify	= cpufreq_generic_frequency_table_verify,</span><br><span class="line">	.attr	= cpufreq_generic_attr,</span><br><span class="line">	.target_index	= scmi_cpufreq_set_target,</span><br><span class="line">	.fast_switch	= scmi_cpufreq_fast_switch,</span><br><span class="line">	.get	= scmi_cpufreq_get_rate,</span><br><span class="line">	.init	= scmi_cpufreq_init,</span><br><span class="line">	.<span class="built_in">exit</span>	= scmi_cpufreq_exit,</span><br><span class="line">	.ready	= scmi_cpufreq_ready,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为每个cluster定义一个cpufreq_policy结构体，对每个cluster上的CPU进行调频管理</span></span><br><span class="line"><span class="comment">// 其中又分别进行cpufreq_driver的初始化和governor的初始化</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">DEFINE_PER_CPU</span><span class="params">(struct cpufreq_policy *, cpufreq_cpu_data)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// cpufreq驱动框架初始化过程，整个过程都围绕着policy这个结构体进行，逐步进行初始化</span></span><br><span class="line">cpufreq_register_driver(&amp;scmi_cpufreq_driver);</span><br><span class="line">	subsys_interface_register(&amp;cpufreq_interface);</span><br><span class="line">		cpufreq_add_dev(dev, sif);</span><br><span class="line">			cpufreq_online(cpu);</span><br><span class="line">				<span class="comment">// 初步初始化policy</span></span><br><span class="line">				policy = cpufreq_policy_alloc(cpu);</span><br><span class="line">				<span class="comment">// 调用cpufreq_drvier init接口，完善policy结构体</span></span><br><span class="line">				<span class="comment">// 将opp表添加到对应的device，通过dev_pm_opp_add接口</span></span><br><span class="line">				<span class="comment">// 生成频率表 freq_table</span></span><br><span class="line">				cpufreq_driver-&gt;init(policy) -&gt; scmi_cpufreq_init(policy)</span><br><span class="line">				cpufreq_table_validate_and_sort(policy);</span><br><span class="line">				<span class="comment">// 创建/sys/device/system/cpu/cpux目录下的cpufreq符号链接</span></span><br><span class="line">				add_cpu_dev_symlink();</span><br><span class="line">				freq_qos_and_request();</span><br><span class="line">				blocking_notifier_call_chain();</span><br><span class="line">				<span class="comment">// CPU进行频率调整，使当前运行频率在频率表中</span></span><br><span class="line">				__cpufreq_driver_target();</span><br><span class="line">				<span class="comment">// 创建sys节点，/sys/device/system/cpu/cpufreq/policyx目录下的一些可选属性</span></span><br><span class="line">				cpufreq_add_dev_interface(policy);</span><br><span class="line">				cpufreq_stats_create_table(policy);</span><br><span class="line">				list_add(&amp;policy-&gt;polic_list, &amp;cpufreq_policy_list);</span><br><span class="line">				<span class="comment">// 使用默认governor初始化policy</span></span><br><span class="line">				cpufreq_init_policy();</span><br></pre></td></tr></table></figure>

<h4 id="cpufreq-governor的初始化过程"><a href="#cpufreq-governor的初始化过程" class="headerlink" title="cpufreq_governor的初始化过程"></a>cpufreq_governor的初始化过程</h4><p>cpufreq governor的初始化过程，在cpufreq_init_policy(policy)中进行，这里以ondemand为例进行分析</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/linux/cpufreq.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cpufreq_governor</span> &#123;</span></span><br><span class="line">	<span class="keyword">char</span>	name[CPUFREQ_NAME_LEN];</span><br><span class="line">	<span class="keyword">int</span>	(*init)(struct cpufreq_policy *policy);</span><br><span class="line">	<span class="keyword">void</span>	(*<span class="built_in">exit</span>)(struct cpufreq_policy *policy);</span><br><span class="line">	<span class="keyword">int</span>	(*start)(struct cpufreq_policy *policy);</span><br><span class="line">	<span class="keyword">void</span>	(*stop)(struct cpufreq_policy *policy);</span><br><span class="line">	<span class="keyword">void</span>	(*limits)(struct cpufreq_policy *policy);</span><br><span class="line">	<span class="keyword">ssize_t</span>	(*show_setspeed)	(struct cpufreq_policy *policy,</span><br><span class="line">					 <span class="keyword">char</span> *buf);</span><br><span class="line">	<span class="keyword">int</span>	(*store_setspeed)	(struct cpufreq_policy *policy,</span><br><span class="line">					 <span class="keyword">unsigned</span> <span class="keyword">int</span> freq);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">governor_list</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">module</span>		*<span class="title">owner</span>;</span></span><br><span class="line">	u8			flags;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Common Governor data across policies */</span></span><br><span class="line"><span class="comment">// 抽象出的governor调度器结构体</span></span><br><span class="line"><span class="comment">// drivers/cpufreq/cpufreq_governor.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dbs_governor</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cpufreq_governor</span> <span class="title">gov</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kobj_type</span> <span class="title">kobj_type</span>;</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Common data for platforms that don&#x27;t set</span></span><br><span class="line"><span class="comment">	 * CPUFREQ_HAVE_GOVERNOR_PER_POLICY</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dbs_data</span> *<span class="title">gdbs_data</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">unsigned</span> <span class="title">int</span> <span class="params">(*gov_dbs_update)</span><span class="params">(struct cpufreq_policy *policy)</span></span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">policy_dbs_info</span> *(*<span class="title">alloc</span>)(<span class="title">void</span>);</span></span><br><span class="line">	<span class="keyword">void</span> (*<span class="built_in">free</span>)(struct policy_dbs_info *policy_dbs);</span><br><span class="line">	<span class="keyword">int</span> (*init)(struct dbs_data *dbs_data);</span><br><span class="line">	<span class="keyword">void</span> (*<span class="built_in">exit</span>)(struct dbs_data *dbs_data);</span><br><span class="line">	<span class="keyword">void</span> (*start)(struct cpufreq_policy *policy);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// drivers/cpufreq/cpufreq_governor.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CPUFREQ_DBS_GOVERNOR_INITIALIZER(_name_)			\</span></span><br><span class="line"><span class="meta">	&#123;								\</span></span><br><span class="line"><span class="meta">		.name = _name_,						\</span></span><br><span class="line"><span class="meta">		.flags = CPUFREQ_GOV_DYNAMIC_SWITCHING,			\</span></span><br><span class="line"><span class="meta">		.owner = THIS_MODULE,					\</span></span><br><span class="line"><span class="meta">		.init = cpufreq_dbs_governor_init,			\</span></span><br><span class="line"><span class="meta">		.exit = cpufreq_dbs_governor_exit,			\</span></span><br><span class="line"><span class="meta">		.start = cpufreq_dbs_governor_start,			\</span></span><br><span class="line"><span class="meta">		.stop = cpufreq_dbs_governor_stop,			\</span></span><br><span class="line"><span class="meta">		.limits = cpufreq_dbs_governor_limits,			\</span></span><br><span class="line"><span class="meta">	&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ondemand调节器定义</span></span><br><span class="line"><span class="comment">// driver/cpufreq/cpufreq_ondemand.c</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">dbs_governor</span> <span class="title">od_dbs_gov</span> =</span> &#123;</span><br><span class="line">	.gov = CPUFREQ_DBS_GOVERNOR_INITIALIZER(<span class="string">&quot;ondemand&quot;</span>),</span><br><span class="line">	.kobj_type = &#123; .default_attrs = od_attributes &#125;,</span><br><span class="line">	.gov_dbs_update = od_dbs_update,</span><br><span class="line">	.alloc = od_alloc,</span><br><span class="line">	.<span class="built_in">free</span> = od_free,</span><br><span class="line">	.init = od_init,</span><br><span class="line">	.<span class="built_in">exit</span> = od_exit,</span><br><span class="line">	.start = od_start,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化governor</span></span><br><span class="line"><span class="comment">// 该函数会在governor模块驱动的入口函数调用</span></span><br><span class="line"><span class="comment">// 只要编译该模块，就会注册到cpufreq framework中</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CPU_FREQ_GOV_ONDEMAND	(od_dbs_gov.gov)</span></span><br><span class="line">cpufreq_governor_init(CPU_FREQ_GOV_ONDEMAND);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> cpufreq_governor_init(__governor)			\</span></span><br><span class="line"><span class="meta">static int __init __governor##_init(void)			\</span></span><br><span class="line"><span class="meta">&#123;								\</span></span><br><span class="line"><span class="meta">	return cpufreq_register_governor(&amp;__governor);	\</span></span><br><span class="line"><span class="meta">&#125;								\</span></span><br><span class="line"><span class="meta">core_initcall(__governor##_init)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在cpufreq_online()中调用默认governor对policy进行完善，启动当前governor</span></span><br><span class="line">cpufreq_init_policy(policy);</span><br><span class="line">	gov = get_governor(default_governor);</span><br><span class="line">	<span class="comment">// 设置新的governor</span></span><br><span class="line">	cpufreq_set_policy(policy, gov, pol);</span><br><span class="line">		cpufreq_init_governor(policy);</span><br><span class="line">			policy-&gt;governor-&gt;init();  -&gt; cpufreq_dbs_governor_init(policy);</span><br><span class="line">				gov-&gt;init(dbs_data); -&gt; odinit(dbs_data);</span><br><span class="line">		cpufreq_start_governor(policy);</span><br><span class="line">			policy-&gt;governor-&gt;start(); -&gt; cpufreq_dbs_governor_start(policy);</span><br><span class="line">				<span class="comment">// 设置governor回调函数， 以ondemand为例</span></span><br><span class="line">				gov_set_update_util(policy_dbs, sampling_rate);</span><br><span class="line">					cpufreq_add_update_util_hook(cpu, &amp;cdbs-&gt;updata_util,</span><br><span class="line">									dbs_update_util_handler);</span><br></pre></td></tr></table></figure>

<p>启动governor中比较重要的是设置调频回调函数,该函数是真正调频时计算合适频率的函数</p>
<h4 id="schedutil调度器代码分析"><a href="#schedutil调度器代码分析" class="headerlink" title="schedutil调度器代码分析"></a>schedutil调度器代码分析</h4><p><img src="https://raw.githubusercontent.com/JackHuang021/images/master/20230103174117.png"><br>sugov作为一种内核调频策略模块，它主要是根据当前CPU的利用率进行调频。因此，sugov会注册一个callback函数（sugov_update_shared&#x2F;sugov_update_single）到调度器负载跟踪模块，当CPU util发生变化的时候就会调用该callback函数，检查一下当前CPU频率是否和当前的CPU util匹配，如果不匹配，那么就进行升频或者降频。</p>
<p><code>sugov_tunables</code>结构体，用来描述sugov的可调参数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sugov_tunables结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sugov_tunables</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gov_attr_set</span> <span class="title">attr_set</span>;</span></span><br><span class="line">	<span class="comment">// 目前sugov只有这一个可调参数，该参数用来限制连续调频的间隔时间</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> rate_limit_us;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>sugov_policy</code>结构体，sugov为每个cluster构建了该数据结构，记录每个cluster的调频数据信息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sugov_policy结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sugov_policy</span> &#123;</span></span><br><span class="line">	<span class="comment">// 指向cpufreq framework层的policy对象</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cpufreq_policy</span>	*<span class="title">policy</span>;</span></span><br><span class="line">	<span class="comment">// sugov的可调参数</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sugov_tunables</span>	*<span class="title">tunables</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">tunables_hook</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">raw_spinlock_t</span>		update_lock;	<span class="comment">/* For shared policies */</span></span><br><span class="line">	u64			last_freq_update_time;</span><br><span class="line">	s64			freq_update_delay_ns;</span><br><span class="line">	<span class="comment">// 下一个需要调整到的频率值</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		next_freq;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		cached_raw_freq;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* The next fields are only needed if fast switch cannot be used: */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span>			<span class="title">irq_work</span> <span class="title">irq_work</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span>			<span class="title">kthread_work</span> <span class="title">work</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span>			<span class="title">mutex</span> <span class="title">work_lock</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span>			<span class="title">kthread_worker</span> <span class="title">worker</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>	*<span class="title">thread</span>;</span></span><br><span class="line">	<span class="keyword">bool</span>			work_in_progress;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">bool</span>			limits_changed;</span><br><span class="line">	<span class="keyword">bool</span>			need_freq_update;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>sugov_cpu</code>结构体，sugov为每个cpu构建了该数据结构，记录per-cpu的调频数据信息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sugov_cpu</span> &#123;</span></span><br><span class="line">	<span class="comment">// 保存了cpu util变化后的callback函数</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">update_util_data</span>	<span class="title">update_util</span>;</span></span><br><span class="line">	<span class="comment">// 该sugov_cpu对应的sugov_policy对象</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sugov_policy</span>	*<span class="title">sg_policy</span>;</span></span><br><span class="line">	<span class="comment">// 对应的CPU id</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		cpu;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">bool</span>			iowait_boost_pending;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		iowait_boost;</span><br><span class="line">	<span class="comment">// 上一次cpu负载变化驱动调频的时间点，util更新的时间点</span></span><br><span class="line">	u64			last_update;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		bw_dl;</span><br><span class="line">	<span class="comment">// 该CPU的最大算力，即最大utilities，归一化到1024</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		max;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* The field below is for single-CPU policies only: */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NO_HZ_COMMON</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		saved_idle_calls;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>sugov初始化过程和ondemand初始化过程相似，当内核设定默认governor为sugov时，在<code>cpufreq_init_governor(policy);</code>中会调用<code>sugov_init()</code>初始化sugov，然后调用<code>sugov_start()</code>设置调频回调函数，在<code>cpufreq_update_util()</code>被调用时，会调用sugov的回调函数进行调频，<code>sugov_update_shared()</code>当一个簇中有多个CPU是调用该回调，遍历簇上的CPU找到当前最大util的CPU，然后根据该util映射到频率；<code>sugov_update_single()</code>即一个簇上单个CPU的情况直接根据该CPU util计算频率</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sugov_start</span><span class="params">(struct cpufreq_policy *policy)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	...</span><br><span class="line">	for_each_cpu(cpu, policy-&gt;cpus) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">sugov_cpu</span> *<span class="title">sg_cpu</span> =</span> &amp;per_cpu(sugov_cpu, cpu);</span><br><span class="line"></span><br><span class="line">		cpufreq_add_update_util_hook(cpu, &amp;sg_cpu-&gt;update_util,</span><br><span class="line">					     policy_is_shared(policy) ?</span><br><span class="line">							sugov_update_shared :</span><br><span class="line">							sugov_update_single);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>schedutil_cpu_util()</code>函数分析，用来计算cpu util的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用过程</span></span><br><span class="line">sugov_update_single();</span><br><span class="line">	util = sugov_get_util(sg_cpuu);</span><br><span class="line">		schedutil_cpu_util(sg_cpu-&gt;cpu, util, max, FREQUENCY_UTIL, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">schedutil_cpu_util</span><span class="params">(<span class="keyword">int</span> cpu, <span class="keyword">unsigned</span> <span class="keyword">long</span> util_cfs,</span></span></span><br><span class="line"><span class="params"><span class="function">					<span class="keyword">unsigned</span> <span class="keyword">long</span> max, <span class="keyword">enum</span> schedutil_type type,</span></span></span><br><span class="line"><span class="params"><span class="function">					struct task_struct *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> dl_util, util, irq;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span> =</span> cpu_rq(cpu);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!uclamp_is_used() &amp;&amp;</span><br><span class="line">	    type == FREQUENCY_UTIL &amp;&amp; rt_rq_is_runnable(&amp;rq-&gt;rt)) &#123;</span><br><span class="line">		<span class="keyword">return</span> max;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Early check to see if IRQ/steal time saturates the CPU, can be</span></span><br><span class="line"><span class="comment">	 * because of inaccuracies in how we track these -- see</span></span><br><span class="line"><span class="comment">	 * update_irq_load_avg().</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	irq = cpu_util_irq(rq);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(irq &gt;= max))</span><br><span class="line">		<span class="keyword">return</span> max;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Because the time spend on RT/DL tasks is visible as &#x27;lost&#x27; time to</span></span><br><span class="line"><span class="comment">	 * CFS tasks and we use the same metric to track the effective</span></span><br><span class="line"><span class="comment">	 * utilization (PELT windows are synchronized) we can directly add them</span></span><br><span class="line"><span class="comment">	 * to obtain the CPU&#x27;s actual utilization.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * CFS and RT utilization can be boosted or capped, depending on</span></span><br><span class="line"><span class="comment">	 * utilization clamp constraints requested by currently RUNNABLE</span></span><br><span class="line"><span class="comment">	 * tasks.</span></span><br><span class="line"><span class="comment">	 * When there are no CFS RUNNABLE tasks, clamps are released and</span></span><br><span class="line"><span class="comment">	 * frequency will be gracefully reduced with the utilization decay.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">// 累加了cfs和rt任务的utility，根据当前的</span></span><br><span class="line">	util = util_cfs + cpu_util_rt(rq);</span><br><span class="line">	<span class="keyword">if</span> (type == FREQUENCY_UTIL)</span><br><span class="line">		util = uclamp_rq_util_with(rq, util, p);</span><br><span class="line"></span><br><span class="line">	dl_util = cpu_util_dl(rq);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * For frequency selection we do not make cpu_util_dl() a permanent part</span></span><br><span class="line"><span class="comment">	 * of this sum because we want to use cpu_bw_dl() later on, but we need</span></span><br><span class="line"><span class="comment">	 * to check if the CFS+RT+DL sum is saturated (ie. no idle time) such</span></span><br><span class="line"><span class="comment">	 * that we select f_max when there is no idle time.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">NOTE:</span> numerical errors or stop class might cause us to not quite hit</span></span><br><span class="line"><span class="comment">	 * saturation when we should -- something for later.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (util + dl_util &gt;= max)</span><br><span class="line">		<span class="keyword">return</span> max;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * OTOH, for energy computation we need the estimated running time, so</span></span><br><span class="line"><span class="comment">	 * include util_dl and ignore dl_bw.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (type == ENERGY_UTIL)</span><br><span class="line">		util += dl_util;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * There is still idle time; further improve the number by using the</span></span><br><span class="line"><span class="comment">	 * irq metric. Because IRQ/steal time is hidden from the task clock we</span></span><br><span class="line"><span class="comment">	 * need to scale the task numbers:</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 *              max - irq</span></span><br><span class="line"><span class="comment">	 *   U&#x27; = irq + --------- * U</span></span><br><span class="line"><span class="comment">	 *                 max</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	util = scale_irq_capacity(util, irq, max);</span><br><span class="line">	util += irq;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Bandwidth required by DEADLINE must always be granted while, for</span></span><br><span class="line"><span class="comment">	 * FAIR and RT, we use blocked utilization of IDLE CPUs as a mechanism</span></span><br><span class="line"><span class="comment">	 * to gracefully reduce the frequency when no tasks show up for longer</span></span><br><span class="line"><span class="comment">	 * periods of time.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Ideally we would like to set bw_dl as min/guaranteed freq and util +</span></span><br><span class="line"><span class="comment">	 * bw_dl as requested freq. However, cpufreq is not yet ready for such</span></span><br><span class="line"><span class="comment">	 * an interface. So, we only do the latter for now.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (type == FREQUENCY_UTIL)</span><br><span class="line">		util += cpu_bw_dl(rq);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> min(max, util);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="EAS相关"><a href="#EAS相关" class="headerlink" title="EAS相关"></a>EAS相关</h4><p>EAS整体框架<br><img src="https://raw.githubusercontent.com/JackHuang021/images/master/20221216104706.png"></p>
<p>完全公平调度（Completely Fair Scheduler CFS）实现了面向吞吐量的的任务调度策略，EAS为这个调度器添加了一个基于能耗的调度策略，在优化CPU算力冗余的同时实现了节能，EAS在系统中、低度负载情况下工作，CFS在系统满负载情况下工作。</p>
<p>EAS在CPU调度领域，在为任务选核是起作用，目的是保证性能的情况下尽可能节省功耗，EAS涉及内核的几个子系统（任务调度、能源管理、CPU动态调频），EAS代码主要位于<code>kernel/sched.fair.c</code>，能源感知的任务调度需要调度器评估各个任务在CPU上运行带来的能耗影响</p>
<p>EAS负载跟踪有两种模式，一种是“每实体负载跟踪（Per_Entity Load Track）”，通常用于负载跟踪，然后该信息用于确定频率以及如何在CPU上委派任务，另一种是“窗口辅助的负载跟踪（Window-Assisted Load Tracking）”，WALT更具有突发性，而PELT试图让频率保持连贯性，负载跟踪器实际上并不影响CPU频率，它只是告诉系统CPU使用率是多少</p>
<h5 id="CPU算力归一化过程"><a href="#CPU算力归一化过程" class="headerlink" title="CPU算力归一化过程"></a>CPU算力归一化过程</h5><p>归一化CPU capacity，<code>topology_normalize_cpu_scale()</code>，这个capacity在schedutil调度中被<code>sugov_get_util()</code>函数读取</p>
<p><code>topology_normalize_cpu_scale()</code>在CPU初始化<code>parse_dt_topology()</code>中被调用，capacity归一化的前提条件是需要在设备树中CPU节点设置<code>capacity-dmips-mhz</code>属性，该属性表示不同CPU的计算能力，内核读取该属性设置CPU的<code>raw_capacity</code>为<code>capacity-dmips-mhz</code>，参考内核文档<code>Documentation/devicetree/bindings/arm/cpu-capacity.txt</code></p>
<blockquote>
<p>ARM推荐的测试CPU的性能工具：Dhrystone 2.1以上版本，可以通过单核跑分成绩作为<code>capacity-dmips-mhz</code>属性的参考</p>
</blockquote>
<p>CPU算力归一化公式，并不是简单的将capacity-dmips-mhz归一化到capacity，CPU的频率也参与到了计算中<br><code> capacity = (own(capacity-dmips-mhz) * own(max_freq)) / (max(capacity-dmips-mhz) * max(max_freq)) * 1024</code></p>
<p>目前从scmi读到的cpu频率对应的performance level</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[    2.515964] sustained_freq_khz = 2000000</span><br><span class="line">[    2.519971] sustained_perf_level = 2000000</span><br><span class="line">[    2.524201] sustained_freq_khz = 2000000</span><br><span class="line">[    2.528203] sustained_perf_level = 2000000</span><br><span class="line">[    2.532432] sustained_freq_khz = 1500000</span><br><span class="line">[    2.536434] sustained_perf_level = 1500000</span><br></pre></td></tr></table></figure>

<p>EAS全局控制开关<code>/proc/sys/kernel/sched_energy_aware</code></p>
<p>相关结构体</p>
<p>perf_domain结构表示一个CPU性能域，perf_domain和cpufreq_policy是一一对应的，性能域之间形成链，链表头存放在root_domian中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/sched/sched.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">perf_domain</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">em_perf_domain</span> *<span class="title">em_pd</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">perf_domain</span> *<span class="title">next</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">root_domain</span> &#123;</span></span><br><span class="line">	<span class="keyword">atomic_t</span>		refcount;</span><br><span class="line">	<span class="keyword">atomic_t</span>		rto_count;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span>		<span class="title">rcu</span>;</span></span><br><span class="line">	<span class="keyword">cpumask_var_t</span>		span;</span><br><span class="line">	<span class="keyword">cpumask_var_t</span>		online;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 该root_domain是否处于overload状态</span></span><br><span class="line">	<span class="keyword">int</span>			overload;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 该root_domain是否处于overutilized状态</span></span><br><span class="line">	<span class="keyword">int</span>			overutilized;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The bit corresponding to a CPU gets set here if such CPU has more</span></span><br><span class="line"><span class="comment">	 * than one runnable -deadline task (as it is below for RT tasks).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">cpumask_var_t</span>		dlo_mask;</span><br><span class="line">	<span class="keyword">atomic_t</span>		dlo_count;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dl_bw</span>		<span class="title">dl_bw</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cpudl</span>		<span class="title">cpudl</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_RT_PUSH_IPI</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * For IPI pull requests, loop across the rto_mask.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_work</span>		<span class="title">rto_push_work</span>;</span></span><br><span class="line">	<span class="keyword">raw_spinlock_t</span>		rto_lock;</span><br><span class="line">	<span class="comment">/* These are only updated and read within rto_lock */</span></span><br><span class="line">	<span class="keyword">int</span>			rto_loop;</span><br><span class="line">	<span class="keyword">int</span>			rto_cpu;</span><br><span class="line">	<span class="comment">/* These atomics are updated outside of a lock */</span></span><br><span class="line">	<span class="keyword">atomic_t</span>		rto_loop_next;</span><br><span class="line">	<span class="keyword">atomic_t</span>		rto_loop_start;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The &quot;RT overload&quot; flag: it gets set if a CPU has more than</span></span><br><span class="line"><span class="comment">	 * one runnable RT task.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">cpumask_var_t</span>		rto_mask;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cpupri</span>		<span class="title">cpupri</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 系统中算力最大的CPU的算力</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		max_cpu_capacity;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * NULL-terminated list of performance domains intersecting with the</span></span><br><span class="line"><span class="comment">	 * CPUs of the rd. Protected by RCU.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">// perf_domain单链表的表头</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">perf_domain</span> __<span class="title">rcu</span> *<span class="title">pd</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// include/linux/energy_model.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">em_perf_state</span> &#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> frequency;	<span class="comment">// CPU频点，单位KHz</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> power;		<span class="comment">// 此频点下的功耗</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> cost;			<span class="comment">// 此频点下的成本系数，等于 power * max_freq / freq</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">em_perf_domain</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">em_perf_state</span> *<span class="title">table</span>;</span>	<span class="comment">// CPU频点表</span></span><br><span class="line">	<span class="keyword">int</span> nr_perf_states;				<span class="comment">// 频点表中元素的个数</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> cpus[];			<span class="comment">// 此性能域中包括哪些CPU</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>perf_domain_debug 打印信息</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[    2.574534] root_domain 0-3: pd3:&#123; cpus=3 nr_pstate=4 &#125;</span><br><span class="line">[    2.574540] freq: 250000, power: 79, cost: 632</span><br><span class="line">[    2.579072] freq: 500000, power: 197, cost: 788</span><br><span class="line">[    2.583690] freq: 1000000, power: 409, cost: 818</span><br><span class="line">[    2.588390] freq: 2000000, power: 839, cost: 839</span><br><span class="line">[    2.593094]  pd2:&#123; cpus=2 nr_pstate=4 &#125;</span><br><span class="line">[    2.593096] freq: 250000, power: 79, cost: 632</span><br><span class="line">[    2.601445] freq: 500000, power: 197, cost: 788</span><br><span class="line">[    2.606054] freq: 1000000, power: 409, cost: 818</span><br><span class="line">[    2.610749] freq: 2000000, power: 839, cost: 839</span><br><span class="line">[    2.615445]  pd0:&#123; cpus=0-1 nr_pstate=4 &#125;</span><br><span class="line">[    2.615447] freq: 187500, power: 1, cost: 8</span><br><span class="line">[    2.623709] freq: 375000, power: 9, cost: 36</span><br><span class="line">[    2.628058] freq: 750000, power: 55, cost: 110</span><br><span class="line">[    2.632579] freq: 1500000, power: 125, cost: 125</span><br></pre></td></tr></table></figure>

<p>root_domain的overload和overutilized说明：</p>
<ul>
<li>对于一个 CPU 而言，其处于 overload 状态则说明其 rq 上有大于等于2个任务，或者虽然只有一个任务，但是是 misfit task</li>
<li>对于一个 CPU 而言，其处于 overutilized 状态说明该 cpu 的 utility 超过其 capacity（缺省预留20%的算力，另外，这里的 capacity 是用于cfs任务的算力）</li>
<li>对于 root domain，overload 表示至少有一个 cpu 处于 overload 状态。overutilized 表示至少有一个 cpu 处于 overutilized 状态</li>
<li>overutilized 状态非常重要，它决定了调度器是否启用EAS，只有在系统没有 overutilized 的情况下EAS才会生效。overload和newidle balance的频次控制相关，当系统在overload的情况下，newidle balance才会启动进行均衡。</li>
</ul>
<p>EAS的调度过程：<br>在任务被重新唤醒或者fork新建时，会通过<code>select_task_rq_fair()</code>将任务进行balance，达到充分利用CPU的目的。在<code>select_task_rq_fair()</code>，若任务是被重新唤醒就会调用<code>find_energy_efficient_cpu()</code>进行选核执行</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">CPU在某个performance state(ps)下的计算能力</span></span><br><span class="line"><span class="comment">	ps-&gt;cap = ps-&gt;freq * scale_cpu / cpu_max_freq		(1)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">CPU在该频点performace state(ps)下的能量消耗</span></span><br><span class="line"><span class="comment">	cpu_nrg = ps-&gt;power * cpu_util / ps-&gt;cap			(2)</span></span><br><span class="line"><span class="comment">	cpu_util / ps-&gt;cap 也可以表示为一个CPU的busy time</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">结合(1) (2)可以得出CPU在该ps下的能量消耗</span></span><br><span class="line"><span class="comment">	cpu_nrg = ps-&gt;power * cpu_max_freq * cpu_util / ps-&gt;freq * scale_cpu (3)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">其中 ps-&gt;power * cpu_max_freq / ps-&gt;freq 是一个固定数据存放在频点表的cost成员中</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">一个pd内的CPU，拥有相同的cost，所以一个pd内所有CPU的能量消耗可以表示为</span></span><br><span class="line"><span class="comment">	pd_nrg = ps-&gt;cost * sum(cpu_util) / scale_cpu</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * compute_energy(): Estimates the energy that @pd would consume if @p was</span></span><br><span class="line"><span class="comment"> * migrated to @dst_cpu. compute_energy() predicts what will be the utilization</span></span><br><span class="line"><span class="comment"> * landscape of @pd&#x27;s CPUs after the task migration, and uses the Energy Model</span></span><br><span class="line"><span class="comment"> * to compute what would be the energy if we decided to actually migrate that</span></span><br><span class="line"><span class="comment"> * task.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 计算任务迁移到dst_cpu后，整个pd，即此cluster的energy</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span></span></span><br><span class="line"><span class="function"><span class="title">compute_energy</span><span class="params">(struct task_struct *p, <span class="keyword">int</span> dst_cpu, struct perf_domain *pd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cpumask</span> *<span class="title">pd_mask</span> =</span> perf_domain_span(pd);</span><br><span class="line">	<span class="comment">// 获取该CPU的算力</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> cpu_cap = arch_scale_cpu_capacity(cpumask_first(pd_mask));</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> max_util = <span class="number">0</span>, sum_util = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> cpu;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 对此pd中每个online cpu都执行计算</span></span><br><span class="line">	for_each_cpu_and(cpu, pd_mask, cpu_online_mask) &#123;</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> cpu_util, util_cfs = cpu_util_next(cpu, p, dst_cpu);</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">tsk</span> =</span> cpu == dst_cpu ? p : <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 返回该CPU下cfs+irq+rt+dl使用掉的CPU算力总和</span></span><br><span class="line">		sum_util += schedutil_cpu_util(cpu, util_cfs, cpu_cap,</span><br><span class="line">					       ENERGY_UTIL, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">		cpu_util = schedutil_cpu_util(cpu, util_cfs, cpu_cap,</span><br><span class="line">					      FREQUENCY_UTIL, tsk);</span><br><span class="line">		max_util = max(max_util, cpu_util);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 计算该pd下所有CPU的功耗和</span></span><br><span class="line">	<span class="keyword">return</span> em_cpu_energy(pd-&gt;em_pd, max_util, sum_util);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算该pd下所有CPU的功耗和</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">em_cpu_energy</span><span class="params">(struct em_perf_domain *pd,</span></span></span><br><span class="line"><span class="params"><span class="function">				<span class="keyword">unsigned</span> <span class="keyword">long</span> max_util, <span class="keyword">unsigned</span> <span class="keyword">long</span> sum_util)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> freq, scale_cpu;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">em_perf_state</span> *<span class="title">ps</span>;</span></span><br><span class="line">	<span class="keyword">int</span> i, cpu;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * In order to predict the performance state, map the utilization of</span></span><br><span class="line"><span class="comment">	 * the most utilized CPU of the performance domain to a requested</span></span><br><span class="line"><span class="comment">	 * frequency, like schedutil.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	cpu = cpumask_first(to_cpumask(pd-&gt;cpus));</span><br><span class="line">	scale_cpu = arch_scale_cpu_capacity(cpu);</span><br><span class="line">	ps = &amp;pd-&gt;table[pd-&gt;nr_perf_states - <span class="number">1</span>];</span><br><span class="line">	freq = map_util_freq(max_util, ps-&gt;frequency, scale_cpu);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Find the lowest performance state of the Energy Model above the</span></span><br><span class="line"><span class="comment">	 * requested frequency.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; pd-&gt;nr_perf_states; i++) &#123;</span><br><span class="line">		ps = &amp;pd-&gt;table[i];</span><br><span class="line">		<span class="keyword">if</span> (ps-&gt;frequency &gt;= freq)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The capacity of a CPU in the domain at the performance state (ps)</span></span><br><span class="line"><span class="comment">	 * can be computed as:</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 *             ps-&gt;freq * scale_cpu</span></span><br><span class="line"><span class="comment">	 *   ps-&gt;cap = --------------------                          (1)</span></span><br><span class="line"><span class="comment">	 *                 cpu_max_freq</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * So, ignoring the costs of idle states (which are not available in</span></span><br><span class="line"><span class="comment">	 * the EM), the energy consumed by this CPU at that performance state</span></span><br><span class="line"><span class="comment">	 * is estimated as:</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 *             ps-&gt;power * cpu_util</span></span><br><span class="line"><span class="comment">	 *   cpu_nrg = --------------------                          (2)</span></span><br><span class="line"><span class="comment">	 *                   ps-&gt;cap</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * since &#x27;cpu_util / ps-&gt;cap&#x27; represents its percentage of busy time.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 *   <span class="doctag">NOTE:</span> Although the result of this computation actually is in</span></span><br><span class="line"><span class="comment">	 *         units of power, it can be manipulated as an energy value</span></span><br><span class="line"><span class="comment">	 *         over a scheduling period, since it is assumed to be</span></span><br><span class="line"><span class="comment">	 *         constant during that interval.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * By injecting (1) in (2), &#x27;cpu_nrg&#x27; can be re-expressed as a product</span></span><br><span class="line"><span class="comment">	 * of two terms:</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 *             ps-&gt;power * cpu_max_freq   cpu_util</span></span><br><span class="line"><span class="comment">	 *   cpu_nrg = ------------------------ * ---------          (3)</span></span><br><span class="line"><span class="comment">	 *                    ps-&gt;freq            scale_cpu</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * The first term is static, and is stored in the em_perf_state struct</span></span><br><span class="line"><span class="comment">	 * as &#x27;ps-&gt;cost&#x27;.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Since all CPUs of the domain have the same micro-architecture, they</span></span><br><span class="line"><span class="comment">	 * share the same &#x27;ps-&gt;cost&#x27;, and the same CPU capacity. Hence, the</span></span><br><span class="line"><span class="comment">	 * total energy of the domain (which is the simple sum of the energy of</span></span><br><span class="line"><span class="comment">	 * all of its CPUs) can be factorized as:</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 *            ps-&gt;cost * \Sum cpu_util</span></span><br><span class="line"><span class="comment">	 *   pd_nrg = ------------------------                       (4)</span></span><br><span class="line"><span class="comment">	 *                  scale_cpu</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">return</span> ps-&gt;cost * sum_util / scale_cpu;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 寻找工作能耗最低的CPU</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">find_energy_efficient_cpu</span><span class="params">(struct task_struct *p, <span class="keyword">int</span> prev_cpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> prev_delta = ULONG_MAX, best_delta = ULONG_MAX;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">root_domain</span> *<span class="title">rd</span> =</span> cpu_rq(smp_processor_id())-&gt;rd;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> cpu_cap, util, base_energy = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> cpu, best_energy_cpu = prev_cpu;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sched_domain</span> *<span class="title">sd</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">perf_domain</span> *<span class="title">pd</span>;</span></span><br><span class="line"></span><br><span class="line">	rcu_read_lock();</span><br><span class="line">	<span class="comment">// 从rd取pd的指针</span></span><br><span class="line">	pd = rcu_dereference(rd-&gt;pd);</span><br><span class="line">	<span class="keyword">if</span> (!pd || READ_ONCE(rd-&gt;overutilized))</span><br><span class="line">		<span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Energy-aware wake-up happens on the lowest sched_domain starting</span></span><br><span class="line"><span class="comment">	 * from sd_asym_cpucapacity spanning over this_cpu and prev_cpu.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	sd = rcu_dereference(*this_cpu_ptr(&amp;sd_asym_cpucapacity));</span><br><span class="line">	<span class="keyword">while</span> (sd &amp;&amp; !cpumask_test_cpu(prev_cpu, sched_domain_span(sd)))</span><br><span class="line">		sd = sd-&gt;parent;</span><br><span class="line">	<span class="keyword">if</span> (!sd)</span><br><span class="line">		<span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">	sync_entity_load_avg(&amp;p-&gt;se);</span><br><span class="line">	<span class="keyword">if</span> (!task_util_est(p))</span><br><span class="line">		<span class="keyword">goto</span> unlock;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 遍历整个pd链表，计算p在不同pd下的能耗</span></span><br><span class="line">	<span class="keyword">for</span> (; pd; pd = pd-&gt;next) &#123;</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> cur_delta, spare_cap, max_spare_cap = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> base_energy_pd;</span><br><span class="line">		<span class="keyword">int</span> max_spare_cap_cpu = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Compute the &#x27;base&#x27; energy of the pd, without @p */</span></span><br><span class="line">		<span class="comment">// 计算不包括p的情况下此pd当前的energy</span></span><br><span class="line">		base_energy_pd = compute_energy(p, <span class="number">-1</span>, pd);</span><br><span class="line">		<span class="comment">// 不包括p的情况下系统的总energy</span></span><br><span class="line">		base_energy += base_energy_pd;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 遍历整个pd中的CPU，计算p放在该CPU上的功耗</span></span><br><span class="line">		for_each_cpu_and(cpu, perf_domain_span(pd), sched_domain_span(sd)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!cpumask_test_cpu(cpu, p-&gt;cpus_ptr))</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="comment">// 计算p放到此CPU后该CPU总共消耗的算力</span></span><br><span class="line">			util = cpu_util_next(cpu, p, cpu);</span><br><span class="line">			cpu_cap = capacity_of(cpu);</span><br><span class="line">			spare_cap = cpu_cap;</span><br><span class="line">			<span class="comment">// 计算p放到此CPU后剩余的算力</span></span><br><span class="line">			lsub_positive(&amp;spare_cap, util);</span><br><span class="line"></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * Skip CPUs that cannot satisfy the capacity request.</span></span><br><span class="line"><span class="comment">			 * IOW, placing the task there would make the CPU</span></span><br><span class="line"><span class="comment">			 * overutilized. Take uclamp into account to see how</span></span><br><span class="line"><span class="comment">			 * much capacity we can get out of the CPU; this is</span></span><br><span class="line"><span class="comment">			 * aligned with schedutil_cpu_util().</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="comment">// 对util进行下一步uclamp，若clamp后CPU算力不满足需求了，就放弃该CPU的继续探测</span></span><br><span class="line">			util = uclamp_rq_util_with(cpu_rq(cpu), util, p);</span><br><span class="line">			<span class="comment">// CPU需要保留20%左右的算力，不满足需求后进行下一个CPU的探测</span></span><br><span class="line">			<span class="keyword">if</span> (!fits_capacity(util, cpu_cap))</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* Always use prev_cpu as a candidate. */</span></span><br><span class="line">			<span class="comment">// 若对比的这个CPU就是任务之前运行的CPU</span></span><br><span class="line">			<span class="keyword">if</span> (cpu == prev_cpu) &#123;</span><br><span class="line">				<span class="comment">// 计算p放在该cpu后整个pd的能量消耗</span></span><br><span class="line">				prev_delta = compute_energy(p, prev_cpu, pd);</span><br><span class="line">				<span class="comment">// 计算p放在该CPU后整个pd增加的能量消耗</span></span><br><span class="line">				prev_delta -= base_energy_pd;</span><br><span class="line">				<span class="comment">// 更新best_delta，取最优能耗</span></span><br><span class="line">				best_delta = min(best_delta, prev_delta);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * Find the CPU with the maximum spare capacity in</span></span><br><span class="line"><span class="comment">			 * the performance domain</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="comment">// 记录p放上去后剩余算力最大的CPU和最大的剩余算力</span></span><br><span class="line">			<span class="keyword">if</span> (spare_cap &gt; max_spare_cap) &#123;</span><br><span class="line">				max_spare_cap = spare_cap;</span><br><span class="line">				max_spare_cap_cpu = cpu;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Evaluate the energy impact of using this CPU. */</span></span><br><span class="line">		<span class="comment">// 同一个簇上的CPU取最大余量算力的那个CPU与其他簇的CPU做能量消耗对比</span></span><br><span class="line">		<span class="keyword">if</span> (max_spare_cap_cpu &gt;= <span class="number">0</span> &amp;&amp; max_spare_cap_cpu != prev_cpu) &#123;</span><br><span class="line">			<span class="comment">// 计算p放在算力剩余最大的CPU后整个pd的能量消耗</span></span><br><span class="line">			cur_delta = compute_energy(p, max_spare_cap_cpu, pd);</span><br><span class="line">			<span class="comment">// 计算能量消耗增量</span></span><br><span class="line">			cur_delta -= base_energy_pd;</span><br><span class="line">			<span class="comment">// 如果当前能量增量优于p放在prev_cpu运行的能量消耗，则取该cpu运行p</span></span><br><span class="line">			<span class="keyword">if</span> (cur_delta &lt; best_delta) &#123;</span><br><span class="line">				best_delta = cur_delta;</span><br><span class="line">				best_energy_cpu = max_spare_cap_cpu;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">unlock:</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Pick the best CPU if prev_cpu cannot be used, or if it saves at</span></span><br><span class="line"><span class="comment">	 * least 6% of the energy used by prev_cpu.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">// 若prev_cpu找不到，就直接返回最优能耗cpu</span></span><br><span class="line">	<span class="keyword">if</span> (prev_delta == ULONG_MAX)</span><br><span class="line">		<span class="keyword">return</span> best_energy_cpu;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 若最优能耗比放在prev_cpu上运行的能耗还要低6.25%以上，则取最优能耗cpu</span></span><br><span class="line">	<span class="keyword">if</span> ((prev_delta - best_delta) &gt; ((prev_delta + base_energy) &gt;&gt; <span class="number">4</span>))</span><br><span class="line">		<span class="keyword">return</span> best_energy_cpu;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 否则不做改变，直接使用prev_cpu运行p</span></span><br><span class="line">	<span class="keyword">return</span> prev_cpu;</span><br><span class="line"></span><br><span class="line">fail:</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>

    
    
    

    <footer class="post-footer">
          <div class="reward-container">
  <div>Buy me a coffee</div>
  <button>
    赞赏
  </button>
  <div class="post-reward">
      <div>
        <img src="/images/wechatpay.png" alt="Jack 微信">
        <span>微信</span>
      </div>
      <div>
        <img src="/images/alipay.png" alt="Jack 支付宝">
        <span>支付宝</span>
      </div>

  </div>
</div>

          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>Jack
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://jackhuang021.github.io/archives/fbf46cf3.html" title="Linux Cpufreq 框架">https://jackhuang021.github.io/archives/fbf46cf3.html</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/Linux/" rel="tag"># Linux</a>
              <a href="/tags/Cpufreq/" rel="tag"># Cpufreq</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/archives/f8def83d.html" rel="prev" title="Platform设备驱动">
                  <i class="fa fa-chevron-left"></i> Platform设备驱动
                </a>
            </div>
            <div class="post-nav-item">
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2021 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jack</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">1:28</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/JackHuang021" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>




  <script src="/js/third-party/pace.js"></script>

  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





</body>
</html>
