---
title: C/C++面试相关
author: Jack
tags:
  - C/C++
abbrlink: b80e625e
date: 2022-07-04 09:26:33
---

1. malloc/free和new/delete
    + malloc/free是C/C++的标准库函数，new/delete是C++的运算符
    + 对于非内部数据类型的对象，光用malloc/free无法满足动态对象的要求
    + 对象在创建时需要自动执行构造函数，对象在消亡时需要自动运行析构函数，由于malloc/free不是运算符，不在编译器控制权限内，不能将构造函数和析构函数的任务强加于malloc/free上，因此C++需要一个能完成动态内存分配及初始化工作的运算符new，和一个能够即时完成清理和释放内存的运算符delete

2. malloc和new内存申请失败，怎么处理内存耗尽
    + 判断指针是否为null，如果是则直接报错，return终止运行该函数

3. C++不是类型安全的，两个类型的指针之间可以强制类型转换（用reinterpret cast）
   
4. const符号常量的区别：
    + `const char *p`：p是指向const char的指针，p可以改变指向，但是p指向的值不能变
    + `char* const p`：p是一个常指针，这个指针是指向char的const指针，指向不能改变

5. 用C++写一段程序，判断一个系统是16位还是32位：
    + 定义一个指针p，打印sizeof(p)，结果为2表示是16位操作系统，结果为4，表示为32位操作系统
    + 定义一个int变量a，赋初值~0，判断a大于65536则为32位操作系统

6. 内存的分配方式有几种
    + 从静态存储区分配，内存在程序编译时就已经分配好，这块内存在程序整个运行周期都存在
    + 从栈上创建，在执行函数时，函数内局部变量的存储单元都可以在栈上创建，在函数执行结束时这些存储单元自动释放
    + 从堆上分配，也称动态内存分配，程序在运行的时候用malloc/new申请任意多的内存，用free/delete释放内存，动态内存的生存期由我们决定，使用灵活

7. 全局变量和局部变量的区别
    + 生存周期不同：
    + 使用方式不同：

8. 堆和栈的区别

9. C++中explict的含义，protected的含义
    + explict关键字用来修饰类的构造函数，表明该构造函数是显示的，要求类的使用者必须显示调用类的构造函数，反之默认类型转换可能会造成无法预期的问题
    + protected控制的是一个函数对一个类成员的访问权限，只有该类的成员函数及派生类的成员函数可以访问

10. const关键词的作用：
    + 欲阻止一个变量被改变，可以使用const关键词，定义const变量时对其进行初始化
    + 对指针来说，可以指定指针本身为const，也可以指定指针指向的数据为const，或者两者同时指定为const
    + 在一个函数声明中，const可以修饰形参，表明它是一个输入参数，在函数内部不能修改其值
    + 对于类的成员函数，若指定其为const类型，则表明其是一个常函数，不能修改类的成员变量
    + 对于类的成员函数，有时指定其返回值为const类型，使其返回值不为左值

11. 是不是一个父类写了一个virtual函数，如果子类覆盖它的函数不加virtual，也能实现多态？
    + virtual修饰符会被隐形继承，virtual可加可不加，子类空间有父类的所有变量（static除外）同一个函数只能存在一个实体（inline除外），子类覆盖它的函数不加virtual也能实现多态

12. 面向对象的三个基本特性
    + 封装：将客观事物抽象成类，每个类对自身的数据和方法实行权限管理
    + 继承：实现继承，指直接使用基类的属性和方法而无需额外编程；接口继承：仅使用属性和方法，实现滞后到子类实现
    + 多态：是将父对象设置成为一个或更多的与他子对象相等的技术，赋值之后，父对象就可以根据当前赋值给他的子对象的特性以不同的方式运作。简单的说，就是一句话：允许将子类类型的指针赋值给父类类型的指针。

13. 重载（overload），重写（override）,重定义（redefinition）的区别
    + 重载：同一名字空间，指允许存在多个同名函数，而这些函数的参数表不同
    + 重写：不同名字空间，用于继承，子类重新定义父类虚函数的方法
    + 重定义：不同名字空间

14. 多态的作用
    + 隐藏实现细节，使得代码能够模块化，扩展代码模块，实现代码重用
    + 接口重用：为了类在继承和派生的时候，保证家族中任一类的实例的某一属性正确调用

15. 内联函数在编译时要做参数类型检查，这是内联函数跟宏相比的优势

16. 析构函数和虚函数的用法和作用
    + 析构函数是特殊的类成员函数，他没有返回值，没有参数，不能随意调用，也没有重载，只有在类对象生命周期结束时，由系统自动调用，有释放内存空间的作用
    + 虚函数是C++多态的一种表现，使用虚函数，我们可以进行灵活的进行动态绑定

17. C++中struct和class的区别

18. C++中模板的认识：模板使程序员能够快速建立具有类型安全的类库集合和函数集合，方便大规模软件的开发

19. C++中为什么使用模板类
    + 可以创建动态增长和减小的模板类
    + 它是类型无关的，因此具有很高的可复用性
    + 它在编译时而不是运行时检查数据类型，保证了类型安全
    + 它是平台无光的，方便移植
    + 可用于基本数据类型

20. 在类中如何使用const
    + 当我们希望某些常量只有在类中有效，使用const修饰数据成员来实现
    + const数据成员的初始化只能在类构造函数的初始化表中进行

21. 不能被重载的运算符
    + C++内部数据类型的运算符
    + 不能重载'.'，因为'.'在类中对任何成员都有意义，已经成为标准用法
    + 对已经存在的运算符进行重载时，不能改变优先级规则

22. 基类的析构函数不是虚函数，会带来什么问题？
    + 派生类的析构函数用不上，会造成资源的泄露

23. 如何使用return语句
    + return语句不可返回指向栈内存的指针或者引用，因为该内存在函数结束时被自动销毁
    + 要搞清楚返回的究竟是值、指针还是引用
    + 如果函数返回值是一个对象，要考虑return语句的效率



