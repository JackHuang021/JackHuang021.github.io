---
title: ARMv8 寄存器组
tags:
  - ARMv8
  - Register
categories: ARM
abbrlink: 17165b72
date: 2023-01-18 14:22:33
---

### ARMv8-A架构及其对应处理器特性
![](https://raw.githubusercontent.com/JackHuang021/images/master/20230128094507.png)

### ARMv8基本原理
**软件运行异常级别**：
+ EL0: 普通用户应用程序
+ EL1: 操作系统内核通常被描述为具有特权的
+ EL2: 管理程序
+ EL3: 低级固件，包括安全监视器
![](https://raw.githubusercontent.com/JackHuang021/images/master/20230128095322.png)

ARMv8-A提供两种安全状态：安全、非安全

### ARMv8寄存器组
AArch64的执行状态提供了可在所有时间和所有异常级别访问的31个64位通用寄存器，分别是X0~X30，每一个64位的通用寄存器(X0~X30)的低32位又由32位的寄存器(W0~W30)组成（运行在32位程序时使用）
![](https://raw.githubusercontent.com/JackHuang021/images/master/20230128094339.png)

#### AArch64特殊寄存器
![](https://raw.githubusercontent.com/JackHuang021/images/master/20230128102622.png)

当访问Zero寄存器，所有的写入都被忽略，所有的读取都返回0，AArch32执行状态使用WZR指令访问zero寄存器，使用WSP指令访问当前栈指针寄存器；AArch64执行状态使用XZR访问zero寄存器，使用SP指令访问当前栈指针寄存器，AArch32和AArch64执行状态下都使用PC指令访问程序计数寄存器
![](https://raw.githubusercontent.com/JackHuang021/images/master/20230128104400.png)

每个异常级别中都有专用的SP寄存器，退出该异常级别时不需要保存
![](https://raw.githubusercontent.com/JackHuang021/images/master/20230128104005.png)

**Zero寄存器**  
当Zero寄存器当作源寄存器读取时，会得到0值，当Zero寄存器当作目的寄存器写入时，写入的值被丢弃，

**Stack Pointer寄存器**  
在ARMv8架构中，每个异常级别都拥有栈指针寄存器，即拥有4个栈指针寄存器。在默认情况下，异常级别ELn对应SP_ELn，当处理器的执行状态为AArch64且不处于异常级别EL0，则可以使用与异常级别相关的专用64位堆栈指针(SP_ELn)和异常级别EL0相关的堆栈指针寄存器(SP_EL0)，各个异常级别与可使用的栈寄存器关系如下图所示（后缀t表示使用SP_EL0堆栈指针，h表示使用SP_ELx堆栈指针）
![](https://raw.githubusercontent.com/JackHuang021/images/master/20230128134348.png)

**Program Counter寄存器**  
ARMv8架构中删除了对PC寄存器的直接访问，PC寄存器不能作为命名寄存器访问，而是通过确定的指令隐含的访问

**Exception Link寄存器**  
ELR寄存器保存了异常返回地址，ARMv8定义了3个ELR寄存器，分别对应异常级别EL1, EL2, EL3

**Saved Process Status寄存器**  
当异常发生时，处理器的状态将会被保存到相关的SPSR寄存器中，异常发生后，在处理异常之前，处理器会自动的将PSTATE寄存器的内容保存到SPSR中，异常返回时，会将SPSR保存的处理器状态恢复到PSTATE中，ARMv8定义的SPSR寄存器如下，兼容ARMv7中的SPSR寄存器，只使用低32位。在ARMv8架构中，有3个SPSR寄存器，分别为SPSR_EL1、SPSR_EL2、SPSR_EL3，使用那个SPSR寄存器依赖于异常级别
![](https://raw.githubusercontent.com/JackHuang021/images/master/20230128135732.png)
各个位的定义如下：
+ N：符号位
+ Z：0标志
+ C：操作进位
+ V：溢出标志
+ SS：用于软件调试，异常发生的时候，可通过设置启用单步调试机制
+ IL：不合法的执行状态，保存自PSTATE.IL
+ D：处理器状态调试掩码，指示是否屏蔽来自观察点、断电和软件单步调试事件的调试异常
+ A：系统错误掩码
+ I：IRQ掩码位
+ F：FIQ掩码位
+ M[4]：发生异常时处理器的执行状态，0表示AArch64
+ M[3:0]：M[3:2]发生异常的级别，M[1]保留，M[0]根据此选择栈指针寄存器，0表示t，1表示h

#### Processor State
AArch64没有类似ARMv7 Current Program Status Register（CPSR）的寄存器，在AArch64的执行状态中，处理器状态要用PSTATE描述，但PSTATE不是寄存器，而是处理器状态各个位域的总称，PSTATE的大部分位域和传统CPSR寄存器中的位域相同。EL0可以访问PSTATE的N、Z、C、V位域，其他域只能在EL1及更高的异常级别中访问。PSTATE的位域如下图所示：
![](https://raw.githubusercontent.com/JackHuang021/images/master/20230128144328.png)

#### System Registers
