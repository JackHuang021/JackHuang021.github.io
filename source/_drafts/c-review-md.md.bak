---
title: C/C++面试相关
author: Jack
tags:
  - C/C++
abbrlink: b80e625e
notshow: true
date: 2022-07-04 09:26:33
---

1. malloc/free和new/delete
    + malloc/free是C/C++的标准库函数，new/delete是C++的运算符
    + 对于非内部数据类型的对象，光用malloc/free无法满足动态对象的要求
    + 对象在创建时需要自动执行构造函数，对象在消亡时需要自动运行析构函数，由于malloc/free不是运算符，不在编译器控制权限内，不能将构造函数和析构函数的任务强加于malloc/free上，因此C++需要一个能完成动态内存分配及初始化工作的运算符new，和一个能够即时完成清理和释放内存的运算符delete

2. malloc和new内存申请失败，怎么处理内存耗尽
    + 判断指针是否为null，如果是则直接报错，return终止运行该函数

3. C++不是类型安全的，两个类型的指针之间可以强制类型转换（用reinterpret cast）
   
4. const符号常量的区别：
    + `const char *p`：p是指向const char的指针，p可以改变指向，但是p指向的值不能变
    + `char* const p`：p是一个常指针，这个指针是指向char的const指针，指向不能改变

5. 用C++写一段程序，判断一个系统是16位还是32位：
    + 定义一个指针p，打印sizeof(p)，结果为2表示是16位操作系统，结果为4，表示为32位操作系统
    + 定义一个int变量a，赋初值~0，判断a大于65536则为32位操作系统

6. 内存的分配方式有几种
    + 从静态存储区分配，内存在程序编译时就已经分配好，这块内存在程序整个运行周期都存在
    + 从栈上创建，在执行函数时，函数内局部变量的存储单元都可以在栈上创建，在函数执行结束时这些存储单元自动释放
    + 从堆上分配，也称动态内存分配，程序在运行的时候用malloc/new申请任意多的内存，用free/delete释放内存，动态内存的生存期由我们决定，使用灵活

7. 全局变量和局部变量的区别
    + 生存周期不同：
    + 使用方式不同：

8. 堆和栈的区别

9. C++中explict的含义，protected的含义
    + explict关键字用来修饰类的构造函数，表明该构造函数是显示的，要求类的使用者必须显示调用类的构造函数，反之默认类型转换可能会造成无法预期的问题
    + protected控制的是一个函数对一个类成员的访问权限，只有该类的成员函数及派生类的成员函数可以访问

10. const关键词的作用：
    + 欲阻止一个变量被改变，可以使用const关键词，定义const变量时对其进行初始化
    + 对指针来说，可以指定指针本身为const，也可以指定指针指向的数据为const，或者两者同时指定为const
    + 在一个函数声明中，const可以修饰形参，表明它是一个输入参数，在函数内部不能修改其值
    + 对于类的成员函数，若指定其为const类型，则表明其是一个常函数，不能修改类的成员变量
    + 对于类的成员函数，有时指定其返回值为const类型，使其返回值不为左值

11. 是不是一个父类写了一个virtual函数，如果子类覆盖它的函数不加virtual，也能实现多态？
    + virtual修饰符会被隐形继承，virtual可加可不加，子类空间有父类的所有变量（static除外）同一个函数只能存在一个实体（inline除外），子类覆盖它的函数不加virtual也能实现多态

12. 面向对象的三个基本特性
    + 封装：将客观事物抽象成类，每个类对自身的数据和方法实行权限管理
    + 继承：实现继承，指直接使用基类的属性和方法而无需额外编程；接口继承：仅使用属性和方法，实现滞后到子类实现
    + 多态：是将父对象设置成为一个或更多的与他子对象相等的技术，赋值之后，父对象就可以根据当前赋值给他的子对象的特性以不同的方式运作。简单的说，就是一句话：允许将子类类型的指针赋值给父类类型的指针。

13. 重载（overload），重写（override）,重定义（redefinition）的区别
    + 重载：同一名字空间，指允许存在多个同名函数，而这些函数的参数表不同
    + 重写：不同名字空间，用于继承，子类重新定义父类虚函数的方法
    + 重定义：不同名字空间

14. 多态的作用
    + 隐藏实现细节，使得代码能够模块化，扩展代码模块，实现代码重用
    + 接口重用：为了类在继承和派生的时候，保证家族中任一类的实例的某一属性正确调用

15. 内联函数在编译时要做参数类型检查，这是内联函数跟宏相比的优势

16. 析构函数和虚函数的用法和作用
    + 析构函数是特殊的类成员函数，他没有返回值，没有参数，不能随意调用，也没有重载，只有在类对象生命周期结束时，由系统自动调用，有释放内存空间的作用
    + 虚函数是C++多态的一种表现，使用虚函数，我们可以进行灵活的进行动态绑定

17. C++中struct和class的区别

18. C++中模板的认识：模板使程序员能够快速建立具有类型安全的类库集合和函数集合，方便大规模软件的开发

19. C++中为什么使用模板类
    + 可以创建动态增长和减小的模板类
    + 它是类型无关的，因此具有很高的可复用性
    + 它在编译时而不是运行时检查数据类型，保证了类型安全
    + 它是平台无光的，方便移植
    + 可用于基本数据类型

20. 在类中如何使用const
    + 当我们希望某些常量只有在类中有效，使用const修饰数据成员来实现
    + const数据成员的初始化只能在类构造函数的初始化表中进行

21. 不能被重载的运算符
    + C++内部数据类型的运算符
    + 不能重载'.'，因为'.'在类中对任何成员都有意义，已经成为标准用法
    + 对已经存在的运算符进行重载时，不能改变优先级规则

22. 基类的析构函数不是虚函数，会带来什么问题？
    + 派生类的析构函数用不上，会造成资源的泄露

23. 如何使用return语句
    + return语句不可返回指向栈内存的指针或者引用，因为该内存在函数结束时被自动销毁
    + 要搞清楚返回的究竟是值、指针还是引用
    + 如果函数返回值是一个对象，要考虑return语句的效率

24. 父子类构造函数、析构函数的调用顺序：基类派生类构造函数的调用次序：基类构造函数、派生类成员构造函数、派生类本身构造函数，析构函数调用顺序相反

25. 全局类对象的构造函数在main之前运行

26. 在类的成员函数中调用delete this：可以这样操作，调用后该对象还能调用其他方法，但是有个前提，被调用的方法不涉及这个对象的数据成员和虚函数

27. C/C++中类型转换：隐式类型转换和显式类型转换
    + 隐式类型转换：编译器在编译阶段自动运行，能转就转，不能转就报错
    + 显式类型转换：需要用户自己处理，如int(variable)，(int)variable
    ```
    void Test()
    {
        int i = 1;
        // 隐式类型转换
        double d = i;
        printf("%d, %.2f\n", i, d);

        int* p = &i;
        // 显示的强制类型转换
        int address = (int)p;
        printf("%x, %d\n", p, address);
    }
    ```
    + static_cast类型转换：static_cast用于非多态类型的转换（静态转换），编译器隐式执行的任何类型转换都可以用static_cast，但他不能用于两个不相关的类型进行转换
    ```
    int main()
    {
        double d = 12.34;
        int a = static_cast<int>(d);
        cout << a << endl;
        return 0;
    }
    ```
    + reinterpret_cast：reinterpret_cast通常为操作数的位模式提供较低层次的重新解释，用于将一种类型转换为另一种不同的类型，相当于C语言的显示类型转换
    ```
    int main(int argc, char* argv[])
    {
        (void)argc;
        (void)argv;

        int i = 0;
        double* pd = reinterpret_cast<double*>(i);
        return 0;
    }
    ```
    + const_cast：const_cast最常用的用途就是删除变量的const属性，方便赋值
    ```
    void main()
    {
        const int a = 2;
        int *p = const_cast<int*>(&a);
        *p = 3;

        cout << a << endl;
        cout << *p << endl;
    }
    ```
    这里输出a的值仍为2，这是因为编译器做了优化，当编译器读取到a时，此时a是常变量，便存一份到寄存器中，下次读取直接从寄存器上读取，想让编译器每次读取都从内存取值，需要加volatile关键字。
    ```
    void main()
    {
        volatile const int a = 2;
        int *p = const_cast<int*>(&a);
        *p = 3;

        cout << a << endl;
        cout << *p << endl;
    }
    ```
    + dynamic_cast: dynamic_cast用于将一个父类对象的指针/引用转换为子类对象的指针或者/引用，向上转型：子类对象指针/引用转换为父类指针/引用（不需要转换，赋值兼容规则），向下转型：父类对象/引用转换为子类指针/引用（用dynamic_cast是安全的）；dynamic_cast只能用于含有虚函数的表，会先检查是否能转换成功，能成功则转换，否则返回0

+ C++智能指针
    + 动态内存管理经常会出现两种问题：一种是忘记释放内存，造成内存泄露；一种是尚有指针引用内存的情况下就释放了它，就会产生引用非法内存的指针。为了更加容易、更加安全的使用动态内存，引入了智能指针的概念，智能指针的行为类似常规指针，重要的区别是它负责自动释放所指向的对象。
    + 标准库提供两种智能指针：shared_ptr和unique_ptr
    + shared_ptr允许多个指针指向同一个对象
    + unique_ptr则独占所指向的对象
    

#### C++ STL库（standard template library

1. C++标准库可以分为两部分：标准函数库、面向对象类库
    + 标准函数库：这个库是由通用的、独立的、不属于任何类的函数组成，函数库继承自C语言
    + 面向对象类库：这个库是类及相关函数的集合

2. 标准函数库分为以下几类
    + 输入/输出 I/O
    + 字符串和字符处理
    + 数学
    + 时间、日期和本地化
    + 动态分配
    + 其他
    + 宽字符函数

3. 面向对象类库：标准的C++面向对象类库定义了大量支持一些常见操作的类，比如输入输出、字符串处理、数值处理，面向对象类库包含以下内容：
   + 标准的C++ I/O类
   + String类
   + 数值类
   + STL容器类
   + STL算法
   + STL函数对象
   + STL迭代器
   + STL分配器
   + 本地化库
   + 异常处理类
   + 杂项支持库

#### 软件设计模式
+ 设计模式（Design Pattern）代表了最佳实践，通常被有经验的面向对象的软件开发人员所采用，设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案，这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。
+ 设计模式是一套反复被使用的、多人知晓的、经过分类编目的，代码设计经验总结。
+ 设计模式可以分为三大类：创建型模型（Creational Patterns）、结构型模型（Structural Patterns）、行为型模型（Behavioral Patterns）。

+ 创建型模式：这些设计模式提供一种在创建对象的同时隐藏创建逻辑的方式，而不是使用new运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象更灵活。
    + 工厂模式（Factory Pattern）
    + 抽象工厂模式（Abstract Factory Pattern）
    + 单例模式（Singleton Pattern）
    + 建造者模式（Builder Pattern）
    + 原型模式（Prototype Pattern）

+ 工厂模式（Factory Pattern）：在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过一个共同的接口来指向新创建的对象。
    + 意图：定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行
    + 主要解决：主要解决接口选择的问题
    + 何时使用：我们明确地计划不同条件下创建不同实例时
    + 如何解决：让其子类实现工厂接口，返回的也是一个抽象的产品
    + 关键代码：创建过程在其子类执行
    + 应用实例：您需要一辆汽车，可以直接从工厂提货，而不用去管这辆车是怎么做出来的，以及这个汽车里面的具体实现
    + 优点：
        + 一个调用者想创建一个对象，只要知道其名称就行了；
        + 扩展性高，如果想要增加一个产品，只要扩展一个工厂类就行；
        + 屏蔽产品的具体实现，调用者只关注产品的接口
    + 缺点：
        + 每次增加一个产品时都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。

+ MVC模式（Model-View-Controller）：模型-视图-控制器模式，用于应用程序的分层开发
    + Model 模型：模型表示一个存取数据的对象，他也可以带有逻辑，在数据变化时更新控制器
    + Viwe 视图：视图代表模型包含数据的可视化
    + Controller 控制器：控制器作用于模型和视图上。它控制数据流向模型对象，并在数据变化时更新视图。它使视图与模型分离开。


#### Windows的窗口刷新机制
+ 窗口句柄（HWND）都是由操作系统内核管理的，系统内部有一个z-order序列，记录着当前窗口从屏幕底部（假象的从屏幕到眼睛的方向），到屏幕高层的一个窗口句柄的排序，当任意一个窗口接收到WM_PAINT消息产生重绘，更新区域绘制完成后，就搜索它的前面的一个窗口，如果此窗口的范围和更新区域有交集，就向这个窗口发送WM_PAINT消息，周而复始，直到顶层窗口。
+ 父子窗口刷新：当主窗口接收到WM_PAINT消息绘制完成后，会引起更新区域上所有子窗口的重绘（所有子窗口也是自底向上排列的）
+ 兄弟窗口间的刷新管理：如果两个窗口重叠，则两个窗口都会收到WM_PAINT消息，他们收到WM_PAINT消息的顺序与z-index相反，即最上面的（z-order最高）的收到WM_PAINT消息最晚。
应用程序可以为窗口设置WS_CLIPSIBLING样式来避免兄弟窗口的绘制重叠。设置了这个，高z-order的窗口部分就会被上面的窗口裁减掉了，此部分被覆盖的区域就不会被刷新了。

#### Qt半自动化的内存管理
+ QObject及其派生类的对象，如果其parent非空，那么其parent析构时会析构该对象
+ QWidget及其派生类的对象，可以设置Qt:WA_DeleteOnClose标志位，在close时会析构该对象
+ QAbstractAnimation派生类的对象，可以设置 QAbstractAnimation::DeleteWhenStopped。

#### 内存泄露检查的方法
+ 对象计数：在对象构造时计数++，析构时--，每隔一段时间打印对象的数量，缺点是对于第三方库无法修改代码无法定位
+ 重载new和delete

#### QString和string的区别
+ QString使用16位unicode进行编码
+ QString中间可以包含'\0'字符

#### Qt多线程
+ QThread使用的两种方法：
    + QObject::moveToThread();
    + 继承QThread类，重载QThread的run()函数，在run函数中写入需要执行的工作，调用start函数来启动线程

#### 前项声明和include头文件的区别
+ 前向声明指在A程序中引入新的类型B，但是B并不是一个完整清晰的类，因为我们只知道只是一个B类，但是我们不清楚它的具体函数接口实现以及成员变量；不能定义一个B的类型，只能使用指针和引用的方式；
+ 类的前向声明一般写在.h文件里面，include直接添加头文件的方式看起来更加方便，提供了全部接口，代价是增加了编译器的工作量，大量导入的头文件会引起编译比较慢

#### PlayerDemo项目
+ 基于Qt5.12.x开发，FFmpeg3.4，SDL2-2.0.7渲染
+ 支持按键快捷键控制
+ SDL跨平台
+ 播放时开启一个线程处理播放控制循环

#### RTMP协议
+ RTMP(Real Time Message Protocol)，一般是在一个TCP通道上传输flv，f4v格式流
+ RTSP(Real Time Streaming Protocol)，

#### RTSP ffmpeg解码流程
+ 设置参数
+ 打开rtsp地址
+ 找出所有流，查看流类型
+ 判断为视频流则查找解码器
+ 申请AVPacket和AVFrame，其中AVPacket的作用是：保存解码之前的数据和一些附加信息，如显示时间戳（pts）、解码时间戳（dts）、数据时长，所在媒体流的索引等；AVFrame的作用是：存放解码过后的数据。
+ 申请用于存放解码后YUV格式数据的相关buf
+ 开始解码


