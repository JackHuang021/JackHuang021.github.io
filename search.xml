<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>从零开始搭建Hexo博客</title>
    <url>/archives/39fb7b7f.html</url>
    <content><![CDATA[<h2 id="Hexo简介"><a href="#Hexo简介" class="headerlink" title="Hexo简介"></a>Hexo简介</h2><p>引用官网的介绍：A fast, simple &amp; powerful blog framework<br>Hexo是一款基于Node.js的静态博客框架，依赖少易于安装使用，可以方便的生成静态网页托管在GitHub上，是搭建博客的首选框架。</p>
<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>基于Ubuntu20.04安装Hexo配置Next主题</p>
<span id="more"></span>

<h3 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h3><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">sudo apt-<span class="builtin-name">get</span> install git</span><br></pre></td></tr></table></figure>
<p>安装完成后进行配置</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">config</span> --<span class="keyword">global</span> user<span class="variable">.email</span> <span class="string">&quot;you@example.com&quot;</span></span><br><span class="line">git <span class="keyword">config</span> --<span class="keyword">global</span> user<span class="variable">.name</span> <span class="string">&quot;Your Name&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h3><p>使用NVM（Node Version Manager）方式进行安装</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">curl -o- https:<span class="regexp">//</span>raw.githubusercontent.com<span class="regexp">/nvm-sh/</span>nvm<span class="regexp">/v0.35.2/i</span>nstall.sh | bash</span><br></pre></td></tr></table></figure>
<p>安装完成后关闭终端重新打开</p>
<h3 id="安装最新版本node"><a href="#安装最新版本node" class="headerlink" title="安装最新版本node"></a>安装最新版本node</h3><p>安装过程中可能会因为网络问题失败，可以尝试挂梯子,安装完成后更新自带npm</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">nvm install <span class="keyword">node</span></span><br><span class="line"><span class="title">npm</span> install npm -g</span><br></pre></td></tr></table></figure>

<h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><p>安装过程中可能会因为网络问题失败，可以多重试几次或挂梯子</p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-<span class="keyword">cli</span></span><br></pre></td></tr></table></figure>

<h3 id="安装Next主题"><a href="#安装Next主题" class="headerlink" title="安装Next主题"></a>安装Next主题</h3><p>Next主题是Hexo比较知名的第三方主题，极简风格，有相当多的使用者，维护也做得比较好<br>不过Next新旧版本的仓库地址不一样，目前最新的GitHub地址<a href="https://github.com/next-theme/hexo-theme-next.git">hexo-theme-next</a><br>Next主题安装比较简单，直接从仓库clone然后修改Hexo配置文件</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">cd blog</span><br><span class="line">git clone https:<span class="regexp">//gi</span>thub.com<span class="regexp">/next-theme/</span>hexo-theme-<span class="keyword">next</span> themes/<span class="keyword">next</span></span><br></pre></td></tr></table></figure>
<p>修改Hexo配置文件<code>_config.yml</code>，将站点主题改为Next，修改如下</p>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line"># Extensions</span><br><span class="line">## Plugins: https:<span class="comment">//hexo.io/plugins/</span></span><br><span class="line">## Themes: https:<span class="comment">//hexo.io/themes/</span></span><br><span class="line">theme: next</span><br></pre></td></tr></table></figure>

<p>全部安装完成后的版本信息如下</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">jack@linux:~/blog/source/_posts$ hexo -v</span></span><br><span class="line">INFO  Validating config</span><br><span class="line">INFO  ==================================</span><br><span class="line">  ███╗   ██╗███████╗██╗  ██╗████████╗</span><br><span class="line">  ████╗  ██║██╔════╝╚██╗██╔╝╚══██╔══╝</span><br><span class="line">  ██╔██╗ ██║█████╗   ╚███╔╝    ██║</span><br><span class="line">  ██║╚██╗██║██╔══╝   ██╔██╗    ██║</span><br><span class="line">  ██║ ╚████║███████╗██╔╝ ██╗   ██║</span><br><span class="line">  ╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝   ╚═╝</span><br><span class="line">========================================</span><br><span class="line">NexT version 8.11.1</span><br><span class="line"><span class="section">Documentation: https://theme-next.js.org</span></span><br><span class="line">========================================</span><br><span class="line"><span class="section">hexo: 5.4.2</span></span><br><span class="line"><span class="section">hexo-cli: 4.3.0</span></span><br><span class="line"><span class="section">os: linux 5.13.0-40-generic Ubuntu 20.04.4 LTS (Focal Fossa)</span></span><br><span class="line"><span class="section">node: 18.2.0</span></span><br><span class="line"><span class="section">v8: 10.1.124.8-node.13</span></span><br><span class="line"><span class="section">uv: 1.43.0</span></span><br><span class="line"><span class="section">zlib: 1.2.11</span></span><br><span class="line"><span class="section">brotli: 1.0.9</span></span><br><span class="line"><span class="section">ares: 1.18.1</span></span><br><span class="line"><span class="section">modules: 108</span></span><br><span class="line"><span class="section">nghttp2: 1.47.0</span></span><br><span class="line"><span class="section">napi: 8</span></span><br><span class="line"><span class="section">llhttp: 6.0.6</span></span><br><span class="line"><span class="section">openssl: 3.0.3+quic</span></span><br><span class="line"><span class="section">cldr: 41.0</span></span><br><span class="line"><span class="section">icu: 71.1</span></span><br><span class="line"><span class="section">tz: 2022a</span></span><br><span class="line"><span class="section">unicode: 14.0</span></span><br><span class="line"><span class="section">ngtcp2: 0.1.0-DEV</span></span><br><span class="line"><span class="section">nghttp3: 0.1.0-DEV</span></span><br></pre></td></tr></table></figure>

<h3 id="初步运行Hexo进行验证"><a href="#初步运行Hexo进行验证" class="headerlink" title="初步运行Hexo进行验证"></a>初步运行Hexo进行验证</h3><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">hexo init <span class="keyword">blog</span></span><br><span class="line"><span class="keyword"></span>cd <span class="keyword">blog</span></span><br><span class="line"><span class="keyword"></span>npm <span class="keyword">install</span></span><br><span class="line"><span class="keyword"></span>hexo server</span><br></pre></td></tr></table></figure>
<p>运行之后可以通过 <a href="http://localhost:4000/">http://localhost:4000</a> 进行访问</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">INFO  Validating config</span><br><span class="line">INFO  ==================================</span><br><span class="line"><span class="code">  ███╗   ██╗███████╗██╗  ██╗████████╗</span></span><br><span class="line"><span class="code">  ████╗  ██║██╔════╝╚██╗██╔╝╚══██╔══╝</span></span><br><span class="line"><span class="code">  ██╔██╗ ██║█████╗   ╚███╔╝    ██║</span></span><br><span class="line"><span class="code">  ██║╚██╗██║██╔══╝   ██╔██╗    ██║</span></span><br><span class="line"><span class="code">  ██║ ╚████║███████╗██╔╝ ██╗   ██║</span></span><br><span class="line"><span class="section">  ╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝   ╚═╝</span></span><br><span class="line"><span class="section">========================================</span></span><br><span class="line">NexT version 8.11.1</span><br><span class="line"><span class="section">Documentation: https://theme-next.js.org</span></span><br><span class="line"><span class="section">========================================</span></span><br><span class="line">INFO  Start processing</span><br><span class="line">INFO  Hexo is running at http://localhost:4000 . Press Ctrl+C to stop.</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/imageshexo_next_theme.png"></p>
<h3 id="部署GitHub远程服务器"><a href="#部署GitHub远程服务器" class="headerlink" title="部署GitHub远程服务器"></a>部署GitHub远程服务器</h3><h4 id="创建GitHub项目"><a href="#创建GitHub项目" class="headerlink" title="创建GitHub项目"></a>创建GitHub项目</h4><p>在GitHub上注册账号，注册后上传ssh公钥，便于后续的部署操作<br>创建一个与你用户名对应的项目<code>username.github.io</code>，例如我创建的项目地址为<code>https://github.com/JackHuang021/JackHuang021.github.io.git</code>  </p>
<h4 id="进行部署"><a href="#进行部署" class="headerlink" title="进行部署"></a>进行部署</h4><p>部署需要用到<code>hexo deploy</code>上传到GitHub仓库，这里需要下载部署插件，并修改hexo配置文件<code>_config.yml</code>，<br>我们很多的博客设置都可以在这个配置文件里面进行修改<br>首先安装Git部署插件</p>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cd</span> ~<span class="string">/blog</span></span><br><span class="line">npm install hex-deployer-git <span class="params">--save</span></span><br></pre></td></tr></table></figure>
<p>修改博客配置文件<code>_config.yml</code>，增加如下内容</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="meta"># Deployment</span></span><br><span class="line"><span class="meta">## Docs: https:<span class="comment">//hexo.io/docs/one-command-deployment</span></span></span><br><span class="line"><span class="symbol">deploy:</span></span><br><span class="line"><span class="symbol">  type:</span> git</span><br><span class="line"><span class="symbol">  repo:</span> git@github.com:JackHuang021/JackHuang021.github.io.git</span><br><span class="line"><span class="symbol">  branch:</span> master</span><br></pre></td></tr></table></figure>
<p>最后使用<code>hexo d</code>进行上传部署，现在访问<code>username.github.io</code>便可以看到博客页面了<br>后续更新博客设置或者文章的话需要再次进行上传部署<code>hexo g -d</code></p>
<h3 id="Hexo博客备份"><a href="#Hexo博客备份" class="headerlink" title="Hexo博客备份"></a>Hexo博客备份</h3><p>Hexo在进行部署时，是将页面内容解析后放在<code>.depoly_git</code>中进行上传GitHub仓库，博客内文章源文件并未进行上传，所以还需要手动将这些文件进行手动上传。目前比较常用的方法是在原GitHub仓库建立一条分支，将这些文件上传到该分支。</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cd</span> blog </span><br><span class="line">git init </span><br><span class="line">git submodule <span class="built_in">add</span> http<span class="variable">s:</span>//github.<span class="keyword">com</span>/<span class="keyword">next</span>-theme/hexo-theme-<span class="keyword">next</span>.git themes/<span class="keyword">next</span></span><br><span class="line">git <span class="built_in">add</span> .</span><br><span class="line">git commit -<span class="keyword">m</span> <span class="string">&quot;init blog backup&quot;</span></span><br><span class="line">git branch -<span class="keyword">m</span> master hexo</span><br><span class="line">git remote <span class="built_in">add</span> origin git@github.<span class="keyword">com</span>:JackHuang021/JackHuang021.github.io.git</span><br><span class="line">git push -<span class="keyword">u</span> origin hexo</span><br></pre></td></tr></table></figure>

<h3 id="恢复Hexo博客"><a href="#恢复Hexo博客" class="headerlink" title="恢复Hexo博客"></a>恢复Hexo博客</h3><ol>
<li>按照之前的步骤搭建Hexo环境</li>
<li>clone之前备份的hexo分支内容<code>git clone --recursive -b hexo git@github.com:JackHuang021/JackHuang021.github.io.git blog</code></li>
<li>下载npm依赖模块<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> blog</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure></li>
<li>clone master分支内容<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">cd blog</span><br><span class="line">git clone git@github<span class="selector-class">.com</span>:JackHuang021/JackHuang021<span class="selector-class">.github</span><span class="selector-class">.io</span><span class="selector-class">.git</span> <span class="selector-class">.deploy_git</span> </span><br></pre></td></tr></table></figure></li>
<li>正常更新、部署博客<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">hexo g</span></span><br><span class="line"><span class="attribute">hexo s</span></span><br><span class="line"><span class="attribute">hexo d</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="关于Hexo使用的思考"><a href="#关于Hexo使用的思考" class="headerlink" title="关于Hexo使用的思考"></a>关于Hexo使用的思考</h3><p>我觉得Hexo最大的特点就是便捷，借助GitHub可以在多台设备中无缝切换进行博客写作，服务器的维护工作基本不需要作者进行，换设备后直接搭建hexo环境，从GitHub拉取博客内容即可。</p>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
        <tag>博客搭建</tag>
        <tag>博客备份恢复</tag>
      </tags>
  </entry>
  <entry>
    <title>ssh使用密钥实现免密登录</title>
    <url>/archives/37d9659b.html</url>
    <content><![CDATA[<h3 id="本地ssh客户端准备ssh密钥"><a href="#本地ssh客户端准备ssh密钥" class="headerlink" title="本地ssh客户端准备ssh密钥"></a>本地ssh客户端准备ssh密钥</h3><p>ssh密钥默认保存路径<code>~/.ssh</code>，进入该目录查看是否已存在生成的密钥</p>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ls</span> -al ~<span class="string">/.ssh</span></span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220601093641.png"></p>
<span id="more"></span>
<p>如上图，<code>id_rsa.pub</code>和<code>qtc_id.pub</code>都是公钥<br>如果没有公钥，可以使用<code>ssh-keygen</code>生成</p>
<h3 id="上传ssh公钥到ssh服务器"><a href="#上传ssh公钥到ssh服务器" class="headerlink" title="上传ssh公钥到ssh服务器"></a>上传ssh公钥到ssh服务器</h3><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">ssh-<span class="keyword">copy</span>-id -i ~<span class="regexp">/.ssh/i</span>d_rsa.pub username@ip_address</span><br></pre></td></tr></table></figure>
<p>执行后会提示输入服务器用户密码</p>
<h3 id="测试ssh免密登录"><a href="#测试ssh免密登录" class="headerlink" title="测试ssh免密登录"></a>测试ssh免密登录</h3><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">ssh <span class="symbol">username@</span>ip_address</span><br></pre></td></tr></table></figure>
<p>如果可以直接登录，说明已经配置成功<br>都2022年了，不要在输入密码上再浪费更多时间了</p>
<h3 id="删除免密登录"><a href="#删除免密登录" class="headerlink" title="删除免密登录"></a>删除免密登录</h3><p>上传公钥后，服务端<code>.ssh/authorized_keys</code>文件中会添加一行内容，就是本地客户端的公钥，编辑该文件删除改行，即可禁用客户端免密登录<br><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220601094901.png"></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title>imx6ull OpenCV4.5 交叉编译</title>
    <url>/archives/e4359116.html</url>
    <content><![CDATA[<h4 id="交叉编译环境"><a href="#交叉编译环境" class="headerlink" title="交叉编译环境"></a>交叉编译环境</h4><ul>
<li>Ubuntu版本：Ubuntu20.04 64bits</li>
<li>交叉编译工具：arm-linux-gnueabihf-</li>
<li>硬件平台正点原子IMX6ULL (ALPHA)</li>
</ul>
<span id="more"></span>

<h4 id="准备源码和交叉编译工具链"><a href="#准备源码和交叉编译工具链" class="headerlink" title="准备源码和交叉编译工具链"></a>准备源码和交叉编译工具链</h4><p>Linux环境下的编译方法可以参考<a href="https://docs.opencv.org/4.x/d7/d9f/tutorial_linux_install.html">Opencv安装官网教程</a></p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">wget -O opencv.zip https:<span class="regexp">//gi</span>thub.com<span class="regexp">/opencv/</span>opencv<span class="regexp">/archive/</span><span class="number">4</span>.x.zip</span><br><span class="line">unzip opencv.zip</span><br></pre></td></tr></table></figure>
<p>交叉编译工具链版本<br><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220602095241.png"></p>
<h4 id="安装cmake和cmake-gui工具"><a href="#安装cmake和cmake-gui工具" class="headerlink" title="安装cmake和cmake-gui工具"></a>安装cmake和cmake-gui工具</h4><p>在命令行使用cmake工具确实很不方便，cmake-gui配置起来比较省时间<br><code>sudo apt-get install cmake cmake-qt-gui  cmake-curses-gui</code>  </p>
<h4 id="配置交叉编译环境"><a href="#配置交叉编译环境" class="headerlink" title="配置交叉编译环境"></a>配置交叉编译环境</h4><ol>
<li>运行cmake-gui<br><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220602100408.png">  </li>
<li>在第一个框输入OpenCV源码路径，在第二个框输入OpenCV编译目录  </li>
<li>点击<code>Configure</code>配置交叉编译环境<br><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220602100750.png"></li>
<li>选择<code>Spcify options for cross-compile</code>  </li>
<li>按照下图设置交叉编译工具链<br><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220602101028.png"></li>
<li>点击<code>Finish</code>回到cmake-gui主页面，勾选Advanced<br><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220602101237.png"></li>
</ol>
<h4 id="配置cmake选项"><a href="#配置cmake选项" class="headerlink" title="配置cmake选项"></a>配置cmake选项</h4><ol>
<li>在CMAKE_EXE_LINKER_FLAGS处添加上<code>-lpthread -lrt -ldl</code><br><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220602101546.png"></li>
<li>在CMAKE_INSTALL_PREFIX处指定安装目录，如果不指定，它会默认安装到Ubuntu系统目录<code>/usr/local</code>下。  </li>
<li>取消<code>BUILD_opencv_gapi</code>选项，不取消这个选项后续编译的时候会报错</li>
<li>再依次点击<code>Configure</code>， <code>Generate</code>，击了Generate后看到信息像如下图一样，表明生成成功，一般按照上面配置后基本都不会报错。<br><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220602102258.png"></li>
</ol>
<h4 id="编译OpenCV"><a href="#编译OpenCV" class="headerlink" title="编译OpenCV"></a>编译OpenCV</h4><ol>
<li>打开之前设置的imx6编译目录，该目录下有刚才生成的Makefile  </li>
<li>输入<code>make -j12</code>开始编译</li>
<li>编译完成后输入<code>make install</code>，OpenCV的库和头文件会安装到之前设置的<code>CMAKE_INSTALL_PREFIX</code>目录</li>
</ol>
<h4 id="编译过程中遇到的错误"><a href="#编译过程中遇到的错误" class="headerlink" title="编译过程中遇到的错误"></a>编译过程中遇到的错误</h4><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">/home/</span>tanyd<span class="regexp">/zdyz/</span>linaro494<span class="regexp">/arm-linux-gnueabihf/</span>libc<span class="regexp">/usr/i</span>nclude/features.h:<span class="number">311</span>:<span class="number">52</span>: error: operator <span class="string">&#x27;&amp;&amp;&#x27;</span> has no right operand <span class="comment">#if defined _FILE_OFFSET_BITS &amp;&amp; _FILE_OFFSET_BITS == 64</span></span><br></pre></td></tr></table></figure>
<p>解决方法： 在<code>#if defined</code>前面加上 <code>#define _FILE_OFFSET_BITS 64</code>  </p>
<h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><ol>
<li><a href="https://blog.csdn.net/qq_26943851/article/details/104434130">正点原子IMX6ULL移植OpenCV3.4.1</a></li>
<li><a href="https://blog.csdn.net/u011827554/article/details/123657141">imx6ull编译opencv4.4问题整理</a></li>
</ol>
]]></content>
      <categories>
        <category>OpenCV</category>
      </categories>
      <tags>
        <tag>imx6ull OpenCV 交叉编译</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu安装搜狗输入法的问题记录</title>
    <url>/archives/245a6c83.html</url>
    <content><![CDATA[<ul>
<li>最近在帮一个客户安装搜狗输入法时遇到了安装后无候选框的问题，记录一下该问题的解决办法，今天进入官网查看，官网已经修改安装指南，建议按照官网指南安装，本文截图来自搜狗官网</li>
</ul>
<h4 id="Ubuntu搜狗输入法下载"><a href="#Ubuntu搜狗输入法下载" class="headerlink" title="Ubuntu搜狗输入法下载"></a>Ubuntu搜狗输入法下载</h4><ul>
<li><a href="https://pinyin.sogou.com/linux?r=pinyin">搜狗输入法Linux版官网</a>，目前最新版本为V4.0.1</li>
<li><a href="https://pinyin.sogou.com/linux/guide">搜狗输入法Linux版安装指南</a></li>
</ul>
<span id="more"></span>

<h4 id="Ubuntu20-04安装步骤"><a href="#Ubuntu20-04安装步骤" class="headerlink" title="Ubuntu20.04安装步骤"></a>Ubuntu20.04安装步骤</h4><ol>
<li>添加中文语言支持，打开 系统设置——区域和语言——管理已安装的语言——在“语言”tab下——点击“添加或删除语言”<br><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220606092214.png"></li>
<li>弹出“已安装语言”窗口，勾选中文（简体），点击应用<br><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220606092221.png"></li>
<li>安装fcitx输入法框架<code>sudo apt-get install fcitx</code></li>
<li>卸载系统ibus输入法框架<code>sudo apt purge ibus</code></li>
<li>回到“语言支持”窗口，在键盘输入法系统中，选择<code>fcitx</code><br><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220606092226.png"></li>
<li>通过命令行安装搜狗输入法<code>sudo dpkg -i sogoupinyin_版本号_amd64.deb</code>，如果安装过程中提示缺少相关依赖，则执行如下命令解决：<code>sudo apt -f install</code></li>
<li>安装输入法依赖<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">sudo</span> apt install libqt<span class="number">5</span>qml<span class="number">5</span> libqt<span class="number">5</span>quick<span class="number">5</span> libqt<span class="number">5</span>quickwidgets<span class="number">5</span> qml-module-qtquick<span class="number">2</span></span><br><span class="line"><span class="attribute">sudo</span> apt install libgsettings-qt<span class="number">1</span></span><br></pre></td></tr></table></figure></li>
<li>点击“应用到整个系统”，关闭窗口，重启电脑</li>
<li>查看状态栏右上角，可以看到“搜狗”字样，在输入窗口即可使用搜狗输入法。没有“搜狗”字样，选择配置，将搜狗加入输入法列表即可。<br><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220606094224.png"><br><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220606094237.png"><br><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220606094048.png"></li>
</ol>
<h4 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h4><ul>
<li>安装完成后输入候选框不出现，只能输入英文</li>
<li>解决办法，安装qt依赖库可以解决<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">sudo</span> apt install libqt<span class="number">5</span>qml<span class="number">5</span> libqt<span class="number">5</span>quick<span class="number">5</span> libqt<span class="number">5</span>quickwidgets<span class="number">5</span> qml-module-qtquick<span class="number">2</span></span><br><span class="line"><span class="attribute">sudo</span> apt install libgsettings-qt<span class="number">1</span></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>搜狗输入法</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCV图像容器Mat</title>
    <url>/archives/d2c86892.html</url>
    <content><![CDATA[<h4 id="图像的存储"><a href="#图像的存储" class="headerlink" title="图像的存储"></a>图像的存储</h4><p><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220608085010.png"><br>借助官方这张很有代表性的图片，在计算机中以像素值的方式存储图像中的每个像素点，所有像素值以类似矩阵的二维数组形式进行存储。官网给OpenCV的定义：OpenCV是一个计算机视觉库，主要的目的就是在这些像素值上进行处理、计算，所以首先就需要学习OpenCV是怎么存储、处理这些图像的。</p>
<span id="more"></span>

<h4 id="Mat介绍"><a href="#Mat介绍" class="headerlink" title="Mat介绍"></a>Mat介绍</h4><ul>
<li>OpenCV起始于2001年，最开始是基于C语言编写，图像存储在C结构体<code>IplImage</code>。</li>
<li>OpenCV2.0基于C++进行重写，图像以Mat类进行存储。</li>
<li>Mat类包含两部分数据：  <ol>
<li>图像数据头部分，包含图像尺寸、存储方式、图像数据指针等信息</li>
<li>图像数据部分</li>
</ol>
</li>
<li>每个Mat对象都独立的保存数据头部分，但是可能共享图像数据部分。</li>
<li>Mat的拷贝构造只会拷贝数据头部分，数据部分不会进行拷贝。  <figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">Mat A, C;                          <span class="comment">// creates just the header parts</span></span><br><span class="line">A = imread<span class="comment">(argv[1], IMREAD_COLOR)</span>; <span class="comment">// here we&#x27;ll know the method used (allocate matrix)</span></span><br><span class="line">Mat B<span class="comment">(A)</span>;                          <span class="comment">// Use the copy constructor</span></span><br><span class="line">C = A;                             <span class="comment">// Assignment operator</span></span><br></pre></td></tr></table></figure></li>
<li>Mat类有一个引用计数机制，进行拷贝构造时引用加1，Mat对象析构时引用减1，当引用变为0时，释放数据部分内存。</li>
<li>当需要进行数据部分拷贝时，OpenCV提供了<code>cv::Mat::clone()</code>和<code>cv::Mat::copyTo</code>两个方法</li>
</ul>
<h4 id="Mat数据存储方式"><a href="#Mat数据存储方式" class="headerlink" title="Mat数据存储方式"></a>Mat数据存储方式</h4><ul>
<li>根据颜色空间和数据类型来选择图像数据存储方式</li>
</ul>
<h4 id="Mat对象操作"><a href="#Mat对象操作" class="headerlink" title="Mat对象操作"></a>Mat对象操作</h4><ul>
<li>使用<code>cv::Mat::Mat</code>构造函数进行创建<code>Mat img(2, 2, CV_8UC3, Scalar(0, 0, 255))</code>，指定图像的行和列大小、像素数据类型、像素颜色通道，如<code>CV_8UC3</code>表示8位无符号数据，颜色通道为3，由以下方式进行定义<br><code>CV_[The number of bits per item][Signed or Unsigned][Type Prefix]C[The channel number]</code></li>
<li>类似MATLAB方式创建单位矩阵<code>cv::Mat::eyes</code>、零矩阵<code>cv::Mat::zeros</code>、元素全为1的矩阵<code>cv::Mat::ones</code>  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Mat E = Mat::<span class="built_in">eye</span>(<span class="number">4</span>, <span class="number">4</span>, CV_64F);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;E = &quot;</span> &lt;&lt; endl &lt;+ Mat对象的打印</span><br><span class="line"><span class="number">1.</span> 默认输出&lt; <span class="string">&quot; &quot;</span> &lt;&lt; E &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line">Mat O = Mat::<span class="built_in">ones</span>(<span class="number">2</span>, <span class="number">2</span>, CV_32F);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;O = &quot;</span> &lt;&lt; endl &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; O &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line">Mat Z = Mat::<span class="built_in">zeros</span>(<span class="number">3</span>,<span class="number">3</span>, CV_8UC1);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Z = &quot;</span> &lt;&lt; endl &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; Z &lt;&lt; endl &lt;&lt; endl;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>OpenCV</category>
      </categories>
      <tags>
        <tag>OpenCV Mat</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCV图像操作</title>
    <url>/archives/117a3b0c.html</url>
    <content><![CDATA[<h4 id="图像读取和保存"><a href="#图像读取和保存" class="headerlink" title="图像读取和保存"></a>图像读取和保存</h4><ul>
<li>图像读取<code>Mat img = imread(filename)</code></li>
<li>图像保存<code>imwrite(filename, img)</code><span id="more"></span></li>
</ul>
<h4 id="像素级操作"><a href="#像素级操作" class="headerlink" title="像素级操作"></a>像素级操作</h4><ul>
<li>获取单通道灰度图像(x, y)位置像素值<code>Scalar intensity = img.at&lt;uchar&gt;(Point(x, y));</code></li>
<li>修改像素值<code>img.at&lt;uchar&gt;(Point(x, y)) = 128</code></li>
<li>获取3通道BGR颜色空间图像(x, y)位置像素值  <figure class="highlight sml"><table><tr><td class="code"><pre><span class="line"><span class="type">Vec3b</span> <span class="built_in">vector</span> = img.at&lt;<span class="type">Vec3b</span>&gt;(<span class="type">Point</span>(x, y));</span><br><span class="line">uchar blue = <span class="built_in">vector</span>.<span class="keyword">val</span>[<span class="number">0</span>];</span><br><span class="line">uchar green = <span class="built_in">vector</span>.<span class="keyword">val</span>[<span class="number">1</span>];</span><br><span class="line">uchar red = <span class="built_in">vector</span>.<span class="keyword">val</span>[<span class="number">2</span>];</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="图像基本操作"><a href="#图像基本操作" class="headerlink" title="图像基本操作"></a>图像基本操作</h4><ul>
<li>选取图像某个区域  <figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Rect</span> r(<span class="number">10</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line"><span class="attribute">Mat</span> smallImg = img(r);</span><br></pre></td></tr></table></figure></li>
<li>颜色空间转换  <figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">Mat img = imread(<span class="string">&quot;image.jpg&quot;</span>);</span><br><span class="line">Mat gray;</span><br><span class="line">cvt<span class="constructor">Color(<span class="params">img</span>, <span class="params">gray</span>, COLOR_BGR2GRAY)</span>;</span><br></pre></td></tr></table></figure></li>
<li>数据类型转换<code>src.convertTo(dst, CV_32F)</code></li>
<li>图像显示  <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">Mat img = imread(<span class="string">&quot;image.jpg&quot;</span>)<span class="comment">;</span></span><br><span class="line">namedWindow(<span class="string">&quot;image&quot;</span>, WINDOW_AUTOSIZE)<span class="comment">;</span></span><br><span class="line">imshow(<span class="string">&quot;image&quot;</span>, img)<span class="comment">;</span></span><br><span class="line">waitKey()<span class="comment">;</span></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>OpenCV</category>
      </categories>
      <tags>
        <tag>OpenCV Image</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCV 图像处理基本操作</title>
    <url>/archives/6465c2cc.html</url>
    <content><![CDATA[<h4 id="基于Mat类的图像操作"><a href="#基于Mat类的图像操作" class="headerlink" title="基于Mat类的图像操作"></a>基于Mat类的图像操作</h4><p><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220608085010.png"></p>
<ul>
<li>Mat类分为两个数据部分：数据头部分（保存矩阵大小、矩阵存储方式等信息）、矩阵数据部分， 一般的Mat对象复制构造仅拷贝数据头部分，矩阵数据部分共享。也可以通过<code>cv::Mat::copyTo</code>和<code>cv::Mat::clone</code>进行深度拷贝。<span id="more"></span></li>
<li>Mat构造函数<code>Mat img(2, 2, CV_8UC3, Scalar(0, 0, 255))</code>， 需要明确矩阵大小、矩阵存储数据类型、像素颜色通道数、像素值。</li>
<li>CV_8UC3含义表示8位无符号数据，颜色通道为3，含义参考：<code>CV_[The number of bits per item][Signed or Unsigned][Type Prefix]C[The channel number]</code></li>
<li>几种特殊矩阵的构造，<code>cv::Mat::eyes</code>单位矩阵、<code>cv::Mat::zeros</code>零矩阵、<code>cv::Mat::ones</code>全1矩阵</li>
</ul>
<h4 id="图像卷积操作"><a href="#图像卷积操作" class="headerlink" title="图像卷积操作"></a>图像卷积操作</h4><ul>
<li><p>根据kernel矩阵重新计算图像中每个像素的值，<em>h(k, j)</em> 为kernel，使用<code>filter2D</code>进行卷积操作<br>  <img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220609163143.png"></p>
  <figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">CV_EXPORTS_W <span class="type">void</span> filter2D( InputArray src, </span><br><span class="line">                            OutputArray dst, </span><br><span class="line">                            <span class="type">int</span> ddepth, </span><br><span class="line">                            InputArray kernel, </span><br><span class="line">                            <span class="type">Point</span> anchor = <span class="type">Point</span>(<span class="number">-1</span>,<span class="number">-1</span>), </span><br><span class="line">                            <span class="type">double</span> delta = <span class="number">0</span>, </span><br><span class="line">                            <span class="type">int</span> borderType = BORDER_DEFAULT );</span><br></pre></td></tr></table></figure></li>
<li><p>使用图像卷积进行图像模糊（平滑）</p>
<ol>
<li>简单的图像平滑，Kernel模型如下<br>  <img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220609163417.png"></li>
<li>高斯模糊，根据距当前像素点的距离决定平滑的权重，一维高斯核的图像如下<br>  <img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220609163925.png"><br>  二维高斯公式，其中μ为平均值，σ为方差<br>  <img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220609164447.png"></li>
<li>中值滤波，将像素点周围区域内的像素进行排序，采用中间位置的像素值作为当前像素点的值</li>
<li>双边滤波，权重由两部分来决定，第一部分是类似于二维高斯，另一部分由颜色差异来决定，这样可以比较好的保留边缘信息。</li>
</ol>
</li>
<li><p>图像边界处理，使用<code>copyMakeBorder</code>给图像创建一个边框</p>
<ol>
<li><code>BORDER_CONTANT</code>，使用固定像素值填充创建的边框</li>
<li><code>BORDER_REPLICATE</code>，复制原图像中的边界值</li>
</ol>
</li>
<li><p>使用图像卷积进行形态学操作，主要针对阈值化后的图像</p>
<ol>
<li>膨胀 Dilate，使用Kernel范围内的最大值取代当前像素值<br>  膨胀二值化图像<br>  <img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220610150255.png"><br>  膨胀灰度图像<br>  <img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220610150405.png"></li>
<li>腐蚀 Erode，使用Kernel范围内的最小值取代当前像素值<br>  腐蚀二值化图像<br>  <img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220610150527.png"><br>  腐蚀灰度图像<br>  <img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220610150618.png"></li>
<li>开操作 Opening，先腐蚀后膨胀，去除暗黑背景中细小的噪点，原理 *dst &#x3D; open(src, element) &#x3D; dilate(erode(src, element))*， <em>element</em>为kernel</li>
<li>闭操作 Closing，先膨胀后腐蚀，去除明亮背景中的细小噪点，原理 <em>dst &#x3D; close(src, element) &#x3D; erode(dilate(src, element))</em></li>
<li>形态梯度 Morphological Gradient，膨胀图像与腐蚀图像的差，用来找出物体轮廓，原理 <em>dst &#x3D; morphy(src, element) &#x3D; dilate(src, element) - erode(src, element)</em></li>
<li>高帽 Top Hat</li>
</ol>
</li>
<li><p>也可以使用 <em>getStructuringElement</em> 创造指定形状和大小的Kernel，进行图像的特征提取，如官方教程<a href="https://docs.opencv.org/4.x/dd/dd7/tutorial_morph_lines_detection.html">提取乐谱中的直线和音符</a>，就是借助形态学开操作进行直线和音符的提取。</p>
</li>
</ul>
<h4 id="图像融合"><a href="#图像融合" class="headerlink" title="图像融合"></a>图像融合</h4><ul>
<li>图像融合公式<code>dst = src1*alpha + src2*beta + gamma</code>，使用<code>addWeighted()</code>进行融合。  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cv::addWeighted</span><span class="params">( InputArray src1,</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="keyword">double</span> alpha,</span></span></span><br><span class="line"><span class="params"><span class="function">                      InputArray src2,</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="keyword">double</span> beta,</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="keyword">double</span> gamma,</span></span></span><br><span class="line"><span class="params"><span class="function">                      OutputArray dst,</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="keyword">int</span> dtype = <span class="number">-1</span> )</span></span>;	</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="改变图像对比度和亮度"><a href="#改变图像对比度和亮度" class="headerlink" title="改变图像对比度和亮度"></a>改变图像对比度和亮度</h4><ul>
<li>公式<code>g(x)=αf(x)+β</code>改变α的值可以改变图像的对比度，改变β的值可以改变图像的亮度</li>
<li>Gamma校准，使用查找表，按照如下公式对像素值进行一个非线性的转换 <em>O &#x3D; (I &#x2F; 255)^γ × 255</em>，γ越大整体亮度降低。<br><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220609161302.png"></li>
</ul>
<h4 id="图像的缩放"><a href="#图像的缩放" class="headerlink" title="图像的缩放"></a>图像的缩放</h4><ul>
<li>高斯金字塔(Gaussian Pyramid)，从底部开始计数，第 <em>i+1</em> 层表示为 <em>G(i + 1)</em><br><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220613132715.png"></li>
<li>*G(i + 1)<em>层的变换过程，由</em>G(i)*层先进行高斯模糊，然后丢掉偶数行和偶数列的像素，即图像缩小的操作</li>
<li>图像放大的操作，图像放大两倍，在奇数行和奇数列填充0像素，再进行高斯模糊<br><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220613141653.png"></li>
</ul>
<h4 id="图像阈值操作threshold的几种方法"><a href="#图像阈值操作threshold的几种方法" class="headerlink" title="图像阈值操作threshold的几种方法"></a>图像阈值操作<em>threshold</em>的几种方法</h4><ol>
<li>二值化（Threshold Binary），<code>src(x, y)</code>大于阈值<code>threshold</code>则置为最大值，否则置为0</li>
<li>反向二值化（Threshold Binary, Inverted），<code>src(x, y)</code>小于阈值<code>threshold</code>则置为最大值，否则置为0</li>
<li>截取像素值（Truncate），<code>src(x, y)</code>大于阈值<code>threshold</code>则令<code>src(x, y)</code>等于<code>threshold</code>，否则不变</li>
<li>只保留超过阈值部分，<code>src(x, y)</code>大于阈值<code>threshold</code>则置为原值，否则置为0</li>
<li>只保留小于阈值部分，<code>src(x, y)</code>小于阈值<code>threshold</code>则置为0，否则不变</li>
</ol>
<h4 id="图像像素梯度计算"><a href="#图像像素梯度计算" class="headerlink" title="图像像素梯度计算"></a>图像像素梯度计算</h4><ul>
<li><p><code>Sobel</code>边缘检测算子，利用图像边缘像素强度值变化非常显著的特点，使用特殊的卷积核计算水平方向的梯度变化和竖直方向的梯度变化。如下图是图像边缘像素强度的变化曲线的一维图像和该图像像素强度变化梯度图像（即导数图像），像素强度变化最剧烈的地方就可能是物体边缘。<br><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220614155216.png"> <img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220614160139.png">  </p>
</li>
<li><p>利用特殊的卷积核计算水平梯度变化和垂直梯度变化，然后再融合两个梯度图像<br><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220614160526.png"> <img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220614160536.png"><br><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220614160543.png"> <img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220614160552.png"></p>
</li>
<li><p>利用二级导数，像素强度变化剧烈的点即一阶导数极值点，其二级导数值接近0，拉普拉斯算子<code>Laplacian</code>计算水平方向和竖直方向上二级导数的和，OpenCV提供的<code>Laplacian()</code>函数，内部也是通过调用<code>Sobel()</code>来计算的，如下图二级导数图像和拉普拉斯公式。<br><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220624144442.png"><br><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220624144513.png"></p>
</li>
<li><p><code>Canny</code>边缘检测，1986年由John F. Canny提出，被认为是最优的边缘检测算法，其具有三个主要的特点：较低的错误率、较好的边缘定位、较快的检测速度，其检测步骤如下：</p>
<ol>
<li>使用高斯平滑模糊图像</li>
<li>计算图像亮度梯度图像，其过程与Sobel算子类似，分别计算x y方向上的梯度，再进行融合</li>
<li>去掉不是很连续的像素点，认为其不属于边缘</li>
<li>使用两个阈值，一大一小，其比例一般为2:1或者3:1，高于upper阈值认为其为边缘，低于lower阈值丢弃该像素点，介于upper与lower之间的像素点则看邻接像素点是否高于upper，是的话接受其为边缘</li>
</ol>
</li>
</ul>
<h4 id="霍夫变换直线检测"><a href="#霍夫变换直线检测" class="headerlink" title="霍夫变换直线检测"></a>霍夫变换直线检测</h4><ul>
<li>图像转化为灰度颜色，首先进行高斯模糊</li>
<li>再进行边缘检测，使其变成了一个二值化包含边缘的图像</li>
<li>经过该图像上像素点（x0, y0）的所有直线的方程可以表述为如下，霍夫变换检测每一个像素点的经过直线的条数，经过的直线条数到达一定阈值后可认为该</li>
</ul>
]]></content>
      <categories>
        <category>OpenCV</category>
      </categories>
      <tags>
        <tag>OpenCV Core</tag>
      </tags>
  </entry>
  <entry>
    <title>HI3559AV100调试记录</title>
    <url>/archives/7803046f.html</url>
    <content><![CDATA[<h4 id="内核编译与烧写"><a href="#内核编译与烧写" class="headerlink" title="内核编译与烧写"></a>内核编译与烧写</h4><ul>
<li>内核版本4.9.37，Linux内核源码如下<br><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220609101727.png"><span id="more"></span></li>
<li>编译<code>make ARCH=arm64 CROSS_COMPILE=aarch64-himix100-linux- uImage -j12</code>，编译完成结果如下，编译完成后会在arch&#x2F;arm64&#x2F;boot&#x2F;生成UImage<br><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220609101926.png"></li>
<li>arm-trusted-firmware目录中运行mk.sh生成fip.bin<br><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220609110821.png"></li>
<li>主机搭建tftp服务器，将fip.bin拷贝到共享目录</li>
<li>进入uboot，配置ethact ipaddr serverip环境变量<br><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220609111122.png"></li>
<li>从tftp加载内核，测试内核是否能启动、  <figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">tftp</span> fip.bin <span class="number">0</span>x<span class="number">42000000</span></span><br><span class="line"><span class="attribute">bootm</span> <span class="number">0</span>x<span class="number">42000000</span></span><br></pre></td></tr></table></figure></li>
<li>烧写内核到emmc  <figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">tftp</span> fip.bin <span class="number">0</span>x<span class="number">42000000</span></span><br><span class="line"><span class="attribute">mmc</span> dev <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="attribute">mmc</span> write <span class="number">0</span> <span class="number">0</span>x<span class="number">42000000</span> <span class="number">800</span> <span class="number">4800</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="驱动调试"><a href="#驱动调试" class="headerlink" title="驱动调试"></a>驱动调试</h4><ul>
<li>参照正点原子教程搭建驱动调试环境，配置的<em>Makefile</em>内容如下  <figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">KERNEL_DIR = /home/jack/hisi/minimum_system/linux-4.9.y_multi-core</span><br><span class="line">CURRENT_PATH = <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line">obj-m := gpio-pca953x.o</span><br><span class="line"></span><br><span class="line"><span class="section">build: kernel_modules</span></span><br><span class="line"></span><br><span class="line"><span class="section">kernel_modules: </span></span><br><span class="line"><span class="variable">$(MAKE)</span> ARCH=arm64 CROSS_COMPILE=aarch64-himix100-linux- -C <span class="variable">$(KERNEL_DIR)</span> M=<span class="variable">$(CURRENT_PATH)</span> modules</span><br><span class="line"></span><br><span class="line"><span class="section">clean: </span></span><br><span class="line"><span class="variable">$(MAKE)</span> ARCH=arm64 CROSS_COMPILE=aarch64-himix100-linux- -C <span class="variable">$(KERNEL_DIR)</span> M=<span class="variable">$(CURRENT_PATH)</span> clean</span><br></pre></td></tr></table></figure></li>
<li><em>KERNEL_DIR</em>表示Linux内核源码目录，使用绝对路径</li>
<li><em>CURRENT_PATH</em>表示当前路径，直接使用<em>pwd</em>来获取当前路径</li>
<li><em>obj-m</em>表示将这个c文件编译为ko模块</li>
<li><em>modules</em>表示编译模块，*-C*表示将当前的工作目录切换到指定目录中， <em>M</em>表示模块源码目录</li>
<li><em>make modules</em>命令中加入 M&#x3D;dir 以后程序会自动到指定的 dir 目录中读取模块的源码并将其编译为.ko 文件</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Hi3559AV100 Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux Input子系统按键连按驱动调试记录</title>
    <url>/archives/e19e1ecc.html</url>
    <content><![CDATA[<h4 id="Linux-Input子系统介绍"><a href="#Linux-Input子系统介绍" class="headerlink" title="Linux Input子系统介绍"></a>Linux Input子系统介绍</h4><blockquote>
<p>按键、鼠标、键盘、触摸屏等都属于输入(input)设备, Linux 内核为此专门做了一个叫做 input子系统的框架来处理输入事件。输入设备本质上还是字符设备,只是在此基础上套上了 input 框架,用户只需要负责上报输入事件,比如按键值、坐标等信息, input 核心层负责处理这些事件。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220609141734.png"></p>
<span id="more"></span>

<h4 id="input驱动编写流程"><a href="#input驱动编写流程" class="headerlink" title="input驱动编写流程"></a>input驱动编写流程</h4><ul>
<li><p>注册input_dev</p>
<ol>
<li>使用<em>input_allocate_device</em>申请一个<em>input_dev</em>结构体</li>
<li>初始化<em>input_dev</em>的事件类型以及事件值</li>
<li>使用<em>input_register_device</em>函数向系统注册<em>input_dev</em></li>
<li><strong>按键需要实现连按时<em>evbit</em>需要设置<em>EV_REP</em>标志，调按键驱动时在调连按功能时在这里卡了很久</strong>  <figure class="highlight xl"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">chip</span>-&gt;</span>input = input_allocate_device();</span><br><span class="line"><span class="function"><span class="title">if</span> (!chip-&gt;</span>input) </span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_ERR <span class="string">&quot;Unable to allocate the input device !!\n&quot;</span>);</span><br><span class="line">    return -ENOMEM;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">chip</span>-&gt;</span><span class="function"><span class="title">input</span>-&gt;</span><span class="keyword">name</span> = <span class="string">&quot;pca953x_button&quot;</span>;</span><br><span class="line"><span class="function"><span class="title">set_bit</span>(EV_KEY, chip-&gt;</span><span class="function"><span class="title">input</span>-&gt;</span>evbit);     <span class="comment">/* 设置产生按键事件 */</span> </span><br><span class="line"><span class="function"><span class="title">set_bit</span>(EV_REP, chip-&gt;</span><span class="function"><span class="title">input</span>-&gt;</span>evbit);     <span class="comment">/* 设置重复事件  */</span> </span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; ZKEY_NUM + <span class="number">5</span>; i++)	</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="title">set_bit</span>(button_info[i].code, chip-&gt;</span><span class="function"><span class="title">input</span>-&gt;</span>keybit);	<span class="comment">//支持具体按键键码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">status</span> = input_register_device(chip-&gt;</span>input);   <span class="comment">//注册input设备</span></span><br><span class="line"><span class="keyword">if</span>(status)</span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_ERR <span class="string">&quot;input_register_device\n&quot;</span>);</span><br><span class="line">    return -ENOMEM;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="上报输入事件"><a href="#上报输入事件" class="headerlink" title="上报输入事件"></a>上报输入事件</h4></li>
</ol>
</li>
<li><p>使用<em>input_event</em>函数上报指定的事件及对应的值，函数原型如下</p>
  <figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> input_event(<span class="keyword">struct</span> input_dev *dev,</span><br><span class="line">                 <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="keyword">type</span>,</span><br><span class="line">                 <span class="keyword">unsigned</span> <span class="keyword">int</span> code,</span><br><span class="line">                 <span class="keyword">int</span> value)</span><br></pre></td></tr></table></figure>
<p>  dev:需要上报的 input_dev。<br>  type: 上报的事件类型,比如 EV_KEY。<br>  code:事件码,也就是我们注册的按键值,比如 KEY_0、KEY_1 等等。<br>  value:事件值,比如 1 表示按键按下,0 表示按键松开。</p>
</li>
<li><p>上报按键事件，Linux内核也提供了具体的上报函数<em>input_report_key</em></p>
  <figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">static inline void input<span class="constructor">_report_key(<span class="params">struct</span> <span class="params">input_dev</span> <span class="operator">*</span><span class="params">dev</span>, <span class="params">unsigned</span> <span class="params">int</span> <span class="params">code</span>, <span class="params">int</span> <span class="params">value</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    input<span class="constructor">_event(<span class="params">dev</span>, EV_KEY, <span class="params">code</span>, !!<span class="params">value</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  type:事件类型,比如 EV_KEY,表示此次事件为按键事件,此成员变量为 16 位。<br>  code:事件码,比如在 EV_KEY 事件中 code 就表示具体的按键码,如:KEY_0、KEY_1等等这些按键。此成员变量为 16 位。<br>  value:值,比如 EV_KEY 事件中 value 就是按键值,表示按键有没有被按下,如果为1的话说明按键按下,如果为0的话说明按键没有被按下或者按键松开了。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux Driver 按键驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt中串口数据处理机制</title>
    <url>/archives/6e893f38.html</url>
    <content><![CDATA[<p>在嵌入式项目或者工控项目中经常会用到串口通讯，用到串口通讯可能就涉及到串口私有协议（类似 包头 + 帧类型 + 帧长度 + 帧数据 + 校验和 的形式）的解析。在Qt中经常用到<code>QSerialPort</code>类来进行串口数据收发，<code>QSerialPort</code>在串口数据可读时会释放<code>readyRead()</code>信号，接到这个信号再调用<code>readAll()</code>将缓冲区的数据全部读出来（串口数据量比较大，这个过程一般都是在一个独立的接收线程中进行处理）。<span id="more"></span>但是这个<code>readyRead()</code>信号释放时，缓冲区的数据长度是不固定的（一般是几十个字节会释放一次读信号），不过串口私有协议各个帧的长度基本都是固定的，这就导致处理串口数据时需要对<code>readAll()</code>中读出来的数据进行链接，然后进行数据解析。<br>记录一下最近调试Qt串口通讯时用到的方法，这个方法也适用于任何系统的串口数据接收，可以达到不错的处理速度，保证不丢帧的接收。该方法的处理机制比较简单，在槽函数中接收到串口数据后，释放信号将读到的数据传递出去，接收信号方逐字节的按照协议对这些数据进行处理，这样只要<code>QSerialPort</code>将串口上的数据都完整的读出来了，应该是不会出现丢帧的情况。</p>
<h4 id="串口初始化及数据接收"><a href="#串口初始化及数据接收" class="headerlink" title="串口初始化及数据接收"></a>串口初始化及数据接收</h4><ul>
<li>串口类进行初始化后，转移到<code>thread</code>线程中进行处理，在<code>readSerialData()</code>中将数据读取后将数据传递出去。<br>  serialport.h  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SerialPort</span> :</span> <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">SerialPort</span><span class="params">(QObject *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">    ~<span class="built_in">SerialPort</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">startThread</span><span class="params">(<span class="keyword">const</span> QString &amp;port)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">closeSerialPort</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">writeSerialData</span><span class="params">(<span class="keyword">const</span> QByteArray &amp;data)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">openSerialPort</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">readSerialData</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">serialStateChanged</span><span class="params">(<span class="keyword">bool</span> state)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dataReaded</span><span class="params">(<span class="keyword">const</span> QByteArray &amp;data)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QString port;</span><br><span class="line">    qint32 baudrate;</span><br><span class="line">    QSerialPort *serial;</span><br><span class="line">    QThread *thread;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
  serialport.cpp  <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &quot;serialport.h&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@brief</span> SerialPort::SerialPort</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> parent</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">SerialPort::SerialPort(QObject *<span class="built_in">parent</span>) : QObject(<span class="built_in">parent</span>)</span><br><span class="line">&#123;</span><br><span class="line">    serial = <span class="keyword">new</span> QSerialPort;</span><br><span class="line">    thread = <span class="keyword">new</span> QThread;</span><br><span class="line">    this-&gt;moveToThread(thread);</span><br><span class="line">    serial-&gt;moveToThread(thread);</span><br><span class="line">    connect(thread, &amp;QThread::started, this, &amp;SerialPort::openSerialPort);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@brief</span> SerialPort::~SerialPort</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">SerialPort::~SerialPort()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (serial-&gt;isOpen())</span><br><span class="line">    &#123;</span><br><span class="line">        serial-&gt;close();</span><br><span class="line">    &#125;</span><br><span class="line">    serial-&gt;deleteLater();</span><br><span class="line">    thread-&gt;quit();</span><br><span class="line">    thread-&gt;wait();</span><br><span class="line">    thread-&gt;deleteLater();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@brief</span> SerialPort::startThread</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> port serial port name(QSerialPortInfo::name)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">void</span> SerialPort::startThread(<span class="keyword">const</span> QString &amp;port)</span><br><span class="line">&#123;</span><br><span class="line">    this-&gt;port = port;</span><br><span class="line">    qDebug() &lt;&lt; <span class="string">&quot;current port is &quot;</span> &lt;&lt; port;</span><br><span class="line">    <span class="keyword">if</span> (!thread-&gt;isRunning())</span><br><span class="line">    &#123;</span><br><span class="line">        thread-&gt;start();</span><br><span class="line">        qDebug() &lt;&lt; <span class="string">&quot;serialport thread start: &quot;</span> &lt;&lt; QThread::currentThread();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@brief</span> SerialPort::openSerialPort</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">void</span> SerialPort::openSerialPort()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (serial-&gt;isOpen())</span><br><span class="line">    &#123;</span><br><span class="line">        qDebug() &lt;&lt; <span class="string">&quot;serial is opened, return.&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    serial-&gt;setPortName(port);</span><br><span class="line">    serial-&gt;setBaudRate(<span class="number">115200</span>);</span><br><span class="line">    serial-&gt;setDataBits(QSerialPort::Data8);</span><br><span class="line">    serial-&gt;setStopBits(QSerialPort::OneStop);</span><br><span class="line">    serial-&gt;setParity(QSerialPort::NoParity);</span><br><span class="line">    serial-&gt;setFlowControl(QSerialPort::NoFlowControl);</span><br><span class="line">    <span class="keyword">if</span> (serial-&gt;open(QIODevice::ReadWrite))</span><br><span class="line">    &#123;</span><br><span class="line">        qDebug() &lt;&lt; <span class="string">&quot;serial open success.&quot;</span> &lt;&lt; QThread::currentThread();</span><br><span class="line">        connect(serial, &amp;QSerialPort::readyRead,</span><br><span class="line">                this, &amp;SerialPort::readSerialData, Qt::QueuedConnection);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        qDebug() &lt;&lt; <span class="string">&quot;serial open failed.&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@brief</span> SerialPort::readSerialData</span></span><br><span class="line"><span class="comment">* read 16 bytes each time</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">void</span> SerialPort::readSerialData()</span><br><span class="line">&#123;</span><br><span class="line">    QByteArray buf = serial-&gt;readAll();</span><br><span class="line">    emit dataReaded(buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@brief</span> SerialPort::writeSerialData</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> data  buff to write</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">void</span> SerialPort::writeSerialData(<span class="keyword">const</span> QByteArray &amp;data)</span><br><span class="line">&#123;</span><br><span class="line">    serial-&gt;write(data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@brief</span> SerialPort::closeSerialPort</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">void</span> SerialPort::closeSerialPort()</span><br><span class="line">&#123;</span><br><span class="line">    qDebug() &lt;&lt; <span class="string">&quot;close serialport.&quot;</span>;</span><br><span class="line">    serial-&gt;clear();</span><br><span class="line">    serial-&gt;close();</span><br><span class="line">    <span class="keyword">if</span> (thread-&gt;isRunning())</span><br><span class="line">    &#123;</span><br><span class="line">        thread-&gt;quit();</span><br><span class="line">        thread-&gt;wait();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="串口数据处理"><a href="#串口数据处理" class="headerlink" title="串口数据处理"></a>串口数据处理</h4><ul>
<li>数据处理类接收到串口类传递的数据后，按照协议逐字节的进行处理，帧头的处理比较麻烦，因为帧头一般是两个字节，可能被缓冲到前后两个数据缓冲区，所以需要对前后两个帧头的位置关系进行判断。<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uartRecvProcess</span><span class="params">(<span class="keyword">const</span> QByteArray&amp; data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> firstHeadPos = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> frameLen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> frameDataIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> lastLen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">uint8_t</span> frameData[MAX_FRAME_LEN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> PRINT_UART_DEBUG</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; data.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;0x%02x &quot;</span>, (<span class="keyword">uint8_t</span>)data.<span class="built_in">at</span>(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (index &lt; data.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">uint8_t</span> temp = data.<span class="built_in">at</span>(index);</span><br><span class="line"></span><br><span class="line">        <span class="built_in"><span class="keyword">switch</span></span> (step)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="comment">// 查找第一个帧头</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="number">0x55</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                step = <span class="number">1</span>;</span><br><span class="line">                firstHeadPos = index;</span><br><span class="line">                frameData[frameDataIndex++] = temp;</span><br><span class="line">                lastLen = data.<span class="built_in">size</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查找第二个帧头</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> ((temp == <span class="number">0xAA</span>) &amp;&amp;</span><br><span class="line">                ((index == firstHeadPos + <span class="number">1</span>) ||</span><br><span class="line">                ((firstHeadPos == lastLen <span class="number">-1</span>) &amp;&amp; index == <span class="number">0</span>)))</span><br><span class="line">            &#123;</span><br><span class="line">                step = <span class="number">2</span>;</span><br><span class="line">                frameData[frameDataIndex++] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                step = <span class="number">0</span>;</span><br><span class="line">                firstHeadPos = <span class="number">-1</span>;</span><br><span class="line">                frameDataIndex = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 帧类型判断</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">if</span>(temp == CMD_AD)</span><br><span class="line">            &#123;</span><br><span class="line">                frameLen = FRAME_SIZE_AD;</span><br><span class="line">                frameData[frameDataIndex++] = temp;</span><br><span class="line">                step = <span class="number">3</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(temp == CMD_IO)</span><br><span class="line">            &#123;</span><br><span class="line">                frameLen = FRAME_SIZE_IO;</span><br><span class="line">                step = <span class="number">3</span>;</span><br><span class="line">                frameData[frameDataIndex++] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//去掉帧头，重新查找</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;unknow uart frame type\n&quot;</span>);</span><br><span class="line">                step = <span class="number">0</span>;</span><br><span class="line">                frameLen = <span class="number">0</span>;</span><br><span class="line">                firstHeadPos = <span class="number">-1</span>;</span><br><span class="line">                frameDataIndex = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 帧数据接收及解析</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">if</span> (frameDataIndex &lt; frameLen)</span><br><span class="line">                frameData[frameDataIndex++] = temp;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (frameDataIndex == frameLen)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(frameData[frameLen - <span class="number">1</span>] != <span class="built_in">checkSum</span>(frameData, frameLen - <span class="number">1</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;type: %d, checksum error! received is 0x%02x, calculated is 0x%02x\n&quot;</span>,</span><br><span class="line">                           frameLen, frameData[frameLen - <span class="number">1</span>], <span class="built_in">checkSum</span>(frameData, frameLen - <span class="number">1</span>));</span><br><span class="line">                    step = <span class="number">0</span>;</span><br><span class="line">                    frameLen = <span class="number">0</span>;</span><br><span class="line">                    firstHeadPos = <span class="number">-1</span>;</span><br><span class="line">                    frameDataIndex = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;type: %d, uart data handler\n&quot;</span>, frameLen);</span><br><span class="line">                    <span class="built_in">uartDataHandler</span>(frameData, frameLen);</span><br><span class="line">                    step = <span class="number">0</span>;</span><br><span class="line">                    frameLen = <span class="number">0</span>;</span><br><span class="line">                    firstHeadPos = <span class="number">-1</span>;</span><br><span class="line">                    frameDataIndex = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        index ++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>Qt QSerialPort 串口</tag>
      </tags>
  </entry>
  <entry>
    <title>龙芯2K1000内核源码编译</title>
    <url>/archives/67263a86.html</url>
    <content><![CDATA[<h4 id="解压PMON源码pmon-loongson3-tar-gz"><a href="#解压PMON源码pmon-loongson3-tar-gz" class="headerlink" title="解压PMON源码pmon-loongson3.tar.gz"></a>解压PMON源码<em>pmon-loongson3.tar.gz</em></h4><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">tar</span> -xvf pmon-loongson<span class="number">3</span>-nd-<span class="number">33</span>j.tar.gz</span><br></pre></td></tr></table></figure>
<h4 id="配置交叉编译环境"><a href="#配置交叉编译环境" class="headerlink" title="配置交叉编译环境"></a>配置交叉编译环境</h4><ul>
<li>解压交叉编译工具<em>gcc-4.4.0-pmon.tgz</em>，配置环境<span id="more"></span>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">tar</span> -xvf gcc-<span class="number">4</span>.<span class="number">4</span>.<span class="number">0</span>-pmon.tgz</span><br></pre></td></tr></table></figure>
编辑&#x2F;etc&#x2F;profile，配置交叉编译工具路径<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">export PATH=<span class="variable">$PATH</span><span class="symbol">:/home/jack/loongson/tools/gcc-</span><span class="number">4.4</span>.0-pmon/bin</span><br><span class="line">export LD_LIBRARY_PATH=<span class="regexp">/home/jack</span><span class="regexp">/loongson/tools</span><span class="regexp">/gcc-4.4.0-pmon/lib</span><span class="symbol">:</span><span class="variable">$LD_LIBRARY_PATH</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>安装makedepend，<code>sudo apt-get install xutils-dev </code></li>
<li>进入源码目录编译安装pmoncfg<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> install bison flex build-essential patch</span><br><span class="line"><span class="keyword">cd</span> tools/pmoncfg </span><br><span class="line"><span class="keyword">make</span> </span><br><span class="line">sudo <span class="keyword">cp</span> pmoncfg /usr/bin</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="编译PMON源码"><a href="#编译PMON源码" class="headerlink" title="编译PMON源码"></a>编译PMON源码</h4><p>进入PMON源码目录，若只需要修改PMON，可在原来的项目目录基础上进行编译，源码内有脚本文件<em>build.sh</em>，输入格式: <code>./build.sh [cputype] [proID]</code>，比如龙芯2K1000，项目ID hm19047，输入<code>./build.sh ls2k hm19047</code>即可开始编译，编译结果在<em>zloader.ls2k-hm19047</em>目录中，会生成<em>gzrom-dtb.bin</em>，将该文件烧录进flash即可。</p>
<h4 id="PMON网络烧录"><a href="#PMON网络烧录" class="headerlink" title="PMON网络烧录"></a>PMON网络烧录</h4><ul>
<li>主机IP地址为192.168.0.100，搭建tftp服务器</li>
<li>开机按C键进入PMON下，设置IP地址<code>ifconfig syn0 192.168.0.10</code></li>
<li>烧写PMON<code>load -rf 0xbfc00000 tftp://192.168.0.100/gzrom-dtb.bin</code></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>PMON</tag>
        <tag>Loongson</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu编译QFtp并使用</title>
    <url>/archives/1b5a9595.html</url>
    <content><![CDATA[<h4 id="下载QFtp源码"><a href="#下载QFtp源码" class="headerlink" title="下载QFtp源码"></a>下载QFtp源码</h4><p><a href="https://github.com/qt/qtftp.git">QFtp源码</a><br><code>gti clone https://github.com/qt/qtftp.git</code></p>
<h4 id="编译QFtp模块"><a href="#编译QFtp模块" class="headerlink" title="编译QFtp模块"></a>编译QFtp模块</h4><p>在QtCreator上编译出了点问题，只能在终端进行编译</p>
<ul>
<li>进入源码目录<code>cd src/qftp</code>，修改pro文件<code>qftp.pro</code>,修改如下<span id="more"></span>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">load(qt_build_config)</span><br><span class="line"></span><br><span class="line">TARGET = QtFtp</span><br><span class="line">CONFIG += static</span><br><span class="line">CONFIG -= shared</span><br><span class="line">QT = core network</span><br><span class="line"></span><br><span class="line">MODULE_PRI = ../../modules/qt_ftp.pri</span><br><span class="line">MODULE = ftp</span><br><span class="line"></span><br><span class="line">load(qt_module)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Input</span></span><br><span class="line">HEADERS += qftp.h qurlinfo.h</span><br><span class="line">SOURCES += qftp.cpp qurlinfo.cpp</span><br><span class="line"></span><br></pre></td></tr></table></figure>
修改<code>qurlinfo.cpp</code>中的<code>qurlinfo.h</code>路径，修改如下<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &quot;qurlinfo.h&quot;</span><br><span class="line"></span><br><span class="line">#include &quot;qurl.h&quot;</span><br><span class="line">#include &quot;qdir.h&quot;</span><br><span class="line">#include &lt;limits.h&gt;</span><br><span class="line"></span><br><span class="line">QT_BEGIN_NAMESPACE</span><br></pre></td></tr></table></figure></li>
<li>在终端中进入源码目录<code>cd src/qftp</code>，运行<code>qmake</code>，之后会生成Makefile</li>
<li><code>make</code>生成<code>libQt5Ftp.a</code>静态库，pri模块文件</li>
<li><code>make install</code>将生成的库文件及QFtp头文件复制到Qt安装目录</li>
<li>对于交叉编译环境下其他平台的编译也可按照上面的步骤，qmake需要替换交叉编译环境下对应的qmake</li>
</ul>
<h4 id="QFtp使用"><a href="#QFtp使用" class="headerlink" title="QFtp使用"></a>QFtp使用</h4><ul>
<li>官方源码目录example文件夹下有一个例程，网上有大佬稍加修改上传到了GitHub，<a href="https://github.com/chuanstudyup/QFtpExample.git">QFtp例程</a>  </li>
<li>下载这个例程，上述编译步骤没问题的话，直接编译运行即可<br><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220627150335.png"></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>QFtp</tag>
      </tags>
  </entry>
  <entry>
    <title>C/C++ 中宏定义中#和##的作用</title>
    <url>/archives/57aaac13.html</url>
    <content><![CDATA[<h4 id="宏定义中-的功能"><a href="#宏定义中-的功能" class="headerlink" title="宏定义中#的功能"></a>宏定义中#的功能</h4><p>C&#x2F;C++宏定义#中的功能是将其后面的宏参数进行字符串化操作，简单说就是在对它所引用的宏变量通过替换后在其左右各添加一个双引号。</p>
<span id="more"></span>

<h4 id="宏定义中-的功能-1"><a href="#宏定义中-的功能-1" class="headerlink" title="宏定义中##的功能"></a>宏定义中##的功能</h4><p>宏定义中##中的功能是在带参数的宏定义中将##前后的子串进行拼接。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STR(s) #s</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONS(a, b) int(a##e##b)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">STR</span>(hello) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">CONS</span>(<span class="number">2</span>, <span class="number">3</span>) &lt;&lt; endl;     <span class="comment">// CONS(2, 3) -&gt; 2e3 </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line">hello</span><br><span class="line"><span class="number">2000</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核链表结构</title>
    <url>/archives/4896cd7d.html</url>
    <content><![CDATA[<p>Linux内核中，对于数据管理，提供了2种类型的双向链表，一种是使用list_head结构体构成的双向环形链表。<br><img src="https://raw.githubusercontent.com/JackHuang021/images/master/20221103103152.png"></p>
<span id="more"></span>
<h3 id="list-head链表"><a href="#list-head链表" class="headerlink" title="list_head链表"></a>list_head链表</h3><h4 id="list-head定义"><a href="#list-head定义" class="headerlink" title="list_head定义"></a>list_head定义</h4><p><code>list_head</code>结构体定义在<code>include/linux/types.h</code>中，定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">next</span>, *<span class="title">prev</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>list_head</code>组成的双向链表，仅包含两个成员，<code>next</code>和<code>prev</code>指针，分别指向下一个和前一个<code>list_head</code></p>
<p><code>list_head</code>一般不是单独使用的，一般用来嵌入到其他结构体中，知道<code>list_head</code>指针时就可以通过<code>include/linux/list.h</code>中提供的<code>list_entry</code>宏来获取它父结构的地址，其中调用了<code>container_of</code>宏，该宏定义在<code>include/linux/kernel</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* list_head 使用示例 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_list</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *item;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* list_entry */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* list_entry - get the struct for this entry</span></span><br><span class="line"><span class="comment">* @ptr:	the &amp;struct list_head pointer.</span></span><br><span class="line"><span class="comment">* @type:	the type of the struct this is embedded in.</span></span><br><span class="line"><span class="comment">* @member:	the name of the list_head within the struct.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_entry(ptr, type, member) \</span></span><br><span class="line"><span class="meta">    container_of(ptr, type, member)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* container_of - cast a member of a structure out to the containing structure</span></span><br><span class="line"><span class="comment">* @ptr:	the pointer to the member.</span></span><br><span class="line"><span class="comment">* @type:	the type of the container struct this is embedded in.</span></span><br><span class="line"><span class="comment">* @member:	the name of the member within the struct.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> container_of(ptr, type, member) (&#123; \</span></span><br><span class="line"><span class="meta">    void *__mptr = (void *)(ptr); \</span></span><br><span class="line"><span class="meta">    ((type *)(__mptr - offsetof(type, member))); &#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* offsetof */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> offsetof(TYPE, MEMBER) ((size_t) &amp;((TYPE *)0)-&gt;MEMBER)</span></span><br></pre></td></tr></table></figure>
<p><code>offsetof</code>获取结构体成员在结构体中地址的偏移量<br><code>container_of</code>的作用是通过结构体的成员地址获取结构体变量的地址，container_of一共需要传入三个参数，<code>ptr</code>指针地址，<code>type</code>结构体类型，<code>member</code>结构体成员名称，具体的做法就是通过成员的指针地址，减去成员在结构体中偏移的地址</p>
<h4 id="list-head链表操作"><a href="#list-head链表操作" class="headerlink" title="list_head链表操作"></a><code>list_head</code>链表操作</h4><h5 id="list-head初始化"><a href="#list-head初始化" class="headerlink" title="list_head初始化"></a><code>list_head</code>初始化</h5><p><strong>静态初始化</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIST_HEAD_INIT(name) &#123; &amp;(name), &amp;(name) &#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIST_HEAD(name) struct list_head name = LIST_HEAD_INIT(name)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 例如 */</span></span><br><span class="line">LIST_HEAD(my_list);</span><br><span class="line"><span class="comment">/* 展开即为 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">mylist</span> =</span> &#123; &amp;(mylist), &amp;(mylist) &#125;;</span><br></pre></td></tr></table></figure>

<p><strong>动态初始化</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIST_HEAD_INIT(name) &#123; &amp;(name), &amp;(name) &#125;</span></span><br><span class="line"><span class="comment">/* 或者 */</span></span><br><span class="line"><span class="function">struct <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">INIT_LIST_HEAD</span><span class="params">(struct list_head *<span class="built_in">list</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    WRITE_ONCE(<span class="built_in">list</span>-&gt;next, <span class="built_in">list</span>);</span><br><span class="line">    <span class="built_in">list</span>-&gt;prev = <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 例如 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">mylist</span> =</span> LIST_HEAD_INIT(mylist);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">mylist2</span>;</span></span><br><span class="line">INIT_LIST_HEAD(&amp;mylist2);</span><br></pre></td></tr></table></figure>

<h5 id="从list-head中获取对象结构体"><a href="#从list-head中获取对象结构体" class="headerlink" title="从list_head中获取对象结构体"></a>从<code>list_head</code>中获取对象结构体</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @ptr:	the list head to take the element from.</span></span><br><span class="line"><span class="comment"> * @type:	the type of the struct this is embedded in.</span></span><br><span class="line"><span class="comment"> * @member:	the name of the list_head within the struct.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 实际就是使用container_of通过list_head地址来获取原结构体的地址</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_entry(ptr, type, member) \</span></span><br><span class="line"><span class="meta">    container_of(ptr, type, member)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取链表上的第一个节点，这里ptr传入的默认应该是链表头节点，且传入的这个ptr不能为空指针</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_first_enrty(ptr, type, member) \</span></span><br><span class="line"><span class="meta">    container_of((ptr)-&gt;next, type, member)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取链表上的最后一个节点，通过双向链表的prev指针来获取</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_last_entry(ptr, type, member) \</span></span><br><span class="line"><span class="meta">    container_of((ptr)-&gt;prev, type, member)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断当前给入的链表是否为空链表，不为空表返回下一个节点对应的结构体地址</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_first_enrty_or_null(ptr, type, member) (&#123; \</span></span><br><span class="line"><span class="meta">    struct list_head *head__ = (ptr); \</span></span><br><span class="line"><span class="meta">    struct list_head *pos__ = READ_ONCE(head__-&gt;next); \</span></span><br><span class="line"><span class="meta">    pos__ != head__ ? list_entry(pos__, type, member) : NULL; \</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* @pos:     含list_head结构体对象的指针</span></span><br><span class="line"><span class="comment">* @member:  list_head在这个结构体中的成员名</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 通过结构体对象的指针来获取链表中下一个节点的结构体对象地址</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_next_entry(pos, member) \</span></span><br><span class="line"><span class="meta">    list_entry((pos)-&gt;member.next, typeof(*(pos)), member)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过结构体对象的指针来获取链表中上一个节点的结构体对象地址</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_prev_entry(pos, member) \</span></span><br><span class="line"><span class="meta">    list_entry((pos)-&gt;member.prev, typeof(*(pos)), member)</span></span><br></pre></td></tr></table></figure>

<h5 id="list-head增加节点"><a href="#list-head增加节点" class="headerlink" title="list_head增加节点"></a><code>list_head</code>增加节点</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> __list_add(struct list_head *<span class="keyword">new</span>,</span><br><span class="line">                struct list_head *prev,</span><br><span class="line">                struct list_head *next)</span><br><span class="line">&#123;</span><br><span class="line">    next-&gt;prev = <span class="keyword">new</span>;</span><br><span class="line">    <span class="keyword">new</span>-&gt;next = next;</span><br><span class="line">    <span class="keyword">new</span>-&gt;prev = prev;</span><br><span class="line">    prev-&gt;next = <span class="keyword">new</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* new插入到head后 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">list_add</span><span class="params">(struct list_head *<span class="keyword">new</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                struct list_head *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __list_add(<span class="keyword">new</span>, head, head-&gt;next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* new插入到head之前 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">list_add_tail</span><span class="params">(struct list_head *<span class="keyword">new</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                struct list_node *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __list_add(<span class="keyword">new</span>, head-&gt;prev, head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="list-head删除节点"><a href="#list-head删除节点" class="headerlink" title="list_head删除节点"></a><code>list_head</code>删除节点</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Delete a list entry by making the prev/next entries</span></span><br><span class="line"><span class="comment"> * point to each other.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * This is only for internal list manipulation where we know</span></span><br><span class="line"><span class="comment"> * the prev/next entries already!</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> __list_del(struct list_head *prev, struct list_head *next)</span><br><span class="line">&#123;</span><br><span class="line">    next-&gt;prev = prev;</span><br><span class="line">    prev-&gt;next = next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除entry这个节点</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> __list_del_entry(struct list_head *entry)</span><br><span class="line">&#123;</span><br><span class="line">    __list_del(entry-&gt;prev, entry-&gt;next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// include/linux/poison.h</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * These are non-NULL pointers that will result in page faults</span></span><br><span class="line"><span class="comment"> * under normal circumstances, used to verify that nobody uses</span></span><br><span class="line"><span class="comment"> * non-initialized list entries.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIST_POISON1  ((void *) 0x100 + POISON_POINTER_DELTA)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIST_POISON2  ((void *) 0x122 + POISON_POINTER_DELTA)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * list_del - deletes entry from list.</span></span><br><span class="line"><span class="comment"> * @entry: the element to delete from the list.</span></span><br><span class="line"><span class="comment"> * Note: list_empty() on entry dose not return true after this, the entry</span></span><br><span class="line"><span class="comment"> * is in an undefined state.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 删除entry这个节点，并让其prev、next指向一个错误地址</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">list_del</span><span class="params">(struct list_head *entry)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __list_del_entry(entry);</span><br><span class="line">    entry-&gt;next = LIST_POISON1;</span><br><span class="line">    entry-&gt;prev = LIST_POISON2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="遍历list-head"><a href="#遍历list-head" class="headerlink" title="遍历list_head"></a>遍历<code>list_head</code></h5><p>通过<code>list_head</code>的头节点向后遍历整个链表</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @pos:    the &amp;struct list_head to use as a loop cursor</span></span><br><span class="line"><span class="comment"> * @head:   the head for your list</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_for_each(pos, head) \</span></span><br><span class="line"><span class="meta">    for (pos = (head)-&gt;next; pos != (head); pos = pos-&gt;next)</span></span><br></pre></td></tr></table></figure>

<p>通过<code>list_head</code>的头节点向前遍历整个链表</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_for_each_prev(pos, head) \</span></span><br><span class="line"><span class="meta">    for (pos = (head)-&gt;prev; pos != (head); pos = pos-&gt;prev)</span></span><br></pre></td></tr></table></figure>

<p>通过<code>list_head</code>的头节点向后遍历链表，这里使用<code>n</code>来存储<code>pos</code>指向的下一个节点的原因主要就是若：当前循环对<code>pos</code>进行了删除操作，因为<code>n</code>存储了下一个节点，那么可以保证遍历安全的进行下去</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @pos:    the &amp;struct list_head to use as a loop cursor</span></span><br><span class="line"><span class="comment"> * @n:      another &amp;struct list_head to use a temporary storage</span></span><br><span class="line"><span class="comment"> * @head:   the head for your list</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_for_each_safe(pos, n, head) \</span></span><br><span class="line"><span class="meta">    for (pos = (head)-&gt;next, n = pos-&gt;next; pos != head; \</span></span><br><span class="line"><span class="meta">        pos = n, n = pos-&gt;next)</span></span><br></pre></td></tr></table></figure>

<p>通过<code>list_head</code>的头节点向前遍历链表</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_for_each_prev_safe(pos, n, head) \</span></span><br><span class="line"><span class="meta">    for (pos = (head)-&gt;prev, n = pos-&gt;prev; pos != head; \</span></span><br><span class="line"><span class="meta">        pos = n, n = pos-&gt;prev)</span></span><br></pre></td></tr></table></figure>

<p>通过<code>list_head</code>指针来向后遍历链表上的所有结构体对象</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_for_each_entry(pos, head, member) \</span></span><br><span class="line"><span class="meta">    for (pos = list_first_entry((head), typeof(*pos), member); \</span></span><br><span class="line"><span class="meta">        &amp;pos-&gt;member != (head); \</span></span><br><span class="line"><span class="meta">        pos = list_next_entry(pos, member))</span></span><br></pre></td></tr></table></figure>

<p>通过<code>list_head</code>指针来向前遍历链表上的所有的结构体对象</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_for_each_entry_reverse(pos, head, member) \</span></span><br><span class="line"><span class="meta">    for (pos = list_last_entry((head), typeof(*pos), member); \</span></span><br><span class="line"><span class="meta">        &amp;pos-&gt;member != (head); \</span></span><br><span class="line"><span class="meta">        pos = list_prev_entry(pos, member))</span></span><br></pre></td></tr></table></figure>

<p>通过给定的结构体指针<code>pos</code>和链表头，<code>pos</code>不能为空，从下一个节点开始继续向后遍历链表</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_for_each_entry_continue(pos, head, member) \</span></span><br><span class="line"><span class="meta">    for (pos = list_next_entry(pos, member); \</span></span><br><span class="line"><span class="meta">        &amp;pos-&gt;member != (head); \</span></span><br><span class="line"><span class="meta">        pos = list_next_entry(pos, member))</span></span><br></pre></td></tr></table></figure>

<p>通过给定的结构体指针<code>pos</code>和链表头，<code>pos</code>不能为空，从上一个节点开始继续向前遍历链表</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_for_each_entry_continue_reverse(pos, head, member) \</span></span><br><span class="line"><span class="meta">    for (pos = list_prev_entry(pos, member); \</span></span><br><span class="line"><span class="meta">        &amp;pos-&gt;member != (head); \</span></span><br><span class="line"><span class="meta">        pos = list_prev_entry(pos, member))</span></span><br></pre></td></tr></table></figure>

<p>通过给定的结构体指针<code>pos</code>和链表头，<code>pos</code>不能为空，从当前节点开始继续向后遍历链表</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_for_each_entry_from(pos, head, member) \</span></span><br><span class="line"><span class="meta">    for (; &amp;pos-&gt;member != (head); \</span></span><br><span class="line"><span class="meta">        pos = list_next_entry(pos, member))</span></span><br></pre></td></tr></table></figure>

<p>通过给定的结构体指针<code>pos</code>和链表头，来安全的遍历链表，可以在循环中对当前遍历的结构体进行删除操作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* list_for_each_entry_safe - iterate over list of given type safe against removal of list entry</span></span><br><span class="line"><span class="comment">* @pos:	    the type * to use as a loop cursor.</span></span><br><span class="line"><span class="comment">* @n:		another type * to use as temporary storage</span></span><br><span class="line"><span class="comment">* @head:	the head for your list.</span></span><br><span class="line"><span class="comment">* @member:	the name of the list_head within the struct.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_for_each_entry_safe(pos, n, head, member)			\</span></span><br><span class="line"><span class="meta">    for (pos = list_first_entry(head, typeof(*pos), member),	\</span></span><br><span class="line"><span class="meta">        n = list_next_entry(pos, member);			\</span></span><br><span class="line"><span class="meta">        !list_entry_is_head(pos, head, member); 			\</span></span><br><span class="line"><span class="meta">        pos = n, n = list_next_entry(n, member))</span></span><br></pre></td></tr></table></figure>

<p><code>platform</code>总线初始化的时候<code>platform_bus_init()</code>会调用<code>early_platform_clean()</code>来清除<code>early_platform_device_list</code>链表上的节点，代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> __initdata <span class="title">LIST_HEAD</span><span class="params">(early_platform_device_list)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * early_platform_cleanup - clean up early platform code</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> __init <span class="title">early_platform_cleanup</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> *<span class="title">pd</span>, *<span class="title">pd2</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* clean up the devres list used to chain devices */</span></span><br><span class="line">    list_for_each_entry_safe(pd, pd2, &amp;early_platform_device_list,</span><br><span class="line">                dev.devres_head) &#123;</span><br><span class="line">        list_del(&amp;pd-&gt;dev.devres_head);</span><br><span class="line">        <span class="built_in">memset</span>(&amp;pd-&gt;dev.devres_head, <span class="number">0</span>, <span class="keyword">sizeof</span>(pd-&gt;dev.devres_head));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>采用这种遍历的方式可以安全的删除当前遍历的节点</p>
<h3 id="klist链表"><a href="#klist链表" class="headerlink" title="klist链表"></a>klist链表</h3><p>Linux内核提供了两个封装list_head的结构体，链表头klist和链表节点klist_node，klist是list的线程安全版本，在结构体中提供了自旋锁，对链表的操作进行锁保护，klist的链表节点数据结构klist_node使用了引用计数器，只有当节点的引用计数为0时，才允许该节点从klist链表中移除</p>
<h4 id="klist链表定义"><a href="#klist链表定义" class="headerlink" title="klist链表定义"></a>klist链表定义</h4><p>首先来看klist的定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/linux/klist.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">klist</span> &#123;</span></span><br><span class="line">    <span class="keyword">spinlock_t</span> k_lock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">k_list</span>;</span></span><br><span class="line">    <span class="keyword">void</span> (*get)(struct klist_node *);</span><br><span class="line">    <span class="keyword">void</span> (*put)(struct klist_node *);</span><br><span class="line">&#125; __attribute__ ((aligned (<span class="keyword">sizeof</span>(<span class="keyword">void</span> *))));</span><br></pre></td></tr></table></figure>
<ul>
<li>k_lock：链接节点操作的自旋锁</li>
<li>k_list：双向链表</li>
<li>get：用于对链表内的节点增加引用计数</li>
<li>put：用于对链表内的节点减少引用计数</li>
</ul>
<p>klist_node结构体定义如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">klist_node</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *n_klist;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">n_node</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kref</span> <span class="title">n_ref</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>n_klist：用来指向链表头</li>
<li>n_node：用来链接前后节点</li>
<li>n_ref：引用计数，实际就是一个int类型变量</li>
</ul>
<h4 id="klist初始化"><a href="#klist初始化" class="headerlink" title="klist初始化"></a>klist初始化</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//include/linux/klist.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KLIST_INIT(_name, _get, _put) \</span></span><br><span class="line"><span class="meta">    &#123; .k_lock = __SPIN_LOCK_UNLOCKED(_name.k_lock), \</span></span><br><span class="line"><span class="meta">      .k_list = LIST_HEAD_INIT(_name.k_list), \</span></span><br><span class="line"><span class="meta">      .get = _get, \</span></span><br><span class="line"><span class="meta">      .put = _put, &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFINE_KLIST(_name, _get, _put) \</span></span><br><span class="line"><span class="meta">    struct klist _name = KLIST_INIT(_name, _get, _put)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">klist_init</span><span class="params">(struct klist *k, <span class="keyword">void</span> (*get)(struct klist_node *),</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">void</span> (*put)(struct klist_node *))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    INIT_LIST_HEAD(&amp;k-&gt;k_list);</span><br><span class="line">    spin_lock_init(&amp;k-&gt;k_lock);</span><br><span class="line">    k-&gt;get = get;</span><br><span class="line">    k-&gt;put = put;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>klist_node初始化</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lib/klist.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">klist_node_init</span><span class="params">(struct klist *k, struct klist_node *n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    INIT_LIST_HEAD(&amp;n-&gt;n_node);</span><br><span class="line">    <span class="comment">// klist_node引用计数加1</span></span><br><span class="line">    kref_init(&amp;n-&gt;n_ref);</span><br><span class="line">    <span class="comment">// 将n_klist指向klist，即指向头节点</span></span><br><span class="line">    knode_set_klist(n, k);</span><br><span class="line">    <span class="keyword">if</span> (k-&gt;get)</span><br><span class="line">        k-&gt;get(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="klist操作接口"><a href="#klist操作接口" class="headerlink" title="klist操作接口"></a>klist操作接口</h4><h5 id="klist增加节点"><a href="#klist增加节点" class="headerlink" title="klist增加节点"></a>klist增加节点</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将新节点n初始化并添加节点到链表尾部</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">klist_add_tail</span><span class="params">(struct klist_node *n, struct klist *k)</span></span>;</span><br><span class="line"><span class="comment">// 将新节点n初始化并添加节点到链表头部</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">klist_add_head</span><span class="params">(struct klist_node *n, struct klist *k)</span></span>;</span><br><span class="line"><span class="comment">// 将新节点n初始化并将节点插到pos节点后</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">klist_add_behind</span><span class="params">(struct klist_node *n, struct klist_node *pos)</span></span>;</span><br><span class="line"><span class="comment">// 将新节点n初始化并将节点插到pos节点前</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">klist_add_before</span><span class="params">(struct klist_node *n, struct klist_node *pos)</span></span>;</span><br></pre></td></tr></table></figure>
<h5 id="klist删除节点"><a href="#klist删除节点" class="headerlink" title="klist删除节点"></a>klist删除节点</h5><p>在链表节点klist_node中，引入了一个引用计数器，使用kref实现了节点的动态删除，当引用计数器为0时，就会调用<code>klist_release()</code>函数将节点进行脱离，之前有线程申请删除某节点，但节点的引用计数仍在，所以只能把请求删除的线程阻塞，在klist_release()调用时还要将阻塞的线程唤醒</p>
<p>klist_remove()会调用klist_del()减少引用计数，还会一直阻塞到节点被删除，若某个线程需要删除某个节点，需要调用这个klist_remove()接口</p>
<p>klist_del接口</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">klist_waiter</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span>          <span class="comment">// 将等待删除的节点链起来</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">klist_node</span> *<span class="title">node</span>;</span>        <span class="comment">// 当前等待删除的节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">process</span>;</span>    <span class="comment">// 进程或者线程指针</span></span><br><span class="line">    <span class="keyword">int</span> woken;                      <span class="comment">// 进程唤醒标记</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">DEFINE_SPINLOCK</span><span class="params">(klist_remove_lock)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">LIST_HEAD</span><span class="params">(klist_remove_waiters)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用klist_node最低位标记该节点是否被删除</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KNODE_DEAD          1LU</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KNODE_KLIST_MASK    ~KNODE_DEAD</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 取得klist node对应的klist头节点</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct klist *<span class="title">knode_klist</span><span class="params">(struct klist_node *knode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// n_klist是指向链表头的，可以通过它查找klist</span></span><br><span class="line">    <span class="comment">// 这里最低位默认是置零的</span></span><br><span class="line">    <span class="keyword">return</span> (struct klist *)</span><br><span class="line">        ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)knode-&gt;n_klist &amp; KNODE_KLIST_MASK);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计数为0时调用klist_release</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">klist_release</span><span class="params">(struct kref *kref)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">klist_waiter</span> *<span class="title">waiter</span>, *<span class="title">tmp</span>;</span></span><br><span class="line">    <span class="comment">// 通过kref获取klist_node指针</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">klist_node</span> *<span class="title">n</span> =</span> container_of(kref, struct klist_node, n_ref);</span><br><span class="line"></span><br><span class="line">	WARN_ON(!knode_dead(n));</span><br><span class="line">    <span class="comment">// 删除该节点</span></span><br><span class="line">	list_del(&amp;n-&gt;n_node);</span><br><span class="line">	spin_lock(&amp;n_lock);</span><br><span class="line">    <span class="comment">// 通过klist_remove_waiters链表头遍历整个remove链表</span></span><br><span class="line">	list_for_each_entry_safe(waiter, tmp, &amp;klist_remove_waiters, <span class="built_in">list</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (waiter-&gt;node != n)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 删除该klist节点对应的remove waiter节点</span></span><br><span class="line">		list_del(&amp;waiter-&gt;<span class="built_in">list</span>);</span><br><span class="line">		waiter-&gt;woken = <span class="number">1</span>;</span><br><span class="line">		mb();</span><br><span class="line">		wake_up_process(waiter-&gt;process);</span><br><span class="line">	&#125;</span><br><span class="line">	spin_unlock(&amp;klist_remove_lock);</span><br><span class="line">	knode_set_klist(n, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">klist_dec_and_del</span><span class="params">(struct klist_node *n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// klist节点引用计数减1，当引用计数到0时调用klist_release</span></span><br><span class="line">    <span class="keyword">return</span> kref_put(&amp;n-&gt;nref, klist_release);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">klist_put</span><span class="params">(struct klist_node *n, <span class="keyword">bool</span> kill)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 取得链表头</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">klist</span> *<span class="title">k</span> =</span> knode_klist(n);</span><br><span class="line">    <span class="keyword">void</span> (*put)(struct klist_node *) = k-&gt;put;</span><br><span class="line"></span><br><span class="line">    spin_lock(&amp;k-&gt;k_lock);</span><br><span class="line">    <span class="comment">// 将klist_node的n_klist标记为dead</span></span><br><span class="line">    <span class="keyword">if</span> (kill)</span><br><span class="line">        knode_kill(n);</span><br><span class="line">    <span class="keyword">if</span> (!klist_dev_and_del(n))</span><br><span class="line">        put = <span class="literal">NULL</span>;</span><br><span class="line">    spin_unlock(&amp;k-&gt;k_lock);</span><br><span class="line">    <span class="keyword">if</span> (put)</span><br><span class="line">        put(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">klist_del</span><span class="params">(struct klist_node *n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    klist_put(n, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>klist中引入dead标识的原因：当一个线程要让某个klist_node无效时，不能简单地从klist中删除，因为有可能还有其它线程还在使用这个节点，因此只能减少klist_node的引用计数，节点还在klist中，遍历的时候将对这个节点dead标识进行判断，避开这些申请删除的节点，当其它线程不引用该节点后，引用计数为0，该节点会自动从klist链表中移除</p>
</blockquote>
<p>klist_remove()接口</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">klist_remove</span><span class="params">(struct klist_node *n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">klist_waiter</span> <span class="title">waiter</span>;</span></span><br><span class="line">    </span><br><span class="line">    waiter.node = n;</span><br><span class="line">    waiter.process = current;</span><br><span class="line">    waiter.woken = <span class="number">0</span>;</span><br><span class="line">    spin_lock(&amp;klist_remove_lock);</span><br><span class="line">    list_add(&amp;waiter.<span class="built_in">list</span>, &amp;klist_remove_waiters);</span><br><span class="line">    spin_unlock(&amp;klist_remove_lock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 减少引用计数，如果当前节点的引用计数为1会直接删除该节点</span></span><br><span class="line">    klist_del(n);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 引用计数减少后还没到0，会阻塞当前进程</span></span><br><span class="line">    <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">        set_current_state(TASK_UNINTERRUPTIBLE);</span><br><span class="line">        <span class="keyword">if</span> (waiter.woken)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        schedule();</span><br><span class="line">    &#125;</span><br><span class="line">    __set_current_state(TASK_RUNNING);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="遍历klist"><a href="#遍历klist" class="headerlink" title="遍历klist"></a>遍历klist</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">klist_iter</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">klist</span> *<span class="title">i_klist</span>;</span>      <span class="comment">// 当前遍历的klist链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">klist_node</span> *<span class="title">i_cur</span>;</span>   <span class="comment">// 当前遍历的节点</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>迭代器初始化</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从链表头开始遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">klist_iter_init</span><span class="params">(struct klist *k, struct klist_iter *i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    klist_iter_init_node(k, i, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 若n不为空，则从节点n进行遍历，从节点n初始化迭代器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">klist_iter_init_node</span><span class="params">(struct klist *k, struct klist_iter *i,</span></span></span><br><span class="line"><span class="params"><span class="function">                    struct klist_node *n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    i-&gt;i_klist = k;</span><br><span class="line">    i-&gt;i_cur = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 若节点不为空需要对该节点增加引用计数</span></span><br><span class="line">    <span class="keyword">if</span> (n &amp;&amp; kref_get_unless_zero(&amp;n-&gt;n_ref))</span><br><span class="line">        i-&gt;i_cur = n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">klist_iter_exit</span><span class="params">(struct klist_iter *i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i-&gt;i_cur) &#123;</span><br><span class="line">        klist_put(i-&gt;i_cur, <span class="literal">false</span>);</span><br><span class="line">        i-&gt;i_cur = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>klist向前遍历</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct klist_node *<span class="title">to_klist_node</span><span class="params">(struct list_head *n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> container_of(n, struct klist_node, n_node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">struct klist_node *<span class="title">klist_prev</span><span class="params">(struct klist_iter *i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> (*put)(struct klist_node *) = i-&gt;i_klist-&gt;put;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">klist_node</span> *<span class="title">last</span> =</span> i-&gt;i_cur;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">klist_node</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"></span><br><span class="line">    spin_lock_irqsave(&amp;i-&gt;i_klist-&gt;k_lock, flags);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 假如是从链表头进行遍历</span></span><br><span class="line">    <span class="keyword">if</span> (last) &#123;</span><br><span class="line">        prev = to_klist_node(last-&gt;node.prev);</span><br><span class="line">        <span class="comment">// 对之前节点的引用计数进行减一操作</span></span><br><span class="line">        <span class="keyword">if</span> (!klist_dec_and_del(last))</span><br><span class="line">            put = <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        prev = to_klist_node(i-&gt;i_klist-&gt;k_list.prev);</span><br><span class="line"></span><br><span class="line">    i-&gt;i_cur = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 往前找一个非dead节点</span></span><br><span class="line">    <span class="keyword">while</span> (prev != to_klist_node(&amp;i-&gt;i_klist-&gt;k_list)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (likely(!knode_dead(prev))) &#123;</span><br><span class="line">            <span class="comment">// 找到了节点，增加它的引用计数</span></span><br><span class="line">            kref_get(&amp;prev-&gt;n_ref);</span><br><span class="line">            i-&gt;i_cur = prev;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        prev = to_klist_node(prev-&gt;n_node.prev);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    spin_unlock_irqrestore(&amp;i-&gt;i_klist-&gt;k_lock, flags);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (put &amp;&amp; last)</span><br><span class="line">        put(last);</span><br><span class="line">    <span class="keyword">return</span> i-&gt;i_cur;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>klist向后遍历</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">struct klist_node *<span class="title">klist_next</span><span class="params">(struct klist_iter *i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> (*put)(struct klist_node *) = i-&gt;i_klist-&gt;put;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">klist_node</span> *<span class="title">last</span> =</span> i-&gt;i_cur;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">klist_node</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"></span><br><span class="line">    spin_lock_irqsave(&amp;i-&gt;i_klist-&gt;k_lock, flags);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (last) &#123;</span><br><span class="line">        next = to_klist_node(last-&gt;node.next);</span><br><span class="line">        <span class="keyword">if</span> (!klist_dec_and_del(last))</span><br><span class="line">            put = <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        next = to_klist_node(i-&gt;i_klist-&gt;k_list.next);</span><br><span class="line"></span><br><span class="line">    i-&gt;i_cur = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (next != to_klist_node(&amp;i-&gt;i_klist-&gt;klist)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (likely(!knode_dead(next))) &#123;</span><br><span class="line">            kref_get(&amp;next-&gt;n_ref);</span><br><span class="line">            i-&gt;i_cur = next;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    spin_unlock_irqrestore(&amp;i-&gt;klist-&gt;k_lock, flags);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (put &amp;&amp; last)</span><br><span class="line">        put(last);</span><br><span class="line">    <span class="keyword">return</span> i-&gt;i_cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>List</tag>
      </tags>
  </entry>
  <entry>
    <title>Platform设备驱动模型</title>
    <url>/archives/f8def83d.html</url>
    <content><![CDATA[<h4 id="Platform平台驱动模型"><a href="#Platform平台驱动模型" class="headerlink" title="Platform平台驱动模型"></a>Platform平台驱动模型</h4><p>Linux内核在2.6版本引入设备驱动模型，简化了驱动程序的编写，Linux设备驱动模型包含<strong>设备（device）、总线（bus）、类（class）和驱动（driver）</strong>，其中<strong>设备</strong>和<strong>驱动</strong>通过<strong>总线</strong>绑定在一起，由于某些外设是没有总线这个概念的，但是又要使用总线、驱动和设备模型的话，就需要使用<code>platform</code>这个虚拟总线，相应的就有<code>platform_device</code>和<code>platform_driver</code></p>
<span id="more"></span>

<p>Linux内核中，分别用<code>bus_type</code>、<code>device_driver</code>和<code>device</code>结构体来描述总线、驱动和设备，结构体定义在<code>include/linux/device.h</code>，设备和对应的驱动必须依附于同一种总线，因此<code>device_driver</code>和<code>device</code>结构体中都包含<code>bus_type</code>指针</p>
<h4 id="Platform总线"><a href="#Platform总线" class="headerlink" title="Platform总线"></a>Platform总线</h4><p>Linux内核使用<code>bus_type</code>结构体表示总线，该结构体定义在<code>include/linux/device/bus.h</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/linux/device/bus.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>		*name;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>		*dev_name;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span>		*<span class="title">dev_root</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> **<span class="title">bus_groups</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> **<span class="title">dev_groups</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> **<span class="title">drv_groups</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> (*match)(struct device *dev, struct device_driver *drv);</span><br><span class="line">    <span class="keyword">int</span> (*uevent)(struct device *dev, struct kobj_uevent_env *env);</span><br><span class="line">    <span class="keyword">int</span> (*probe)(struct device *dev);</span><br><span class="line">    <span class="keyword">int</span> (*remove)(struct device *dev);</span><br><span class="line">    <span class="keyword">void</span> (*shutdown)(struct device *dev);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> (*online)(struct device *dev);</span><br><span class="line">    <span class="keyword">int</span> (*offline)(struct device *dev);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> (*suspend)(struct device *dev, <span class="keyword">pm_message_t</span> state);</span><br><span class="line">    <span class="keyword">int</span> (*resume)(struct device *dev);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> (*num_vf)(struct device *dev);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> (*dma_configure)(struct device *dev);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dev_pm_ops</span> *<span class="title">pm</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">iommu_ops</span> *<span class="title">iommu_ops</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">subsys_private</span> *<span class="title">p</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">lock_key</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> need_parent_lock;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>设备和驱动的匹配函数：<br><code>int (*match)(struct device *dev, struct device_driver*drv)</code><br>match函数有两个参数dev和driver，这两个参数分别为<code>device</code>和<code>device_driver</code>类型，也就是设备和驱动</p>
<p>platform总线是<code>bus_type</code>的一个具体实例，定义在<code>driver/base/platform.c</code>中，同时也定义了设备<code>platform_bus</code>，用来管理所有挂载在platform总线下的设备，定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// driver/base/platform.c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> <span class="title">platform_bus_type</span> =</span> &#123;</span><br><span class="line">    .name		= <span class="string">&quot;platform&quot;</span>,</span><br><span class="line">    .dev_groups	= platform_dev_groups,</span><br><span class="line">    .match		= platform_match,</span><br><span class="line">    .uevent		= platform_uevent,</span><br><span class="line">    .dma_configure	= platform_dma_configure,</span><br><span class="line">    .pm		= &amp;platform_dev_pm_ops,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> <span class="title">platform_bus</span> =</span> &#123;</span><br><span class="line">    .init_name = <span class="string">&quot;platform&quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="Platform总线初始化过程"><a href="#Platform总线初始化过程" class="headerlink" title="Platform总线初始化过程"></a>Platform总线初始化过程</h5><p>内核在初始化过程中调用<code>platform_bus_init()</code>来初始化Platform总线，调用流程如下<br><code>kernel_init_freeable() -&gt; do_basic_setup() -&gt; driver_init() -&gt; platform_bus_init()</code><br>其中<code>platform_bus_init()</code>函数定义在<code>drivers/base/platform.c</code>中，内容如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// drivers/base/platform.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> __init <span class="title">platform_bus_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line"></span><br><span class="line">    early_platform_cleanup();</span><br><span class="line"></span><br><span class="line">    error = device_register(&amp;platform_bus);</span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        put_device(&amp;platform_bus);</span><br><span class="line">        <span class="keyword">return</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">    error = bus_register(&amp;platform_bus_type);</span><br><span class="line">    <span class="keyword">if</span> (error)</span><br><span class="line">        device_unregister(&amp;platform_bus);</span><br><span class="line">    of_platform_register_reconfig_notifier();</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先来看<code>early_platform_cleanup()</code>这个函数，位于<code>arch/sh/drivers/platform_early.c</code>中，这个函数主要的功能就是清除所有和early device&#x2F;driver相关的代码，执行到这里的时候，证明系统已经完成了early阶段的启动，转而进行正常的设备初始化、启动操作，所以不再需要early platform相关的东西</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/linux/init.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __initdata __section(<span class="meta-string">&quot;.init.data&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> _initdata <span class="title">LIST_HEAD</span><span class="params">(sh_early_platform_device_list)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * early_platform_cleanup - clean up early platform code</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> __init <span class="title">early_platform_cleanup</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> *<span class="title">pd</span>, *<span class="title">pd2</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* clean up the devres list used to chain devices */</span></span><br><span class="line">    list_for_each_entry_safe(pd, pd2, &amp;sh_early_platform_device_list,</span><br><span class="line">                        dev.devres_head) &#123;</span><br><span class="line">        list_del(&amp;pd-&gt;dev.devres_head);</span><br><span class="line">        <span class="built_in">memset</span>(&amp;pd-&gt;dev.devres_head, <span class="number">0</span>, <span class="keyword">sizeof</span>(pd-&gt;dev.devres_head));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着来看<code>device_register(&amp;platform_bus)</code>，将<code>platform_bus</code>设备注册到驱动模型中，该步骤会在sysfs中创建<code>/sys/device/platform/</code>目录，所有的platform设备都会包含在此目录下，所有的platform设备都会包含在此目录下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// drivers/base/core.c</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * device_register - register a device with the system.</span></span><br><span class="line"><span class="comment"> * @dev: pointer to the device structure</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This happens in two clean steps - initialize the device</span></span><br><span class="line"><span class="comment"> * and add it to the system. The two steps can be called</span></span><br><span class="line"><span class="comment"> * separately, but this is the easiest and most common.</span></span><br><span class="line"><span class="comment"> * I.e. you should only call the two helpers separately if</span></span><br><span class="line"><span class="comment"> * have a clearly defined need to use and refcount the device</span></span><br><span class="line"><span class="comment"> * before it is added to the hierarchy.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * For more information, see the kerneldoc for device_initialize()</span></span><br><span class="line"><span class="comment"> * and device_add().</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">NOTE:</span> _Never_ directly free @dev after calling this function, even</span></span><br><span class="line"><span class="comment"> * if it returned an error! Always use put_device() to give up the</span></span><br><span class="line"><span class="comment"> * reference initialized in this function instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">device_register</span><span class="params">(struct device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    device_initialize(dev);</span><br><span class="line">    <span class="keyword">return</span> device_add(dev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后是<code>bus_register(&amp;platform_bus_type);</code>，将<code>platform</code>总线注册到Linux的总线系统中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// drivers/base/base.h</span></span><br><span class="line"><span class="comment">// 子系统私有数据的数据结构定义</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct subsys_private - structure to hold the private to the driver core portions of the bus_type/class structure.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @subsys - the struct kset that defines this subsystem</span></span><br><span class="line"><span class="comment"> * @devices_kset - the subsystem&#x27;s &#x27;devices&#x27; directory</span></span><br><span class="line"><span class="comment"> * @interfaces - list of subsystem interfaces associated</span></span><br><span class="line"><span class="comment"> * @mutex - protect the devices, and interfaces lists.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @drivers_kset - the list of drivers associated</span></span><br><span class="line"><span class="comment"> * @klist_devices - the klist to iterate over the @devices_kset</span></span><br><span class="line"><span class="comment"> * @klist_drivers - the klist to iterate over the @drivers_kset</span></span><br><span class="line"><span class="comment"> * @bus_notifier - the bus notifier list for anything that cares about things</span></span><br><span class="line"><span class="comment"> *                 on this bus.</span></span><br><span class="line"><span class="comment"> * @bus - pointer back to the struct bus_type that this structure is associated</span></span><br><span class="line"><span class="comment"> *        with.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @glue_dirs - &quot;glue&quot; directory to put in-between the parent device to</span></span><br><span class="line"><span class="comment"> *              avoid namespace conflicts</span></span><br><span class="line"><span class="comment"> * @class - pointer back to the struct class that this structure is associated</span></span><br><span class="line"><span class="comment"> *          with.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This structure is the one that is the actual kobject allowing struct</span></span><br><span class="line"><span class="comment"> * bus_type/class to be statically allocated safely.  Nothing outside of the</span></span><br><span class="line"><span class="comment"> * driver core should ever touch these fields.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">subsys_private</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kset</span> <span class="title">subsys</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kset</span> *<span class="title">devices_kset</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">interfaces</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">mutex</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kset</span> *<span class="title">drivers_kset</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">klist</span> <span class="title">klist_devices</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">klist</span> <span class="title">klist_drivers</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">blocking_notifier_head</span> <span class="title">bus_notifier</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> drivers_autoprobe:<span class="number">1</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> *<span class="title">bus</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kset</span> <span class="title">glue_dirs</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * bus_register - register a driver-core subsystem</span></span><br><span class="line"><span class="comment"> * @bus: bus to register</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Once we have that, we register the bus with the kobject</span></span><br><span class="line"><span class="comment"> * infrastructure, then register the children subsystems it has:</span></span><br><span class="line"><span class="comment"> * the devices and drivers that belong to the subsystem.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bus_register</span><span class="params">(struct bus_type *bus)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> retval;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">subsys_private</span> *<span class="title">priv</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> *<span class="title">key</span> =</span> &amp;bus-&gt;lock_key;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化bus的私有数据</span></span><br><span class="line">	priv = kzalloc(<span class="keyword">sizeof</span>(struct subsys_private), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!priv)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	priv-&gt;bus = bus;</span><br><span class="line">	bus-&gt;p = priv;</span><br><span class="line"></span><br><span class="line">	BLOCKING_INIT_NOTIFIER_HEAD(&amp;priv-&gt;bus_notifier);</span><br><span class="line"></span><br><span class="line">	retval = kobject_set_name(&amp;priv-&gt;subsys.kobj, <span class="string">&quot;%s&quot;</span>, bus-&gt;name);</span><br><span class="line">	<span class="keyword">if</span> (retval)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	priv-&gt;subsys.kobj.kset = bus_kset;</span><br><span class="line">	priv-&gt;subsys.kobj.ktype = &amp;bus_ktype;</span><br><span class="line">	priv-&gt;drivers_autoprobe = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	retval = kset_register(&amp;priv-&gt;subsys);</span><br><span class="line">	<span class="keyword">if</span> (retval)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	retval = bus_create_file(bus, &amp;bus_attr_uevent);</span><br><span class="line">	<span class="keyword">if</span> (retval)</span><br><span class="line">		<span class="keyword">goto</span> bus_uevent_fail;</span><br><span class="line"></span><br><span class="line">	priv-&gt;devices_kset = kset_create_and_add(<span class="string">&quot;devices&quot;</span>, <span class="literal">NULL</span>,</span><br><span class="line">						 &amp;priv-&gt;subsys.kobj);</span><br><span class="line">	<span class="keyword">if</span> (!priv-&gt;devices_kset) &#123;</span><br><span class="line">		retval = -ENOMEM;</span><br><span class="line">		<span class="keyword">goto</span> bus_devices_fail;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	priv-&gt;drivers_kset = kset_create_and_add(<span class="string">&quot;drivers&quot;</span>, <span class="literal">NULL</span>,</span><br><span class="line">						 &amp;priv-&gt;subsys.kobj);</span><br><span class="line">	<span class="keyword">if</span> (!priv-&gt;drivers_kset) &#123;</span><br><span class="line">		retval = -ENOMEM;</span><br><span class="line">		<span class="keyword">goto</span> bus_drivers_fail;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	INIT_LIST_HEAD(&amp;priv-&gt;interfaces);</span><br><span class="line">	__mutex_init(&amp;priv-&gt;mutex, <span class="string">&quot;subsys mutex&quot;</span>, key);</span><br><span class="line">	klist_init(&amp;priv-&gt;klist_devices, klist_devices_get, klist_devices_put);</span><br><span class="line">	klist_init(&amp;priv-&gt;klist_drivers, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	retval = add_probe_files(bus);</span><br><span class="line">	<span class="keyword">if</span> (retval)</span><br><span class="line">		<span class="keyword">goto</span> bus_probe_files_fail;</span><br><span class="line"></span><br><span class="line">	retval = bus_add_groups(bus, bus-&gt;bus_groups);</span><br><span class="line">	<span class="keyword">if</span> (retval)</span><br><span class="line">		<span class="keyword">goto</span> bus_groups_fail;</span><br><span class="line"></span><br><span class="line">	pr_debug(<span class="string">&quot;bus: &#x27;%s&#x27;: registered\n&quot;</span>, bus-&gt;name);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">bus_groups_fail:</span><br><span class="line">	remove_probe_files(bus);</span><br><span class="line">bus_probe_files_fail:</span><br><span class="line">	kset_unregister(bus-&gt;p-&gt;drivers_kset);</span><br><span class="line">bus_drivers_fail:</span><br><span class="line">	kset_unregister(bus-&gt;p-&gt;devices_kset);</span><br><span class="line">bus_devices_fail:</span><br><span class="line">	bus_remove_file(bus, &amp;bus_attr_uevent);</span><br><span class="line">bus_uevent_fail:</span><br><span class="line">	kset_unregister(&amp;bus-&gt;p-&gt;subsys);</span><br><span class="line">out:</span><br><span class="line">	kfree(bus-&gt;p);</span><br><span class="line">	bus-&gt;p = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(bus_register);</span><br></pre></td></tr></table></figure>

<h4 id="Platform驱动"><a href="#Platform驱动" class="headerlink" title="Platform驱动"></a>Platform驱动</h4><p><code>platform_driver</code>结构体表示<code>platform</code>驱动，定义在<code>include/linux/platform.h</code>里面</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> (*probe)(struct platform_device *);</span><br><span class="line">    <span class="keyword">int</span> (*remove)(struct platform_device *);</span><br><span class="line">    <span class="keyword">void</span> (*shutdown)(struct platform_device *);</span><br><span class="line">    <span class="keyword">int</span> (*suspend)(struct platform_device *, <span class="keyword">pm_message_t</span> state);</span><br><span class="line">    <span class="keyword">int</span> (*resume)(struct platform_device *);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_driver</span> <span class="title">driver</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_device_id</span> *<span class="title">id_table</span>;</span></span><br><span class="line">    <span class="keyword">bool</span> prevent_deferred_probe;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当驱动和设备匹配成功后<code>platform_driver</code>的<code>probe</code>函数就会执行，<code>driver</code>成员为<code>device_driver</code>结构体变量，<code>device_driver</code>相当于基类，提供了最基础的驱动框架，<code>platform_driver</code>相当于继承了这个基类，在这个基类基础上添加了一些特有的成员变量</p>
<p><code>device_driver</code>结构体定义在*<code>include/linux/device.h</code>，内容如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_driver</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>		*name;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span>		*<span class="title">bus</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span>		*<span class="title">owner</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>		*mod_name;	<span class="comment">/* used for built-in modules */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> suppress_bind_attrs;	<span class="comment">/* disables bind/unbind via sysfs */</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">probe_type</span> <span class="title">probe_type</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span>	*<span class="title">of_match_table</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">acpi_device_id</span>	*<span class="title">acpi_match_table</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> (*probe) (struct device *dev);</span><br><span class="line">    <span class="keyword">int</span> (*remove) (struct device *dev);</span><br><span class="line">    <span class="keyword">void</span> (*shutdown) (struct device *dev);</span><br><span class="line">    <span class="keyword">int</span> (*suspend) (struct device *dev, <span class="keyword">pm_message_t</span> state);</span><br><span class="line">    <span class="keyword">int</span> (*resume) (struct device *dev);</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> **<span class="title">groups</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dev_pm_ops</span> *<span class="title">pm</span>;</span></span><br><span class="line">    <span class="keyword">void</span> (*coredump) (struct device *dev);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">driver_private</span> *<span class="title">p</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在编写<code>platform</code>驱动的时候，首先需要定义一个<code>platform_driver</code>结构体变量，实现结构体中的成员变量，重点是实现匹配方法和<code>probe</code>函数，具体的驱动程序在<code>probe</code>里面编写</p>
<p>定义好<code>platform_driver</code>结构体变量以后，需要在驱动入口函数里面调用<code>platform_driver_register()</code>函数向内核注册一个platform驱动，<code>platform_driver_register()</code>函数的原型如下：<br><code>int platform_driver_register(struct platform_driver *driver)</code></p>
<p>还需要在驱动卸载函数中通过<code>platform_driver_unregister()</code>来卸载platform驱动，函数原型如下：<br><code>int platform_driver_unregister(struct platform_driver *driver)</code></p>
<h4 id="Platform设备"><a href="#Platform设备" class="headerlink" title="Platform设备"></a>Platform设备</h4><p><code>platform_device</code>结构体表示<code>platfrom</code>设备，如果内核支持设备树的话，就不需要使用<code>platform_device</code>来描述设备，改用设备树来描述，<code>platform_device</code>结构体定义在<em>include&#x2F;linux&#x2F;platform_device.h</em>中，结构体的内容如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>	*name;</span><br><span class="line">    <span class="keyword">int</span>		id;</span><br><span class="line">    <span class="keyword">bool</span>		id_auto;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span>	<span class="title">dev</span>;</span></span><br><span class="line">    u32		num_resources;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">resource</span>	*<span class="title">resource</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_device_id</span>	*<span class="title">id_entry</span>;</span></span><br><span class="line">    <span class="keyword">char</span> *driver_override; <span class="comment">/* Driver name to force a match */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* MFD cell pointer */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mfd_cell</span> *<span class="title">mfd_cell</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* arch specific additions */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pdev_archdata</span>	<span class="title">archdata</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>name</code>表示设备的名字，要和所使用的<code>platform_driver</code>的<code>name</code>字段相同，否则设备无法匹配到对应的驱动</li>
<li><code>resource</code>表示资源，一般用来表示设备的寄存器信息，结构体内容如下  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">resource</span> &#123;</span></span><br><span class="line">    <span class="keyword">resource_size_t</span> start;</span><br><span class="line">    <span class="keyword">resource_size_t</span> end;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> desc;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">parent</span>, *<span class="title">sibling</span>, *<span class="title">child</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
  <code>start</code>和<code>end</code>分别表示资源的起始和终止信息，对于内存类资源就表示内存起始和终止地址，<code>name</code>表示资源名称，<code>flag</code>表示资源类型</li>
</ul>
<p>Linux支持设备树之后就不需要用户去手动注册<code>platform</code>设备了，因为设备信息都放到设备树中去描述，Linux内核启动的时候会从设备树中读取设备信息，然后将其组织成<code>platform_device</code>形式</p>
<h4 id="Platform驱动匹配过程"><a href="#Platform驱动匹配过程" class="headerlink" title="Platform驱动匹配过程"></a>Platform驱动匹配过程</h4><p>这里使用phytium i2c适配器驱动分析，驱动文件位于<code>drivers/i2c/busses/i2c-phytium-platform.c</code>，在<code>module_platform_driver(phytium_i2c_driver)</code>进行<code>platform_drvier</code>的注册，<code>module_platform_driver</code>是一个宏定义，该宏定义定义在<code>include/linux/platform_device.h</code>其内容如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> module_platform_driver(__platform_drvier) module_driver(__platform_drvier, platform_drvier_register, platform_drvier_unregister)</span></span><br></pre></td></tr></table></figure>
<p>继续对<em>module_driver</em>宏进行展开，其内容如下：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> module_driver(__driver, __register, __unregister, ...) \</span></span><br><span class="line"><span class="meta">static int __init __driver##_init(void) \</span></span><br><span class="line"><span class="meta">&#123; \</span></span><br><span class="line"><span class="meta">    return __register(&amp;(__driver) , ##__VA_ARGS__); \</span></span><br><span class="line"><span class="meta">&#125; \</span></span><br><span class="line"><span class="meta">module_init(__driver##_init); \</span></span><br><span class="line"><span class="meta">static void __exit __driver##_exit(void) \</span></span><br><span class="line"><span class="meta">&#123; \</span></span><br><span class="line"><span class="meta">    __unregister(&amp;(__driver) , ##__VA_ARGS__); \</span></span><br><span class="line"><span class="meta">&#125; \</span></span><br><span class="line"><span class="meta">module_exit(__driver##_exit);</span></span><br></pre></td></tr></table></figure>
<p>最终展开后的内容相当于：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">phytium_i2c_driver_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> platform_driver_register(&amp;(phytium_i2c_driver));</span><br><span class="line">&#125;</span><br><span class="line">module_init(phytium_i2c_driver_init);</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __exit <span class="title">phytium_i2c_driver_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> platform_driver_unregister(&amp;(phytium_i2c_driver));</span><br><span class="line">&#125;</span><br><span class="line">moudle_exit(phytium_i2c_driver_exit);</span><br></pre></td></tr></table></figure>

<p>在<code>moudle_init</code>中调用了<code>platform_drvier_register(&amp;phytium_i2c_driver)</code>，<code>platform_driver_regsiter</code>又是一个宏定义，定义在<code>include/linux/platform_device.h</code>中，其内容如下：<br><code>#define platform_driver_regsiter(drv) __platform_drvier_register(drv, THIS_MODULE)</code><br>其中<code>__platform_drvier_register()</code>函数的定义如下：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// drivers/base/platform.c</span></span><br><span class="line"><span class="keyword">int</span> __platform_drvier_register(struct platform_driver *drv, struct <span class="keyword">module</span> *owner)`</span><br><span class="line">&#123;</span><br><span class="line">    drv-&gt;driver.owner = owner;</span><br><span class="line">    <span class="comment">// bus_type指向platform_bus_type</span></span><br><span class="line">    drv-&gt;driver.bus = &amp;platform_bus_type;</span><br><span class="line">    drv-&gt;driver.probe = platform_drv_porbe;</span><br><span class="line">    drv-&gt;driver.remove = platform_drv_remove;</span><br><span class="line">    drv-&gt;driver.shutdown = platform_drv_shutdown;</span><br><span class="line">    <span class="comment">// 继续调用device_driver注册设备驱动</span></span><br><span class="line">    <span class="keyword">return</span> driver_register(&amp;drv-&gt;driver);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>driver</code>成员的类型为之前提到的<code>device_driver</code>结构体，<code>driver-&gt;bus</code>指向了<code>platform_bus_type</code></p>
<p>继续来看<code>driver_register(&amp;drv-&gt;driver)</code>，该函数位于<code>drivers/base/driver.c</code>中，其内容如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// drivers/base/driver.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">driver_register</span><span class="params">(struct device_driver *drv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_driver</span> *<span class="title">other</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!drv-&gt;bus-&gt;p) &#123;</span><br><span class="line">        pr_err(<span class="string">&quot;Driver &#x27;%s&#x27; was unable to register with bus_type &#x27;%s&#x27; because the bus was not initialized.\n&quot;</span>,</span><br><span class="line">            drv-&gt;name, drv-&gt;bus-&gt;name);</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 检测总线的操作函数和驱动的操作函数是否都已经定义好 */</span></span><br><span class="line">    <span class="keyword">if</span> ((drv-&gt;bus-&gt;probe &amp;&amp; drv-&gt;probe) ||</span><br><span class="line">        (drv-&gt;bus-&gt;remove &amp;&amp; drv-&gt;remove) ||</span><br><span class="line">        (drv-&gt;bus-&gt;shutdown &amp;&amp; drv-&gt;shutdown))</span><br><span class="line">        printk(KERN_WARNING <span class="string">&quot;Driver &#x27;%s&#x27; needs updating - please use &quot;</span></span><br><span class="line">            <span class="string">&quot;bus_type methods\n&quot;</span>, drv-&gt;name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查driver是否已经在bus上注册</span></span><br><span class="line">    <span class="comment">// 已经注册的话会返回device_driver结构</span></span><br><span class="line">    other = driver_find(drv-&gt;name, drv-&gt;bus);</span><br><span class="line">    <span class="keyword">if</span> (other) &#123;</span><br><span class="line">        printk(KERN_ERR <span class="string">&quot;Error: Driver &#x27;%s&#x27; is already registered, &quot;</span></span><br><span class="line">            <span class="string">&quot;aborting...\n&quot;</span>, drv-&gt;name);</span><br><span class="line">        <span class="keyword">return</span> -EBUSY;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将该device_driver注册到总线</span></span><br><span class="line">    ret = bus_add_driver(drv);</span><br><span class="line">    <span class="keyword">if</span> (ret)</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    ret = driver_add_groups(drv, drv-&gt;groups);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        bus_remove_driver(drv);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    kobject_uevent(&amp;drv-&gt;p-&gt;kobj, KOBJ_ADD);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>driver_register()</code>中调用了<code>bus_add_driver(drv)</code>，该函数位于<code>driver/base/bus.c</code>中，<code>bus_add_driver()</code>源码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * bus_add_driver - Add a driver to the bus.</span></span><br><span class="line"><span class="comment">    * @drv: driver.</span></span><br><span class="line"><span class="comment">    */</span>,<span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bus_add_driver</span><span class="params">(struct device_driver *drv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> *<span class="title">bus</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">driver_private</span> *<span class="title">priv</span>;</span></span><br><span class="line">    <span class="keyword">int</span> error = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 增加该bus的kobject引用计数，这里返回的bus就是platform bus</span></span><br><span class="line">    bus = bus_get(drv-&gt;bus);</span><br><span class="line">    <span class="keyword">if</span> (!bus)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    pr_debug(<span class="string">&quot;bus: &#x27;%s&#x27;: add driver %s\n&quot;</span>, bus-&gt;name, drv-&gt;name);</span><br><span class="line">    <span class="comment">// device_drvier的私有数据</span></span><br><span class="line">    priv = kzalloc(<span class="keyword">sizeof</span>(*priv), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!priv) &#123;</span><br><span class="line">        error = -ENOMEM;</span><br><span class="line">        <span class="keyword">goto</span> out_put_bus;</span><br><span class="line">    &#125;</span><br><span class="line">    klist_init(&amp;priv-&gt;klist_devices, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    priv-&gt;driver = drv;</span><br><span class="line">    drv-&gt;p = priv;</span><br><span class="line">    <span class="comment">// drivers_kset 本bus下所有的device_driver kobject集合</span></span><br><span class="line">    priv-&gt;kobj.kset = bus-&gt;p-&gt;drivers_kset;</span><br><span class="line">    <span class="comment">// 初始化私有数据kobject</span></span><br><span class="line">    error = kobject_init_and_add(&amp;priv-&gt;kobj, &amp;driver_ktype, <span class="literal">NULL</span>,</span><br><span class="line">                        <span class="string">&quot;%s&quot;</span>, drv-&gt;name);</span><br><span class="line">    <span class="keyword">if</span> (error)</span><br><span class="line">        <span class="keyword">goto</span> out_unregister;</span><br><span class="line">    <span class="comment">// 将该driver链接到bus的klist_driver上</span></span><br><span class="line">    klist_add_tail(&amp;priv-&gt;knode_bus, &amp;bus-&gt;p-&gt;klist_drivers);</span><br><span class="line">    <span class="comment">// 进入到autoprobe里面</span></span><br><span class="line">    <span class="keyword">if</span> (drv-&gt;bus-&gt;p-&gt;drivers_autoprobe) &#123;</span><br><span class="line">        error = driver_attach(drv);</span><br><span class="line">        <span class="keyword">if</span> (error)</span><br><span class="line">            <span class="keyword">goto</span> out_unregister;</span><br><span class="line">    &#125;</span><br><span class="line">    module_add_driver(drv-&gt;owner, drv);</span><br><span class="line"></span><br><span class="line">    error = driver_create_file(drv, &amp;driver_attr_uevent);</span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        printk(KERN_ERR <span class="string">&quot;%s: uevent attr (%s) failed\n&quot;</span>,</span><br><span class="line">            __func__, drv-&gt;name);</span><br><span class="line">    &#125;</span><br><span class="line">    error = driver_add_groups(drv, bus-&gt;drv_groups);</span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        <span class="comment">/* How the hell do we get out of this pickle? Give up */</span></span><br><span class="line">        printk(KERN_ERR <span class="string">&quot;%s: driver_create_groups(%s) failed\n&quot;</span>,</span><br><span class="line">            __func__, drv-&gt;name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!drv-&gt;suppress_bind_attrs) &#123;</span><br><span class="line">        error = add_bind_files(drv);</span><br><span class="line">        <span class="keyword">if</span> (error) &#123;</span><br><span class="line">            <span class="comment">/* Ditto */</span></span><br><span class="line">            printk(KERN_ERR <span class="string">&quot;%s: add_bind_files(%s) failed\n&quot;</span>,</span><br><span class="line">                __func__, drv-&gt;name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">out_unregister:</span><br><span class="line">    kobject_put(&amp;priv-&gt;kobj);</span><br><span class="line">    <span class="comment">/* drv-&gt;p is freed in driver_release()  */</span></span><br><span class="line">    drv-&gt;p = <span class="literal">NULL</span>;</span><br><span class="line">out_put_bus:</span><br><span class="line">    bus_put(bus);</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续来看driver_attach</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// drivers/base/dd.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">driver_attach</span><span class="params">(struct device_driver *drv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 遍历bus上所有的device</span></span><br><span class="line">    <span class="keyword">return</span> bus_for_each_dev(drv-&gt;bus, <span class="literal">NULL</span>, drv, __driver_attach);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// drivers/base/dd.c</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __driver_attach(struct device *dev, <span class="keyword">void</span> *data)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_driver</span> *<span class="title">drv</span> =</span> data;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Lock device and try to bind to it. We drop the error</span></span><br><span class="line"><span class="comment">	 * here and always return 0, because we need to keep trying</span></span><br><span class="line"><span class="comment">	 * to bind to devices and some drivers will return an error</span></span><br><span class="line"><span class="comment">	 * simply if it didn&#x27;t support the device.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * driver_probe_device() will spit a warning if there</span></span><br><span class="line"><span class="comment">	 * is an error.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">// 这里会调用platform_match(drv, dev)</span></span><br><span class="line">    <span class="comment">// 不匹配的时候会返回0</span></span><br><span class="line">	ret = driver_match_device(drv, dev);</span><br><span class="line">	<span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">/* no match */</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret == -EPROBE_DEFER) &#123;</span><br><span class="line">		dev_dbg(dev, <span class="string">&quot;Device match requests probe deferral\n&quot;</span>);</span><br><span class="line">		driver_deferred_probe_add(dev);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		dev_dbg(dev, <span class="string">&quot;Bus failed to match device: %d\n&quot;</span>, ret);</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125; <span class="comment">/* ret &gt; 0 means positive match */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (driver_allows_async_probing(drv)) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Instead of probing the device synchronously we will</span></span><br><span class="line"><span class="comment">		 * probe it asynchronously to allow for more parallelism.</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * We only take the device lock here in order to guarantee</span></span><br><span class="line"><span class="comment">		 * that the dev-&gt;driver and async_driver fields are protected</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		dev_dbg(dev, <span class="string">&quot;probing driver %s asynchronously\n&quot;</span>, drv-&gt;name);</span><br><span class="line">		device_lock(dev);</span><br><span class="line">		<span class="keyword">if</span> (!dev-&gt;driver) &#123;</span><br><span class="line">			get_device(dev);</span><br><span class="line">			dev-&gt;p-&gt;async_driver = drv;</span><br><span class="line">			async_schedule_dev(__driver_attach_async_helper, dev);</span><br><span class="line">		&#125;</span><br><span class="line">		device_unlock(dev);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 进行驱动的初始化工作，即调用probe</span></span><br><span class="line">	device_driver_attach(drv, dev);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>driver_match_device中会调用platform_match来进行驱动和设备的匹配</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// drivers/base/base.h</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">driver_match_device</span><span class="params">(struct device_driver *drv,</span></span></span><br><span class="line"><span class="params"><span class="function">                                struct device &amp;dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> drv-&gt;bus-&gt;match ? drv-&gt;bus-&gt;match(dev, drv) : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// drivers/base/platform.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">platform_match</span><span class="params">(struct device *dev, struct device_driver *drv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> *<span class="title">pdev</span> =</span> to_platform_device(dev);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> *<span class="title">pdrv</span> =</span> to_platform_driver(drv);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* When driver_override is set, only bind to the matching driver */</span></span><br><span class="line">	<span class="keyword">if</span> (pdev-&gt;driver_override)</span><br><span class="line">		<span class="keyword">return</span> !<span class="built_in">strcmp</span>(pdev-&gt;driver_override, drv-&gt;name);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Attempt an OF style match first */</span></span><br><span class="line">	<span class="keyword">if</span> (of_driver_match_device(dev, drv))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Then try ACPI style match */</span></span><br><span class="line">	<span class="keyword">if</span> (acpi_driver_match_device(dev, drv))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Then try to match against the id table */</span></span><br><span class="line">	<span class="keyword">if</span> (pdrv-&gt;id_table)</span><br><span class="line">		<span class="keyword">return</span> platform_match_id(pdrv-&gt;id_table, pdev) != <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* fall-back to driver name match */</span></span><br><span class="line">	<span class="keyword">return</span> (<span class="built_in">strcmp</span>(pdev-&gt;name, drv-&gt;name) == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设备和驱动匹配顺序：</p>
<ol>
<li>先用设备树中的compatible属性和platform_driver中的driver中的of_match_table来匹配</li>
<li>再用platform_driver的id_table中的name和platform_device中的name来匹配</li>
<li>最后用platform_device中的name和platform_driver中的driver中的name来匹配</li>
</ol>
<p>接着来看device_driver_attach()</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// drivers/base/dd.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">device_driver_attach</span><span class="params">(struct device_driver *drv, struct device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 给当前device上锁</span></span><br><span class="line">	__device_driver_lock(dev, dev-&gt;parent);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If device has been removed or someone has already successfully</span></span><br><span class="line"><span class="comment">	 * bound a driver before us just skip the driver probe call.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">// 为device绑定驱动</span></span><br><span class="line">    <span class="comment">// dead标志该device已经从系统移除</span></span><br><span class="line">	<span class="keyword">if</span> (!dev-&gt;p-&gt;dead &amp;&amp; !dev-&gt;driver)</span><br><span class="line">		ret = driver_probe_device(drv, dev);</span><br><span class="line"></span><br><span class="line">	__device_driver_unlock(dev, dev-&gt;parent);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再继续来看driver_probe_device()</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// drivers/base/dd.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">driver_probe_device</span><span class="params">(struct device_driver *drv, struct device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过该device的kobject中的state_in_sysfs这个标志判断该设备是否已经注册</span></span><br><span class="line">	<span class="keyword">if</span> (!device_is_registered(dev))</span><br><span class="line">		<span class="keyword">return</span> -ENODEV;</span><br><span class="line"></span><br><span class="line">	pr_debug(<span class="string">&quot;bus: &#x27;%s&#x27;: %s: matched device %s with driver %s\n&quot;</span>,</span><br><span class="line">		 drv-&gt;bus-&gt;name, __func__, dev_name(dev), drv-&gt;name);</span><br><span class="line"></span><br><span class="line">	pm_runtime_get_suppliers(dev);</span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;parent)</span><br><span class="line">		pm_runtime_get_sync(dev-&gt;parent);</span><br><span class="line"></span><br><span class="line">	pm_runtime_barrier(dev);</span><br><span class="line">	<span class="keyword">if</span> (initcall_debug)</span><br><span class="line">		ret = really_probe_debug(dev, drv);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		ret = really_probe(dev, drv);</span><br><span class="line">	pm_request_idle(dev);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;parent)</span><br><span class="line">		pm_runtime_put(dev-&gt;parent);</span><br><span class="line"></span><br><span class="line">	pm_runtime_put_suppliers(dev);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续看really_probe()</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">really_probe</span><span class="params">(struct device *dev, struct device_driver *drv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret = -EPROBE_DEFER;</span><br><span class="line">	<span class="keyword">int</span> local_trigger_count = atomic_read(&amp;deferred_trigger_count);</span><br><span class="line">	<span class="keyword">bool</span> test_remove = IS_ENABLED(CONFIG_DEBUG_TEST_DRIVER_REMOVE) &amp;&amp;</span><br><span class="line">			   !drv-&gt;suppress_bind_attrs;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果正处于S3或者S4状态，需要延迟进行驱动初始化</span></span><br><span class="line">	<span class="keyword">if</span> (defer_all_probes) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Value of defer_all_probes can be set only by</span></span><br><span class="line"><span class="comment">		 * device_block_probing() which, in turn, will call</span></span><br><span class="line"><span class="comment">		 * wait_for_device_probe() right after that to avoid any races.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		dev_dbg(dev, <span class="string">&quot;Driver %s force probe deferral\n&quot;</span>, drv-&gt;name);</span><br><span class="line">		driver_deferred_probe_add(dev);</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ret = device_links_check_suppliers(dev);</span><br><span class="line">	<span class="keyword">if</span> (ret == -EPROBE_DEFER)</span><br><span class="line">		driver_deferred_probe_add_trigger(dev, local_trigger_count);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">	atomic_inc(&amp;probe_count);</span><br><span class="line">	pr_debug(<span class="string">&quot;bus: &#x27;%s&#x27;: %s: probing driver %s with device %s\n&quot;</span>,</span><br><span class="line">		 drv-&gt;bus-&gt;name, __func__, drv-&gt;name, dev_name(dev));</span><br><span class="line">	<span class="keyword">if</span> (!list_empty(&amp;dev-&gt;devres_head)) &#123;</span><br><span class="line">		dev_crit(dev, <span class="string">&quot;Resources present before probing\n&quot;</span>);</span><br><span class="line">		ret = -EBUSY;</span><br><span class="line">		<span class="keyword">goto</span> done;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">re_probe:</span><br><span class="line">	dev-&gt;driver = drv;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* If using pinctrl, bind pins now before probing */</span></span><br><span class="line">	ret = pinctrl_bind_pins(dev);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">goto</span> pinctrl_bind_failed;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;bus-&gt;dma_configure) &#123;</span><br><span class="line">		ret = dev-&gt;bus-&gt;dma_configure(dev);</span><br><span class="line">		<span class="keyword">if</span> (ret)</span><br><span class="line">			<span class="keyword">goto</span> probe_failed;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (driver_sysfs_add(dev)) &#123;</span><br><span class="line">		pr_err(<span class="string">&quot;%s: driver_sysfs_add(%s) failed\n&quot;</span>,</span><br><span class="line">		       __func__, dev_name(dev));</span><br><span class="line">		<span class="keyword">goto</span> probe_failed;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;pm_domain &amp;&amp; dev-&gt;pm_domain-&gt;activate) &#123;</span><br><span class="line">		ret = dev-&gt;pm_domain-&gt;activate(dev);</span><br><span class="line">		<span class="keyword">if</span> (ret)</span><br><span class="line">			<span class="keyword">goto</span> probe_failed;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 这里调用platform_drv_probe()</span></span><br><span class="line">    <span class="comment">// 在platform_drv_probe()里面会调用driver-&gt;probe()</span></span><br><span class="line">    <span class="comment">// 这里即phytium_i2c_plat_probe()</span></span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;bus-&gt;probe) &#123;</span><br><span class="line">		ret = dev-&gt;bus-&gt;probe(dev);</span><br><span class="line">		<span class="keyword">if</span> (ret)</span><br><span class="line">			<span class="keyword">goto</span> probe_failed;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (drv-&gt;probe) &#123;</span><br><span class="line">		ret = drv-&gt;probe(dev);</span><br><span class="line">		<span class="keyword">if</span> (ret)</span><br><span class="line">			<span class="keyword">goto</span> probe_failed;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (device_add_groups(dev, drv-&gt;dev_groups)) &#123;</span><br><span class="line">		dev_err(dev, <span class="string">&quot;device_add_groups() failed\n&quot;</span>);</span><br><span class="line">		<span class="keyword">goto</span> dev_groups_failed;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dev_has_sync_state(dev) &amp;&amp;</span><br><span class="line">	    device_create_file(dev, &amp;dev_attr_state_synced)) &#123;</span><br><span class="line">		dev_err(dev, <span class="string">&quot;state_synced sysfs add failed\n&quot;</span>);</span><br><span class="line">		<span class="keyword">goto</span> dev_sysfs_state_synced_failed;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (test_remove) &#123;</span><br><span class="line">		test_remove = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">		device_remove_file(dev, &amp;dev_attr_state_synced);</span><br><span class="line">		device_remove_groups(dev, drv-&gt;dev_groups);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (dev-&gt;bus-&gt;remove)</span><br><span class="line">			dev-&gt;bus-&gt;remove(dev);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (drv-&gt;remove)</span><br><span class="line">			drv-&gt;remove(dev);</span><br><span class="line"></span><br><span class="line">		devres_release_all(dev);</span><br><span class="line">		driver_sysfs_remove(dev);</span><br><span class="line">		dev-&gt;driver = <span class="literal">NULL</span>;</span><br><span class="line">		dev_set_drvdata(dev, <span class="literal">NULL</span>);</span><br><span class="line">		<span class="keyword">if</span> (dev-&gt;pm_domain &amp;&amp; dev-&gt;pm_domain-&gt;dismiss)</span><br><span class="line">			dev-&gt;pm_domain-&gt;dismiss(dev);</span><br><span class="line">		pm_runtime_reinit(dev);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">goto</span> re_probe;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pinctrl_init_done(dev);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;pm_domain &amp;&amp; dev-&gt;pm_domain-&gt;sync)</span><br><span class="line">		dev-&gt;pm_domain-&gt;sync(dev);</span><br><span class="line"></span><br><span class="line">	driver_bound(dev);</span><br><span class="line">	ret = <span class="number">1</span>;</span><br><span class="line">	pr_debug(<span class="string">&quot;bus: &#x27;%s&#x27;: %s: bound device %s to driver %s\n&quot;</span>,</span><br><span class="line">		 drv-&gt;bus-&gt;name, __func__, dev_name(dev), drv-&gt;name);</span><br><span class="line">	<span class="keyword">goto</span> done;</span><br><span class="line"></span><br><span class="line">dev_sysfs_state_synced_failed:</span><br><span class="line">	device_remove_groups(dev, drv-&gt;dev_groups);</span><br><span class="line">dev_groups_failed:</span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;bus-&gt;remove)</span><br><span class="line">		dev-&gt;bus-&gt;remove(dev);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (drv-&gt;remove)</span><br><span class="line">		drv-&gt;remove(dev);</span><br><span class="line">probe_failed:</span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;bus)</span><br><span class="line">		blocking_notifier_call_chain(&amp;dev-&gt;bus-&gt;p-&gt;bus_notifier,</span><br><span class="line">					     BUS_NOTIFY_DRIVER_NOT_BOUND, dev);</span><br><span class="line">pinctrl_bind_failed:</span><br><span class="line">	device_links_no_driver(dev);</span><br><span class="line">	devres_release_all(dev);</span><br><span class="line">	arch_teardown_dma_ops(dev);</span><br><span class="line">	driver_sysfs_remove(dev);</span><br><span class="line">	dev-&gt;driver = <span class="literal">NULL</span>;</span><br><span class="line">	dev_set_drvdata(dev, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;pm_domain &amp;&amp; dev-&gt;pm_domain-&gt;dismiss)</span><br><span class="line">		dev-&gt;pm_domain-&gt;dismiss(dev);</span><br><span class="line">	pm_runtime_reinit(dev);</span><br><span class="line">	dev_pm_set_driver_flags(dev, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (ret) &#123;</span><br><span class="line">	<span class="keyword">case</span> -EPROBE_DEFER:</span><br><span class="line">		<span class="comment">/* Driver requested deferred probing */</span></span><br><span class="line">		dev_dbg(dev, <span class="string">&quot;Driver %s requests probe deferral\n&quot;</span>, drv-&gt;name);</span><br><span class="line">		driver_deferred_probe_add_trigger(dev, local_trigger_count);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> -ENODEV:</span><br><span class="line">	<span class="keyword">case</span> -ENXIO:</span><br><span class="line">		pr_debug(<span class="string">&quot;%s: probe of %s rejects match %d\n&quot;</span>,</span><br><span class="line">			 drv-&gt;name, dev_name(dev), ret);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="comment">/* driver matched but the probe failed */</span></span><br><span class="line">		pr_warn(<span class="string">&quot;%s: probe of %s failed with error %d\n&quot;</span>,</span><br><span class="line">			drv-&gt;name, dev_name(dev), ret);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Ignore errors returned by -&gt;probe so that the next driver can try</span></span><br><span class="line"><span class="comment">	 * its luck.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ret = <span class="number">0</span>;</span><br><span class="line">done:</span><br><span class="line">	atomic_dec(&amp;probe_count);</span><br><span class="line">	wake_up_all(&amp;probe_waitqueue);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Platform</tag>
      </tags>
  </entry>
  <entry>
    <title>phytium i2c适配器驱动</title>
    <url>/archives/1dd4e6b7.html</url>
    <content><![CDATA[<h4 id="I2C总线驱动"><a href="#I2C总线驱动" class="headerlink" title="I2C总线驱动"></a>I2C总线驱动</h4><p>I2C总线驱动重点是I2C适配器（也就是SOC的I2C接口）控制器驱动，这里涉及到两个重要的数据结构：i2c_adapter和i2c_algorithm，Linux内核将SOC的I2C控制器抽象成i2c_adapter，i2c_adapter定义在include&#x2F;linux&#x2F;i2c.h中，结构体的内容如下：</p>
<span id="more"></span>
<pre><code><figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="type">i2c_adapter</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="type">module</span> *owner;</span><br><span class="line">    unsigned int class;		  <span class="comment">/* classes to allow probing for */</span></span><br><span class="line">    const <span class="keyword">struct</span> <span class="type">i2c_algorithm</span> *algo; <span class="comment">/* the algorithm to access the bus */</span></span><br><span class="line">    void *algo_data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* data fields that are valid for all devices	*/</span></span><br><span class="line">    const <span class="keyword">struct</span> <span class="type">i2c_lock_operations</span> *lock_ops;</span><br><span class="line">    <span class="keyword">struct</span> <span class="type">rt_mutex</span> bus_lock;</span><br><span class="line">    <span class="keyword">struct</span> <span class="type">rt_mutex</span> mux_lock;</span><br><span class="line"></span><br><span class="line">    int timeout;			<span class="comment">/* in jiffies */</span></span><br><span class="line">    int retries;</span><br><span class="line">    <span class="keyword">struct</span> <span class="type">device</span> dev;		<span class="comment">/* the adapter device */</span></span><br><span class="line"></span><br><span class="line">    int nr;</span><br><span class="line">    char name[<span class="number">48</span>];</span><br><span class="line">    <span class="keyword">struct</span> <span class="type">completion</span> dev_released;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="type">mutex</span> userspace_clients_lock;</span><br><span class="line">    <span class="keyword">struct</span> <span class="type">list_head</span> userspace_clients;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="type">i2c_bus_recovery_info</span> *bus_recovery_info;</span><br><span class="line">    const <span class="keyword">struct</span> <span class="type">i2c_adapter_quirks</span> *quirks;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="type">irq_domain</span> *host_notify_domain;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
其中algo成员为i2c适配器对外提供的API读写操作函数，i2c_algorithm为I2C适配器和I2C设备通信的方法，i2c_algorithm结构体的内容如下：
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> i2c_algorithm &#123;</span><br><span class="line">    <span class="comment">/* If an adapter algorithm can&#x27;t do I2C-level access, set master_xfer</span></span><br><span class="line"><span class="comment">       to NULL. If an adapter algorithm can do SMBus access, set</span></span><br><span class="line"><span class="comment">       smbus_xfer. If set to NULL, the SMBus protocol is simulated</span></span><br><span class="line"><span class="comment">       using common I2C messages */</span></span><br><span class="line">    <span class="comment">/* master_xfer should return the number of messages successfully</span></span><br><span class="line"><span class="comment">       processed, or a negative value on error */</span></span><br><span class="line">    <span class="keyword">int</span> (*master_xfer)(<span class="keyword">struct</span> i2c_adapter *adap, <span class="keyword">struct</span> i2c_msg *msgs,</span><br><span class="line">               <span class="keyword">int</span> num);</span><br><span class="line">    <span class="keyword">int</span> (*smbus_xfer) (<span class="keyword">struct</span> i2c_adapter *adap, u16 addr,</span><br><span class="line">               <span class="keyword">unsigned</span> <span class="keyword">short</span> flags, <span class="keyword">char</span> read_write,</span><br><span class="line">               u8 command, <span class="keyword">int</span> size, <span class="keyword">union</span> i2c_smbus_data *data);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* To determine what the adapter supports */</span></span><br><span class="line">    u32 (*functionality) (<span class="keyword">struct</span> i2c_adapter *);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> IS_ENABLED(CONFIG_I2C_SLAVE)</span></span><br><span class="line">    <span class="keyword">int</span> (*reg_slave)(<span class="keyword">struct</span> i2c_client *client);</span><br><span class="line">    <span class="keyword">int</span> (*unreg_slave)(<span class="keyword">struct</span> i2c_client *client);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
+ master_xfer是I2C适配器的的传输函数
+ smbus_xfer是SMBUS总线的传输函数
</code></pre>
<ul>
<li>I2C适配器驱动的主要工作就是初始化i2c_adapter的结构体变量，然后实现i2c_algorithm中的传输函数，完成后通过<em>i2c_add_numbered_adapter</em>或者<em>i2c_add_adapter</em>这两个函数向系统注册设置好的i2c_adapter，函数原型如下：<br><code>int i2c_add_adapter(struct i2c_adapter *adapter)</code><br><code>int i2c_add_numbered_adapter(struct i2c_adapter *adap)</code><br>i2c_add_adapter()使用动态的总线号，i2c_add_numbered_adapter()使用静态的总线号</li>
</ul>
<h4 id="phytium-i2c适配器驱动分析"><a href="#phytium-i2c适配器驱动分析" class="headerlink" title="phytium i2c适配器驱动分析"></a>phytium i2c适配器驱动分析</h4><ul>
<li><p>phytium i2c设备树节点内容</p>
  <figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="symbol">mio14:</span> <span class="class">i2c@28030000 </span>&#123;</span><br><span class="line">    compatible = <span class="string">&quot;phytium,i2c&quot;</span>;</span><br><span class="line">    reg = <span class="params">&lt;<span class="number">0x0</span> <span class="number">0x28030000</span> <span class="number">0x0</span> <span class="number">0x1000</span>&gt;</span>;</span><br><span class="line">    interrupts = <span class="params">&lt;GIC_SPI <span class="number">106</span> IRQ_TYPE_LEVEL_HIGH&gt;</span>;</span><br><span class="line">    clocks = <span class="params">&lt;<span class="variable">&amp;sysclk_50mhz</span>&gt;</span>;</span><br><span class="line">    <span class="meta">#address-cells = &lt;1&gt;;</span></span><br><span class="line">    <span class="meta">#size-cells = &lt;0&gt;;</span></span><br><span class="line">    status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>  对应的驱动文件为<em>drivers&#x2F;i2c&#x2F;busses&#x2F;i2c-phytium-platform.c</em></p>
</li>
<li><p>phytium i2c适配器驱动为一个标准的platform驱动</p>
  <figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">static struct platform_driver <span class="attr">phytium_i2c_driver</span> = &#123;</span><br><span class="line">    .<span class="attr">probe</span> = phytium_i2c_plat_probe,</span><br><span class="line">    .<span class="attr">remove</span> = phytium_i2c_plat_remove,</span><br><span class="line">    .<span class="attr">driver</span> = &#123;</span><br><span class="line">        .<span class="attr">name</span> = DRV_NAME,</span><br><span class="line">        .<span class="attr">of_match_table</span> = of_match_ptr(phytium_i2c_of_match),</span><br><span class="line">        .<span class="attr">acpi_match_table</span> = ACPI_PTR(phytium_i2c_acpi_match),</span><br><span class="line">        .<span class="attr">pm</span> = &amp;phytium_i2c_dev_pm_ops,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<em>of_device_id</em>与设备树mio14节点相匹配，在platform_match函数中进行匹配</p>
  <figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">static const <span class="keyword">struct</span> of_device_id phytium_i2c_of_match<span class="literal">[]</span> = &#123;</span><br><span class="line">    &#123; .compatible = <span class="string">&quot;phytium,i2c&quot;</span>, &#125;,</span><br><span class="line">    &#123;   &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="constructor">MODULE_DEVICE_TABLE(<span class="params">of</span>, <span class="params">phytium_i2c_of_match</span>)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>当设备和驱动匹配完成后，<em>phytium_i2c_plat_probe</em>函数就会执行，完成i2c适配器的初始化工作，probe中的工作如下：</p>
<ul>
<li>调用platform_get_irq()函数获取中断号</li>
<li>调用platform_get_resource()函数获取I2C控制器的寄存器物理基地址，获取到物理基地址后再使用devm_ioremap_resource()函数对其进行内存映射，得到可以在Linux内核中使用的虚拟内存地址</li>
<li>设置I2C设备总线速度</li>
<li>根据I2C地址第30位数据来判断当前I2C适配器配置成slave模式还是master模式，填充phytium_i2c_dev数据成员，主要设计适配器工作能力等一些参数标志</li>
<li>使能I2C总线时钟</li>
<li>调用i2c_phytium_probe()函数，该函数位于drivers&#x2F;i2c&#x2F;busses&#x2F;i2c-phytium-master.c，在i2c_phytium_probe()里面继续完善adapter数据成员</li>
</ul>
</li>
<li><p>phytium_i2c_dev结构体</p>
  <figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">struct phytium_i2c_dev &#123;</span><br><span class="line">    struct device		*dev<span class="comment">;</span></span><br><span class="line">    void __iomem		*base<span class="comment">;</span></span><br><span class="line">    int			irq<span class="comment">;</span></span><br><span class="line">    u32			flags<span class="comment">;</span></span><br><span class="line">    struct completion	cmd_complete<span class="comment">;</span></span><br><span class="line">    struct clk		*clk<span class="comment">;</span></span><br><span class="line">    struct reset_control	*rst<span class="comment">;</span></span><br><span class="line">    int			mode<span class="comment">;</span></span><br><span class="line">    struct i2c_client	*slave<span class="comment">;</span></span><br><span class="line">    u32			(*get_clk_rate_khz)(struct phytium_i2c_dev *dev)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    struct i2c_adapter	adapter<span class="comment">;</span></span><br><span class="line">    struct i2c_client	*ara<span class="comment">;</span></span><br><span class="line">    struct i2c_smbus_alert_setup alert_data<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    struct phytium_pci_i2c *controller<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    unsigned int		status<span class="comment">;</span></span><br><span class="line">    int			cmd_err<span class="comment">;</span></span><br><span class="line">    u32			abort_source<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    struct i2c_msg		*msgs<span class="comment">;</span></span><br><span class="line">    int			msgs_num<span class="comment">;</span></span><br><span class="line">    int			msg_write_idx<span class="comment">;</span></span><br><span class="line">    int			msg_read_idx<span class="comment">;</span></span><br><span class="line">    int			msg_err<span class="comment">;</span></span><br><span class="line">    u32			tx_buf_len<span class="comment">;</span></span><br><span class="line">    u8			*tx_buf<span class="comment">;</span></span><br><span class="line">    u32			rx_buf_len<span class="comment">;</span></span><br><span class="line">    u8			*rx_buf<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    u32			master_cfg<span class="comment">;</span></span><br><span class="line">    u32			slave_cfg<span class="comment">;</span></span><br><span class="line">    u32			functionality<span class="comment">;</span></span><br><span class="line">    unsigned int		tx_fifo_depth<span class="comment">;</span></span><br><span class="line">    unsigned int		rx_fifo_depth<span class="comment">;</span></span><br><span class="line">    int			rx_outstanding<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    struct i2c_timings	timings<span class="comment">;</span></span><br><span class="line">    u32			sda_hold_time<span class="comment">;</span></span><br><span class="line">    u16			ss_hcnt<span class="comment">;</span></span><br><span class="line">    u16			ss_lcnt<span class="comment">;</span></span><br><span class="line">    u16			fs_hcnt<span class="comment">;</span></span><br><span class="line">    u16			fs_lcnt<span class="comment">;</span></span><br><span class="line">    u16			fp_hcnt<span class="comment">;</span></span><br><span class="line">    u16			fp_lcnt<span class="comment">;</span></span><br><span class="line">    u16			hs_hcnt<span class="comment">;</span></span><br><span class="line">    u16			hs_lcnt<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    bool			pm_disabled<span class="comment">;</span></span><br><span class="line">    void			(*disable)(struct phytium_i2c_dev *dev)<span class="comment">;</span></span><br><span class="line">    void			(*disable_int)(struct phytium_i2c_dev *dev)<span class="comment">;</span></span><br><span class="line">    int			(*init)(struct phytium_i2c_dev *dev)<span class="comment">;</span></span><br><span class="line">&#125;<span class="comment">;</span></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>I2C</tag>
      </tags>
  </entry>
  <entry>
    <title>ASoC Platform Driver</title>
    <url>/archives/131a876a.html</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>ALSA是Advanced Linux Sound Architecture的缩写，<a href="https://www.alsa-project.org/">ALSA官网地址</a></p>
<span id="more"></span>

<p>ALSA作为Linux现在主流的音频体系架构，提供了内核的驱动框架，也提供了应用层的<br><code>alsa-lib</code>库，ALSA还提供了<code>alsa-utils</code>应用程序，方便进行音频控制</p>
<p>音频设备文件结构如下</p>
<p><img src="https://raw.githubusercontent.com/JackHuang021/images/master/20221108112754.png"></p>
<ul>
<li>controlC0: 用于card0声卡的控制</li>
<li>pcmC0D0c: 用于card0 device0录音的pcm设备</li>
<li>pcmC0D0p: 用于card0 device0播放的pcm设备</li>
<li>timer: 定时器</li>
</ul>
<p><img src="https://raw.githubusercontent.com/JackHuang021/images/master/20240124105117.png"></p>
<h3 id="ASoC驱动框架"><a href="#ASoC驱动框架" class="headerlink" title="ASoC驱动框架"></a>ASoC驱动框架</h3><p>ASoC（ALSA system on chip）是建立在标准ALSA驱动层上，对底层的ALSA框架封装了一层，为了更好的支持嵌入式CPU和音频编解码设备的一套软件体系，ASoC驱动主要由platform驱动、codec驱动、machine驱动组成。</p>
<p>machine驱动：充当描述和绑定其他组件驱动程序以形成ALSA声卡的粘合剂，machine可以理解为对声卡的抽象，它把cpu_dai，codec_dai通过dai_link链接起来，然后注册snd_soc_card。该驱动实现<code>struct snd_soc_card</code>的定义和注册，并通过指定<code>struct snd_soc_dai_link</code>中的<code>codec_name</code>, <code>platform_name</code>, <code>codec_dai_name</code>, <code>platform_dai_name</code>从而实现与其他各个驱动组件的绑定</p>
<p>platform驱动：一般指某一个SoC平台，与音频相关的通常包括SoC中的时钟、DMA、I2S、I2C等，我们可以认为他们组成了一个对应的音频platform，这个Platform只与SoC有关，这样我们可以把Platform抽象出来</p>
<p>codec驱动：codec字面上的意思就是编解码器，codec和platform一样，可以被多个machine使用，嵌入式codec一般通过I2C或SPI对内部的寄存器进行控制</p>
<p><img src="https://raw.githubusercontent.com/JackHuang021/images/master/20240124105147.png"></p>
<h3 id="相关名词描述"><a href="#相关名词描述" class="headerlink" title="相关名词描述"></a>相关名词描述</h3><p>DAPM（Dynamic Audio Power Management）：动态音频电源管理，用于Linux设备使用音频子系统内的最低电量，它独立于其他内核PM，DAPM对所有的用户空间应用程序来说也是完全透明的，因为所有电源切换都是在ASoC核心内完成的，对于用户空间应用程序，不需要更改代码，DAPM根据当前激活的音频流和声卡中的Mixer等的配置来决定哪些音频控件的电源开关打开或关闭</p>
<p>DAI(Digital Audio Interface)数字音频接口：数字音频接口全部是硬件接口，即同一个主板上IC芯片和IC芯片之间的通讯协议，数字音频接口有PCM、I2S、AC97、PDM</p>
<p>PCM编码（Pulse Code Modulation）：通过等时间间隔（即采样率时钟周期）采样将模拟信号转化为数字信号的方法，PCM使用等间隔采样方法，将每次采样的模拟分量幅度表示为N位的数字分量，因此PCM方式每次采样的结果都是N bit长的数据</p>
<p>Kcontrols：代表声卡里面的各种硬件开关，滑动控件等，通过软件定义kcontrol可以通过用户态配置硬件寄存器的开关，ALSA用snd_kcontrol_new定义kcontrol</p>
<p>Widget：具备路径和电源管理的kcontrol</p>
<p>Mixer：多个输入混合成一个输出，可以使用SND_SOC_DAPM_MIXER来定义这种类型的widget，mixer的widget类型为snd_soc_dapm_mixer</p>
<p>Mux：多路选择器，多路输入，但是只能选择一路作为输出，可以使用SND_SOC_DAPM_MUX来定义这个widget，widget类型为snd_soc_dapm_mux</p>
<p>pga：单路输入，单路输出，带gain调整的部件，可以使用SND_SOC_DAPM_PGA来定义这个widget，所属widget类型为snd_soc_dapm_pga</p>
<p>Path：path相当于电路中的一条跳线，它把一个widget的输出端和另一个widget的输入端连接在一起</p>
<p>Route：route用来描述一条完整的路径，它包括 起始端widget -&gt; path的输入 -&gt; path的输出 -&gt; 目标端widget，DAPM使用<code>struct snd_soc_dapm_route</code>结构来描述这样一个完整路径</p>
<h3 id="Control设备和kcontrol"><a href="#Control设备和kcontrol" class="headerlink" title="Control设备和kcontrol"></a>Control设备和kcontrol</h3><h4 id="Control设备"><a href="#Control设备" class="headerlink" title="Control设备"></a>Control设备</h4><p>Control是音频驱动中用来表示用户可操作的音频参数或功能的抽象设备，它可以是音量控制、Mixer（混音控制）、Mux（开关控制）等，Control提供了一个统一的接口，用于能够通过音频设备驱动程序来管理和调整音频参数，ALSA core层已经实现了Control中间层，在<code>include\sound\control.h</code>中定义了所有的Control API</p>
<h5 id="Control设备的创建"><a href="#Control设备的创建" class="headerlink" title="Control设备的创建"></a>Control设备的创建</h5><p>Control设备和PCM设备一样，都属于声卡下的逻辑设备。用户空间的应用程序通过alsa-lib访问该Control设备，读取或控制控件的控制状态，从而达到控制音频Codec进行各种Mixer等控制操作。</p>
<p>在声卡的初始化过程中会调用到<code>snd_ctrl_create()</code>来初始化Control设备，具体的流程如下：</p>
<p><img src="https://raw.githubusercontent.com/JackHuang021/images/master/20240410140458.png"></p>
<h4 id="kcontrol"><a href="#kcontrol" class="headerlink" title="kcontrol"></a>kcontrol</h4><p>kcontrol是一种控件，也可以理解为switch，主要实现控制声卡的音量、混音等一系列控制</p>
<p>kcontrol对应的数据结构是<code>struct snd_kcontrol_new</code>和<code>struct kcontrol</code>，kcontol的创建步骤如下：</p>
<ul>
<li>在codec驱动中定义<code>struct snd_kcontrol_new</code>数组</li>
<li>在声卡初始化的阶段，通过<code>snd_soc_component_controls()</code>创建并添加多个kcontrol到<code>struct snd_card</code>的controls链表中</li>
</ul>
<h5 id="kcontrol相关的数据结构"><a href="#kcontrol相关的数据结构" class="headerlink" title="kcontrol相关的数据结构"></a>kcontrol相关的数据结构</h5><p><code>struct snd_kcontrol_new</code>结构体</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/sound/control.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_kcontrol_new</span> &#123;</span></span><br><span class="line">	<span class="keyword">snd_ctl_elem_iface_t</span> iface;	<span class="comment">/* interface identifier */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> device;		<span class="comment">/* device/client number */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> subdevice;		<span class="comment">/* subdevice (substream) number */</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *name;		<span class="comment">/* ASCII name of item */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> index;		<span class="comment">/* index of item */</span></span><br><span class="line">	<span class="comment">/* 控件的访问类型 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> access;		<span class="comment">/* access rights */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> count;		<span class="comment">/* count of same elements */</span></span><br><span class="line">	<span class="comment">/* info回调函数用于获取控件的详细信息 */</span></span><br><span class="line">	<span class="keyword">snd_kcontrol_info_t</span> *info;</span><br><span class="line">	<span class="comment">/* get回调函数用于读取控件的当前值 */</span></span><br><span class="line">	<span class="keyword">snd_kcontrol_get_t</span> *get;</span><br><span class="line">	<span class="comment">/* put回调函数用于把应用程序的控制值设置到控件中 */</span></span><br><span class="line">	<span class="keyword">snd_kcontrol_put_t</span> *put;</span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="keyword">snd_kcontrol_tlv_rw_t</span> *c;</span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> *p;</span><br><span class="line">	&#125; tlv;</span><br><span class="line">	<span class="comment">/* 存储了struct soc_mixer_control的信息 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> private_value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>通常可以分成3部分来定义控件的名字：源——方向——功能，kernel文档中关于kcontrol命名<a href="https://www.kernel.org/doc/html/v6.3/sound/designs/control-names.html">https://www.kernel.org/doc/html/v6.3/sound/designs/control-names.html</a></p>
<h5 id="kcontrol的辅助宏"><a href="#kcontrol的辅助宏" class="headerlink" title="kcontrol的辅助宏"></a>kcontrol的辅助宏</h5><p><code>SOC_SINGLE</code>宏，这种控件只一个控制量，比如一个开关</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/sound/soc.h</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * xname: 控件的名字</span></span><br><span class="line"><span class="comment"> * reg: 控件对应寄存器的地址</span></span><br><span class="line"><span class="comment"> * shift: 控件在寄存器中的偏移</span></span><br><span class="line"><span class="comment"> * max: 控件可设置的最大值</span></span><br><span class="line"><span class="comment"> * invert: 设定值是否逻辑取反</span></span><br><span class="line"><span class="comment"> * private_value: </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SOC_SINGLE(xname, reg, shift, max, invert) \</span></span><br><span class="line"><span class="meta">&#123;	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \</span></span><br><span class="line"><span class="meta">	.info = snd_soc_info_volsw, .get = snd_soc_get_volsw,\</span></span><br><span class="line"><span class="meta">	.put = snd_soc_put_volsw, \</span></span><br><span class="line"><span class="meta">	.private_value = SOC_SINGLE_VALUE(reg, shift, max, invert, 0) &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SOC_SINGLE_VALUE(xreg, xshift, xmax, xinvert, xautodisable) \</span></span><br><span class="line"><span class="meta">	SOC_DOUBLE_VALUE(xreg, xshift, xshift, xmax, xinvert, xautodisable)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SOC_DOUBLE_VALUE(xreg, shift_left, shift_right, xmax, xinvert, xautodisable) \</span></span><br><span class="line"><span class="meta">	((unsigned long)&amp;(struct soc_mixer_control) \</span></span><br><span class="line"><span class="meta">	&#123;.reg = xreg, .rreg = xreg, .shift = shift_left, \</span></span><br><span class="line"><span class="meta">	.rshift = shift_right, .max = xmax, .platform_max = xmax, \</span></span><br><span class="line"><span class="meta">	.invert = xinvert, .autodisable = xautodisable&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使用soc_mixer_control来描述该控件对应寄存器控制的详细信息 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">soc_mixer_control</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> min, max, platform_max;</span><br><span class="line">	<span class="keyword">int</span> reg, rreg;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> shift, rshift;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> sign_bit;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> invert:<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> autodisable:<span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SND_SOC_TOPOLOGY</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dobj</span> <span class="title">dobj</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>SOC_SINGLE_TLV</code>宏，主要定义那些有增益控制的控件，例如音量控制器，EQ均衡器等</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SOC_SINGLE_TLV(xname, reg, shift, max, invert, tlv_array) \</span></span><br><span class="line"><span class="meta">&#123;	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \</span></span><br><span class="line"><span class="meta">	.access = SNDRV_CTL_ELEM_ACCESS_TLV_READ |\</span></span><br><span class="line"><span class="meta">		 SNDRV_CTL_ELEM_ACCESS_READWRITE,\</span></span><br><span class="line"><span class="meta">	.tlv.p = (tlv_array), \</span></span><br><span class="line"><span class="meta">	.info = snd_soc_info_volsw, .get = snd_soc_get_volsw,\</span></span><br><span class="line"><span class="meta">	.put = snd_soc_put_volsw, \</span></span><br><span class="line"><span class="meta">	.private_value = SOC_SINGLE_VALUE(reg, shift, max, invert, 0) &#125;</span></span><br></pre></td></tr></table></figure>

<p><code>SOC_DOUBLE</code>宏，可以在同一个寄存器中控制两个相似的变量，最常用的就是用于一些立体声的控件，我们需要同时对左右声道进行控制，因为多了一个声道，参数也就相应地多了一个shift偏移</p>
<h5 id="kcontrol创建过程"><a href="#kcontrol创建过程" class="headerlink" title="kcontrol创建过程"></a>kcontrol创建过程</h5><p>codec驱动在在进行kcontrol的定义后，会对<code>struct snd_soc_component_driver</code>的<code>controls</code>和<code>num_controls</code>成员进行填充。在声卡的初始化过程中，会调用<code>soc_probe_link_components()</code>对dai_link上的所有component进行初始化设置，其中包括了kcontrol的创建<code>snd_soc_add_component_controls()</code>，其创建过程如下：</p>
<p><img src="https://raw.githubusercontent.com/JackHuang021/images/master/20240409143156.png"></p>
<h5 id="es8336-kcontrol定义示例"><a href="#es8336-kcontrol定义示例" class="headerlink" title="es8336 kcontrol定义示例"></a>es8336 kcontrol定义示例</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sound/soc/codec/es8336.c</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">snd_kcontrol_new</span> <span class="title">es8336_snd_controls</span>[] =</span> &#123;</span><br><span class="line">	<span class="comment">/* HP OUT VOLUME */</span></span><br><span class="line">	SOC_DOUBLE_TLV(<span class="string">&quot;HP Playback Volume&quot;</span>, ES8336_CPHP_ICAL_VOL_REG18,</span><br><span class="line">		       <span class="number">4</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">1</span>, hpout_vol_tlv),</span><br><span class="line">	<span class="comment">/* HPMIXER VOLUME Control */</span></span><br><span class="line">	SOC_DOUBLE_TLV(<span class="string">&quot;HPMixer Gain&quot;</span>, ES8336_HPMIX_VOL_REG16,</span><br><span class="line">		       <span class="number">0</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">0</span>, hpmixer_gain_tlv),</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* DAC Digital controls */</span></span><br><span class="line">	SOC_DOUBLE_R_TLV(<span class="string">&quot;DAC Playback Volume&quot;</span>, ES8336_DAC_VOLL_REG33,</span><br><span class="line">			 ES8336_DAC_VOLR_REG34, <span class="number">0</span>, <span class="number">0xC0</span>, <span class="number">1</span>, dac_vol_tlv),</span><br><span class="line"></span><br><span class="line">	SOC_SINGLE(<span class="string">&quot;Enable DAC Soft Ramp&quot;</span>, ES8336_DAC_SET1_REG30, <span class="number">4</span>, <span class="number">1</span>, <span class="number">1</span>),</span><br><span class="line">	SOC_SINGLE(<span class="string">&quot;DAC Soft Ramp Rate&quot;</span>, ES8336_DAC_SET1_REG30, <span class="number">2</span>, <span class="number">4</span>, <span class="number">0</span>),</span><br><span class="line"></span><br><span class="line">	SOC_ENUM(<span class="string">&quot;Playback Polarity&quot;</span>, dacpol),</span><br><span class="line">	SOC_SINGLE(<span class="string">&quot;DAC Notch Filter&quot;</span>, ES8336_DAC_SET2_REG31, <span class="number">6</span>, <span class="number">1</span>, <span class="number">0</span>),</span><br><span class="line">	SOC_SINGLE(<span class="string">&quot;DAC Double Fs Mode&quot;</span>, ES8336_DAC_SET2_REG31, <span class="number">7</span>, <span class="number">1</span>, <span class="number">0</span>),</span><br><span class="line">	SOC_SINGLE(<span class="string">&quot;DAC Volume Control-LeR&quot;</span>, ES8336_DAC_SET2_REG31, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>),</span><br><span class="line">	SOC_SINGLE(<span class="string">&quot;DAC Stereo Enhancement&quot;</span>, ES8336_DAC_SET3_REG32, <span class="number">0</span>, <span class="number">7</span>, <span class="number">0</span>),</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* +20dB D2SE PGA Control */</span></span><br><span class="line">	SOC_SINGLE_TLV(<span class="string">&quot;MIC Boost&quot;</span>, ES8336_ADC_D2SEPGA_REG24,</span><br><span class="line">		       <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, mic_bst_tlv),</span><br><span class="line">	<span class="comment">/* 0-+24dB Lineinput PGA Control */</span></span><br><span class="line">	SOC_SINGLE_TLV(<span class="string">&quot;Input PGA&quot;</span>, ES8336_ADC_PGAGAIN_REG23,</span><br><span class="line">		       <span class="number">4</span>, <span class="number">8</span>, <span class="number">0</span>, linin_pga_tlv),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 填充到struct snd_soc_component_driver */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_component_driver</span> <span class="title">soc_component_dev_es8336</span> =</span> &#123;</span><br><span class="line">	.probe =	es8336_probe,</span><br><span class="line">	.remove =	es8336_remove,</span><br><span class="line">	.suspend =	es8336_suspend,</span><br><span class="line">	.resume =	es8336_resume,</span><br><span class="line">	.set_bias_level = es8336_set_bias_level,</span><br><span class="line"></span><br><span class="line">	.controls = es8336_snd_controls,</span><br><span class="line">	.num_controls = ARRAY_SIZE(es8336_snd_controls),</span><br><span class="line">	.dapm_widgets = es8336_dapm_widgets,</span><br><span class="line">	.num_dapm_widgets = ARRAY_SIZE(es8336_dapm_widgets),</span><br><span class="line">	.dapm_routes = es8336_dapm_routes,</span><br><span class="line">	.num_dapm_routes = ARRAY_SIZE(es8336_dapm_routes),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="应用层访问Control设备"><a href="#应用层访问Control设备" class="headerlink" title="应用层访问Control设备"></a>应用层访问Control设备</h5><p>Control设备的文件操作集，<code>struct file_operations snd_ctl_f_ops</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sound/core/control.c</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">snd_ctl_f_ops</span> =</span></span><br><span class="line">&#123;</span><br><span class="line">	.owner =	THIS_MODULE,</span><br><span class="line">	.read =		snd_ctl_read,</span><br><span class="line">	.open =		snd_ctl_open,</span><br><span class="line">	.release =	snd_ctl_release,</span><br><span class="line">	.llseek =	no_llseek,</span><br><span class="line">	.poll =		snd_ctl_poll,</span><br><span class="line">	.unlocked_ioctl =	snd_ctl_ioctl,</span><br><span class="line">	.compat_ioctl =	snd_ctl_ioctl_compat,</span><br><span class="line">	.fasync =	snd_ctl_fasync,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="PCM设备"><a href="#PCM设备" class="headerlink" title="PCM设备"></a>PCM设备</h3><p>PCM设备是挂载<code>struct snd_card</code>的devices链表下的一个snd device，一个pcm实例由一个playback stream和一个capture stream组成，这两个stream又分别有一个或多个substream组成，在嵌入式系统中，通常不会有这么复杂，大多数情况下是一个声卡，一个pcm实例，pcm下面有一个playback stream和capture stream，playback和capture下面各自有一个substream</p>
<h4 id="ALSA中pcm相关的数据结构"><a href="#ALSA中pcm相关的数据结构" class="headerlink" title="ALSA中pcm相关的数据结构"></a>ALSA中pcm相关的数据结构</h4><p><code>struct snd_pcm</code>，pcm使用<code>struct snd_pcm</code>数据结构来描述，一个pcm实例由一个playback stream和一个capture stream组成，这两个stream又分别有一个或者多个substream组成</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/sound/pcm.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_pcm</span> &#123;</span></span><br><span class="line">	<span class="comment">/* 指向pcm_runtime-&gt;card-&gt;snd_card */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snd_card</span> *<span class="title">card</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">	<span class="comment">/* pcm设备编号 这里一般情况下就是rtd-&gt;num的值 */</span></span><br><span class="line">	<span class="keyword">int</span> device; <span class="comment">/* device number */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> info_flags;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span> dev_class;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span> dev_subclass;</span><br><span class="line">	<span class="keyword">char</span> id[<span class="number">64</span>];</span><br><span class="line">	<span class="keyword">char</span> name[<span class="number">80</span>];</span><br><span class="line">	<span class="comment">/* streams[0]表示placyback stream，streams[1]表示capture stream */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snd_pcm_str</span> <span class="title">streams</span>[2];</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">open_mutex</span>;</span></span><br><span class="line">	<span class="keyword">wait_queue_head_t</span> open_wait;</span><br><span class="line">	<span class="keyword">void</span> *private_data;</span><br><span class="line">	<span class="keyword">void</span> (*private_free) (struct snd_pcm *pcm);</span><br><span class="line">	<span class="keyword">bool</span> internal; <span class="comment">/* pcm is for internal use only */</span></span><br><span class="line">	<span class="keyword">bool</span> nonatomic; <span class="comment">/* whole PCM operations are in non-atomic context */</span></span><br><span class="line">	<span class="keyword">bool</span> no_device_suspend; <span class="comment">/* don&#x27;t invoke device PM suspend */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> IS_ENABLED(CONFIG_SND_PCM_OSS)</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snd_pcm_oss</span> <span class="title">oss</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>struct snd_pcm_str</code>，用于表示pcm stream，snd_pcm_str的主要作用就是指向<code>snd_pcm_substream</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_pcm_str</span> &#123;</span></span><br><span class="line">	<span class="comment">/* </span></span><br><span class="line"><span class="comment">	 * stream方向：</span></span><br><span class="line"><span class="comment">	 * SNDRV_PCM_STREAM_PLAYBACK表示播放</span></span><br><span class="line"><span class="comment">	 * SNDRV_PCM_STREAM_CAPTURE表示捕获 </span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">int</span> stream;				<span class="comment">/* stream (direction) */</span></span><br><span class="line">	<span class="comment">/* 指向所属pcm */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snd_pcm</span> *<span class="title">pcm</span>;</span></span><br><span class="line">	<span class="comment">/* -- substreams -- */</span></span><br><span class="line">	<span class="comment">/* substream的个数 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> substream_count;</span><br><span class="line">	<span class="comment">/* substream的打开标志 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> substream_opened;</span><br><span class="line">	<span class="comment">/* 用来链接所有的substream */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snd_pcm_substream</span> *<span class="title">substream</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> IS_ENABLED(CONFIG_SND_PCM_OSS)</span></span><br><span class="line">	<span class="comment">/* -- OSS things -- */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snd_pcm_oss_stream</span> <span class="title">oss</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SND_VERBOSE_PROCFS</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snd_info_entry</span> *<span class="title">proc_root</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SND_PCM_XRUN_DEBUG</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> xrun_debug;	<span class="comment">/* 0 = disabled, 1 = verbose, 2 = stacktrace */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snd_kcontrol</span> *<span class="title">chmap_kctl</span>;</span> <span class="comment">/* channel-mapping controls */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> <span class="title">dev</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>struct snd_pcm_substream</code>，用于表pcm substream</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_pcm_substream</span> &#123;</span></span><br><span class="line">	<span class="comment">/* 指向对应的snd_pcm和snd_pcm_str */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snd_pcm</span> *<span class="title">pcm</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snd_pcm_str</span> *<span class="title">pstr</span>;</span></span><br><span class="line">	<span class="comment">/* 指向pcm_runtime */</span></span><br><span class="line">	<span class="keyword">void</span> *private_data;		<span class="comment">/* copied from pcm-&gt;private_data */</span></span><br><span class="line">	<span class="keyword">int</span> number;</span><br><span class="line">	<span class="keyword">char</span> name[<span class="number">32</span>];			<span class="comment">/* substream name */</span></span><br><span class="line">	<span class="keyword">int</span> stream;			<span class="comment">/* stream (direction) */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pm_qos_request</span> <span class="title">latency_pm_qos_req</span>;</span> <span class="comment">/* pm_qos request */</span></span><br><span class="line">	<span class="keyword">size_t</span> buffer_bytes_max;	<span class="comment">/* limit ring buffer size */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snd_dma_buffer</span> <span class="title">dma_buffer</span>;</span></span><br><span class="line">	<span class="keyword">size_t</span> dma_max;</span><br><span class="line">	<span class="comment">/* -- hardware operations -- */</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">snd_pcm_ops</span> *<span class="title">ops</span>;</span></span><br><span class="line">	<span class="comment">/* -- runtime information -- */</span></span><br><span class="line">	<span class="comment">/* pcm 运行时实例，读写数据的时候由它来控制 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snd_pcm_runtime</span> *<span class="title">runtime</span>;</span></span><br><span class="line">        <span class="comment">/* -- timer section -- */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snd_timer</span> *<span class="title">timer</span>;</span>		<span class="comment">/* timer */</span></span><br><span class="line">	<span class="keyword">unsigned</span> timer_running: <span class="number">1</span>;	<span class="comment">/* time is running */</span></span><br><span class="line">	<span class="keyword">long</span> wait_time;	<span class="comment">/* time in ms for R/W to wait for avail */</span></span><br><span class="line">	<span class="comment">/* -- next substream -- */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snd_pcm_substream</span> *<span class="title">next</span>;</span></span><br><span class="line">	<span class="comment">/* -- linked substreams -- */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">link_list</span>;</span>	<span class="comment">/* linked list member */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snd_pcm_group</span> <span class="title">self_group</span>;</span>	<span class="comment">/* fake group for non linked substream (with substream lock inside) */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snd_pcm_group</span> *<span class="title">group</span>;</span>		<span class="comment">/* pointer to current group */</span></span><br><span class="line">	<span class="comment">/* -- assigned files -- */</span></span><br><span class="line">	<span class="keyword">int</span> ref_count;</span><br><span class="line">	<span class="keyword">atomic_t</span> mmap_count;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> f_flags;</span><br><span class="line">	<span class="keyword">void</span> (*pcm_release)(struct snd_pcm_substream *);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">pid</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> IS_ENABLED(CONFIG_SND_PCM_OSS)</span></span><br><span class="line">	<span class="comment">/* -- OSS things -- */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snd_pcm_oss_substream</span> <span class="title">oss</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SND_VERBOSE_PROCFS</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snd_info_entry</span> *<span class="title">proc_root</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_SND_VERBOSE_PROCFS */</span></span></span><br><span class="line">	<span class="comment">/* misc flags */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> hw_opened: <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> managed_buffer_alloc:<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>struct snd_pcm_hw_params</code>结构体，用于配置音频硬件参数的结构体，比如通道数、采样率、数据格式等</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// includ/uapi/sound/asound.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_pcm_hw_params</span> &#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> flags;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snd_mask</span> <span class="title">masks</span>[<span class="title">SNDRV_PCM_HW_PARAM_LAST_MASK</span> -</span></span><br><span class="line"><span class="class">			       <span class="title">SNDRV_PCM_HW_PARAM_FIRST_MASK</span> + 1];</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snd_mask</span> <span class="title">mres</span>[5];</span>	<span class="comment">/* reserved masks */</span></span><br><span class="line">	<span class="comment">/* 用于描述各个硬件参数的取值范围 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snd_interval</span> <span class="title">intervals</span>[<span class="title">SNDRV_PCM_HW_PARAM_LAST_INTERVAL</span> -</span></span><br><span class="line"><span class="class">				        <span class="title">SNDRV_PCM_HW_PARAM_FIRST_INTERVAL</span> + 1];</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snd_interval</span> <span class="title">ires</span>[9];</span>	<span class="comment">/* reserved intervals */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> rmask;		<span class="comment">/* W: requested masks */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> cmask;		<span class="comment">/* R: changed masks */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> info;		<span class="comment">/* R: Info flags for returned setup */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> msbits;		<span class="comment">/* R: used most significant bits */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> rate_num;		<span class="comment">/* R: rate numerator */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> rate_den;		<span class="comment">/* R: rate denominator */</span></span><br><span class="line">	<span class="keyword">snd_pcm_uframes_t</span> fifo_size;	<span class="comment">/* R: chip FIFO size in frames */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> reserved[<span class="number">64</span>];	<span class="comment">/* reserved for future */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="ASoC中pcm相关的数据结构"><a href="#ASoC中pcm相关的数据结构" class="headerlink" title="ASoC中pcm相关的数据结构"></a>ASoC中pcm相关的数据结构</h4><p><code>struct snd_soc_pcm_stream</code>，用于描述SoC pcm stream的信息</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/sound/soc.h</span></span><br><span class="line"><span class="comment">/* SoC PCM stream information */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_pcm_stream</span> &#123;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *stream_name;</span><br><span class="line">	<span class="comment">/* 数据传输的位宽 */</span></span><br><span class="line">	u64 formats;			<span class="comment">/* SNDRV_PCM_FMTBIT_* */</span></span><br><span class="line">	<span class="comment">/* 音频采样率 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> rates;		<span class="comment">/* SNDRV_PCM_RATE_* */</span></span><br><span class="line">	<span class="comment">/* 最低 最高采样率 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> rate_min;		<span class="comment">/* min rate */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> rate_max;		<span class="comment">/* max rate */</span></span><br><span class="line">	<span class="comment">/* 最少通道数 最大通道数 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> channels_min;	<span class="comment">/* min channels */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> channels_max;	<span class="comment">/* max channels */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> sig_bits;		<span class="comment">/* number of bits of content */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>struct snd_soc_pcm_runtime</code>，在注册声卡时会调用<code>soc_new_pcm_runtime()</code>为每一个<code>dai_link</code>分配一个<code>snd_soc_pcm_runtime</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/sound/soc.h</span></span><br><span class="line"><span class="comment">/* SoC machine DAI configuration, glues a codec and cpu DAI together */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_pcm_runtime</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span></span><br><span class="line">	<span class="comment">/* 指向ASoC sound card */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_card</span> *<span class="title">card</span>;</span></span><br><span class="line">	<span class="comment">/* 指向ASoC sound card中对应的dai_link */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dai_link</span> *<span class="title">dai_link</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snd_pcm_ops</span> <span class="title">ops</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> params_select; <span class="comment">/* currently selected param for dai link */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Dynamic PCM BE runtime data */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dpcm_runtime</span> <span class="title">dpcm</span>[2];</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">long</span> pmdown_time;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* runtime devices */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snd_pcm</span> *<span class="title">pcm</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snd_compr</span> *<span class="title">compr</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * dais = cpu_dai + codec_dai</span></span><br><span class="line"><span class="comment">	 * see</span></span><br><span class="line"><span class="comment">	 *	soc_new_pcm_runtime()</span></span><br><span class="line"><span class="comment">	 *	asoc_rtd_to_cpu()</span></span><br><span class="line"><span class="comment">	 *	asoc_rtd_to_codec()</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">/* 用于保存当前音频数据链路上的dai，包括cpu dai, codec dai */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dai</span> **<span class="title">dais</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> num_codecs;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> num_cpus;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dapm_widget</span> *<span class="title">playback_widget</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dapm_widget</span> *<span class="title">capture_widget</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">delayed_work</span> <span class="title">delayed_work</span>;</span></span><br><span class="line">	<span class="keyword">void</span> (*close_delayed_work_func)(struct snd_soc_pcm_runtime *rtd);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_FS</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">debugfs_dpcm_root</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 为ASoC声卡设备的每个pcm runtime会分配一个编号，从0开始 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> num; <span class="comment">/* 0-based and monotonic increasing */</span></span><br><span class="line">	<span class="comment">/* 将当前的pcm runtime链接到ASoC sound card的rtd_list中 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span> <span class="comment">/* rtd list of the soc card */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* function mark */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snd_pcm_substream</span> *<span class="title">mark_startup</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snd_pcm_substream</span> *<span class="title">mark_hw_params</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snd_pcm_substream</span> *<span class="title">mark_trigger</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snd_compr_stream</span>  *<span class="title">mark_compr_startup</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* bit field */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> pop_wait:<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> fe_compr:<span class="number">1</span>; <span class="comment">/* for Dynamic PCM */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> num_components;</span><br><span class="line">	<span class="comment">/* 指向存储当前dai_link上的platform以及codec的component */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_component</span> *<span class="title">components</span>[];</span> <span class="comment">/* CPU/Codec/Platform */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="PCM设备创建过程"><a href="#PCM设备创建过程" class="headerlink" title="PCM设备创建过程"></a>PCM设备创建过程</h4><p><img src="https://raw.githubusercontent.com/JackHuang021/images/master/20240410153336.png"></p>
<h3 id="DAPM相关"><a href="#DAPM相关" class="headerlink" title="DAPM相关"></a>DAPM相关</h3><p>DAPM是Dynamic Audio Power Management的缩写，即动态音频电源管理，是独立于内核其他PM的一套音频电源管理系统，DAPM对所有用户应用程序来说是完全透明的，电源切换的过程都在ASoC核心内完成，DAPM根据当前激活的音频流对声卡中的Mixer等进行配置，来决定音频控件的电源打开和关闭，达到省电的目的</p>
<h4 id="Widget介绍"><a href="#Widget介绍" class="headerlink" title="Widget介绍"></a>Widget介绍</h4><p>Widget是具备路径和电源管理的kcontrol，可以理解为kcontrol的进一步升级和封装，ASoC把系统划分为多个dapm域，每个widget属于某个dapm域，比如同一个codec中的widgets通常位于同一个dapm域，而platform上的widget可能又会位于另一个dapm域中</p>
<h5 id="相关数据结构"><a href="#相关数据结构" class="headerlink" title="相关数据结构"></a>相关数据结构</h5><p><code>struct snd_soc_dapm_widget</code>，用来描述Widget</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/sound/soc_dapm.h</span></span><br><span class="line"><span class="comment">/* dapm widget */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dapm_widget</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">snd_soc_dapm_type</span> <span class="title">id</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *name;		<span class="comment">/* widget name */</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *sname;	<span class="comment">/* stream name */</span></span><br><span class="line">	<span class="comment">/* 链接到snd_soc_card的widgets链表 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dapm_context</span> *<span class="title">dapm</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">void</span> *priv;				<span class="comment">/* widget specific data */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">regulator</span> *<span class="title">regulator</span>;</span>		<span class="comment">/* attached regulator */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pinctrl</span> *<span class="title">pinctrl</span>;</span>		<span class="comment">/* attached pinctrl */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* dapm control */</span></span><br><span class="line">	<span class="comment">/* 用于dapm控制的寄存器地址 */</span></span><br><span class="line">	<span class="keyword">int</span> reg;				<span class="comment">/* negative reg = no direct dapm */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> shift;			<span class="comment">/* bits to shift */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> mask;			<span class="comment">/* non-shifted mask */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> on_val;			<span class="comment">/* on state value */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> off_val;			<span class="comment">/* off state value */</span></span><br><span class="line">	<span class="comment">/* 表示widget的上电状态 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> power:<span class="number">1</span>;			<span class="comment">/* block power status */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> active:<span class="number">1</span>;			<span class="comment">/* active stream on DAC, ADC&#x27;s */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> connected:<span class="number">1</span>;		<span class="comment">/* connected codec pin */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="keyword">new</span>:<span class="number">1</span>;			<span class="comment">/* cnew complete */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> force:<span class="number">1</span>;			<span class="comment">/* force state */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> ignore_suspend:<span class="number">1</span>;         <span class="comment">/* kept enabled over suspend */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> new_power:<span class="number">1</span>;		<span class="comment">/* power from this run */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> power_checked:<span class="number">1</span>;		<span class="comment">/* power checked this run */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> is_supply:<span class="number">1</span>;		<span class="comment">/* Widget is a supply type widget */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> is_ep:<span class="number">2</span>;			<span class="comment">/* Widget is a endpoint type widget */</span></span><br><span class="line">	<span class="keyword">int</span> subseq;				<span class="comment">/* sort within widget type */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> (*power_check)(struct snd_soc_dapm_widget *w);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* external events */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span> event_flags;		<span class="comment">/* flags to specify event types */</span></span><br><span class="line">	<span class="keyword">int</span> (*event)(struct snd_soc_dapm_widget*, struct snd_kcontrol *, <span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* kcontrols that relate to this widget */</span></span><br><span class="line">	<span class="keyword">int</span> num_kcontrols;</span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">snd_kcontrol_new</span> *<span class="title">kcontrol_news</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snd_kcontrol</span> **<span class="title">kcontrols</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dobj</span> <span class="title">dobj</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* widget input and output edges */</span></span><br><span class="line">	<span class="comment">/* edge[0] 链接输出端连接的struct snd_soc_dapm_path */</span></span><br><span class="line">	<span class="comment">/* edge[1] 链接输入端连接的struct snd_soc_dapm_path */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">edges</span>[2];</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* used during DAPM updates */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">work_list</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">power_list</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">dirty</span>;</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * endpoints[0]保存从当前widget向前遍历，连接至SND_SOC_DAPM_EP_SOURCE</span></span><br><span class="line"><span class="comment">	 * 类型端点的路径数量</span></span><br><span class="line"><span class="comment">	 * endpoints[1]保存从当前widget向后遍历，连接至SND_SOC_DAPM_EP_SINK</span></span><br><span class="line"><span class="comment">	 * 类型端点的路径数量</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">int</span> endpoints[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">clk</span> *<span class="title">clk</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> channel;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>struct snd_soc_dapm_context</code>，描述dapm域</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/sound/soc_dapm.h</span></span><br><span class="line"><span class="comment">/* DAPM context */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dapm_context</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">snd_soc_bias_level</span> <span class="title">bias_level</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> idle_bias_off:<span class="number">1</span>; <span class="comment">/* Use BIAS_OFF instead of STANDBY */</span></span><br><span class="line">	<span class="comment">/* Go to BIAS_OFF in suspend if the DAPM context is idle */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> suspend_bias_off:<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span> <span class="comment">/* from parent - for debug */</span></span><br><span class="line">	<span class="comment">/* 所属的component */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_component</span> *<span class="title">component</span>;</span> <span class="comment">/* parent component */</span></span><br><span class="line">	<span class="comment">/* 所属的snd_soc_card */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_card</span> *<span class="title">card</span>;</span> <span class="comment">/* parent card */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* used during DAPM updates */</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">snd_soc_bias_level</span> <span class="title">target_bias_level</span>;</span></span><br><span class="line">	<span class="comment">/* 链接到snd_soc_card的dapm_list链表中 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dapm_wcache</span> <span class="title">path_sink_cache</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dapm_wcache</span> <span class="title">path_source_cache</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_FS</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">debugfs_dapm</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="辅助宏定义widget"><a href="#辅助宏定义widget" class="headerlink" title="辅助宏定义widget"></a>辅助宏定义widget</h5><p>DAPM系统提供的一些辅助宏定义来定义各种类型的widget和它所用到的dapm kcontrol（这些由DAPM系统提供的辅助宏定义的kcontrol我们统一称为dapm kcontrol，以便和普通的kcontrol进行区分），这些宏定义在<code>include/sound/soc_dapm.h</code>中，分类为了4个不同域的widget辅助定义宏</p>
<p>platform域widget，一般是一些需要物理连接的输入、输出接口，这些widget是没有寄存器控制位来控制widget的电源状态的，因此reg字段被设置为SND_SOC_NOPM</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/sound/soc_dapm.h</span></span><br><span class="line"><span class="comment">/* platform domain */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SND_SOC_DAPM_SIGGEN(wname) \</span></span><br><span class="line"><span class="meta">&#123;	.id = snd_soc_dapm_siggen, .name = wname, .kcontrol_news = NULL, \</span></span><br><span class="line"><span class="meta">	.num_kcontrols = 0, .reg = SND_SOC_NOPM &#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SND_SOC_DAPM_SINK(wname) \</span></span><br><span class="line"><span class="meta">&#123;	.id = snd_soc_dapm_sink, .name = wname, .kcontrol_news = NULL, \</span></span><br><span class="line"><span class="meta">	.num_kcontrols = 0, .reg = SND_SOC_NOPM &#125;</span></span><br><span class="line"><span class="comment">/* 对应codec芯片的输入引脚 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SND_SOC_DAPM_INPUT(wname) \</span></span><br><span class="line"><span class="meta">&#123;	.id = snd_soc_dapm_input, .name = wname, .kcontrol_news = NULL, \</span></span><br><span class="line"><span class="meta">	.num_kcontrols = 0, .reg = SND_SOC_NOPM &#125;</span></span><br><span class="line"><span class="comment">/* 对应codec芯片的输出引脚 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SND_SOC_DAPM_OUTPUT(wname) \</span></span><br><span class="line"><span class="meta">&#123;	.id = snd_soc_dapm_output, .name = wname, .kcontrol_news = NULL, \</span></span><br><span class="line"><span class="meta">	.num_kcontrols = 0, .reg = SND_SOC_NOPM &#125;</span></span><br><span class="line"><span class="comment">/* 对应麦克风 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SND_SOC_DAPM_MIC(wname, wevent) \</span></span><br><span class="line"><span class="meta">&#123;	.id = snd_soc_dapm_mic, .name = wname, .kcontrol_news = NULL, \</span></span><br><span class="line"><span class="meta">	.num_kcontrols = 0, .reg = SND_SOC_NOPM, .event = wevent, \</span></span><br><span class="line"><span class="meta">	.event_flags = SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD&#125;</span></span><br><span class="line"><span class="comment">/* 对应耳机 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SND_SOC_DAPM_HP(wname, wevent) \</span></span><br><span class="line"><span class="meta">&#123;	.id = snd_soc_dapm_hp, .name = wname, .kcontrol_news = NULL, \</span></span><br><span class="line"><span class="meta">	.num_kcontrols = 0, .reg = SND_SOC_NOPM, .event = wevent, \</span></span><br><span class="line"><span class="meta">	.event_flags = SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD&#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SND_SOC_DAPM_SPK(wname, wevent) \</span></span><br><span class="line"><span class="meta">&#123;	.id = snd_soc_dapm_spk, .name = wname, .kcontrol_news = NULL, \</span></span><br><span class="line"><span class="meta">	.num_kcontrols = 0, .reg = SND_SOC_NOPM, .event = wevent, \</span></span><br><span class="line"><span class="meta">	.event_flags = SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD&#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SND_SOC_DAPM_LINE(wname, wevent) \</span></span><br><span class="line"><span class="meta">&#123;	.id = snd_soc_dapm_line, .name = wname, .kcontrol_news = NULL, \</span></span><br><span class="line"><span class="meta">	.num_kcontrols = 0, .reg = SND_SOC_NOPM, .event = wevent, \</span></span><br><span class="line"><span class="meta">	.event_flags = SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SND_SOC_DAPM_INIT_REG_VAL(wreg, wshift, winvert) \</span></span><br><span class="line"><span class="meta">	.reg = wreg, .mask = 1, .shift = wshift, \</span></span><br><span class="line"><span class="meta">	.on_val = winvert ? 0 : 1, .off_val = winvert ? 1 : 0</span></span><br></pre></td></tr></table></figure>

<p>path域widget，一般指codec内部的Mixer、Mux、Switch、Demux等控制音频路径的widget，这些widget是有相应的寄存器控制的，DAPM框架在扫描和更新音频路径时，会利用这些寄存器来控制widget的电源状态</p>
<p>es8336的示例，通过es8336的datasheet可知，Left Hp Mixer通过ES8336_HPMIX_PDN_REG15的bit4来控制Left Hp Mixer的电源状态，而es8336_out_left_mixer是通过ES8336_HPMIX_SWITCH_REG14寄存器的bit7来控制Left DAC的开关</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Output mixer  */</span></span><br><span class="line">SND_SOC_DAPM_MIXER(<span class="string">&quot;Left Hp mixer&quot;</span>, ES8336_HPMIX_PDN_REG15,</span><br><span class="line">			<span class="number">4</span>, <span class="number">1</span>, &amp;es8336_out_left_mix[<span class="number">0</span>],</span><br><span class="line">			ARRAY_SIZE(es8336_out_left_mix)),</span><br><span class="line"></span><br><span class="line"><span class="comment">/* headphone Output Mixer */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">snd_kcontrol_new</span> <span class="title">es8336_out_left_mix</span>[] =</span> &#123;</span><br><span class="line">	SOC_DAPM_SINGLE(<span class="string">&quot;LLIN Switch&quot;</span>, ES8336_HPMIX_SWITCH_REG14,</span><br><span class="line">			<span class="number">6</span>, <span class="number">1</span>, <span class="number">0</span>),</span><br><span class="line">	SOC_DAPM_SINGLE(<span class="string">&quot;Left DAC Switch&quot;</span>, ES8336_HPMIX_SWITCH_REG14,</span><br><span class="line">			<span class="number">7</span>, <span class="number">1</span>, <span class="number">0</span>),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>stream域widget，指那些需要处理音频数据流的widget，例如ADC、DAC、AIF IN、AIF OUT等</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/sound/soc-dapm.h</span></span><br><span class="line"><span class="comment">/* stream domain */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SND_SOC_DAPM_AIF_IN(wname, stname, wchan, wreg, wshift, winvert) \</span></span><br><span class="line"><span class="meta">&#123;	.id = snd_soc_dapm_aif_in, .name = wname, .sname = stname, \</span></span><br><span class="line"><span class="meta">	.channel = wchan, SND_SOC_DAPM_INIT_REG_VAL(wreg, wshift, winvert), &#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SND_SOC_DAPM_AIF_IN_E(wname, stname, wchan, wreg, wshift, winvert, \</span></span><br><span class="line"><span class="meta">			      wevent, wflags)				\</span></span><br><span class="line"><span class="meta">&#123;	.id = snd_soc_dapm_aif_in, .name = wname, .sname = stname, \</span></span><br><span class="line"><span class="meta">	.channel = wchan, SND_SOC_DAPM_INIT_REG_VAL(wreg, wshift, winvert), \</span></span><br><span class="line"><span class="meta">	.event = wevent, .event_flags = wflags &#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SND_SOC_DAPM_AIF_OUT(wname, stname, wchan, wreg, wshift, winvert) \</span></span><br><span class="line"><span class="meta">&#123;	.id = snd_soc_dapm_aif_out, .name = wname, .sname = stname, \</span></span><br><span class="line"><span class="meta">	.channel = wchan, SND_SOC_DAPM_INIT_REG_VAL(wreg, wshift, winvert), &#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SND_SOC_DAPM_AIF_OUT_E(wname, stname, wchan, wreg, wshift, winvert, \</span></span><br><span class="line"><span class="meta">			     wevent, wflags)				\</span></span><br><span class="line"><span class="meta">&#123;	.id = snd_soc_dapm_aif_out, .name = wname, .sname = stname, \</span></span><br><span class="line"><span class="meta">	.channel = wchan, SND_SOC_DAPM_INIT_REG_VAL(wreg, wshift, winvert), \</span></span><br><span class="line"><span class="meta">	.event = wevent, .event_flags = wflags &#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SND_SOC_DAPM_DAC(wname, stname, wreg, wshift, winvert) \</span></span><br><span class="line"><span class="meta">&#123;	.id = snd_soc_dapm_dac, .name = wname, .sname = stname, \</span></span><br><span class="line"><span class="meta">	SND_SOC_DAPM_INIT_REG_VAL(wreg, wshift, winvert) &#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SND_SOC_DAPM_DAC_E(wname, stname, wreg, wshift, winvert, \</span></span><br><span class="line"><span class="meta">			   wevent, wflags)				\</span></span><br><span class="line"><span class="meta">&#123;	.id = snd_soc_dapm_dac, .name = wname, .sname = stname, \</span></span><br><span class="line"><span class="meta">	SND_SOC_DAPM_INIT_REG_VAL(wreg, wshift, winvert), \</span></span><br><span class="line"><span class="meta">	.event = wevent, .event_flags = wflags&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SND_SOC_DAPM_ADC(wname, stname, wreg, wshift, winvert) \</span></span><br><span class="line"><span class="meta">&#123;	.id = snd_soc_dapm_adc, .name = wname, .sname = stname, \</span></span><br><span class="line"><span class="meta">	SND_SOC_DAPM_INIT_REG_VAL(wreg, wshift, winvert), &#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SND_SOC_DAPM_ADC_E(wname, stname, wreg, wshift, winvert, \</span></span><br><span class="line"><span class="meta">			   wevent, wflags)				\</span></span><br><span class="line"><span class="meta">&#123;	.id = snd_soc_dapm_adc, .name = wname, .sname = stname, \</span></span><br><span class="line"><span class="meta">	SND_SOC_DAPM_INIT_REG_VAL(wreg, wshift, winvert), \</span></span><br><span class="line"><span class="meta">	.event = wevent, .event_flags = wflags&#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SND_SOC_DAPM_CLOCK_SUPPLY(wname) \</span></span><br><span class="line"><span class="meta">&#123;	.id = snd_soc_dapm_clock_supply, .name = wname, \</span></span><br><span class="line"><span class="meta">	.reg = SND_SOC_NOPM, .event = dapm_clock_event, \</span></span><br><span class="line"><span class="meta">	.event_flags = SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD &#125;</span></span><br></pre></td></tr></table></figure>

<h5 id="辅助宏定义dapm-kcontrol"><a href="#辅助宏定义dapm-kcontrol" class="headerlink" title="辅助宏定义dapm kcontrol"></a>辅助宏定义dapm kcontrol</h5><p>对于音频路径上的Mixer或Mux类型的widget，他们包含了若干个kcontrol，dapm利用这些kcontrol完成音频的控制</p>
<p>es8336驱动中的示例，用来控制Left DAC的开关</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* headphone Output Mixer */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">snd_kcontrol_new</span> <span class="title">es8336_out_left_mix</span>[] =</span> &#123;</span><br><span class="line">	SOC_DAPM_SINGLE(<span class="string">&quot;LLIN Switch&quot;</span>, ES8336_HPMIX_SWITCH_REG14,</span><br><span class="line">			<span class="number">6</span>, <span class="number">1</span>, <span class="number">0</span>),</span><br><span class="line">	SOC_DAPM_SINGLE(<span class="string">&quot;Left DAC Switch&quot;</span>, ES8336_HPMIX_SWITCH_REG14,</span><br><span class="line">			<span class="number">7</span>, <span class="number">1</span>, <span class="number">0</span>),</span><br></pre></td></tr></table></figure>

<h4 id="Path介绍"><a href="#Path介绍" class="headerlink" title="Path介绍"></a>Path介绍</h4><p>DAPM提出了path的概念，path将一个widget的输出端和另一个widget的输入端连接在一起</p>
<p>path使用<code>struct snd_soc_dapm_path</code>来描述，当widget之间发生连接关系时，snd_soc_dapm_path作为连接者，它的source字段会指向路径起始端widget，sink字段会指向路径目标端的widget</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/sound/soc_dapm.h</span></span><br><span class="line"><span class="comment">/* dapm audio path between two widgets */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dapm_path</span> &#123;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * source (input) and sink (output) widgets</span></span><br><span class="line"><span class="comment">	 * The union is for convience, since it is a lot nicer to type</span></span><br><span class="line"><span class="comment">	 * p-&gt;source, rather than p-&gt;node[SND_SOC_DAPM_DIR_IN]</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">			<span class="comment">/* 输入端widget */</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dapm_widget</span> *<span class="title">source</span>;</span></span><br><span class="line">			<span class="comment">/* 输出端widget */</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dapm_widget</span> *<span class="title">sink</span>;</span></span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dapm_widget</span> *<span class="title">node</span>[2];</span></span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* status */</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * connect用来表示source widget和sink widget之间的连接状态 </span></span><br><span class="line"><span class="comment">	 * 如果在source widget和sink widget中间有kcontrol可以控制通断，</span></span><br><span class="line"><span class="comment">	 * 那么connect表示的就是kcontrol的通断状态，对于两个直连的widget，</span></span><br><span class="line"><span class="comment">	 * connect值始终为1。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	u32 connect:<span class="number">1</span>;	<span class="comment">/* source and sink widgets are connected */</span></span><br><span class="line">	u32 walking:<span class="number">1</span>;  <span class="comment">/* path is in the process of being walked */</span></span><br><span class="line">	u32 weak:<span class="number">1</span>;	<span class="comment">/* path ignored for power management */</span></span><br><span class="line">	u32 is_supply:<span class="number">1</span>;	<span class="comment">/* At least one of the connected widgets is a supply */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> (*connected)(struct snd_soc_dapm_widget *source,</span><br><span class="line">			 struct snd_soc_dapm_widget *sink);</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list_node</span>[2];</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list_kcontrol</span>;</span></span><br><span class="line">	<span class="comment">/* 链接到声卡的paths链表中 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="complete-path"><a href="#complete-path" class="headerlink" title="complete path"></a>complete path</h5><p>complete path: 一条完整的音频路径必须要有起点和终点，我们把这些起点和终点widget称之为端点widget</p>
<p>下面这些类型的widget可以称为端点widget</p>
<table>
<thead>
<tr>
<th align="center">分类</th>
<th align="left">widget类型</th>
</tr>
</thead>
<tbody><tr>
<td align="center">codec的输入输出引脚</td>
<td align="left">snd_soc_dapm_input, SND_SOC_DAPM_EP_SOURCE类型端点</td>
</tr>
<tr>
<td align="center"></td>
<td align="left">snd_soc_dapm_output, SND_SOC_DAPM_EP_SINK类型端点</td>
</tr>
<tr>
<td align="center">codec外接音频设备</td>
<td align="left">snd_soc_dapm_mic, SND_SOC_DAPM_EP_SOURCE类型端点</td>
</tr>
<tr>
<td align="center"></td>
<td align="left">snd_soc_dapm_hp, SND_SOC_DAPM_EP_SINK类型端点</td>
</tr>
<tr>
<td align="center"></td>
<td align="left">snd_soc_dapm_spk, SND_SOC_DAPM_EP_SINK类型端点</td>
</tr>
<tr>
<td align="center"></td>
<td align="left">snd_soc_dapm_line</td>
</tr>
<tr>
<td align="center">dai widget</td>
<td align="left">snd_soc_dapm_dai_in</td>
</tr>
<tr>
<td align="center"></td>
<td align="left">snd_soc_dapm_dai_out</td>
</tr>
</tbody></table>
<p>DAPM要给一个widget上电的其中一个条件是：这个widget位于一条完整路径上，即向前、向后查找连接的widget均能找到一个端点widget，并且路径上的widget、path都是处于连接状态的</p>
<h4 id="Route介绍"><a href="#Route介绍" class="headerlink" title="Route介绍"></a>Route介绍</h4><p>一个路径包括：起始端widget -&gt; path的输入端 -&gt; path的输出 -&gt; 目标端widget，DAPM使用<code>struct snd_soc_dapm_route</code>结构来描述这样一个完整路径route</p>
<p><code>struct snd_soc_dapm_route</code>结构体，用来描述一个路径</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * DAPM audio route definition.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Defines an audio route originating at source via control and finishing</span></span><br><span class="line"><span class="comment"> * at sink.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dapm_route</span> &#123;</span></span><br><span class="line">	<span class="comment">/* 指向目标端widget的名称 */</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *sink;</span><br><span class="line">	<span class="comment">/* 指向负责控制该连接所对应的kcontrol名称 */</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *control;</span><br><span class="line">	<span class="comment">/* 指向起始端widget的名称 */</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *source;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Note: currently only supported for links where source is a supply */</span></span><br><span class="line">	<span class="keyword">int</span> (*connected)(struct snd_soc_dapm_widget *source,</span><br><span class="line">			 struct snd_soc_dapm_widget *sink);</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dobj</span> <span class="title">dobj</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里直接使用名称来描述连接关系，所有定义好的route，最后都要注册到dapm系统中，dapm会根据这些名字找出相应的widget，并动态地生成所需要的snd_soc_dapm_path结构，正确地处理各个链表和指针的关系，实现两个widget之间的连接。</p>
<h3 id="machine驱动-以Phytium-DP音频为例"><a href="#machine驱动-以Phytium-DP音频为例" class="headerlink" title="machine驱动 以Phytium DP音频为例"></a>machine驱动 以Phytium DP音频为例</h3><p>这里通过飞腾dp音频驱动来看一下DP声卡注册的过程</p>
<p><code>struct snd_soc_card</code>结构体定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sound/soc/phytium/pmdk_dp.c</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_card</span> <span class="title">pmdk</span> =</span> &#123;</span><br><span class="line">	.name = <span class="string">&quot;PMDK-I2S&quot;</span>,</span><br><span class="line">	.owner = THIS_MODULE,</span><br><span class="line"></span><br><span class="line">	.dapm_widgets = pmdk_dp_dapm_widgets,</span><br><span class="line">	.num_dapm_widgets = ARRAY_SIZE(pmdk_dp_dapm_widgets),</span><br><span class="line">	.controls = pmdk_controls,</span><br><span class="line">	.num_controls = ARRAY_SIZE(pmdk_controls),</span><br><span class="line">	.dapm_routes = pmdk_dp_audio_map,</span><br><span class="line">	.num_dapm_routes = ARRAY_SIZE(pmdk_dp_audio_map),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>struct snd_soc_dai_link</code>的定义，这里用到了<code>SND_SOC_DAILINK_DEFS</code>及<code>SND_SOC_DAILINK_REG</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SND_SOC_DAILINK_DEFS(pmdk_dp0_dai,</span><br><span class="line">	DAILINK_COMP_ARRAY(COMP_CPU(<span class="string">&quot;phytium-i2s-dp0&quot;</span>)),</span><br><span class="line">	DAILINK_COMP_ARRAY(COMP_CODEC(<span class="string">&quot;hdmi-audio-codec.1346918656&quot;</span>, <span class="string">&quot;i2s-hifi&quot;</span>)),</span><br><span class="line">	DAILINK_COMP_ARRAY(COMP_PLATFORM(<span class="string">&quot;snd-soc-dummy&quot;</span>)));</span><br><span class="line"></span><br><span class="line">SND_SOC_DAILINK_DEFS(pmdk_dp1_dai,</span><br><span class="line">	DAILINK_COMP_ARRAY(COMP_CPU(<span class="string">&quot;phytium-i2s-dp1&quot;</span>)),</span><br><span class="line">	DAILINK_COMP_ARRAY(COMP_CODEC(<span class="string">&quot;hdmi-audio-codec.1346918657&quot;</span>, <span class="string">&quot;i2s-hifi&quot;</span>)),</span><br><span class="line">	DAILINK_COMP_ARRAY(COMP_PLATFORM(<span class="string">&quot;snd-soc-dummy&quot;</span>)));</span><br><span class="line"></span><br><span class="line">SND_SOC_DAILINK_DEFS(pmdk_dp2_dai,</span><br><span class="line">	DAILINK_COMP_ARRAY(COMP_CPU(<span class="string">&quot;phytium-i2s-dp2&quot;</span>)),</span><br><span class="line">	DAILINK_COMP_ARRAY(COMP_CODEC(<span class="string">&quot;hdmi-audio-codec.1346918658&quot;</span>, <span class="string">&quot;i2s-hifi&quot;</span>)),</span><br><span class="line">	DAILINK_COMP_ARRAY(COMP_PLATFORM(<span class="string">&quot;snd-soc-dummy&quot;</span>)));</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dai_link</span> <span class="title">pmdk_dai_local</span>[] =</span> &#123;</span><br><span class="line">&#123;</span><br><span class="line">	.name = <span class="string">&quot;Phytium dp0-audio&quot;</span>,</span><br><span class="line">	.stream_name = <span class="string">&quot;Playback&quot;</span>,</span><br><span class="line">	.dai_fmt = SMDK_DAI_FMT,</span><br><span class="line">	.init = pmdk_dp0_init,</span><br><span class="line">	SND_SOC_DAILINK_REG(pmdk_dp0_dai),</span><br><span class="line">&#125;,&#123;</span><br><span class="line">	.name = <span class="string">&quot;Phytium dp1-audio&quot;</span>,</span><br><span class="line">	.stream_name = <span class="string">&quot;Playback&quot;</span>,</span><br><span class="line">	.dai_fmt = SMDK_DAI_FMT,</span><br><span class="line">	.init = pmdk_dp1_init,</span><br><span class="line">	SND_SOC_DAILINK_REG(pmdk_dp1_dai),</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">	.name = <span class="string">&quot;Phytium dp2-audio&quot;</span>,</span><br><span class="line">	.stream_name = <span class="string">&quot;Playback&quot;</span>,</span><br><span class="line">	.dai_fmt = SMDK_DAI_FMT,</span><br><span class="line">	.init = pmdk_dp2_init,</span><br><span class="line">	SND_SOC_DAILINK_REG(pmdk_dp2_dai),</span><br><span class="line">&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>展开其中一个dai_link为</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">snc_soc_dai_link_component</span> <span class="title">pmdk_dp0_dai_cpus</span>[] =</span> &#123;</span><br><span class="line">    .dai_name = <span class="string">&quot;phytium_i2s_dp0&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">snc_soc_dai_link_component</span> <span class="title">pmdk_dp0_dai_codecs</span>[] =</span> &#123;</span><br><span class="line">    .name = <span class="string">&quot;hdmi-audio-codec.1346918656&quot;</span>,</span><br><span class="line">    .dai_name = <span class="string">&quot;i2s_hifi&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">snc_soc_dai_link_component</span> <span class="title">pmdk_dp0_dai_platforms</span>[] =</span> &#123;</span><br><span class="line">    .name = <span class="string">&quot;snd_soc_dummy&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SND_SOC_DAILINK_REG(pmdk_dp0_dai);</span><br><span class="line"></span><br><span class="line">SND_SOC_DAILINK_REGx(pmdk_dp0_dai,</span><br><span class="line">                     SND_SOC_DAILINK_REG3,</span><br><span class="line">                     SND_SOC_DAILINK_REG2,</span><br><span class="line">                     SND_SOC_DAILINK_REG1)(pmdk_dp0_dai)</span><br><span class="line"></span><br><span class="line">SND_SOC_DAILINK_REG1(pmdk_dp0_dai)</span><br><span class="line"></span><br><span class="line">SND_SOC_DAILINK_REG3(pmdk_dp0_dai_cpus, pmdk_dp0_dai_codecs, pmdk_dp0_dai_platforms)</span><br><span class="line"></span><br><span class="line">.cpu            = pdmk_dp0_dai_cpus,</span><br><span class="line">.num_cpus       = ARRAY_SIZE(pdmk_dp0_dai_cpus),</span><br><span class="line">.codecs         = pmdk_dp0_dai_codecs,</span><br><span class="line">.num_codecs     = ARRAY_SIZE(pdmk_dp0_dai_codecs),</span><br><span class="line">.platforms      = pmdk_dp0_dai_platforms</span><br><span class="line">.num_platforms  = ARRAY_SIZE(pdmk_dp0_dai_platforms)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> struct snd_soc_dai_link pmdk_dai_local[] = &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        .name = <span class="string">&quot;Phyitum dp0-audio&quot;</span>,</span><br><span class="line">        .stream_name = <span class="string">&quot;Playback&quot;</span>,</span><br><span class="line">        .dai_fmt = SMDK_DAI_FMT,</span><br><span class="line">        .init = pmdk_dp0_init,</span><br><span class="line">        .cpu            = pdmk_dp0_dai_cpus,</span><br><span class="line">        .num_cpus       = ARRAY_SIZE(pdmk_dp0_dai_cpus),</span><br><span class="line">        .codecs         = pmdk_dp0_dai_codecs,</span><br><span class="line">        .num_codecs     = ARRAY_SIZE(pdmk_dp0_dai_codecs),</span><br><span class="line">        .platforms      = pmdk_dp0_dai_platforms</span><br><span class="line">        .num_platforms  = ARRAY_SIZE(pdmk_dp0_dai_platforms)</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="machine驱动-以asoc-simple-card为例"><a href="#machine驱动-以asoc-simple-card为例" class="headerlink" title="machine驱动 以asoc-simple-card为例"></a>machine驱动 以asoc-simple-card为例</h3><p>ASoC声卡的注册从machine驱动开始，machine驱动相关的主要数据结构如下：</p>
<ul>
<li><code>struct snd_soc_card</code>: ASoC中的核心数据结构，对ASoC声卡进行抽象</li>
<li><code>struct snd_soc_dai_link</code>: 用来描述音频数据链路，在snd_soc_dai_link中，指定了platform, codec, codec_dai, cpu_dai的名字</li>
<li><code>struct snd_soc_dai_link_components</code>: 保存components的名称和设备树节点，用于后续查找component</li>
</ul>
<h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p><code>struct snd_soc_card</code>结构体，对ASoC声卡的抽象，machine驱动需要对其实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/sound/soc.h</span></span><br><span class="line"><span class="comment">/* SoC card */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_card</span> &#123;</span></span><br><span class="line">	<span class="comment">/* 声卡的名称，如果使用设备树，解析simple-audio-card,name得到 */</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *long_name;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *driver_name;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *components;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DMI</span></span><br><span class="line">	<span class="keyword">char</span> dmi_longname[<span class="number">80</span>];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_DMI */</span></span></span><br><span class="line">	<span class="keyword">char</span> topology_shortname[<span class="number">32</span>];</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span></span><br><span class="line">	<span class="comment">/* 指向ALSA声卡 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snd_card</span> *<span class="title">snd_card</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">mutex</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">dapm_mutex</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Mutex for PCM operations */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">pcm_mutex</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">snd_soc_pcm_subclass</span> <span class="title">pcm_subclass</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> (*probe)(struct snd_soc_card *card);</span><br><span class="line">	<span class="keyword">int</span> (*late_probe)(struct snd_soc_card *card);</span><br><span class="line">	<span class="keyword">int</span> (*remove)(struct snd_soc_card *card);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* the pre and post PM functions are used to do any PM work before and</span></span><br><span class="line"><span class="comment">	 * after the codec and DAI&#x27;s do any PM work. */</span></span><br><span class="line">	<span class="keyword">int</span> (*suspend_pre)(struct snd_soc_card *card);</span><br><span class="line">	<span class="keyword">int</span> (*suspend_post)(struct snd_soc_card *card);</span><br><span class="line">	<span class="keyword">int</span> (*resume_pre)(struct snd_soc_card *card);</span><br><span class="line">	<span class="keyword">int</span> (*resume_post)(struct snd_soc_card *card);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* callbacks */</span></span><br><span class="line">	<span class="keyword">int</span> (*set_bias_level)(struct snd_soc_card *,</span><br><span class="line">			      struct snd_soc_dapm_context *dapm,</span><br><span class="line">			      <span class="keyword">enum</span> snd_soc_bias_level level);</span><br><span class="line">	<span class="keyword">int</span> (*set_bias_level_post)(struct snd_soc_card *,</span><br><span class="line">				   struct snd_soc_dapm_context *dapm,</span><br><span class="line">				   <span class="keyword">enum</span> snd_soc_bias_level level);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> (*add_dai_link)(struct snd_soc_card *,</span><br><span class="line">			    struct snd_soc_dai_link *link);</span><br><span class="line">	<span class="keyword">void</span> (*remove_dai_link)(struct snd_soc_card *,</span><br><span class="line">			    struct snd_soc_dai_link *link);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">long</span> pmdown_time;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* CPU &lt;--&gt; Codec DAI links  */</span></span><br><span class="line">	<span class="comment">/* 存储所有的dai link */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dai_link</span> *<span class="title">dai_link</span>;</span>  <span class="comment">/* predefined links only */</span></span><br><span class="line">	<span class="comment">/* dai_link的数量 */</span></span><br><span class="line">	<span class="keyword">int</span> num_links;  <span class="comment">/* predefined links only */</span></span><br><span class="line">	<span class="comment">/* 链接所有的snd_soc_pcm_runtime，一个dai_link对应一个runtime */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">rtd_list</span>;</span></span><br><span class="line">	<span class="comment">/* pcm runtime的数量 */</span></span><br><span class="line">	<span class="keyword">int</span> num_rtd;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* optional codec specific configuration */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_codec_conf</span> *<span class="title">codec_conf</span>;</span></span><br><span class="line">	<span class="keyword">int</span> num_configs;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * optional auxiliary devices such as amplifiers or codecs with DAI</span></span><br><span class="line"><span class="comment">	 * link unused</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_aux_dev</span> *<span class="title">aux_dev</span>;</span></span><br><span class="line">	<span class="keyword">int</span> num_aux_devs;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">aux_comp_list</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">snd_kcontrol_new</span> *<span class="title">controls</span>;</span></span><br><span class="line">	<span class="keyword">int</span> num_controls;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Card-specific routes and widgets.</span></span><br><span class="line"><span class="comment">	 * Note: of_dapm_xxx for Device Tree; Otherwise for driver build-in.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dapm_widget</span> *<span class="title">dapm_widgets</span>;</span></span><br><span class="line">	<span class="keyword">int</span> num_dapm_widgets;</span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dapm_route</span> *<span class="title">dapm_routes</span>;</span></span><br><span class="line">	<span class="keyword">int</span> num_dapm_routes;</span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dapm_widget</span> *<span class="title">of_dapm_widgets</span>;</span></span><br><span class="line">	<span class="keyword">int</span> num_of_dapm_widgets;</span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dapm_route</span> *<span class="title">of_dapm_routes</span>;</span></span><br><span class="line">	<span class="keyword">int</span> num_of_dapm_routes;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* lists of probed devices belonging to this card */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">component_dev_list</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">widgets</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">paths</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">dapm_list</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">dapm_dirty</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* attached dynamic objects */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">dobj_list</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Generic DAPM context for the card */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dapm_context</span> <span class="title">dapm</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dapm_stats</span> <span class="title">dapm_stats</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dapm_update</span> *<span class="title">update</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_FS</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">debugfs_card_root</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PM_SLEEP</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">deferred_resume_work</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	u32 pop_time;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* bit field */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> instantiated:<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> topology_shortname_created:<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> fully_routed:<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> disable_route_checks:<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> probed:<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> component_chaining:<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">void</span> *drvdata;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>struct snd_soc_dai_link</code>结构体，描述音频数据链路</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/sound/soc.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dai_link</span> &#123;</span></span><br><span class="line">	<span class="comment">/* config - must be set by machine driver */</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *name;			<span class="comment">/* Codec name */</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *stream_name;		<span class="comment">/* Stream name */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * You MAY specify the link&#x27;s CPU-side device, either by device name,</span></span><br><span class="line"><span class="comment">	 * or by DT/OF node, but not both. If this information is omitted,</span></span><br><span class="line"><span class="comment">	 * the CPU-side DAI is matched using .cpu_dai_name only, which hence</span></span><br><span class="line"><span class="comment">	 * must be globally unique. These fields are currently typically used</span></span><br><span class="line"><span class="comment">	 * only for codec to codec links, or systems using device tree.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * You MAY specify the DAI name of the CPU DAI. If this information is</span></span><br><span class="line"><span class="comment">	 * omitted, the CPU-side DAI is matched using .cpu_name/.cpu_of_node</span></span><br><span class="line"><span class="comment">	 * only, which only works well when that device exposes a single DAI.</span></span><br><span class="line"><span class="comment">	 */</span> </span><br><span class="line">	<span class="comment">/* 保存当前dai_link上所有的cpu components */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dai_link_component</span> *<span class="title">cpus</span>;</span></span><br><span class="line">	<span class="comment">/* cpu components的数量，一般来说1个dai_link只对应1个cpu和1个codec */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> num_cpus;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * You MUST specify the link&#x27;s codec, either by device name, or by</span></span><br><span class="line"><span class="comment">	 * DT/OF node, but not both.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">/* You MUST specify the DAI name within the codec */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dai_link_component</span> *<span class="title">codecs</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> num_codecs;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * You MAY specify the link&#x27;s platform/PCM/DMA driver, either by</span></span><br><span class="line"><span class="comment">	 * device name, or by DT/OF node, but not both. Some forms of link</span></span><br><span class="line"><span class="comment">	 * do not need a platform. In such case, platforms are not mandatory.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dai_link_component</span> *<span class="title">platforms</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> num_platforms;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> id;	<span class="comment">/* optional ID for machine driver link identification */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_pcm_stream</span> *<span class="title">params</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> num_params;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 数字音频接口格式 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> dai_fmt;           <span class="comment">/* format to set on init */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">snd_soc_dpcm_trigger</span> <span class="title">trigger</span>[2];</span> <span class="comment">/* trigger type for DPCM */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* codec/machine specific init - e.g. add machine controls */</span></span><br><span class="line">	<span class="keyword">int</span> (*init)(struct snd_soc_pcm_runtime *rtd);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* codec/machine specific exit - dual of init() */</span></span><br><span class="line">	<span class="keyword">void</span> (*<span class="built_in">exit</span>)(struct snd_soc_pcm_runtime *rtd);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* optional hw_params re-writing for BE and FE sync */</span></span><br><span class="line">	<span class="keyword">int</span> (*be_hw_params_fixup)(struct snd_soc_pcm_runtime *rtd,</span><br><span class="line">			struct snd_pcm_hw_params *params);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* machine stream operations */</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_ops</span> *<span class="title">ops</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_compr_ops</span> *<span class="title">compr_ops</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Mark this pcm with non atomic ops */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> nonatomic:<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* For unidirectional dai links */</span></span><br><span class="line">	<span class="comment">/* 仅支持播放和录制标志 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> playback_only:<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> capture_only:<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Keep DAI active over suspend */</span></span><br><span class="line">	<span class="comment">/* 是否在挂起时保持DAI的活动状态 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> ignore_suspend:<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Symmetry requirements */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> symmetric_rate:<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> symmetric_channels:<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> symmetric_sample_bits:<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Do not create a PCM for this DAI link (Backend link) */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> no_pcm:<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* This DAI link can route to other DAI links at runtime (Frontend)*/</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> dynamic:<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* DPCM capture and Playback support */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> dpcm_capture:<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> dpcm_playback:<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* DPCM used FE &amp; BE merged format */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> dpcm_merged_format:<span class="number">1</span>;</span><br><span class="line">	<span class="comment">/* DPCM used FE &amp; BE merged channel */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> dpcm_merged_chan:<span class="number">1</span>;</span><br><span class="line">	<span class="comment">/* DPCM used FE &amp; BE merged rate */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> dpcm_merged_rate:<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* pmdown_time is ignored at stop */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> ignore_pmdown_time:<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Do not create a PCM for this DAI link (Backend link) */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> ignore:<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* This flag will reorder stop sequence. By enabling this flag</span></span><br><span class="line"><span class="comment">	 * DMA controller stop sequence will be invoked first followed by</span></span><br><span class="line"><span class="comment">	 * CPU DAI driver stop sequence</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> stop_dma_first:<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SND_SOC_TOPOLOGY</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dobj</span> <span class="title">dobj</span>;</span> <span class="comment">/* For topology */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>aso_simple_priv</code>结构体，asoc-simple-card驱动中集成的数据结构体</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/sound/simple_card_util.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">asoc_simple_priv</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_card</span> <span class="title">snd_card</span>;</span></span><br><span class="line">	<span class="comment">/* dai_props是和dai_link对应的 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">simple_dai_props</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">asoc_simple_dai</span> *<span class="title">cpu_dai</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">asoc_simple_dai</span> *<span class="title">codec_dai</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dai_link_component</span> *<span class="title">cpus</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dai_link_component</span> *<span class="title">codecs</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dai_link_component</span> *<span class="title">platforms</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">asoc_simple_data</span> <span class="title">adata</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_codec_conf</span> *<span class="title">codec_conf</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">prop_nums</span> <span class="title">num</span>;</span></span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">int</span> mclk_fs;</span><br><span class="line">	&#125; *dai_props;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">asoc_simple_jack</span> <span class="title">hp_jack</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">asoc_simple_jack</span> <span class="title">mic_jack</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dai_link</span> *<span class="title">dai_link</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">asoc_simple_dai</span> *<span class="title">dais</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dai_link_component</span> *<span class="title">dlcs</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dai_link_component</span> <span class="title">dummy</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_codec_conf</span> *<span class="title">codec_conf</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_desc</span> *<span class="title">pa_gpio</span>;</span></span><br><span class="line">	<span class="comment">/* ALSA PCM操作集 */</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_ops</span> *<span class="title">ops</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> dpcm_selectable:<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> force_dpcm:<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>struct link_info</code>用于保存dai_link信息</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">link_info</span> &#123;</span></span><br><span class="line">	<span class="comment">/* 表示音频数据链路的数量 */</span></span><br><span class="line">	<span class="keyword">int</span> link; <span class="comment">/* number of link */</span></span><br><span class="line">	<span class="comment">/* 表示当前正在处理的是第几个cpu */</span></span><br><span class="line">	<span class="keyword">int</span> cpu;  <span class="comment">/* turn for CPU / Codec */</span></span><br><span class="line">	<span class="comment">/* 保存每条音频数据链路所需的信息 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">prop_nums</span> <span class="title">num</span>[<span class="title">SNDRV_MAX_LINKS</span>];</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">prop_nums</span> &#123;</span></span><br><span class="line">	<span class="comment">/* 分别表示该dai_link下cpu codec platform的数量 */</span></span><br><span class="line">	<span class="keyword">int</span> cpus;</span><br><span class="line">	<span class="keyword">int</span> codecs;</span><br><span class="line">	<span class="keyword">int</span> platforms;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="asoc-simple-card设备树节点描述"><a href="#asoc-simple-card设备树节点描述" class="headerlink" title="asoc-simple-card设备树节点描述"></a>asoc-simple-card设备树节点描述</h4><p>E2000Q设备树sound-card节点描述</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sound_card: sound &#123;</span><br><span class="line">	compatible = <span class="string">&quot;simple-audio-card&quot;</span>;</span><br><span class="line">	simple-audio-card,format = <span class="string">&quot;i2s&quot;</span>;</span><br><span class="line">	simple-audio-card,name = <span class="string">&quot;phytium,pe220x-i2s-audio&quot;</span>;</span><br><span class="line">	simple-audio-card,pin-switches = <span class="string">&quot;mic-in&quot;</span>;</span><br><span class="line">	simple-audio-card,widgets = <span class="string">&quot;Microphone&quot;</span>,<span class="string">&quot;mic-in&quot;</span>;</span><br><span class="line">	simple-audio-card,routing = <span class="string">&quot;MIC2&quot;</span>,<span class="string">&quot;mic-in&quot;</span>;</span><br><span class="line">	simple-audio-card,cpu &#123;</span><br><span class="line">		sound-dai = &lt;&amp;i2s0&gt;;</span><br><span class="line">	&#125;;</span><br><span class="line">	simple-audio-card,codec&#123;</span><br><span class="line">		sound-dai = &lt;&amp;codec0&gt;;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>simple-audio-card的各个属性设置<a href="https://www.kernel.org/doc/Documentation/devicetree/bindings/sound/simple-card.yaml">simple-card.yaml</a></p>
<ol>
<li><code>simple-audio-card,name</code>： 指定声卡的名称为“phytium,pe220x-i2s-audio”;</li>
<li><code>simple-audio-card,audio</code>： 指定数字音频接口格式为<code>i2s</code></li>
<li><code>simple-audio-card,widge</code> ： 在alsa驱动中，使用widget描述具有路径电源管理的kcontrol，每个条目都是一对字符串，其中第一个是widget模板名称，在machine驱动中只有确定的几种”Microphone（表示麦克风）”、“Headphone（表示耳机）”、“Speaker（表示扬声器）”、“Line（表示线路）”；第二个是widget实例名称，可以自由定义</li>
<li><code>simple-audio-card,routing</code>：配置与codec物理输入引脚、物理输出引脚连接的路径，每个条目都是一对字符串，第一个事目的(sink)，第二个是源(source)，E2000设备树中的描述指的是将其中名字为<code>mic-in</code>的widget连接到名字为<code>MIC2</code>的widget</li>
<li><code>simple-audio-card,cpu</code>：指定cpu接入音频编码的dai</li>
<li><code>simple-audio-card,codec</code>：指定codec接入cpu的dai</li>
</ol>
<p>asoc-simple-card machine驱动probe的流程</p>
<p>总结来说，machine驱动的工作内容如下</p>
<ul>
<li>构造一个<code>struct snd_soc_dai_link</code>，将cpu和codec关联起来</li>
<li>负责创建<code>struct snd_soc_card</code>即asoc-sound-card这个结构体，走<code>devm_snd_soc_register_card()</code>将其注册到asoc中</li>
</ul>
<h3 id="plarform驱动-以phytium-i2s驱动为例"><a href="#plarform驱动-以phytium-i2s驱动为例" class="headerlink" title="plarform驱动 以phytium i2s驱动为例"></a>plarform驱动 以phytium i2s驱动为例</h3><p>以phytium phytium-i2s.c platform驱动为例进行分析</p>
<h4 id="相关结构体"><a href="#相关结构体" class="headerlink" title="相关结构体"></a>相关结构体</h4><p><code>struct i2s_bus</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sound/soc/phytium/local.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2s_bus</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">i2sc_bus</span> <span class="title">core</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snd_card</span> *<span class="title">card</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pci_dev</span> *<span class="title">pci</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">prepare_mutex</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>struct i2s_phytium</code>用于驱动集中管理</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sound/soc/phytium/local.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2s_phytium</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">azx</span> <span class="title">chip</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snd_pcm_substream</span> *<span class="title">substream</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">pdev</span>;</span></span><br><span class="line">	u32 paddr;</span><br><span class="line">	<span class="comment">/* i2s 寄存器基地址 */</span></span><br><span class="line">	<span class="keyword">void</span> __iomem *regs;</span><br><span class="line">	<span class="comment">/* DDMA 寄存器基地址 */</span></span><br><span class="line">	<span class="keyword">void</span> __iomem *regs_db;</span><br><span class="line">	<span class="keyword">int</span> irq_id;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* for pending irqs */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">irq_pending_work</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* sync probing */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">completion</span> <span class="title">probe_wait</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">probe_work</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* extra flags */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> pcie:<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> irq_pending_warned:<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> probe_continued:<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> i2s_dp:<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> i2s_reg_comp1;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> i2s_reg_comp2;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">clk</span> *<span class="title">clk</span>;</span></span><br><span class="line">	<span class="comment">// capability用来标识当前是否有播放和录音的能力</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> capability;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> quirks;</span><br><span class="line">	u32 fifo_th;</span><br><span class="line">	<span class="keyword">int</span> active;</span><br><span class="line">	u32 xfer_resolution;</span><br><span class="line">	u32 ccr;</span><br><span class="line">	u32 clk_base;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">i2s_clk_config_data</span> <span class="title">config</span>;</span></span><br><span class="line"></span><br><span class="line">	  <span class="comment">/*azx_dev*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">i2s_stream</span> <span class="title">core</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>struct azx</code>结构体</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">azx</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">i2s_bus</span> <span class="title">bus</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snd_card</span> *<span class="title">card</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pci_dev</span> *<span class="title">pci</span>;</span></span><br><span class="line">	<span class="keyword">int</span> dev_index;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* playback stream数量，默认是1 */</span></span><br><span class="line">	<span class="keyword">int</span> playback_streams;</span><br><span class="line">	<span class="comment">/* playback索引偏移，默认为0 */</span></span><br><span class="line">	<span class="keyword">int</span> playback_index_offset;</span><br><span class="line">	<span class="comment">/* capture stream数量，默认是1 */</span></span><br><span class="line">	<span class="keyword">int</span> capture_streams;</span><br><span class="line">	<span class="comment">/* capture索引偏移，默认在playback索引之后 */</span></span><br><span class="line">	<span class="keyword">int</span> capture_index_offset;</span><br><span class="line">	<span class="keyword">int</span> num_streams;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Register interaction */</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2s_controller_ops</span> *<span class="title">ops</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* locks */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">open_mutex</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* PCM */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">pcm_list</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* flags */</span></span><br><span class="line">	<span class="keyword">int</span> bdl_pos_adj;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> running:<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> region_requested:<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> disabled:<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>struct azx_dev</code>结构体</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">azx_dev</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">i2s_stream</span> <span class="title">core</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> irq_pending:<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>struct i2sc_bus</code>结构体</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2s_io_ops</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> (*dma_alloc_pages)(struct i2sc_bus *bus, <span class="keyword">int</span> type, <span class="keyword">size_t</span> size,</span><br><span class="line">			       struct snd_dma_buffer *buf);</span><br><span class="line">	<span class="keyword">void</span> (*dma_free_pages)(struct i2sc_bus *bus,</span><br><span class="line">			       struct snd_dma_buffer *buf);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sound/soc/phytium/local.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2sc_bus</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2s_bus_ops</span> *<span class="title">ops</span>;</span></span><br><span class="line">	<span class="comment">/* 用于dma内存分配和释放的操作 */</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2s_io_ops</span> *<span class="title">io_ops</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2s_ext_bus_ops</span> *<span class="title">ext_ops</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* h/w resources */</span></span><br><span class="line">	<span class="comment">/* I2S控制器寄存器基地址 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> addr;</span><br><span class="line">	<span class="comment">/* DMA控制器映射后的寄存器基地址 */</span></span><br><span class="line">	<span class="keyword">void</span> __iomem *remap_addr;</span><br><span class="line">	<span class="comment">/* 中断号 */</span></span><br><span class="line">	<span class="keyword">int</span> irq;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* codec linked list */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">codec_list</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> num_codecs;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> unsol_rp, unsol_wp;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">unsol_work</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snd_dma_buffer</span> <span class="title">bdl0</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snd_dma_buffer</span> <span class="title">bdl1</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* i2s_stream linked list */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">stream_list</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">bool</span> reverse_assign;		<span class="comment">/* assign devices in reverse order */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> bdl_pos_adj;		<span class="comment">/* BDL position adjustment */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* locks */</span></span><br><span class="line">	<span class="keyword">spinlock_t</span> reg_lock;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>struct i2s_stream</code>结构体</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2s_stream</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">i2sc_bus</span> *<span class="title">bus</span>;</span></span><br><span class="line">	<span class="comment">/* 用于描述该stream的dma内存 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snd_dma_buffer</span> <span class="title">bdl</span>;</span> <span class="comment">/* BDL buffer */</span></span><br><span class="line">	__le32 *posbuf;		<span class="comment">/* position buffer pointer */</span></span><br><span class="line">	<span class="comment">/* stream的方向 */</span></span><br><span class="line">	<span class="keyword">int</span> direction;		<span class="comment">/* playback / capture (SNDRV_PCM_STREAM_*) */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> bufsize;	<span class="comment">/* size of the play buffer in bytes */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> period_bytes; <span class="comment">/* size of the period in bytes */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> frags;	<span class="comment">/* number for period in the play buffer */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> fifo_size;	<span class="comment">/* FIFO size */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* DMA控制器映射后的寄存器基地址 */</span></span><br><span class="line">	<span class="keyword">void</span> __iomem *sd_addr;	<span class="comment">/* stream descriptor pointer */</span></span><br><span class="line"></span><br><span class="line">	u32 sd_int_sta_mask;	<span class="comment">/* stream int status mask */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* pcm support */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snd_pcm_substream</span> *<span class="title">substream</span>;</span>	<span class="comment">/* assigned substream,</span></span><br><span class="line"><span class="comment">						 * set in PCM open</span></span><br><span class="line"><span class="comment">						 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> format_val;	<span class="comment">/* format value to be set in the</span></span><br><span class="line"><span class="comment">					 * controller and the codec</span></span><br><span class="line"><span class="comment">					 */</span></span><br><span class="line">	<span class="comment">/* stream的标记，意义应该不大 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> stream_tag;	<span class="comment">/* assigned stream */</span></span><br><span class="line">	<span class="comment">/* stream的索引号 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> index;		<span class="comment">/* stream index */</span></span><br><span class="line">	<span class="keyword">int</span> assigned_key;		<span class="comment">/* last device# key assigned to */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">bool</span> opened;</span><br><span class="line">	<span class="keyword">bool</span> running;</span><br><span class="line">	<span class="keyword">bool</span> prepared;</span><br><span class="line">	<span class="keyword">bool</span> no_period_wakeup;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> delay_negative_threshold;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="platform-driver注册过程"><a href="#platform-driver注册过程" class="headerlink" title="platform driver注册过程"></a>platform driver注册过程</h4><p>phytium i2s的设备树描述</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">i2s0: i2s@<span class="number">28009000</span> &#123;</span><br><span class="line">	compatible = <span class="string">&quot;phytium,i2s&quot;</span>;</span><br><span class="line">	reg = &lt;<span class="number">0x0</span> <span class="number">0x28009000</span> <span class="number">0x0</span> <span class="number">0x1000</span>&gt;,</span><br><span class="line">			&lt;<span class="number">0x0</span> <span class="number">0x28005000</span> <span class="number">0x0</span> <span class="number">0x1000</span>&gt;;</span><br><span class="line">	interrupts = &lt;GIC_SPI <span class="number">77</span> IRQ_TYPE_LEVEL_HIGH&gt;;</span><br><span class="line">	clocks = &lt;&amp;sysclk_600mhz&gt;;</span><br><span class="line">	clock-names = <span class="string">&quot;i2s_clk&quot;</span>;</span><br><span class="line">	status = <span class="string">&quot;disabled&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><code>struct snd_soc_component_driver phyitum_i2s_component</code>的定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sound/soc/phytium/phytium_i2s.c</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_component_driver</span> <span class="title">phytium_i2s_component</span> =</span> &#123;</span><br><span class="line">	.name			= <span class="string">&quot;phytium-i2s&quot;</span>,</span><br><span class="line">	.pcm_construct	= phytium_pcm_new,</span><br><span class="line">	.suspend		= phyitum_i2s_suspend,</span><br><span class="line">	.resume 		= phytium_i2s_resume,</span><br><span class="line"></span><br><span class="line">	.open			= phytium_pcm_open,</span><br><span class="line">	.close			= phytium_pcm_close,</span><br><span class="line">	.hw_params 		= phytium_pcm_hw_params,</span><br><span class="line">	.prepare 		= phytium_pcm_prepare,</span><br><span class="line">	.hw_free		= phytium_pcm_hw_free,</span><br><span class="line">	.trigger		= phytium_pcm_trigger,</span><br><span class="line">	.pointer 		= phytium_pcm_pointer,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>struct snd_soc_dai_driver phytium_i2s_dai</code>的定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dai_ops</span> <span class="title">phytium_i2s_dai_ops</span> =</span> &#123;</span><br><span class="line">	.hw_params	= phytium_i2s_hw_params,</span><br><span class="line">	.prepare	= phytium_i2s_prepare,</span><br><span class="line">	.trigger	= phytium_i2s_trigger,</span><br><span class="line">	.set_fmt	= phytium_i2s_set_fmt,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dai_driver</span> <span class="title">phytium_i2s_dai</span> =</span> &#123;</span><br><span class="line">	.playback = &#123;</span><br><span class="line">		.stream_name = <span class="string">&quot;i2s-Playback&quot;</span>,</span><br><span class="line">		.channels_min = <span class="number">2</span>,</span><br><span class="line">		.channels_max = <span class="number">2</span>,</span><br><span class="line">		.rates = SNDRV_PCM_RATE_8000_192000,</span><br><span class="line">		.formats = SNDRV_PCM_FMTBIT_S8 |</span><br><span class="line">			   SNDRV_PCM_FMTBIT_S16_LE |</span><br><span class="line">			   SNDRV_PCM_FMTBIT_S20_LE |</span><br><span class="line">			   SNDRV_PCM_FMTBIT_S24_LE |</span><br><span class="line">			   SNDRV_PCM_FMTBIT_S32_LE,</span><br><span class="line">	&#125;,</span><br><span class="line">	.capture = &#123;</span><br><span class="line">		.stream_name = <span class="string">&quot;i2s-Capture&quot;</span>,</span><br><span class="line">		.channels_min = <span class="number">2</span>,</span><br><span class="line">		.channels_max = <span class="number">2</span>,</span><br><span class="line">		.rates = SNDRV_PCM_RATE_8000_192000,</span><br><span class="line">		.formats = SNDRV_PCM_FMTBIT_S8 |</span><br><span class="line">			   SNDRV_PCM_FMTBIT_S16_LE |</span><br><span class="line">			   SNDRV_PCM_FMTBIT_S20_LE |</span><br><span class="line">			   SNDRV_PCM_FMTBIT_S24_LE |</span><br><span class="line">			   SNDRV_PCM_FMTBIT_S32_LE,</span><br><span class="line">	&#125;,</span><br><span class="line">	.ops     = &amp;phytium_i2s_dai_ops,</span><br><span class="line">	.symmetric_rate = <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="codec驱动-以es8336为例"><a href="#codec驱动-以es8336为例" class="headerlink" title="codec驱动 以es8336为例"></a>codec驱动 以es8336为例</h3><p>codec driver不应包含任何特定于目标平台或者设备的代码，</p>
<p>描述codec的最主要的几个数据结构分别是：</p>
<ul>
<li><code>struct snd_soc_dai</code>: 描述codec端的dai</li>
<li><code>struct snd_soc_dai_driver</code>: 描述dai的驱动，用于定义pcm的能力和操作集</li>
<li><code>struct snd_soc_component</code>: ASoC使用统一的数据结构来描述codec设备和platform设备，一个component对应一个模块</li>
<li><code>struct snd_soc_component_driver</code>: 描述component的驱动</li>
</ul>
<h4 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h4><p><code>struct snd_soc_component</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_component</span> &#123;</span></span><br><span class="line">	<span class="comment">/* </span></span><br><span class="line"><span class="comment">	 * component名称 dai_link可以通过这个字段在全局链表component_list中查找对应的</span></span><br><span class="line"><span class="comment">	 * component</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">	<span class="keyword">int</span> id;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *name_prefix;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span></span><br><span class="line">	<span class="comment">/* 该component绑定的snd_soc_card声卡 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_card</span> *<span class="title">card</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> active;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> suspended:<span class="number">1</span>; <span class="comment">/* is in suspend PM state */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 链接到全局链表 component_list上 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">card_aux_list</span>;</span> <span class="comment">/* for auxiliary bound components */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">card_list</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_component_driver</span> *<span class="title">driver</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 用于管理component上的dai */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">dai_list</span>;</span></span><br><span class="line">	<span class="comment">/* component中dai的数量 */</span></span><br><span class="line">	<span class="keyword">int</span> num_dai;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">regmap</span> *<span class="title">regmap</span>;</span></span><br><span class="line">	<span class="keyword">int</span> val_bytes;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">io_mutex</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* attached dynamic objects */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">dobj_list</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * DO NOT use any of the fields below in drivers, they are temporary and</span></span><br><span class="line"><span class="comment">	 * are going to be removed again soon. If you use them in driver code</span></span><br><span class="line"><span class="comment">	 * the driver will be marked as BROKEN when these fields are removed.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Don&#x27;t use these, use snd_soc_component_get_dapm() */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dapm_context</span> <span class="title">dapm</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* machine specific init */</span></span><br><span class="line">	<span class="keyword">int</span> (*init)(struct snd_soc_component *component);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* function mark */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snd_pcm_substream</span> *<span class="title">mark_module</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snd_pcm_substream</span> *<span class="title">mark_open</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snd_pcm_substream</span> *<span class="title">mark_hw_params</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snd_pcm_substream</span> *<span class="title">mark_trigger</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snd_compr_stream</span>  *<span class="title">mark_compr_open</span>;</span></span><br><span class="line">	<span class="keyword">void</span> *mark_pm;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_FS</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">debugfs_root</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *debugfs_prefix;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>struct snd_soc_component_driver</code>，用于component的driver，例如phytium i2s的platform驱动中定义的<code>phytium_i2s_component</code>实例</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/sound/soc-component.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_component_driver</span> &#123;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Default control and setup, added after probe() is run */</span></span><br><span class="line">	<span class="comment">/* 在codec的driver中一般会在驱动中直接进行定义并赋值到这几个成员 */</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">snd_kcontrol_new</span> *<span class="title">controls</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> num_controls;</span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dapm_widget</span> *<span class="title">dapm_widgets</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> num_dapm_widgets;</span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dapm_route</span> *<span class="title">dapm_routes</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> num_dapm_routes;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 注册声卡时回调的probe函数 */</span></span><br><span class="line">	<span class="keyword">int</span> (*probe)(struct snd_soc_component *component);</span><br><span class="line">	<span class="keyword">void</span> (*remove)(struct snd_soc_component *component);</span><br><span class="line">	<span class="keyword">int</span> (*suspend)(struct snd_soc_component *component);</span><br><span class="line">	<span class="keyword">int</span> (*resume)(struct snd_soc_component *component);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 用于读写寄存器的值，假如使用了regmap就不需要实现这两个接口了 */</span></span><br><span class="line">	<span class="function"><span class="keyword">unsigned</span> <span class="title">int</span> <span class="params">(*read)</span><span class="params">(struct snd_soc_component *component,</span></span></span><br><span class="line"><span class="params"><span class="function">			     <span class="keyword">unsigned</span> <span class="keyword">int</span> reg)</span></span>;</span><br><span class="line">	<span class="keyword">int</span> (*write)(struct snd_soc_component *component,</span><br><span class="line">		     <span class="keyword">unsigned</span> <span class="keyword">int</span> reg, <span class="keyword">unsigned</span> <span class="keyword">int</span> val);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* pcm creation and destruction */</span></span><br><span class="line">	<span class="keyword">int</span> (*pcm_construct)(struct snd_soc_component *component,</span><br><span class="line">			     struct snd_soc_pcm_runtime *rtd);</span><br><span class="line">	<span class="keyword">void</span> (*pcm_destruct)(struct snd_soc_component *component,</span><br><span class="line">			     struct snd_pcm *pcm);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* component wide operations */</span></span><br><span class="line">	<span class="keyword">int</span> (*set_sysclk)(struct snd_soc_component *component,</span><br><span class="line">			  <span class="keyword">int</span> clk_id, <span class="keyword">int</span> source, <span class="keyword">unsigned</span> <span class="keyword">int</span> freq, <span class="keyword">int</span> dir);</span><br><span class="line">	<span class="keyword">int</span> (*set_pll)(struct snd_soc_component *component, <span class="keyword">int</span> pll_id,</span><br><span class="line">		       <span class="keyword">int</span> source, <span class="keyword">unsigned</span> <span class="keyword">int</span> freq_in, <span class="keyword">unsigned</span> <span class="keyword">int</span> freq_out);</span><br><span class="line">	<span class="keyword">int</span> (*set_jack)(struct snd_soc_component *component,</span><br><span class="line">			struct snd_soc_jack *jack,  <span class="keyword">void</span> *data);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* DT */</span></span><br><span class="line">	<span class="keyword">int</span> (*of_xlate_dai_name)(struct snd_soc_component *component,</span><br><span class="line">				 <span class="keyword">const</span> struct of_phandle_args *args,</span><br><span class="line">				 <span class="keyword">const</span> <span class="keyword">char</span> **dai_name);</span><br><span class="line">	<span class="keyword">int</span> (*of_xlate_dai_id)(struct snd_soc_component *comment,</span><br><span class="line">			       struct device_node *endpoint);</span><br><span class="line">	<span class="keyword">void</span> (*seq_notifier)(struct snd_soc_component *component,</span><br><span class="line">			     <span class="keyword">enum</span> snd_soc_dapm_type type, <span class="keyword">int</span> subseq);</span><br><span class="line">	<span class="keyword">int</span> (*stream_event)(struct snd_soc_component *component, <span class="keyword">int</span> event);</span><br><span class="line">	<span class="keyword">int</span> (*set_bias_level)(struct snd_soc_component *component,</span><br><span class="line">			      <span class="keyword">enum</span> snd_soc_bias_level level);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> (*open)(struct snd_soc_component *component,</span><br><span class="line">		    struct snd_pcm_substream *substream);</span><br><span class="line">	<span class="keyword">int</span> (*close)(struct snd_soc_component *component,</span><br><span class="line">		     struct snd_pcm_substream *substream);</span><br><span class="line">	<span class="keyword">int</span> (*ioctl)(struct snd_soc_component *component,</span><br><span class="line">		     struct snd_pcm_substream *substream,</span><br><span class="line">		     <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">void</span> *arg);</span><br><span class="line">	<span class="keyword">int</span> (*hw_params)(struct snd_soc_component *component,</span><br><span class="line">			 struct snd_pcm_substream *substream,</span><br><span class="line">			 struct snd_pcm_hw_params *params);</span><br><span class="line">	<span class="keyword">int</span> (*hw_free)(struct snd_soc_component *component,</span><br><span class="line">		       struct snd_pcm_substream *substream);</span><br><span class="line">	<span class="keyword">int</span> (*prepare)(struct snd_soc_component *component,</span><br><span class="line">		       struct snd_pcm_substream *substream);</span><br><span class="line">	<span class="keyword">int</span> (*trigger)(struct snd_soc_component *component,</span><br><span class="line">		       struct snd_pcm_substream *substream, <span class="keyword">int</span> cmd);</span><br><span class="line">	<span class="keyword">int</span> (*sync_stop)(struct snd_soc_component *component,</span><br><span class="line">			 struct snd_pcm_substream *substream);</span><br><span class="line">	<span class="keyword">snd_pcm_uframes_t</span> (*pointer)(struct snd_soc_component *component,</span><br><span class="line">				     struct snd_pcm_substream *substream);</span><br><span class="line">	<span class="keyword">int</span> (*get_time_info)(struct snd_soc_component *component,</span><br><span class="line">		struct snd_pcm_substream *substream, struct timespec64 *system_ts,</span><br><span class="line">		struct timespec64 *audio_ts,</span><br><span class="line">		struct snd_pcm_audio_tstamp_config *audio_tstamp_config,</span><br><span class="line">		struct snd_pcm_audio_tstamp_report *audio_tstamp_report);</span><br><span class="line">	<span class="keyword">int</span> (*copy_user)(struct snd_soc_component *component,</span><br><span class="line">			 struct snd_pcm_substream *substream, <span class="keyword">int</span> channel,</span><br><span class="line">			 <span class="keyword">unsigned</span> <span class="keyword">long</span> pos, <span class="keyword">void</span> __user *buf,</span><br><span class="line">			 <span class="keyword">unsigned</span> <span class="keyword">long</span> bytes);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *(*<span class="title">page</span>)(<span class="keyword">struct</span> <span class="title">snd_soc_component</span> *<span class="title">component</span>,</span></span><br><span class="line"><span class="class">			     <span class="keyword">struct</span> <span class="title">snd_pcm_substream</span> *<span class="title">substream</span>,</span></span><br><span class="line"><span class="class">			     <span class="title">unsigned</span> <span class="title">long</span> <span class="title">offset</span>);</span></span><br><span class="line">	<span class="keyword">int</span> (*mmap)(struct snd_soc_component *component,</span><br><span class="line">		    struct snd_pcm_substream *substream,</span><br><span class="line">		    struct vm_area_struct *vma);</span><br><span class="line">	<span class="keyword">int</span> (*ack)(struct snd_soc_component *component,</span><br><span class="line">		   struct snd_pcm_substream *substream);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">snd_compress_ops</span> *<span class="title">compress_ops</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* probe ordering - for components with runtime dependencies */</span></span><br><span class="line">	<span class="comment">/* probe的顺序，一共有5个顺序，驱动初始化的过程中根据顺序进行component的probe */</span></span><br><span class="line">	<span class="keyword">int</span> probe_order;</span><br><span class="line">	<span class="keyword">int</span> remove_order;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * signal if the module handling the component should not be removed</span></span><br><span class="line"><span class="comment">	 * if a pcm is open. Setting this would prevent the module</span></span><br><span class="line"><span class="comment">	 * refcount being incremented in probe() but allow it be incremented</span></span><br><span class="line"><span class="comment">	 * when a pcm is opened and decremented when it is closed.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> module_get_upon_open:<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* bits */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> idle_bias_on:<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> suspend_bias_off:<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> use_pmdown_time:<span class="number">1</span>; <span class="comment">/* care pmdown_time at stop */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> endianness:<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> non_legacy_dai_naming:<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* this component uses topology and ignore machine driver FEs */</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *ignore_machine;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *topology_name_prefix;</span><br><span class="line">	<span class="keyword">int</span> (*be_hw_params_fixup)(struct snd_soc_pcm_runtime *rtd,</span><br><span class="line">				  struct snd_pcm_hw_params *params);</span><br><span class="line">	<span class="keyword">bool</span> use_dai_pcm_id;	<span class="comment">/* use DAI link PCM ID as PCM device number */</span></span><br><span class="line">	<span class="keyword">int</span> be_pcm_base;	<span class="comment">/* base device ID for all BE PCMs */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>struct snd_soc_dai</code>，用来描述dai</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/sound/soc_dai.h</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Digital Audio Interface runtime data.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Holds runtime data for a DAI.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dai</span> &#123;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">	<span class="keyword">int</span> id;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 指向dai_driver */</span></span><br><span class="line">	<span class="comment">/* driver ops */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dai_driver</span> *<span class="title">driver</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* DAI runtime info */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> stream_active[SNDRV_PCM_STREAM_LAST + <span class="number">1</span>]; <span class="comment">/* usage count */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dapm_widget</span> *<span class="title">playback_widget</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dapm_widget</span> *<span class="title">capture_widget</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* DAI DMA data */</span></span><br><span class="line">	<span class="keyword">void</span> *playback_dma_data;</span><br><span class="line">	<span class="keyword">void</span> *capture_dma_data;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Symmetry data - only valid if symmetry is being enforced */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> rate;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> channels;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> sample_bits;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 指向component */</span></span><br><span class="line">	<span class="comment">/* parent platform/codec */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_component</span> *<span class="title">component</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* CODEC TDM slot masks and params (for fixup) */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> tx_mask;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> rx_mask;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 链接到component的dai_list链表 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* function mark */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snd_pcm_substream</span> *<span class="title">mark_startup</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snd_pcm_substream</span> *<span class="title">mark_hw_params</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snd_pcm_substream</span> *<span class="title">mark_trigger</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snd_compr_stream</span>  *<span class="title">mark_compr_startup</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* bit field */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> probed:<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>struct snd_soc_dai_driver</code>，描述dai驱动</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/sound/soc_dai.h</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Digital Audio Interface Driver.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Describes the Digital Audio Interface in terms of its ALSA, DAI and AC97</span></span><br><span class="line"><span class="comment"> * operations and capabilities. Codec and platform drivers will register this</span></span><br><span class="line"><span class="comment"> * structure for every DAI they have.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This structure covers the clocking, formating and ALSA operations for each</span></span><br><span class="line"><span class="comment"> * interface.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dai_driver</span> &#123;</span></span><br><span class="line">	<span class="comment">/* DAI description */</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">	<span class="comment">/* dai标识符 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> id;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> base;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dobj</span> <span class="title">dobj</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* DAI driver callbacks */</span></span><br><span class="line">	<span class="keyword">int</span> (*probe)(struct snd_soc_dai *dai);</span><br><span class="line">	<span class="keyword">int</span> (*remove)(struct snd_soc_dai *dai);</span><br><span class="line">	<span class="comment">/* compress dai */</span></span><br><span class="line">	<span class="keyword">int</span> (*compress_new)(struct snd_soc_pcm_runtime *rtd, <span class="keyword">int</span> num);</span><br><span class="line">	<span class="comment">/* Optional Callback used at pcm creation*/</span></span><br><span class="line">	<span class="keyword">int</span> (*pcm_new)(struct snd_soc_pcm_runtime *rtd,</span><br><span class="line">		       struct snd_soc_dai *dai);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* ops */</span></span><br><span class="line">	<span class="comment">/* dai的操作集，codec和platform驱动需要实现它 */</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dai_ops</span> *<span class="title">ops</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_cdai_ops</span> *<span class="title">cops</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* DAI capabilities */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_pcm_stream</span> <span class="title">capture</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_pcm_stream</span> <span class="title">playback</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> symmetric_rate:<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> symmetric_channels:<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> symmetric_sample_bits:<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* probe ordering - for components with runtime dependencies */</span></span><br><span class="line">	<span class="keyword">int</span> probe_order;</span><br><span class="line">	<span class="keyword">int</span> remove_order;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>struct snd_soc_dai_ops</code>，dai的控制和参数配置操作集结构体</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/sound/soc_dai.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dai_ops</span> &#123;</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * DAI clocking configuration, all optional.</span></span><br><span class="line"><span class="comment">	 * Called by soc_card drivers, normally in their hw_params.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">/* 配置dai的时钟 */</span></span><br><span class="line">	<span class="keyword">int</span> (*set_sysclk)(struct snd_soc_dai *dai,</span><br><span class="line">		<span class="keyword">int</span> clk_id, <span class="keyword">unsigned</span> <span class="keyword">int</span> freq, <span class="keyword">int</span> dir);</span><br><span class="line">	<span class="keyword">int</span> (*set_pll)(struct snd_soc_dai *dai, <span class="keyword">int</span> pll_id, <span class="keyword">int</span> source,</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">int</span> freq_in, <span class="keyword">unsigned</span> <span class="keyword">int</span> freq_out);</span><br><span class="line">	<span class="keyword">int</span> (*set_clkdiv)(struct snd_soc_dai *dai, <span class="keyword">int</span> div_id, <span class="keyword">int</span> div);</span><br><span class="line">	<span class="keyword">int</span> (*set_bclk_ratio)(struct snd_soc_dai *dai, <span class="keyword">unsigned</span> <span class="keyword">int</span> ratio);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * DAI format configuration</span></span><br><span class="line"><span class="comment">	 * Called by soc_card drivers, normally in their hw_params.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">int</span> (*set_fmt)(struct snd_soc_dai *dai, <span class="keyword">unsigned</span> <span class="keyword">int</span> fmt);</span><br><span class="line">	<span class="keyword">int</span> (*xlate_tdm_slot_mask)(<span class="keyword">unsigned</span> <span class="keyword">int</span> slots,</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">int</span> *tx_mask, <span class="keyword">unsigned</span> <span class="keyword">int</span> *rx_mask);</span><br><span class="line">	<span class="keyword">int</span> (*set_tdm_slot)(struct snd_soc_dai *dai,</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">int</span> tx_mask, <span class="keyword">unsigned</span> <span class="keyword">int</span> rx_mask,</span><br><span class="line">		<span class="keyword">int</span> slots, <span class="keyword">int</span> slot_width);</span><br><span class="line">	<span class="keyword">int</span> (*set_channel_map)(struct snd_soc_dai *dai,</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">int</span> tx_num, <span class="keyword">unsigned</span> <span class="keyword">int</span> *tx_slot,</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">int</span> rx_num, <span class="keyword">unsigned</span> <span class="keyword">int</span> *rx_slot);</span><br><span class="line">	<span class="keyword">int</span> (*get_channel_map)(struct snd_soc_dai *dai,</span><br><span class="line">			<span class="keyword">unsigned</span> <span class="keyword">int</span> *tx_num, <span class="keyword">unsigned</span> <span class="keyword">int</span> *tx_slot,</span><br><span class="line">			<span class="keyword">unsigned</span> <span class="keyword">int</span> *rx_num, <span class="keyword">unsigned</span> <span class="keyword">int</span> *rx_slot);</span><br><span class="line">	<span class="keyword">int</span> (*set_tristate)(struct snd_soc_dai *dai, <span class="keyword">int</span> tristate);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> (*set_stream)(struct snd_soc_dai *dai,</span><br><span class="line">			  <span class="keyword">void</span> *stream, <span class="keyword">int</span> direction);</span><br><span class="line">	<span class="keyword">void</span> *(*get_stream)(struct snd_soc_dai *dai, <span class="keyword">int</span> direction);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * DAI digital mute - optional.</span></span><br><span class="line"><span class="comment">	 * Called by soc-core to minimise any pops.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">int</span> (*mute_stream)(struct snd_soc_dai *dai, <span class="keyword">int</span> mute, <span class="keyword">int</span> stream);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * ALSA PCM audio operations - all optional.</span></span><br><span class="line"><span class="comment">	 * Called by soc-core during audio PCM operations.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">int</span> (*startup)(struct snd_pcm_substream *,</span><br><span class="line">		struct snd_soc_dai *);</span><br><span class="line">	<span class="keyword">void</span> (*shutdown)(struct snd_pcm_substream *,</span><br><span class="line">		struct snd_soc_dai *);</span><br><span class="line">	<span class="comment">/* 配置PCM音频的硬件参数 */</span></span><br><span class="line">	<span class="keyword">int</span> (*hw_params)(struct snd_pcm_substream *,</span><br><span class="line">		struct snd_pcm_hw_params *, struct snd_soc_dai *);</span><br><span class="line">	<span class="comment">/* 释放PCM音频的硬件资源 */</span></span><br><span class="line">	<span class="keyword">int</span> (*hw_free)(struct snd_pcm_substream *,</span><br><span class="line">		struct snd_soc_dai *);</span><br><span class="line">	<span class="comment">/* 准备PCM音频操作 */</span></span><br><span class="line">	<span class="keyword">int</span> (*prepare)(struct snd_pcm_substream *,</span><br><span class="line">		struct snd_soc_dai *);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">NOTE:</span> Commands passed to the trigger function are not necessarily</span></span><br><span class="line"><span class="comment">	 * compatible with the current state of the dai. For example this</span></span><br><span class="line"><span class="comment">	 * sequence of commands is possible: START STOP STOP.</span></span><br><span class="line"><span class="comment">	 * So do not unconditionally use refcounting functions in the trigger</span></span><br><span class="line"><span class="comment">	 * function, e.g. clk_enable/disable.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	 <span class="comment">/* 触发PCM音频操作 */</span></span><br><span class="line">	<span class="keyword">int</span> (*trigger)(struct snd_pcm_substream *, <span class="keyword">int</span>,</span><br><span class="line">		struct snd_soc_dai *);</span><br><span class="line">	<span class="keyword">int</span> (*bespoke_trigger)(struct snd_pcm_substream *, <span class="keyword">int</span>,</span><br><span class="line">		struct snd_soc_dai *);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * For hardware based FIFO caused delay reporting.</span></span><br><span class="line"><span class="comment">	 * Optional.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">snd_pcm_sframes_t</span> (*delay)(struct snd_pcm_substream *,</span><br><span class="line">		struct snd_soc_dai *);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Format list for auto selection.</span></span><br><span class="line"><span class="comment">	 * Format will be increased if priority format was</span></span><br><span class="line"><span class="comment">	 * not selected.</span></span><br><span class="line"><span class="comment">	 * see</span></span><br><span class="line"><span class="comment">	 *	snd_soc_dai_get_fmt()</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	u64 *auto_selectable_formats;</span><br><span class="line">	<span class="keyword">int</span> num_auto_selectable_formats;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* bit field */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> no_capture_mute:<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h4 id="component注册过程"><a href="#component注册过程" class="headerlink" title="component注册过程"></a>component注册过程</h4><p>一般在codec和platform驱动中会调用<code>devm_snd_soc_register_component()</code>来注册component和dai，<code>devm_snd_soc_register_component</code>是带有资源管理的component注册函数，该函数会动态申请一个component，并将其添加到全局链表component_list中，同时会为每个dai driver动态分配一个dai，并建立dai与component、dai与dai driver的关系。</p>
<p>在Machine驱动中匹配codec，实际上就是根据音频数据链路snd_soc_dai_link codec指定的name去遍历component_list找到匹配的component，然后再根据dai_name从component-&gt;dai_list中获取到匹配的codec dai。</p>
<p><img src="https://raw.githubusercontent.com/JackHuang021/images/master/20240410171031.png"></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>ASoC</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux设备模型</title>
    <url>/archives/f8def83d.html</url>
    <content><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>为了降低设备多样性带来的Linux驱动开发的复杂度，以及设备热插拔处理，电源管理等，Linux内核提出了设备模型（Driver Model）的概念。设备模型将硬件设备归纳、分类，然后抽象出一套标准的数据结构和接口，驱动的开发，就简化为对内核所规定的数据结构的填充和实现</p>
<span id="more"></span>

<h4 id="设备模型基本概念"><a href="#设备模型基本概念" class="headerlink" title="设备模型基本概念"></a>设备模型基本概念</h4><h5 id="Linux设备模型组成"><a href="#Linux设备模型组成" class="headerlink" title="Linux设备模型组成"></a>Linux设备模型组成</h5><p>硬件拓扑描述Linux设备模型中四个重要概念：Bus、Class、Device、Device Driver</p>
<ol>
<li>Bus：总线是CPU和一个或多个设备之间信息交互的通道，而为了方便设备模型的抽象，所有的设备都应连接到总线上</li>
<li>Class：在Linux设备模型中，Class的概念非常类似面向对象程序设计中的Class，它主要是集合具有相似功能或属性的设备，这样就可以抽象出一套可以在多个设备之间共用的数据结构和接口函数，因为从属于相同Class的设备和驱动程序就不需要重复定义这些公共资源，直接从Class中继承</li>
<li>Device：抽象系统中所有的硬件设备，描述它的名字、属性、从属的Bus、从属的Class</li>
<li>Device Driver：Linux设备模型用Driver抽象硬件设备的驱动程序，它包含设备初始化、电源管理相关的接口实现，Linux内核中的驱动开发，基本都围绕该抽象进行实现</li>
</ol>
<h5 id="设备模型的核心思想"><a href="#设备模型的核心思想" class="headerlink" title="设备模型的核心思想"></a>设备模型的核心思想</h5><p>Linux设备模型的核心思想</p>
<ol>
<li>用Device和Device Driver两个数据结构，分别从“有什么用”和“怎么用”两个角度描述硬件设备，统一了编写设备驱动的格式</li>
<li>通过<code>Bus-&gt;Device</code>类型的树状结构解决设备之间的依赖，启动某一个设备前，内核会检查该设备是否依赖其它设备或者总线，如果依赖，则检查所依赖的对象是否已经启动，如果没有，则会先启动它们，直到启动该设备的条件具备为止。而驱动开发人员需要做的，就是在编写设备驱动时，告知内核该设备的依赖关系即可</li>
<li>使用Class结构，在设备模型中引入面向对象的概念，这样可以最大限度地抽象共性，减少驱动开发过程中的重复劳动，降低工作量</li>
</ol>
<h4 id="KObject"><a href="#KObject" class="headerlink" title="KObject"></a>KObject</h4><p>Linux内核中有大量的驱动，而这些驱动往往具有类似的结构，根据面向对象的思想，可以将共同的部分提取为父类，这个父类就是<code>kobject</code>，<code>kobject</code>中包含了大量设备的必须信息，三大类设备驱动都需要包含这个<code>kobject</code>结构，从面向对象的思想来看，即继承自<code>kobject</code>，一个<code>kobject</code>对象往往就对应sysfs中的一个目录，<code>kobject</code>是组成设备模型的基本结构，<code>kobject</code>需要处理的基本任务如下：</p>
<ul>
<li>通过parent指针，可以将所有kobject以层次结构的形式组合起来</li>
<li>对象的引用计数，当一个内核对象被创建时，不知道该对象的存活时间，跟踪该对象的生命周期的一个方法就是使用引用计数，当内核中没有代码持有该对象的引用时，说明该对象可以被销毁了</li>
<li>和sysfs虚拟文件系统配合，将每一个kobject及其特性，以文件的形式开放到用户空间</li>
</ul>
<p><em>注1：在Linux中，kobject几乎不会单独存在，它的主要功能就是内嵌在一个大型的数据结构中，为这个数据结构提供一些底层的功能实现</em></p>
<p><em>注2：Linux driver开发者，很少会直接使用Kobject以及它提供的接口，而是使用构建在Kobject之上的设备模型接口</em></p>
<p>kobject, kset, ktype三者的概念</p>
<ul>
<li>kobject是基本数据类型，每个kobject都会在<code>/sys</code>文件系统中以目录的形式出现</li>
<li>ktype代表kobject的属性操作集合，</li>
<li>Kset是一个特殊的Kobject（因此它也会在<code>/sys</code>文件系统中以目录的形式出现），它用来集合相似的Kobject</li>
</ul>
<p><code>kobject</code>的结构体定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/linux/kobject.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>		*name;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">entry</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span>		*<span class="title">parent</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kset</span>		*<span class="title">kset</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobj_type</span>	*<span class="title">ktype</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kernfs_node</span>	*<span class="title">sd</span>;</span> <span class="comment">/* sysfs directory entry */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kref</span>		<span class="title">kref</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_KOBJECT_RELEASE</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">delayed_work</span>	<span class="title">release</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> state_initialized:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> state_in_sysfs:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> state_add_uevent_sent:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> state_remove_uevent_sent:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> uevent_suppress:<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>name: 表示<code>kobject</code>对象的名字，对应sysfs下的一个目录</li>
<li>entry: <code>list_head</code>链表，用来链接各个<code>kobject</code>对象</li>
<li>parent: 指向当前<code>kobject</code>父对象的指针</li>
<li>kset: 表示当前<code>kobject</code>所属的集合</li>
<li>ktype: 表示当前<code>kobject</code>的类型</li>
<li>sd: 在sysfs中的表示</li>
<li>kref: 为<code>kobject</code>的引用计数，当引用计数为0时，就回调<code>release</code>方法释放该对象</li>
<li>state_initialized: 初始化标志位，在对象初始化时被置位，表示对象是否被初始化</li>
<li>state_in_sysfs: 表示<code>kobject</code>在sysfs中的状态，在对应目录中被创建则为1，否则为0</li>
<li>state_add_uevent_sent: 添加设备的uevent事件是否被发送标志</li>
<li>state_remove_uevent_sent: 删除设备的uevent事件是否被发送标志</li>
<li>uevent_suppress：如果该字段为1，则表示忽略所有上报的uevent事件</li>
</ul>
<p><em>uevent提供了“用户空间通知”的功能实现，通过该功能，当内核中有kobject的增加、删除、修改等动作时，会通知用户空间</em></p>
<p>kset的结构体定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//include/linux/kobject.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kset</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">    <span class="keyword">spinlock_t</span> list_lock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">kset_uevent_ops</span> *<span class="title">uevent_ops</span>;</span></span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure>
<ul>
<li>list, list_lock：用于保存该kset下所有的kobject链表</li>
<li>kobj，该kset自己的kobject（kset是一个特殊的kobject，也会在sysfs中以目录的形式体现）</li>
<li>uevent_ops：该kset的uevent操作函数集。当任何Kobject需要上报uevent时，都要调用它所从属的kset的uevent_ops，添加环境变量，或者过滤event（kset可以决定哪些event可以上报）。因此，如果一个kobject不属于任何kset时，是不允许发送uevent的</li>
</ul>
<p>ktype的结构体定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//include/linux/ktype.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kobj_type</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> (*release)(struct kobject *kobj);</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sysfs_ops</span> *<span class="title">sysfs_ops</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">attribute</span> **<span class="title">default_attrs</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> **<span class="title">default_groups</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">kobj_ns_type_operations</span> *(*<span class="title">child_ns_type</span>)（<span class="keyword">struct</span> <span class="title">kobject</span> *<span class="title">kobj</span>）;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">void</span> *(*<span class="keyword">namespace</span>)(struct kobject *kobj);</span><br><span class="line">    <span class="keyword">void</span> (*get_ownership)(struct kobject *kobj, <span class="keyword">kuid_t</span> *uid, <span class="keyword">kgid_t</span> *gid);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>release: 通过该回调函数，可以将包含该种类型kobject的数据结构的内存空间释放掉</li>
<li>sysfs_ops：该种类型的kobject的sysfs文件系统接口</li>
<li>default_attrs：该种类型的kobject的atrribute列表（所谓attribute，就是sysfs文件系统中的一个文件）。将会在Kobject添加到内核时，一并注册到sysfs中</li>
<li>child_ns_type, namespace：和文件系统（sysfs）的命名空间有关</li>
</ul>
<p>每一个内嵌kobject的数据结构，例如kset、device、device_driver等等，都要实现一个ktype，并定义其中的回调函数，sysfs的相关操作也一样，必须经过ktype的中转，因为sysfs看到的是kobject，而真正的文件操作的主体，是内嵌kobject的上层数据结构</p>
<h5 id="kobject使用流程"><a href="#kobject使用流程" class="headerlink" title="kobject使用流程"></a>kobject使用流程</h5><p>kobject在大多数情况下会嵌在其他数据结构中使用，使用流程如下：</p>
<ol>
<li>定义一个<code>struct kset</code>类型的指针，并在初始化时为它分配空间，添加到内核中</li>
<li>根据实际情况，定义自己所需的数据结构原型，该数据结构中包含有kobjet</li>
<li>定义一个适合自己的ktype，并实现其中回调函数</li>
<li>在需要用到包含kobject的数据结构中，动态分配该数据结构，并分配kobject空间，添加到内核中</li>
<li>每一次引用数据结构时，调用<code>kobject_get</code>接口增加引用计数；引用结束时，调用<code>kobject_put</code>接口，减少引用计数</li>
<li>当引用计数减少为0时，kobject模块调用ktype所提供的release接口，释放上层数据结构以及kobject的内存空间</li>
</ol>
<h4 id="Uevent"><a href="#Uevent" class="headerlink" title="Uevent"></a>Uevent</h4><h5 id="Uevent的功能"><a href="#Uevent的功能" class="headerlink" title="Uevent的功能"></a>Uevent的功能</h5><p>Uevent是kobject的一部分，用于在kobject状态发生改变时，例如增加、移除等，通知用户空间程序，用户空间程序收到这样的事件后，会做相应的处理</p>
<p>该机制通常是用来支持热拔插设备的，例如U盘插入后，USB相关的驱动软件会动态创建用于表示该U盘的device结构（相应的也包括其中的kobject），并告知用户空间程序，为该U盘动态的创建&#x2F;dev&#x2F;目录下的设备节点，更进一步，可以通知其它的应用程序，将该U盘设备mount到系统中，从而动态的支持该设备。</p>
<h5 id="Uevent代码实现"><a href="#Uevent代码实现" class="headerlink" title="Uevent代码实现"></a>Uevent代码实现</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/linux/kobject.h</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">kobject_action</span> &#123;</span></span><br><span class="line">    KOBJ_ADD,</span><br><span class="line">    KOBJ_REMOVE,</span><br><span class="line">    KOBJ_CHANGE,</span><br><span class="line">    KOBJ_MOVE,</span><br><span class="line">    KOBJ_ONLINE,</span><br><span class="line">    KOBJ_OFFLINE,</span><br><span class="line">    KOBJ_BIND,</span><br><span class="line">    KOBJ_UNBIND,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>ADD&#x2F;REMOVE: kobject（或上层数据结构）的添加、移除事件</li>
<li>ONLINE&#x2F;OFFLINE： kobject（或上层数据结构）的上线、下线事件</li>
<li>CHANGE：Kobject（或上层数据结构）的状态或者内容发生改变</li>
<li>MOVE：Kobject（或上层数据结构）更改名称或者更改Parent（意味着在sysfs中更改了目录结构）</li>
<li>CHANGE：如果设备驱动需要上报的事件不再上面事件的范围内，或者是自定义的事件，可以使用该event，并携带相应的参数</li>
</ul>
<p>在利用kmod向用户空间上报event事件时，会直接执行用户空间的可执行文件，而在Linux系统，可执行文件的执行依赖于环境变量，因此<code>kobj_uevent_env</code>用于组织此次事件上报时的环境变量</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/linux/kobject.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UEVENT_NUM_ENVP         64</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UEVENT_BUFFER_SIZE      2048</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kobj_uevent_env</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> *argv[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">char</span> *envp[UEVENT_NUM_ENVP];</span><br><span class="line">    <span class="keyword">int</span> envp_idx;</span><br><span class="line">    <span class="keyword">char</span> buf[UEVENT_BUFFER_SIZE];</span><br><span class="line">    <span class="keyword">int</span> buflen;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>envp：指针数组，用于保存每个环境变量的地址，最多可支持的环境变量数量为UEVENT_NUM_ENVP</li>
<li>envp_idx：用于访问环境变量指针数组的index</li>
<li>buf：保存环境变量的buffer，最大为UEVENT_BUFFER_SIZE</li>
<li>buflen：访问buf的变量</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kset_uevent_ops</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> (* <span class="keyword">const</span> filter)(struct kset *kset, struct kobject *kobj);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *(* <span class="keyword">const</span> name)(struct kset *kset, struct kobject *kobj);</span><br><span class="line">    <span class="keyword">int</span> (* <span class="keyword">const</span> uevent)(struct kset *kset, struct kobject *kobj,</span><br><span class="line">                        struct kobj_uevent_env *env);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>kset_uevent_ops</code>是为kset定制的一个数据结构，里面包含filter和uevent两个回调函数，用处如下：</p>
<ul>
<li>filter：当任何kobject需要上报uevent时，它所属的kset可以通过该接口过滤，阻止不希望上报的event，从而达到从整体上管理的目的</li>
<li>name：该接口可以返回kset的名称，如果一个kset没有合法的名称，则其下的所有kobject将不允许上报uevent</li>
<li>uevent：当任何kobject需要上报uevent时，它所属的kset可以通过给接口统一为这些event添加环境变量，因为很多时候上报uevent时的环境变量都是相同的，因此可以由kset统一处理，就不需要让每个Kobject独自添加了</li>
</ul>
<h4 id="sysfs"><a href="#sysfs" class="headerlink" title="sysfs"></a>sysfs</h4><h5 id="sysfs介绍"><a href="#sysfs介绍" class="headerlink" title="sysfs介绍"></a>sysfs介绍</h5><p>sysfs是一个基于RAM的文件系统，他和kobject一起，可以将kernel的数据结构导出到用户空间，以文件目录结构的形式，提供对这些数据结构的访问支持</p>
<h5 id="sysfs和kobject的关系"><a href="#sysfs和kobject的关系" class="headerlink" title="sysfs和kobject的关系"></a>sysfs和kobject的关系</h5><p>每一个kobject都会对应sysfs中的一个目录，因此在将kobject添加到kernel时，<code>create_dir</code>接口会调用sysfs文件系统的创建目录接口，创建和kobject对应的目录</p>
<h5 id="attribute功能"><a href="#attribute功能" class="headerlink" title="attribute功能"></a>attribute功能</h5><p>attribute是对应kobject而言的，指的是kobject的属性，sysfs中的目录描述了kobject，而kobject是特定数据结构类型变量（如struct device）的体现，因此kobject的属性，就是这些变量的属性，它可以是任何东西，名称、内部变量、字符串等，而attribute在sysfs文件系统中是以文件的形式提供的</p>
<p>attribute就是内核空间和用户空间进行信息交互的一种方法，例如某个driver定义了一个变量，却希望用户空间程序可以修改这个变量，以控制driver的运行行为，那么就可以将该变量以sysfs attribute的形式开放出来</p>
<h5 id="attribute定义"><a href="#attribute定义" class="headerlink" title="attribute定义"></a>attribute定义</h5><p>Linux内核中，attribute分为普通的attribute和二进制attribute，定义如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/linux/types.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">umode_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// include/linux/sysfs.h </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">attribute</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">umode_t</span> mode;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// include/linux/sysfs.h </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bin_attribute</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">attribute</span> <span class="title">attr</span>;</span></span><br><span class="line">    <span class="keyword">size_t</span> size;</span><br><span class="line">    <span class="keyword">void</span>  *<span class="keyword">private</span>;</span><br><span class="line">    <span class="keyword">ssize_t</span> (*read)(struct file *, struct kobject *,</span><br><span class="line">                struct bin_attribute *, <span class="keyword">char</span> *, <span class="keyword">loff_t</span>, <span class="keyword">size_t</span>);</span><br><span class="line">    <span class="keyword">ssize_t</span> (*write)(struct file *, struct kobject *,</span><br><span class="line">                struct bin_attribute );</span><br><span class="line">    <span class="keyword">int</span> (*mmap)(struct file *, struct kobject *, </span><br><span class="line">                struct bin_attribute *attr, struct vm_area_struct *vma);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>struct attribute</code>为普通的attribute，使用该attribute生成的sysfs文件，只能用字符串的形式读写，而<code>struct bin_attribute</code>在<code>struct attribute</code>的基础上增加了read、write等函数，因此它所生成的sysfs文件可以用任何方式读写</p>
<h4 id="device和device-driver"><a href="#device和device-driver" class="headerlink" title="device和device driver"></a>device和device driver</h4><h5 id="关键数据结构"><a href="#关键数据结构" class="headerlink" title="关键数据结构"></a>关键数据结构</h5><p>struct device数据结构</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span>		*<span class="title">parent</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_private</span>	*<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>		*init_name; <span class="comment">/* initial name of the device */</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">device_type</span> *<span class="title">type</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span>	*<span class="title">bus</span>;</span>		<span class="comment">/* type of bus device is on */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_driver</span> *<span class="title">driver</span>;</span>	<span class="comment">/* which driver has allocated this</span></span><br><span class="line"><span class="comment">					   device */</span></span><br><span class="line">	<span class="keyword">void</span>		*platform_data;	<span class="comment">/* Platform specific data, device</span></span><br><span class="line"><span class="comment">					   core doesn&#x27;t touch it */</span></span><br><span class="line">	<span class="keyword">void</span>		*driver_data;	<span class="comment">/* Driver data, set and get with</span></span><br><span class="line"><span class="comment">					   dev_set_drvdata/dev_get_drvdata */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PROVE_LOCKING</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>		<span class="title">lockdep_mutex</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>		<span class="title">mutex</span>;</span>	<span class="comment">/* mutex to synchronize calls to</span></span><br><span class="line"><span class="comment">					 * its driver.</span></span><br><span class="line"><span class="comment">					 */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dev_links_info</span>	<span class="title">links</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dev_pm_info</span>	<span class="title">power</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dev_pm_domain</span>	*<span class="title">pm_domain</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_ENERGY_MODEL</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">em_perf_domain</span>	*<span class="title">em_pd</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_GENERIC_MSI_IRQ_DOMAIN</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_domain</span>	*<span class="title">msi_domain</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PINCTRL</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dev_pin_info</span>	*<span class="title">pins</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_GENERIC_MSI_IRQ</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">msi_list</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DMA_OPS</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dma_map_ops</span> *<span class="title">dma_ops</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	u64		*dma_mask;	<span class="comment">/* dma mask (if dma&#x27;able device) */</span></span><br><span class="line">	u64		coherent_dma_mask;<span class="comment">/* Like dma_mask, but for</span></span><br><span class="line"><span class="comment">					     alloc_coherent mappings as</span></span><br><span class="line"><span class="comment">					     not all hardware supports</span></span><br><span class="line"><span class="comment">					     64 bit addresses for consistent</span></span><br><span class="line"><span class="comment">					     allocations such descriptors. */</span></span><br><span class="line">	u64		bus_dma_limit;	<span class="comment">/* upstream dma constraint */</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">bus_dma_region</span> *<span class="title">dma_range_map</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_dma_parameters</span> *<span class="title">dma_parms</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">dma_pools</span>;</span>	<span class="comment">/* dma pools (if dma&#x27;ble) */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DMA_DECLARE_COHERENT</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dma_coherent_mem</span>	*<span class="title">dma_mem</span>;</span> <span class="comment">/* internal for coherent mem</span></span><br><span class="line"><span class="comment">					     override */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DMA_CMA</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cma</span> *<span class="title">cma_area</span>;</span>		<span class="comment">/* contiguous memory area for dma</span></span><br><span class="line"><span class="comment">					   allocations */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="comment">/* arch specific additions */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dev_archdata</span>	<span class="title">archdata</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span>	*<span class="title">of_node</span>;</span> <span class="comment">/* associated device tree node */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fwnode_handle</span>	*<span class="title">fwnode</span>;</span> <span class="comment">/* firmware device node */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line">	<span class="keyword">int</span>		numa_node;	<span class="comment">/* NUMA node this device is close to */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">dev_t</span>			devt;	<span class="comment">/* dev_t, creates the sysfs &quot;dev&quot; */</span></span><br><span class="line">	u32			id;	<span class="comment">/* device instance */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">spinlock_t</span>		devres_lock;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">devres_head</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="keyword">class</span>		*<span class="keyword">class</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> **<span class="title">groups</span>;</span>	<span class="comment">/* optional groups */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">void</span>	(*release)(struct device *dev);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">iommu_group</span>	*<span class="title">iommu_group</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dev_iommu</span>	*<span class="title">iommu</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">bool</span>			offline_disabled:<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">bool</span>			offline:<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">bool</span>			of_node_reused:<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">bool</span>			state_synced:<span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_ARCH_HAS_SYNC_DMA_FOR_DEVICE) || \</span></span><br><span class="line"><span class="meta">    defined(CONFIG_ARCH_HAS_SYNC_DMA_FOR_CPU) || \</span></span><br><span class="line"><span class="meta">    defined(CONFIG_ARCH_HAS_SYNC_DMA_FOR_CPU_ALL)</span></span><br><span class="line">	<span class="keyword">bool</span>			dma_coherent:<span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DMA_OPS_BYPASS</span></span><br><span class="line">	<span class="keyword">bool</span>			dma_ops_bypass : <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>parent: 该设备的父设备，一般是该设备所从属的bus controller等设备</li>
<li>p：一个用于struct device的私有数据结构指针，该指针中保存子设备链表，用于添加到bus&#x2F;driver&#x2F;parent等设备中的链表头等</li>
<li>kobj：该数据结构对应的kobject</li>
<li>init_name：设备名称，在设备模型中，名称是一个非常重要的变量，任何注册到内核中的设备，都必须有一个合法的名称，可以在初始化时给出，也可以由内核根据”bus_name + device id”的方式去创造</li>
<li>type：<code>struct device_type</code>它和<code>struct device</code>的关系非常类似<code>struct kobject</code>和<code>struct kobj_type</code>之间的关系</li>
<li>bus：该device属于哪个总线</li>
<li>driver：该device对应的device driver</li>
<li>platform_data：用于保存具体的平台相关的数据，可以将一些私有的数据暂存在这里，需要使用的时候，再拿出来</li>
<li>driver_data：用于保存和driver相关的私有数据</li>
<li>dev_t：一个32位的整数，由（major和minor）组成，以设备节点的形式向用户空间提供接口的设备中，当作设备号使用，该变量主要用于在sys文件系统中，为每个具有设备号的device，创建<code>/sys/dev/*</code>下的对应目录</li>
<li>class：该设备属于哪个class</li>
<li>group：该设备的默认attribute集合，将会在设备注册时自动在sysfs中创建对应的文件</li>
</ul>
<p>struct device_driver数据结构</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/linux/device/driver.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_driver</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> *<span class="title">bus</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *mod_name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> suppress_bind_attrs;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">probe_type</span> <span class="title">probe_type</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> *<span class="title">of_match_table</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">acpi_device_id</span> *<span class="title">acpi_match_table</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> (*probe) (struct devcie *dev);</span><br><span class="line">    <span class="keyword">void</span> (*sync_state)(struct device *dev);</span><br><span class="line">    <span class="keyword">int</span> (*remove) (struct device *dev);</span><br><span class="line">    <span class="keyword">void</span> (*shutdown) (struct device *dev);</span><br><span class="line">    <span class="keyword">int</span> (*suspend) (struct device *dev, <span class="keyword">pm_message_t</span> state);</span><br><span class="line">    <span class="keyword">int</span> (*resume) (struct device *dev);</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> **<span class="title">groups</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> **<span class="title">dev_groups</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dev_pm_ops</span> *<span class="title">pm</span>;</span></span><br><span class="line">    <span class="keyword">void</span> (*coredump) (struct device *dev);</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">drvier_private</span> *<span class="title">p</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>name：driver名称，和device结构一样，名称非常重要</li>
<li>bus：该driver所驱动设备的bus，内核要保证在driver运行前，设备所依赖的总线正确初始化</li>
<li>owner, mod_name：内核module相关的变量</li>
<li>suppres_bind_attrs：是否在sysfs中启用bind和unbind attribute</li>
<li>probe, remove：这两个接口函数用于实现driver逻辑的开始和结束，在设备模型的结构下，只有driver和device同时存在时，才需要开始执行driver的代码逻辑。这也是probe和remove两个接口名称的由来：检测到了设备和移除了设备</li>
<li>shutdown、suspend、resume、pm：电源管理相关的内容</li>
<li>groups：和struct device结构中的同名变量类似，driver也可以定义一些默认attribute，这样在将driver注册到内核中时，内核设备模型部分的代码（driver&#x2F;base&#x2F;driver.c）会自动将这些attribute添加到sysfs中</li>
<li>p：driver的私有数据指针，其他模块不能访问</li>
</ul>
<h5 id="设备模型框架下驱动开发的基本步骤"><a href="#设备模型框架下驱动开发的基本步骤" class="headerlink" title="设备模型框架下驱动开发的基本步骤"></a>设备模型框架下驱动开发的基本步骤</h5><p>在设备模型框架下，设备驱动的开发主要包括2个步骤</p>
<ol>
<li>分配一个<code>struct device</code>类型的变量，填充必要的信息后，把它注册到内核中</li>
<li>分配一个<code>struct device_driver</code>类型的变量，填充必要的信息后，把它注册到内核中</li>
</ol>
<p>这两步完成后，内核会在合适的时机，调用<code>struct device_driver</code>变量中的probe, remove, suspend, resume等回调函数，从而触发或终结设备驱动的执行，所有的驱动程序逻辑都会由这些回调函数实现</p>
<p><em>一般情况下，Linux驱动开发很少直接使用device和device_driver，因为内核在它们之上又封装了一层，如platform_device等，这些层次提供的接口更为简单，易用</em></p>
<h4 id="Bus"><a href="#Bus" class="headerlink" title="Bus"></a>Bus</h4><p>在Linux设备模型中，Bus（总线）是一类特殊的设备，它是连接处理器和其它设备之间的通道（channel）。为了方便设备模型的实现，内核规定，系统中的每个设备都要连接在一个Bus上，这个Bus可以是一个内部Bus、虚拟Bus或者Platform Bus</p>
<h5 id="bus定义"><a href="#bus定义" class="headerlink" title="bus定义"></a>bus定义</h5><p>内核通过<code>struct bus_type</code>结构抽象bus</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/linux/device/bus.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *dev_name;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev_root</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> **<span class="title">bus_groups</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> **<span class="title">dev_groups</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> **<span class="title">drv_groups</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> (*match)(struct device *dev, struct device_driver *drv);</span><br><span class="line">    <span class="keyword">int</span> (*uevent)(struct device *dev, struct kobj_uevent_env *env);</span><br><span class="line">    <span class="keyword">int</span> (*probe)(struct device *dev);</span><br><span class="line">    <span class="keyword">void</span> (*sync_state)(struct device *dev);</span><br><span class="line">    <span class="keyword">int</span> (*remove)(struct device *dev);</span><br><span class="line">    <span class="keyword">void</span> (*shutdown)(struct device *dev);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> (*online)(struct device *dev);</span><br><span class="line">    <span class="keyword">int</span> (*offline)(struct device *dev);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> (*suspend)(struct device *dev, <span class="keyword">pm_message_t</span> state);</span><br><span class="line">    <span class="keyword">int</span> (*resume)(struct device *dev);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> (*num_vf)(struct device *dev);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> (*dma_configure)(struct device *dev);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dev_pm_ops</span> *<span class="title">pm</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">iommu_ops</span> *<span class="title">iommu_ops</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">subsys_private</span> *<span class="title">p</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">lock_key</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> need_parent_lock;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>name: 该bus的名称，会在sysfs中以目录的形式存在，platform bus在sysfs中表现为”&#x2F;sys&#x2F;bus&#x2F;platform”</li>
<li>dev_name: 该名称和<code>struct device</code>结构中的init_name有关，对有些设备而言（例如批量化的USB设备），设计者根本就懒得为它起名字的，而内核也支持这种懒惰，允许将设备的名字留空。这样当设备注册到内核后，设备模型的核心逻辑就会用”bus-&gt;dev_name+device ID”的形式，为这样的设备生成一个名称</li>
<li>dev_root：和sub system功能有关</li>
<li>bus_groups, dev_groups, drv_groups：一些默认的attribute组</li>
<li>match：一个由具体的bus driver实现的回调函数，当任何属于该bus的device或device_driver添加到内核时，内核都会调用该接口，如果新加的device或device_driver匹配上了自己的另一半的话，该接口返回非零值，此时bus模块的核心逻辑就会执行后续的处理</li>
<li>uevent：一个由具体的bus driver实现的回调函数，当任何属于该Bus的device，发生添加、移除或者其它动作时，bus模块的核心逻辑就会调用该接口，以便bus driver能够修改环境变量</li>
<li>probe, remove：这两个回调函数，和device_driver中的非常类似，如果probe指定的device的话，需要保证该device所在的bus是被初始化过、确保能正确工作的，这就需要在执行device_driver的probe前，先执行它的bus的probe</li>
<li>shutdown, suspend, resume：和probe, remove的原理类似，这些是电源管理相关的实现</li>
</ul>
<p>subsys_private定义，subsys_private可以看做是bus的私有数据</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// drivers/base/base.h </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">subsys_private</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kset</span> <span class="title">subsys</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kset</span> *<span class="title">devices_kset</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">interfaces</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">mutex</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kset</span> *<span class="title">drivers_kset</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">klist</span> <span class="title">klist_devices</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">klist</span> <span class="title">klist_drivers</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">blocking_notifier_head</span> <span class="title">bus_notifier</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> drivers_autoprobe:<span class="number">1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> *<span class="title">bus</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kset</span> <span class="title">glue_dirs</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>subsys, devices_kset, drivers_kset：subsys代表了本bus的kobject集合，它下面可以包含其它的kset或者其它的kobject，devices_kset和drivers_kset则是bus下面的两个kset（如&#x2F;sys&#x2F;bus&#x2F;spi&#x2F;devices和&#x2F;sys&#x2F;bus&#x2F;spi&#x2F;drivers），分别包括本bus下所有的device和device_driver</li>
<li>interfaces：一个list_head链表，用于保存该bus下所有的interface</li>
<li>klist_devices和klist_drivers：这两个链表分别保存了本bus下所有的device和device_driver指针，以方便查找</li>
<li>drivers_autoprobe：用于控制该bus下的drivers或者devices是否自动probe</li>
<li>bus, class：分别保存上层的bus和class指针</li>
</ul>
<p>bus模块的功能包括：</p>
<ul>
<li>bus的注册和注销</li>
<li>本bus下device或者device_driver注册或注销到内核的处理</li>
<li>device_driver的probe处理</li>
<li>管理bus下的所有device和device_driver</li>
</ul>
<p>bus的注册是由<code>bus_register()</code>接口实现的，在接口的原型在<code>include/linux/device.h</code>中声明，在<code>drivers/base/bus.c</code>中实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// drivers/base/bus.c</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * bus_register - register a driver-core subsystem</span></span><br><span class="line"><span class="comment"> * @bus: bus to register</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Once we have that, we register the bus with the kobject</span></span><br><span class="line"><span class="comment"> * infrastructure, then register the children subsystems it has:</span></span><br><span class="line"><span class="comment"> * the devices and drivers that belong to the subsystem.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bus_register</span><span class="params">(struct bus_type *bus)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> retval;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">subsys_private</span> *<span class="title">priv</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> *<span class="title">key</span> =</span> &amp;bus-&gt;lock_key;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为subsys_private指针分配空间</span></span><br><span class="line">	priv = kzalloc(<span class="keyword">sizeof</span>(struct subsys_private), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!priv)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新priv-&gt;bus和bus-&gt;p的值</span></span><br><span class="line">	priv-&gt;bus = bus;</span><br><span class="line">	bus-&gt;p = priv;</span><br><span class="line"></span><br><span class="line">	BLOCKING_INIT_NOTIFIER_HEAD(&amp;priv-&gt;bus_notifier);</span><br><span class="line"></span><br><span class="line">	retval = kobject_set_name(&amp;priv-&gt;subsys.kobj, <span class="string">&quot;%s&quot;</span>, bus-&gt;name);</span><br><span class="line">	<span class="keyword">if</span> (retval)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	priv-&gt;subsys.kobj.kset = bus_kset;</span><br><span class="line">	priv-&gt;subsys.kobj.ktype = &amp;bus_ktype;</span><br><span class="line">	priv-&gt;drivers_autoprobe = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	retval = kset_register(&amp;priv-&gt;subsys);</span><br><span class="line">	<span class="keyword">if</span> (retval)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向bus目录下添加一个uevent attribute</span></span><br><span class="line">	retval = bus_create_file(bus, &amp;bus_attr_uevent);</span><br><span class="line">	<span class="keyword">if</span> (retval)</span><br><span class="line">		<span class="keyword">goto</span> bus_uevent_fail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向内核添加devices kset和drivers kset，并在sysfs中添加目录</span></span><br><span class="line">	priv-&gt;devices_kset = kset_create_and_add(<span class="string">&quot;devices&quot;</span>, <span class="literal">NULL</span>,</span><br><span class="line">						 &amp;priv-&gt;subsys.kobj);</span><br><span class="line">	<span class="keyword">if</span> (!priv-&gt;devices_kset) &#123;</span><br><span class="line">		retval = -ENOMEM;</span><br><span class="line">		<span class="keyword">goto</span> bus_devices_fail;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	priv-&gt;drivers_kset = kset_create_and_add(<span class="string">&quot;drivers&quot;</span>, <span class="literal">NULL</span>,</span><br><span class="line">						 &amp;priv-&gt;subsys.kobj);</span><br><span class="line">	<span class="keyword">if</span> (!priv-&gt;drivers_kset) &#123;</span><br><span class="line">		retval = -ENOMEM;</span><br><span class="line">		<span class="keyword">goto</span> bus_drivers_fail;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化链表 锁</span></span><br><span class="line">	INIT_LIST_HEAD(&amp;priv-&gt;interfaces);</span><br><span class="line">	__mutex_init(&amp;priv-&gt;mutex, <span class="string">&quot;subsys mutex&quot;</span>, key);</span><br><span class="line">	klist_init(&amp;priv-&gt;klist_devices, klist_devices_get, klist_devices_put);</span><br><span class="line">	klist_init(&amp;priv-&gt;klist_drivers, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在bus下添加drivers_probe和drivers_autoprobe两个attribute</span></span><br><span class="line">    <span class="comment">// 其中drivers_probe允许用户空间主动发出指定bus下的device_driver的probe动作</span></span><br><span class="line">    <span class="comment">// drivers_autoprobe控制是否在device或device_driver添加到内核时自动执行probe</span></span><br><span class="line">	retval = add_probe_files(bus);</span><br><span class="line">	<span class="keyword">if</span> (retval)</span><br><span class="line">		<span class="keyword">goto</span> bus_probe_files_fail;</span><br><span class="line"></span><br><span class="line">	retval = bus_add_groups(bus, bus-&gt;bus_groups);</span><br><span class="line">	<span class="keyword">if</span> (retval)</span><br><span class="line">		<span class="keyword">goto</span> bus_groups_fail;</span><br><span class="line"></span><br><span class="line">	pr_debug(<span class="string">&quot;bus: &#x27;%s&#x27;: registered\n&quot;</span>, bus-&gt;name);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">bus_groups_fail:</span><br><span class="line">	remove_probe_files(bus);</span><br><span class="line">bus_probe_files_fail:</span><br><span class="line">	kset_unregister(bus-&gt;p-&gt;drivers_kset);</span><br><span class="line">bus_drivers_fail:</span><br><span class="line">	kset_unregister(bus-&gt;p-&gt;devices_kset);</span><br><span class="line">bus_devices_fail:</span><br><span class="line">	bus_remove_file(bus, &amp;bus_attr_uevent);</span><br><span class="line">bus_uevent_fail:</span><br><span class="line">	kset_unregister(&amp;bus-&gt;p-&gt;subsys);</span><br><span class="line">out:</span><br><span class="line">	kfree(bus-&gt;p);</span><br><span class="line">	bus-&gt;p = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(bus_register);</span><br></pre></td></tr></table></figure>

<p>device和driver添加到bus中，内核提供了<code>device_register()</code>和<code>driver_register()</code>两个接口，供各个driver模块使用，这两个接口的核心逻辑是通过bus模块的<code>bus_add_device()</code>和<code>bus_add_driver()</code>来实现的</p>
<p><code>bus_add_device()</code>的实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// drivers/base/bus.c</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * bus_add_device - add device to bus</span></span><br><span class="line"><span class="comment"> * @dev: device being added</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * - Add device&#x27;s bus attributes.</span></span><br><span class="line"><span class="comment"> * - Create links to device&#x27;s bus.</span></span><br><span class="line"><span class="comment"> * - Add the device to its bus&#x27;s list of devices.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bus_add_device</span><span class="params">(struct device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> *<span class="title">bus</span> =</span> bus_get(dev-&gt;bus);</span><br><span class="line">	<span class="keyword">int</span> error = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (bus) &#123;</span><br><span class="line">		pr_debug(<span class="string">&quot;bus: &#x27;%s&#x27;: add device %s\n&quot;</span>, bus-&gt;name, dev_name(dev));</span><br><span class="line">		error = device_add_groups(dev, bus-&gt;dev_groups);</span><br><span class="line">		<span class="keyword">if</span> (error)</span><br><span class="line">			<span class="keyword">goto</span> out_put;</span><br><span class="line">        <span class="comment">// 将该device在sysfs中真正的位置，连接到bus的device目录下</span></span><br><span class="line">		error = sysfs_create_link(&amp;bus-&gt;p-&gt;devices_kset-&gt;kobj,</span><br><span class="line">						&amp;dev-&gt;kobj, dev_name(dev));</span><br><span class="line">		<span class="keyword">if</span> (error)</span><br><span class="line">			<span class="keyword">goto</span> out_groups;</span><br><span class="line">        <span class="comment">// 为该device的目录下创建一个名为subsystem的链接，链接到该device所在的bus目录</span></span><br><span class="line">		error = sysfs_create_link(&amp;dev-&gt;kobj,</span><br><span class="line">				&amp;dev-&gt;bus-&gt;p-&gt;subsys.kobj, <span class="string">&quot;subsystem&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (error)</span><br><span class="line">			<span class="keyword">goto</span> out_subsys;</span><br><span class="line">        <span class="comment">// 将该device添加到链表</span></span><br><span class="line">		klist_add_tail(&amp;dev-&gt;p-&gt;knode_bus, &amp;bus-&gt;p-&gt;klist_devices);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">out_subsys:</span><br><span class="line">	sysfs_remove_link(&amp;bus-&gt;p-&gt;devices_kset-&gt;kobj, dev_name(dev));</span><br><span class="line">out_groups:</span><br><span class="line">	device_remove_groups(dev, bus-&gt;dev_groups);</span><br><span class="line">out_put:</span><br><span class="line">	bus_put(dev-&gt;bus);</span><br><span class="line">	<span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h4><p>class是虚拟出来的，为了抽象设备的共性，class为一些相似的device提供通用的接口，定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> **<span class="title">class_groups</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> **<span class="title">dev_groups</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> *<span class="title">dev_kobj</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> (*dev_uevent)(struct device *dev, struct kobj_uevent_env *env);</span><br><span class="line">    <span class="keyword">char</span> *(*devnode)(struct device *dev, <span class="keyword">umode_t</span> *mode);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> (*class_release)(struct class *class);</span><br><span class="line">    <span class="keyword">void</span> (*dev_release)(struct device *device);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> (*shutdown_pre)(struct device *dev);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">kobj_ns_type_operations</span> *<span class="title">ns_type</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">void</span> *(*<span class="keyword">namespace</span>)(struct device *dev);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> (*get_ownership)(struct device *dev, <span class="keyword">kuid_t</span> *uid, <span class="keyword">kgid_t</span> *gid);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dev_pm_ops</span> *<span class="title">pm</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">subsys_private</span> *<span class="title">p</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>name：class的名称，会在<code>/sys/class/</code>下体现</li>
<li>class_groups：</li>
<li>dev_groups：</li>
<li>dev_kobj：表示该class下的设备在<code>/sys/dev/</code>下的目录，现在一般有char和block两个，如果dev_kobj为空，则默认选择char</li>
<li>class_release：用于release自身的回调函数</li>
<li>dev_release：用于release class内设备的回调函数</li>
<li>p：class私有数据</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Platform</tag>
      </tags>
  </entry>
  <entry>
    <title>git使用记录</title>
    <url>/archives/21d76c15.html</url>
    <content><![CDATA[<p>本文记录git使用过程中用到的一些功能</p>
<span id="more"></span>

<h4 id="git-ssh设置代理"><a href="#git-ssh设置代理" class="headerlink" title="git ssh设置代理"></a>git ssh设置代理</h4><p>在没有设置代理的情况下，git拉取 更新偶尔无法成功，在~&#x2F;.ssh&#x2F;config加入如下的配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">	HostName github.com</span><br><span class="line">	User git</span><br><span class="line">    <span class="comment"># socks代理</span></span><br><span class="line">	ProxyCommand nc -v -x 127.0.0.1:1089 %h %p</span><br></pre></td></tr></table></figure>
<p>测试ssh是否能连接github.com</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jack@linux:~/Documents/<span class="built_in">source</span>/vim (master) $ ssh -T git@github.com</span><br><span class="line">Connection to github.com 22 port [tcp/ssh] succeeded!</span><br><span class="line">Hi JackHuang021! You<span class="string">&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span></span><br></pre></td></tr></table></figure>

<h4 id="创建worktree"><a href="#创建worktree" class="headerlink" title="创建worktree"></a>创建worktree</h4><p>在各个差异较大的分支中切换，工程需要做全局编译，导致开发效率下降，创建worktree可以在多个分支并行开发，从而实多个工程环境的缓存，达到提升开发效率的目的，特点：</p>
<ul>
<li>可为一个分支创建一个工作区</li>
<li>每个工作区的工程环境独立运行</li>
<li>每个工作区共享同一个版本仓库信息</li>
</ul>
<p>相比通过git clone方式创建多个独立工程环境的工作区，git worktree的优点在于：</p>
<ul>
<li><strong>更节省硬盘空间</strong>：<code>git clone</code>方式下，每个工作区都有一个版本仓库，<code>git worktree</code>方式下，每个工作区共享同一个版本仓库，节省了n-1&#x2F;n（n为工作区数量）的硬盘空间</li>
<li><strong>各个工作区之间的更新同步更快</strong>：<code>git clone</code>方式下，A工作区和B工作区同步更新的步骤，A工作区commit -&gt; A工作区push -&gt; B工作区pull，<code>git worktree</code>方式下，A工作区只要本地提交更新后，其他工作区就能立即收到</li>
</ul>
<p><strong>git worktree使用</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入工程目录</span></span><br><span class="line"><span class="built_in">cd</span> path/to/project</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看worktree信息</span></span><br><span class="line">git worktree list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建worktree</span></span><br><span class="line">git worktree add worktree test_branch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入工作区worktree上进行开发</span></span><br><span class="line"><span class="built_in">cd</span> worktree</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除工作区</span></span><br><span class="line">git worktree remove path/to/worktree</span><br></pre></td></tr></table></figure>

<h4 id="合并其他分支commit到当前分支"><a href="#合并其他分支commit到当前分支" class="headerlink" title="合并其他分支commit到当前分支"></a>合并其他分支commit到当前分支</h4><p>使用<code>git cherry-pick</code>将其他分支的commit合并到另一个分支</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git cherry-pick &lt;commit-id&gt;</span><br></pre></td></tr></table></figure>
<p>同时也支持批量合并，一次可以cherry-pick一个区间内的commit</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git cherry-pick &lt;start-commit-id&gt;..&lt;end-commit-id&gt;</span><br></pre></td></tr></table></figure>

<h4 id="git生成patch"><a href="#git生成patch" class="headerlink" title="git生成patch"></a>git生成patch</h4><p>使用<code>git format-patch</code>生成patch</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成单个commit的patch</span></span><br><span class="line">git format-patch -1 &lt;commit id&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成最近1次commit的patch</span></span><br><span class="line">git format-patch HEAD^</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成最近2次commit的patch</span></span><br><span class="line">git format-patch HEAD^^</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成两个commit间的修改的patch</span></span><br><span class="line"><span class="comment"># 生成的patch不包含commit id1</span></span><br><span class="line">git format-patch &lt;commit id1&gt;..&lt;commit id2&gt;</span><br></pre></td></tr></table></figure>
<p>合入patch</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 检查patch是否能正常合入</span></span><br><span class="line">git apply --check &lt;path/to/patch&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合入patch</span></span><br><span class="line">git apply &lt;path/to/patch&gt;</span><br></pre></td></tr></table></figure>

<h4 id="git-PR过程"><a href="#git-PR过程" class="headerlink" title="git PR过程"></a>git PR过程</h4><ol>
<li><p>在Git主页fork开源项目，然后将fork后的项目仓库clone到本地</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@gitlab.phytium.com.cn:huangjie1663/linux-kernel.git</span><br></pre></td></tr></table></figure></li>
<li><p>添加远程代码仓库地址</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jack@linux: git remote add upstream git@gitlab.phytium.com.cn:embedded/linux/linux-kernel.git</span><br><span class="line">jack@linux: git remote -v</span><br><span class="line">origin	git@gitlab.phytium.com.cn:huangjie1663/linux-kernel.git (fetch)</span><br><span class="line">origin	git@gitlab.phytium.com.cn:huangjie1663/linux-kernel.git (push)</span><br><span class="line">upstream	git@gitlab.phytium.com.cn:embedded/linux/linux-kernel.git (fetch)</span><br><span class="line">upstream	git@gitlab.phytium.com.cn:embedded/linux/linux-kernel.git (push)</span><br></pre></td></tr></table></figure>
<p>这时总共包含三个仓库信息：本地仓库、origin仓库、upstream仓库</p>
</li>
<li><p>更新git remote中所有远程仓库所包含分支的最新commit，并合并upstream</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git fetch upstream</span><br><span class="line">git merge upstream/branch</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="git代码回滚"><a href="#git代码回滚" class="headerlink" title="git代码回滚"></a>git代码回滚</h4><p>git代码回滚常用的两种方式：<code>git revert</code>和<code>git reset</code></p>
<p>git reset，将提交的commit从历史记录中删除，用途如下：</p>
<ul>
<li>新提交的commit有问题，想要撤销该笔提交，并保留修改的内容<code>git reset --soft HEAD^</code></li>
<li>撤销新提交的commit，不保留修改的内容<code>git reset --hard HEAD^</code></li>
</ul>
<h4 id="git暂存文件转为unstage"><a href="#git暂存文件转为unstage" class="headerlink" title="git暂存文件转为unstage"></a>git暂存文件转为unstage</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 当前所有暂存文件全部转为unstage状态</span></span><br><span class="line">git restore --staged .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将某个暂存文件转为unstage状态</span></span><br><span class="line">git restore --staged &lt;filename&gt;</span><br></pre></td></tr></table></figure>

<h4 id="git-bisect定位问题"><a href="#git-bisect定位问题" class="headerlink" title="git bisect定位问题"></a>git bisect定位问题</h4><p>git bisect命令使用二分搜索算法来查找提交历史中的哪一次提交引入了错误，只需要告诉这个命令一个包含该bug的坏commit ID和一个引入该bug之前的好commit ID，这个命令会用二分法在这两个提交之间选择一个中间的commit ID，切换到那个commit ID的代码，然后询问你这是好的commit ID还是坏的commit ID，你告诉它是好还是坏，然后它会不断缩小范围，直到找到那次引入bug的commit ID</p>
]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux字符设备驱动开发</title>
    <url>/archives/d281c370.html</url>
    <content><![CDATA[<p>字符设备是Linux驱动中最基本的一类设备驱动，字符设备就是一个一个字节，按照字节流进行读写操作的设备，读写数据是分先后顺序的，这些设备的驱动就叫做字符设备驱动</p>
<span id="more"></span>

<p>应用程序运行在用户空间，Linux驱动属于内核的一部分，因此驱动运行于内核空间，当在用户空间想要实现对内核的操作，比如使用<code>open</code>函数打开<code>/dev/led</code>这个设备，因为用户空间不能直接对内核进行操作，因此必须使用一个叫做“系统调用”的方法来实现从用户空间陷入到内核空间，这样才能实现对底层驱动的操作。</p>
<p>应用程序调用<code>open()</code>函数的流程:<br>应用调用open函数（应用程序） -&gt; C库中的open（）函数 -&gt; open（）系统调用</p>
<p>每一个系统调用在驱动中都有与之对应的一个驱动函数，在Linux内核文件<code>include/linux/fs.h</code>中有一个叫做<code>file_operations</code>的结构体，此结构体就是Linux内核驱动操作函数集合，<br>该结构体内容如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">    <span class="keyword">loff_t</span> (*llseek) (struct file *, <span class="keyword">loff_t</span>, <span class="keyword">int</span>);</span><br><span class="line">    <span class="keyword">ssize_t</span> (*read) (struct file *, <span class="keyword">char</span> __user *, <span class="keyword">size_t</span>, <span class="keyword">loff_t</span> *);</span><br><span class="line">    <span class="keyword">ssize_t</span> (*write) (struct file *, <span class="keyword">const</span> <span class="keyword">char</span> __user *, <span class="keyword">size_t</span>, <span class="keyword">loff_t</span> *);</span><br><span class="line">    <span class="keyword">ssize_t</span> (*read_iter) (struct kiocb *, struct iov_iter *);</span><br><span class="line">    <span class="keyword">ssize_t</span> (*write_iter) (struct kiocb *, struct iov_iter *);</span><br><span class="line">    <span class="keyword">int</span> (*iterate) (struct file *, struct dir_context *);</span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span> <span class="params">(*poll)</span> <span class="params">(struct file *, struct poll_table_struct *)</span></span>;</span><br><span class="line">    <span class="keyword">long</span> (*unlocked_ioctl) (struct file *, <span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>);</span><br><span class="line">    <span class="keyword">long</span> (*compat_ioctl) (struct file *, <span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>);</span><br><span class="line">    <span class="keyword">int</span> (*mmap) (struct file *, struct vm_area_struct *);</span><br><span class="line">    <span class="keyword">int</span> (*mremap)(struct file *, struct vm_area_struct *);</span><br><span class="line">    <span class="keyword">int</span> (*open) (struct inode *, struct file *);</span><br><span class="line">    <span class="keyword">int</span> (*flush) (struct file *, <span class="keyword">fl_owner_t</span> id);</span><br><span class="line">    <span class="keyword">int</span> (*release) (struct inode *, struct file *);</span><br><span class="line">    <span class="keyword">int</span> (*fsync) (struct file *, <span class="keyword">loff_t</span>, <span class="keyword">loff_t</span>, <span class="keyword">int</span> datasync);</span><br><span class="line">    <span class="keyword">int</span> (*aio_fsync) (struct kiocb *, <span class="keyword">int</span> datasync);</span><br><span class="line">    <span class="keyword">int</span> (*fasync) (<span class="keyword">int</span>, struct file *, <span class="keyword">int</span>);</span><br><span class="line">    <span class="keyword">int</span> (*lock) (struct file *, <span class="keyword">int</span>, struct file_lock *);</span><br><span class="line">    <span class="keyword">ssize_t</span> (*sendpage) (struct file *, struct page *, <span class="keyword">int</span>, <span class="keyword">size_t</span>, <span class="keyword">loff_t</span> *, <span class="keyword">int</span>);</span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">long</span> <span class="params">(*get_unmapped_area)</span><span class="params">(struct file *, <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> (*check_flags)(<span class="keyword">int</span>);</span><br><span class="line">    <span class="keyword">int</span> (*flock) (struct file *, <span class="keyword">int</span>, struct file_lock *);</span><br><span class="line">    <span class="keyword">ssize_t</span> (*splice_write)(struct pipe_inode_info *, struct file *, <span class="keyword">loff_t</span> *, <span class="keyword">size_t</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span>);</span><br><span class="line">    <span class="keyword">ssize_t</span> (*splice_read)(struct file *, <span class="keyword">loff_t</span> *, struct pipe_inode_info *, <span class="keyword">size_t</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span>);</span><br><span class="line">    <span class="keyword">int</span> (*setlease)(struct file *, <span class="keyword">long</span>, struct file_lock **, <span class="keyword">void</span> **);</span><br><span class="line">    <span class="keyword">long</span> (*fallocate)(struct file *file, <span class="keyword">int</span> mode, <span class="keyword">loff_t</span> offset,</span><br><span class="line">              <span class="keyword">loff_t</span> len);</span><br><span class="line">    <span class="keyword">void</span> (*show_fdinfo)(struct seq_file *m, struct file *f);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONFIG_MMU</span></span><br><span class="line">    <span class="keyword">unsigned</span> (*mmap_capabilities)(struct file *);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<pre><code>+ `owner`拥有该结构体的模块的指针，一般设置为`THIS_MODULE`  
+ `loff_t (*llseak) (struct file *, loff_t, int)`：该函数用于修改文件当前的读写位置  
+ `ssize_t (*read) (struct file *, char __user *, size_t, loff_t *)`：用于读取设备文件
+ `ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *)`：用于向设备文件写入数据
+ `unsigned int (*poll) (struct file *, struct poll_table_struct *)`：用于查询设备是否可以进行非阻塞的读写
+ `long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long)`：与应用程序中的`ioctl`函数对应
+ `long (*compat_ioctl) (struct file *, unsigned int, unsigned long)`：功能与`unlocked_ioctl()`函数功能一样，区别在于在64位系统上，32位的应用程序调用将会使用此函数，在32位的系统上运行32位的应用程序调用的是`unlocked_ioctl()`
+ `int (*mmap) (struct file *, struct vm_area_struct *)`：用于将设备的内存映射到进程空间（即用户空间），一般帧缓冲设备会使用此函数，比如LCD驱动的显存，将帧缓冲映射到用户空间中以后应用程序就可以直接操作显存了，这样就不用在用户空间和内核空间之间来回复制
+ `int (*open) (struct inode *, struct file *)`、：用于打开设备文件
+ `int (*release) (struct inode *, struct file *)`：用于释放设备文件，与应用程序中的`close()`函数对应
+ `int (*fsync) (int, struct file *, int)`：用于刷新待处理的数据，将缓冲区的数据刷新到磁盘中
</code></pre>
<h4 id="sysfs文件系统目录结构"><a href="#sysfs文件系统目录结构" class="headerlink" title="sysfs文件系统目录结构"></a>sysfs文件系统目录结构</h4><table>
<thead>
<tr>
<th align="center">目录</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>sysfs</code></td>
<td>文件系统提供了一种用户与内核数据结构进行交互的方式，Linux设备模型中设备、驱动、总线组织成拓扑结构，通过<code>sysfs</code>文件系统以目录结构进行展示与管理</td>
</tr>
<tr>
<td align="center"><code>devices</code></td>
<td>内核对系统中所有设备的分层次表达模型，也是<code>/sys</code>文件系统管理设备的最重要的目录结构</td>
</tr>
<tr>
<td align="center"><code>dev</code></td>
<td>这个目录下维护一个按字符设备和块设备的设备号文件(major:minor)链接到真实的设备</td>
</tr>
<tr>
<td align="center"><code>bus</code></td>
<td>内核按照总线类型分层放置的目录结构，<code>devices</code>中的所有设备都是连接于某种总线之下，每一种具体总线之下可以找到每一个具体设备的符号链接，是构成Linux统一设备模型的一部分</td>
</tr>
<tr>
<td align="center"><code>class</code></td>
<td>这是按照设备功能分类的设备模型，如系统所有输入设备都会出现在<code>/sys/class/input</code>之下，不论它们是以何种总线连接到系统，它也是构成Linux统一设备模型的一部分</td>
</tr>
<tr>
<td align="center"><code>block</code></td>
<td>这是系统中当前所有块设备所在的目录，按照功能来说放置在<code>/sys/class</code>下更恰当，由于历史遗留因素而一直存在于<code>/sys/block</code>，在2.6.26内核中已经正式移到<code>/sys/class/block</code>，<code>/sys/block</code>中的内容已经变为指向它们在<code>/sys/devices</code>中真实设备的符号链接文件</td>
</tr>
<tr>
<td align="center"><code>firmware</code></td>
<td>系统加载固件机制的对用户空间的接口</td>
</tr>
<tr>
<td align="center"><code>fs</code></td>
<td>用于描述系统中所有文件系统，包括文件系统本身和按文件系统分类存放的已挂载点</td>
</tr>
<tr>
<td align="center"><code>kernel</code></td>
<td>内核所有可调整参数的位置，目前只有<code>uevent_helper</code>,<code>kexec_loaded</code>,<code>mm</code>和新式的<code>slab</code>分配器等几项较新的设计在使用，其它内核可调整参数仍然位于<code>/proc/sys/kernel</code>接口中</td>
</tr>
<tr>
<td align="center"><code>module</code></td>
<td>系统中所有模块的信息，不论这些模块是以内联方式编译到内核镜像<code>vmlinux</code>中还是编译为外部</td>
</tr>
</tbody></table>
<h4 id="对字符设备的封装：cdev结构体"><a href="#对字符设备的封装：cdev结构体" class="headerlink" title="对字符设备的封装：cdev结构体"></a>对字符设备的封装：<code>cdev</code>结构体</h4><ul>
<li><code>cdev</code>结构体定义在<code>include/linux/cdev.h</code>中  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">    <span class="keyword">dev_t</span> dev;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count;</span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure></li>
<li>其中<a href="https://lwn.net/Articles/722293/"><code>__randomsize_layout</code></a>表示随机化一个结构体，在编译时随机排布结构体中元素的顺序，从而使攻击者无法通过地址偏移的方式获取一些敏感数据成员的信息</li>
<li><code>struct kobject kobj;</code>：抽象出来的用来表示设备模型的数据结构</li>
<li><code>const struct file_operations *ops;</code>：定义了字符设备驱动提供给虚拟文件系统的接口函数集合</li>
<li><code>struct list_head list;</code>：将所有字符设备通过链表进行管理</li>
<li><code>dev_t dev</code>：设备号，<code>dev_t</code>数据结构定义在<code>include/linux/types.h</code>中，包含主设备号和次设备号，实际是一个32位整形数据，其中高12位为主设备号，低20位为次设备号  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// dev_t的定义</span></span><br><span class="line"><span class="keyword">typedef</span> u32 <span class="keyword">__kernel_dev_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">__kernel_dev_t</span>		<span class="keyword">dev_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设备号的一些操作宏</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MINORBITS	20</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MINORMASK	((1U &lt;&lt; MINORBITS) - 1)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAJOR(dev)	((unsigned int) ((dev) &gt;&gt; MINORBITS))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MINOR(dev)	((unsigned int) ((dev) &amp; MINORMASK))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MKDEV(ma,mi)	(((ma) &lt;&lt; MINORBITS) | (mi))</span></span><br></pre></td></tr></table></figure></li>
<li><code>unsigned int count;</code>：属于同主设备号的次设备号的个数</li>
</ul>
<h4 id="设备管理机制：kobject"><a href="#设备管理机制：kobject" class="headerlink" title="设备管理机制：kobject"></a>设备管理机制：<code>kobject</code></h4><ul>
<li><code>kobject</code>是Linux设备驱动模型的基础，也是设备模型中抽象的一部分，它与sysfs文件系统紧密相连，在内核中注册的每个<code>kobject</code>对象对应sysfs文件系统中的一个目录</li>
<li><code>kobject</code>是组成设备模型的基本结构，是所有用来描述设备模型的数据结构的基类，它嵌入在所有的描述设备模型的容器对象中，例如bus,devices,drivers，这些容器通过<code>kobject</code>链接起来，形成一个树形结构</li>
<li>该结构体定义在<code>include/linux/kobject.h</code>中，通过这个数据结构可以使所有设备在底层都具有统一的接口，<code>kobject</code>提供基本的对象管理，结构体内容如下：  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>		*name;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">entry</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span>		*<span class="title">parent</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kset</span>		*<span class="title">kset</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobj_type</span>	*<span class="title">ktype</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kernfs_node</span>	*<span class="title">sd</span>;</span> <span class="comment">/* sysfs directory entry */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kref</span>		<span class="title">kref</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_KOBJECT_RELEASE</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">delayed_work</span>	<span class="title">release</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> state_initialized:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> state_in_sysfs:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> state_add_uevent_sent:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> state_remove_uevent_sent:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> uevent_suppress:<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><code>const char *name;</code>：<code>kobject</code>名字，对应<code>sysfs</code>下的一个目录</li>
<li><code>struct list_head entry;</code>：<code>kobject</code>中插入的的<code>list_head</code>链表结构，用于构造双向链表</li>
<li><code>struct kobject *parent;</code>：指向当前<code>kobject</code>父对象的指针，体现在<code>sysfs</code>中就是包含当前<code>kobject</code>对象的目录对象</li>
<li><code>struct kset *kset;</code>：当前<code>kobject</code>对象所属的集合</li>
<li><code>struct kobj_type *ktype;</code>：当前<code>kobject</code>对象的类型</li>
<li><code>struct kernfs_node *sd;</code>：VFS文件系统的目录项，是设备和文件之间的桥梁，<code>sysfs</code>中的符号链接是通过<code>kernel_node</code>内的联合体实现的</li>
<li><code>struct kref kref;</code>：<code>kobject</code>的引用计数，当计数为0时，回调之前注册的<code>release</code>方法释放对象</li>
<li><code>unsigned int state_initialized:1;</code>：初始化标志位，初始化时被置位</li>
<li><code>unsigned int state_in_sysfs:1;</code>：<code>kobject</code>在<code>sysfs</code>中的状态，在目录中创建则为1，否则为0</li>
<li><code>unsigned int state_add_uevent_sent:1</code>：添加设备的<code>uevent</code>事件是否发送标志，添加设备时向用户控件发送<code>uevent</code>事件，请求新增设备</li>
<li><code>unsigned int state_remove_uevent_sent:1</code>：删除设备的<code>uevent</code>事件是否发送标志，删除设备时向用户控件发送<code>uevent</code>事件，请求卸载设备</li>
<li><code>unsigned int uevent_suppress:1</code>：是否忽略上报<code>uevent</code></li>
</ul>
<h4 id="kobject集合-kset"><a href="#kobject集合-kset" class="headerlink" title="kobject集合 kset"></a><code>kobject</code>集合 <code>kset</code></h4><ul>
<li><code>kset</code>是包含多个<code>kobject</code>的集合，如果在<code>sysfs</code>的目录中包含多个子目录，那需要将它定义成一个<code>kset</code>  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct kset - a set of kobjects of a specific type, belonging to a specific subsystem.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * A kset defines a group of kobjects.  They can be individually</span></span><br><span class="line"><span class="comment"> * different &quot;types&quot; but overall these kobjects all want to be grouped</span></span><br><span class="line"><span class="comment"> * together and operated on in the same manner.  ksets are used to</span></span><br><span class="line"><span class="comment"> * define the attribute callbacks and other common events that happen to</span></span><br><span class="line"><span class="comment"> * a kobject.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @list: the list of all kobjects for this kset</span></span><br><span class="line"><span class="comment"> * @list_lock: a lock for iterating over the kobjects</span></span><br><span class="line"><span class="comment"> * @kobj: the embedded kobject for this kset (recursion, isn&#x27;t it fun...)</span></span><br><span class="line"><span class="comment"> * @uevent_ops: the set of uevent operations for this kset.  These are</span></span><br><span class="line"><span class="comment"> * called whenever a kobject has something happen to it so that the kset</span></span><br><span class="line"><span class="comment"> * can add new environment variables, or filter out the uevents if so</span></span><br><span class="line"><span class="comment"> * desired.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kset</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">    <span class="keyword">spinlock_t</span> list_lock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">kset_uevent_ops</span> *<span class="title">uevent_ops</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><code>struct list_head list;</code>：包含在<code>kset</code>在内的所有<code>kobject</code>构成的一个双向链表</li>
<li><code>spinlock_t list_lock;</code>：遍历<code>kobject</code>时的锁</li>
<li><code>struct kobject kobj;</code>：归属于该<code>kset</code>的所有的<code>kobject</code>的parent</li>
<li><code>const struct kset_uevent_ops *uevent_ops;</code>：<code>kset</code>的<code>uevent</code>操作函数集，当<code>kset</code>中的<code>kobject</code>有状态变化时，会回调这个函数集</li>
</ul>
<h4 id="kobject类型-ktype"><a href="#kobject类型-ktype" class="headerlink" title="kobject类型 ktype"></a><code>kobject</code>类型 <code>ktype</code></h4><ul>
<li><code>kobj_type</code>用于表征<code>kobject</code>的类型，指定了删除<code>kobject</code>时要调用的函数，<code>kobject</code>结构体中有<code>struct kref</code>字段对<code>kobject</code>进行引用计数，当计数值为0时，就会调用<code>kobj_type</code>中的<code>release</code>函数对<code>kobject</code>进行释放</li>
<li><code>kobj_type</code>指定了通过<code>sysfs</code>显示或修改有关<code>kobject</code>的信息时要处理的操作，实际是调用<code>show/store</code>函数  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kobj_type</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> (*release)(struct kobject *kobj);</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sysfs_ops</span> *<span class="title">sysfs_ops</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">attribute</span> **<span class="title">default_attrs</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">kobj_ns_type_operations</span> *(*<span class="title">child_ns_type</span>)(<span class="keyword">struct</span> <span class="title">kobject</span> *<span class="title">kobj</span>);</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">void</span> *(*<span class="keyword">namespace</span>)(struct kobject *kobj);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sysfs_ops</span> &#123;</span></span><br><span class="line">    <span class="keyword">ssize_t</span>	(*show)(struct kobject *, struct attribute *, <span class="keyword">char</span> *);</span><br><span class="line">    <span class="keyword">ssize_t</span>	(*store)(struct kobject *, struct attribute *, <span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">size_t</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">attribute</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>		*name;</span><br><span class="line">    <span class="keyword">umode_t</span>			mode;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_LOCK_ALLOC</span></span><br><span class="line">    <span class="keyword">bool</span>			ignore_lockdep:<span class="number">1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span>	*<span class="title">key</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span>	<span class="title">skey</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><code>void (*release)(struct koject *kobj);</code> 释放<code>kobject</code>对象的接口，有点类似面向对象中的析构</li>
<li><code>const struct sysfs_ops *sysfs_ops;</code> 操作<code>kobject</code>的方法集</li>
<li><code>struct attribute **default_attrs;</code> 所谓的<code>attribute</code>就是内核控件和用户空间进行信息交互的一种方法，例如某个driver定义了一个变量，却希望用户空间程序可以修改该变量，那么可以将该变量以<code>sysfs attribute</code>的形式开放出来</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Driver</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核likely()和unlikely()</title>
    <url>/archives/8c0c86d5.html</url>
    <content><![CDATA[<p>Linux内核中多次出现<code>likely()</code>，<code>unlikely()</code>的使用，他们的定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> likely(x)     __builtin_expect(!!(x), 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> unlikely(x)   __builtin_expect(!!(x), 0)</span></span><br></pre></td></tr></table></figure>

<span id="more"></span>
<p><code>__builtin_expect</code>是GCC提供的内置函数（built-in functions），函数原型是</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> __builtin_expect(<span class="keyword">long</span> <span class="built_in">exp</span>, <span class="keyword">long</span> c);</span><br></pre></td></tr></table></figure>
<p>函数的返回值就是<code>exp</code>，不过他告诉编译器，代码期望的是<code>exp == c</code>， 如果<code>exp == c</code>条件成立的机会占绝大多数，那么程序运行性能将会得到提升，否则性能反而会下降</p>
<p><code>builtin_expect()</code>用来引导gcc进行条件分支预测，在一条指令执行时，由于流水线的作用，CPU可以同时完成下一条指令的预取，这样可以提高CPU的利用率，在执行条件分支时，CPU也会预期下一条指令，但是如果预测的结果不为<code>exp == c</code>那么CPU预取的下一条指令就没用了，这样就降低了流水线的效率，跳转指令相对于顺序执行的指令会多消CPU时间，如果可以尽可能不执行跳转，也可以提高CPU性能。</p>
<p>表面上看<code>if(likely(value))</code>和<code>if(unlikely(value))</code>都等同于<code>if(value)</code>，也就是<code>likely()</code>和<code>unlikely()</code>作用是一样的，但是实际上执行的效果是不同的（从指令预测的角度上来说），加<code>likely</code>的意思是value为真的可能性更大一些，那么预测执行if的可能性要大些，<code>unlikely</code>正好相反。</p>
<p>加上这种修饰，编译成二进制代码时<code>likely</code>使得if后面的执行语句紧跟着前面的程序，<code>unlikely</code>使得else后面的语句紧跟着前面的程序，这样就会被cache预读取，增加程序的执行速度。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux DMA驱动框架</title>
    <url>/archives/1990ed3c.html</url>
    <content><![CDATA[<h4 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h4><p>DMA是Direct Memory Access的缩写，就是绕开CPU进行内存的访问，DMA控制器就是用来协助CPU在memory和memory或者memory和设备之间搬运数据</p>
<p><img src="https://raw.githubusercontent.com/JackHuang021/images/master/20230526141809.png"></p>
<span id="more"></span>
<h5 id="DMA-channels"><a href="#DMA-channels" class="headerlink" title="DMA channels"></a>DMA channels</h5><p>一个DMA可以“同时”进行DMA传输的个数是有限的，这称作DMA channels，这里的channel只是一个逻辑上的概念</p>
<blockquote>
<p>鉴于总线访问的冲突，以及内存一致性的考量，从物理的角度看，不大可能会同时进行两个（及以上）的DMA传输。因而DMA channel不太可能是物理上独立的通道；</p>
<p>很多时候，DMA channels是DMA controller为了方便，抽象出来的概念，让consumer以为独占了一个channel，实际上所有channel的DMA传输请求都会在DMA controller中进行仲裁，进而串行传输；</p>
<p>因此，软件也可以基于controller提供的channel（我们称为“物理”channel），自行抽象更多的“逻辑”channel，软件会管理这些逻辑channel上的传输请求。实际上很多平台都这样做了，在DMA Engine framework中，不会区分这两种channel（本质上没区别）。</p>
</blockquote>
<h5 id="DMA-request-line"><a href="#DMA-request-line" class="headerlink" title="DMA request line"></a>DMA request line</h5><p>DMA传输是由CPU发起的，CPU会告诉DMA控制器，把xxx地方的数据搬运到xxx地方，而DMA控制器，除了负责怎么搬之外还要决定一件非常重要的事情：何时开始搬运？</p>
<p>因为，CPU发起DMA传输的时候，并不知道当前是否具备传输条件，例如source设备是否有数据、dest设备的FIFO是否空闲等等。那谁知道是否可以传输呢？设备！因此，需要DMA传输的设备和DMA控制器之间，会有几条物理的连接线（称作DMA request，DRQ），用于通知DMA控制器可以开始传输了。</p>
<p>通常来说，每一个数据收发的节点（称作endpoint），和DMA controller之间，就有一条DMA request line。</p>
<h5 id="传输参数"><a href="#传输参数" class="headerlink" title="传输参数"></a>传输参数</h5><p><strong>transfer size:</strong> 在每一个时钟周期，DMA controller将1 byte的数据从一个buffer搬到另一个buffer，直到搬完transfer size个byte即可停止</p>
<p><strong>transfer width:</strong> 传输的数据宽度，在一个时钟周期中，传输指定的bit的数据，DDMA固定为4字节</p>
<p><strong>buffer size:</strong> DMA控制器内部可缓存的数据量大小</p>
<p><strong>scatter-gather:</strong> DMA传输一般情况下只能处理物理上连续的buffer，在某些场景下将一些非连续的buffer拷贝到一个连续的buffer中，这样的操作称为scatter-gather，对于这种非连续的传输，大多时候都是通过软件，将传输分成多个连续的小块（chunk）,例如在dmaengine中的scatterlist</p>
<p><strong>burst size:</strong> DMA控制器内部可缓存的数据量大小，按照DDMA的手册描述应该是固定为64字节，一次搬64字节</p>
<h4 id="Linux-dmaengine"><a href="#Linux-dmaengine" class="headerlink" title="Linux dmaengine"></a>Linux dmaengine</h4><p>从方向上来说：DMA传输可以分为4类，memory到memory，memory到device，device到memory以及device到device，从linux kernel的角度，外设都是slave，因此这些有device参与的传输（MEM2DEV, DEV2MEM, DEV2DEV）为Slave-DMA传输，另一种memory到memory的传输，被称为Async TX</p>
<p>因为Linux为了方便基于DMA的memcpy、memset等操作，在dma engine之上，封装了一层更为简洁的API，这种API就是Async TX API（以async_开头，例如async_memcpy、async_memset、async_xor等）。因为memory到memory的DMA传输有了比较简洁的API，没必要直接使用dma engine提供的API，最后就导致dma engine所提供的API就特指为Slave-DMA API</p>
<p>Slave-DMA中的slave指的是参与DMA传输的设备，对应的master就是指DMA controller自身</p>
<h5 id="重要数据结构"><a href="#重要数据结构" class="headerlink" title="重要数据结构"></a>重要数据结构</h5><p><code>struct dma_device</code>，用于抽象dma controller</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* include/linux/dmaengine.h */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dma_device</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kref</span> <span class="title">ref</span>;</span></span><br><span class="line">	<span class="comment">/* 当前支持的dma通道数，读取设备树的dma-channels值 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> chancnt;</span><br><span class="line">	<span class="comment">/* 已经申请的dma通道数 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> privatecnt;</span><br><span class="line">  	<span class="comment">/* 用于保存该controller支持的所有dma channel */</span></span><br><span class="line">  	<span class="comment">/* 初始化的时候需要将所有的channel加入到链表头中 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">channels</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">global_node</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dma_filter</span> <span class="title">filter</span>;</span></span><br><span class="line">  	<span class="comment">/* 用于指示dma controller所具备的功能，DDMA仅具有DMA_SLAVE的功能 */</span></span><br><span class="line">	<span class="keyword">dma_cap_mask_t</span>  cap_mask;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* dma controller支持的源数据宽度类型，DDMA只支持4字节 */</span></span><br><span class="line">	u32 src_addr_widths;</span><br><span class="line">	<span class="comment">/* dma controller支持的目的数据宽度类型，DDMA只支持4字节 */</span></span><br><span class="line">	u32 dst_addr_widths;</span><br><span class="line">	<span class="comment">/* dma controller支持的传输方向，DDMA只支持MEM_TO_DEV DEV_TO_MEM */</span></span><br><span class="line">	u32 directions;</span><br><span class="line">	u32 min_burst;</span><br><span class="line">	u32 max_burst;</span><br><span class="line">	<span class="comment">/* 单次传输的一个散列表中支持的最大长度，DDMA驱动里面设置是4KB */</span></span><br><span class="line">	u32 max_sg_burst;</span><br><span class="line">	<span class="comment">/* 报告传输剩余数据长度的功能 */</span></span><br><span class="line">	<span class="keyword">bool</span> descriptor_reuse;</span><br><span class="line">	<span class="comment">/* 剩余数据长度报告的类型，一共有三种：无法上报、传输完成后即可上报、每个brust传输后报告 */</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">dma_residue_granularity</span> <span class="title">residue_granularity</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 分配通道的接口 */</span></span><br><span class="line">	<span class="keyword">int</span> (*device_alloc_chan_resources)(struct dma_chan *chan);</span><br><span class="line">	<span class="comment">/* 释放通道的接口 */</span></span><br><span class="line">	<span class="keyword">void</span> (*device_free_chan_resources)(struct dma_chan *chan);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* dma通道准备传输的接口 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dma_async_tx_descriptor</span> *(*<span class="title">device_prep_slave_sg</span>)(</span></span><br><span class="line"><span class="class">		<span class="keyword">struct</span> <span class="title">dma_chan</span> *<span class="title">chan</span>, <span class="keyword">struct</span> <span class="title">scatterlist</span> *<span class="title">sgl</span>,</span></span><br><span class="line"><span class="class">		<span class="title">unsigned</span> <span class="title">int</span> <span class="title">sg_len</span>, <span class="title">enum</span> <span class="title">dma_transfer_direction</span> <span class="title">direction</span>,</span></span><br><span class="line"><span class="class">		<span class="title">unsigned</span> <span class="title">long</span> <span class="title">flags</span>, <span class="title">void</span> *<span class="title">context</span>);</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">void</span> (*device_caps)(struct dma_chan *chan,</span><br><span class="line">			    struct dma_slave_caps *caps);</span><br><span class="line">	<span class="comment">/* 对dma通道进行配置的接口 */</span></span><br><span class="line">	<span class="keyword">int</span> (*device_config)(struct dma_chan *chan,</span><br><span class="line">			     struct dma_slave_config *config);</span><br><span class="line">	<span class="comment">/* 暂停传输的接口 */</span></span><br><span class="line">	<span class="keyword">int</span> (*device_pause)(struct dma_chan *chan);</span><br><span class="line">	<span class="comment">/* 恢复传输的接口 */</span></span><br><span class="line">	<span class="keyword">int</span> (*device_resume)(struct dma_chan *chan);</span><br><span class="line">	<span class="comment">/* 终止dma通道传输的接口 */</span></span><br><span class="line">	<span class="keyword">int</span> (*device_terminate_all)(struct dma_chan *chan);</span><br><span class="line">	<span class="comment">/* 获取本次传输状态和已经传输完的长度 */</span></span><br><span class="line">	<span class="function"><span class="keyword">enum</span> <span class="title">dma_status</span> <span class="params">(*device_tx_status)</span><span class="params">(struct dma_chan *chan,</span></span></span><br><span class="line"><span class="params"><span class="function">					    <span class="keyword">dma_cookie_t</span> cookie,</span></span></span><br><span class="line"><span class="params"><span class="function">					    struct dma_tx_state *txstate)</span></span>;</span><br><span class="line">	<span class="comment">/* 启动dma传输的接口 */</span></span><br><span class="line">	<span class="keyword">void</span> (*device_issue_pending)(struct dma_chan *chan);</span><br><span class="line">	<span class="keyword">void</span> (*device_release)(struct dma_device *dev);</span><br><span class="line">	<span class="comment">/* debugfs support */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_FS</span></span><br><span class="line">	<span class="keyword">void</span> (*dbg_summary_show)(struct seq_file *s, struct dma_device *dev);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">dbg_dev_root</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>struct dma_chan</code>用于抽象物理dma channel</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* include/linux/dmaengine.h */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dma_chan</span> &#123;</span></span><br><span class="line">	<span class="comment">/* 指向所在的dma device */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dma_device</span> *<span class="title">device</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">slave</span>;</span></span><br><span class="line">	<span class="keyword">dma_cookie_t</span> cookie;</span><br><span class="line">	<span class="comment">/* 在这个channel上最后一次完成的传输的cookie */</span></span><br><span class="line">	<span class="comment">/* dma controller driver可以调用dma_cookie_complete设置它的value */</span></span><br><span class="line">	<span class="keyword">dma_cookie_t</span> completed_cookie;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* sysfs */</span></span><br><span class="line">	<span class="keyword">int</span> chan_id;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dma_chan_dev</span> *<span class="title">dev</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_FS</span></span><br><span class="line">	<span class="keyword">char</span> *dbg_client_name;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 用于将该channel添加到dma_device的channels列表中 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">device_node</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dma_chan_percpu</span> __<span class="title">percpu</span> *<span class="title">local</span>;</span></span><br><span class="line">	<span class="keyword">int</span> client_count;</span><br><span class="line">	<span class="keyword">int</span> table_count;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* DMA router */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dma_router</span> *<span class="title">router</span>;</span></span><br><span class="line">	<span class="keyword">void</span> *route_data;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">void</span> *<span class="keyword">private</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>struct virt_dma_chan</code>用于抽象一个虚拟的dma_channel，多个虚拟channel可以共用一个物理channel，并由软件调度多个传输请求，将多个虚拟channel的传输串行地在物理channel上完成</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* drivers/dma/virt_dma.h */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* struct virt_dma_desc 对请求描述符做了一个简单的封装 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">virt_dma_desc</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dma_async_tx_descriptor</span> <span class="title">tx</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dmaengine_result</span> <span class="title">tx_result</span>;</span></span><br><span class="line">	<span class="comment">/* protected by vc.lock */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">node</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">virt_dma_chan</span> &#123;</span></span><br><span class="line">	<span class="comment">/* 指向一个物理通道 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dma_chan</span>	<span class="title">chan</span>;</span></span><br><span class="line">	<span class="comment">/* 用于等待该虚拟channel上传输的完成，完成后会调度该task */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> <span class="title">task</span>;</span></span><br><span class="line">	<span class="comment">/* 用于传输完成或终止传输后释放描述符内存 */</span></span><br><span class="line">	<span class="keyword">void</span> (*desc_free)(struct virt_dma_desc *);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">spinlock_t</span> lock;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* protected by vc.lock */</span></span><br><span class="line">	<span class="comment">/* 链表用于保存不同状态下的虚拟channel描述符 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">desc_allocated</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">desc_submitted</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">desc_issued</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">desc_completed</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">desc_terminated</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">virt_dma_desc</span> *<span class="title">cyclic</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>struct dma_slave_config</code>，DMA client对DMA channel的配置结构体</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dma_slave_config</span> &#123;</span></span><br><span class="line">	<span class="comment">/* 传输方向 DMA_MEM_TO_DEV DMA_DEV_TO_MEM */</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">dma_transfer_direction</span> <span class="title">direction</span>;</span></span><br><span class="line">	<span class="comment">/* 设备物理地址，dev_to_mem的时候才起作用，通常是固定的外设fifo地址 */</span></span><br><span class="line">	<span class="keyword">phys_addr_t</span> src_addr;</span><br><span class="line">	<span class="comment">/* 设备物理地址，mem_to_dev的时候才起作用，通常是固定的外设fifo地址 */</span></span><br><span class="line">	<span class="keyword">phys_addr_t</span> dst_addr;</span><br><span class="line">	<span class="comment">/* 读取DMA数据源寄存器的的地址宽度 */</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">dma_slave_buswidth</span> <span class="title">src_addr_width</span>;</span></span><br><span class="line">	<span class="comment">/* 读取DMA目标地址寄存器的的地址宽度 */</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">dma_slave_buswidth</span> <span class="title">dst_addr_width</span>;</span></span><br><span class="line">	u32 src_maxburst;</span><br><span class="line">	u32 dst_maxburst;</span><br><span class="line">	u32 src_port_window_size;</span><br><span class="line">	u32 dst_port_window_size;</span><br><span class="line">	<span class="keyword">bool</span> device_fc;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> slave_id;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>struct dma_async_tx_descriptor</code>，用于描述一次DMA传输，类似一个文件句柄，controller driver返回给client driver一个描述符</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dma_async_tx_descriptor</span> &#123;</span></span><br><span class="line">	<span class="comment">/* 用于追踪本次传输 */</span></span><br><span class="line">	<span class="keyword">dma_cookie_t</span> cookie;</span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">dma_ctrl_flags</span> <span class="title">flags</span>;</span> <span class="comment">/* not a &#x27;long&#x27; to pack with cookie */</span></span><br><span class="line">	<span class="keyword">dma_addr_t</span> phys;</span><br><span class="line">	<span class="comment">/* 对应的dma channel */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dma_chan</span> *<span class="title">chan</span>;</span></span><br><span class="line">	<span class="comment">/* controller driver提供的回调函数，用于把该描述符提交到传输列表，由dmaengine调用 */</span></span><br><span class="line">	<span class="keyword">dma_cookie_t</span> (*tx_submit)(struct dma_async_tx_descriptor *tx);</span><br><span class="line">	<span class="comment">/* 用于释放该描述符的回调函数，dmaengine调用 */</span></span><br><span class="line">	<span class="keyword">int</span> (*desc_free)(struct dma_async_tx_descriptor *tx);</span><br><span class="line">	<span class="comment">/* 传输完成的callback函数，client driver提供 */</span></span><br><span class="line">	dma_async_tx_callback callback;</span><br><span class="line">	dma_async_tx_callback_result callback_result;</span><br><span class="line">	<span class="keyword">void</span> *callback_param;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dmaengine_unmap_data</span> *<span class="title">unmap</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">dma_desc_metadata_mode</span> <span class="title">desc_metadata_mode</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dma_descriptor_metadata_ops</span> *<span class="title">metadata_ops</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_ASYNC_TX_ENABLE_CHANNEL_SWITCH</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dma_async_tx_descriptor</span> *<span class="title">next</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dma_async_tx_descriptor</span> *<span class="title">parent</span>;</span></span><br><span class="line">	<span class="keyword">spinlock_t</span> lock;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="DMA-API使用"><a href="#DMA-API使用" class="headerlink" title="DMA API使用"></a>DMA API使用</h4><h5 id="从CPU角度看到的地址和从DMA控制器看到的地址"><a href="#从CPU角度看到的地址和从DMA控制器看到的地址" class="headerlink" title="从CPU角度看到的地址和从DMA控制器看到的地址"></a>从CPU角度看到的地址和从DMA控制器看到的地址</h5><p>在DMA API中涉及到好几个地址的概念（物理地址、虚拟地址、总线地址）</p>
<p>内核通常使用的地址是虚拟地址，我们调用<code>kmalloc()</code>、<code>vmalloc()</code>或者类似的接口返回的地址都是虚拟地址</p>
<p>虚拟内存系统（TLB 页表等）将虚拟地址翻译成物理地址，物理地址保存在<code>phys_addr_t</code>或<code>resource_size_t</code>的变量中，对于一个硬件设备上的寄存器等设备资源，内核是按照物理地址来管理的，通过<code>/proc/iomem</code>可以看到这些和设备IO相关的物理地址，驱动不能直接使用这些物理地址，必须首先通过<code>ioremap()</code>接口将这些物理地址映射到内核虚拟地址空间上去</p>
<p>I&#x2F;O设备使用第三种地址：总线地址。如果设备在MMIO地址空间中有若干的寄存器，或者该设备可以通过DMA执行读写系统内存的操作，这种情况下，设备使用的地址就是总线地址</p>
<p>各种地址概念关系图<br><img src="https://raw.githubusercontent.com/JackHuang021/images/master/20230512103247.png"></p>
<p>DMA使用的内存地址：在驱动中可以通过<code>kmalloc</code>或者其他类似接口分配一个DMA buffer，并且返回了虚拟地址X，MMU将X地址映射成了物理地址Y，从而定位了DMA buffer在系统内存中的位置，因此驱动可以通过地址X来操作DMA buffer，但是设备并不能通过X地址来访问DMA buffer，因为MMU对设备不可见</p>
<p>驱动在调用<code>dma_map_single()</code>这样的接口函数的时候会传递一个虚拟地址X，在这个函数中会设定IOMMU的页表，将地址X映射到Z，并且将返回Z这个总线地址，驱动可以把Z这个总线地址设定到设备上的DMA相关的寄存器中，这样当设备发起对地址Z开始的DMA操作的时候，IOMMU可以进行地址映射，并将DMA操作定位到Y地址开始的DMA buffer</p>
<h5 id="DMA内存映射"><a href="#DMA内存映射" class="headerlink" title="DMA内存映射"></a>DMA内存映射</h5><p>一致性映射（coherent DMA mappings）是使用专门的接口分配一块DMA缓冲区，这块DMA缓冲区是关闭了cache机制的。也就是数据直接写入内存，这样就不存在一致性问题。</p>
<p>一致性dma映射接口：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">dma_alloc_coherent</span><span class="params">(struct device *dev, <span class="keyword">size_t</span> size,<span class="keyword">dma_addr_t</span> *dma_handle, <span class="keyword">gfp_t</span> flag)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">dma_addr_t</span> dma_handle</span>;</span><br><span class="line">cpu_addr = dma_alloc_coherent(dev, size, &amp;dma_handle, gfp);</span><br></pre></td></tr></table></figure>
<p>dma_alloc_coherent函数返回两个值，一个是从CPU角度访问DMA buffer的虚拟地址，另外一个是从设备（DMA controller）角度看到的bus address：dma_handle，驱动可以将这个bus address传递给DMA控制器。</p>
<h5 id="设备驱动使用dmaengine"><a href="#设备驱动使用dmaengine" class="headerlink" title="设备驱动使用dmaengine"></a>设备驱动使用dmaengine</h5><p>对于设备驱动，要基于dmaengine提供的Slave-DMA API进行DMA传输的话，需要如下的操作步骤</p>
<ol>
<li>申请一个DMA channel</li>
<li>根据设备的特性，配置dma channel的参数</li>
<li>要进行DMA传输的时候，获取一个用于识别本次传输的描述符（descriptor）</li>
<li>将本次传输提交给dma engine并启动传输</li>
<li>等待传输结束</li>
</ol>
<h5 id="传输描述符"><a href="#传输描述符" class="headerlink" title="传输描述符"></a>传输描述符</h5><p>DMA属于异步传输，在启动传输之前，slave driver需要将此次传输的一些信息（src dst的地址，传输的方向）提交给dmaengine，dma controller驱动确认后会返回一个描述符（由<code>struct dma_async_tx_escriptor</code>抽象），slave driver就以该描述符为单位，控制并跟踪此次传输</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @chan: 本次传输所用到的channel</span></span><br><span class="line"><span class="comment"> * @sgl: scatter gather buffers 数组地址</span></span><br><span class="line"><span class="comment"> * @sg_len: scatter gather buffers 数组的长度</span></span><br><span class="line"><span class="comment"> * @direction: 数据传输的方向</span></span><br><span class="line"><span class="comment"> * @flags: 一些额外的标志位</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dma_async_tx_descriptor</span> *(*<span class="title">device_prep_slave_sg</span>)(<span class="keyword">struct</span> <span class="title">dma_chan</span> *<span class="title">chan</span>,</span></span><br><span class="line"><span class="class">			<span class="keyword">struct</span> <span class="title">scatterlist</span> *<span class="title">sgl</span>, <span class="title">unsigned</span> <span class="title">int</span> <span class="title">sg_len</span>,</span></span><br><span class="line"><span class="class">			<span class="title">enum</span> <span class="title">dma_transfer_direction</span> <span class="title">direction</span>,</span></span><br><span class="line"><span class="class">			<span class="title">unsigned</span> <span class="title">long</span> <span class="title">flags</span>, <span class="title">void</span> *<span class="title">context</span>);</span></span><br></pre></td></tr></table></figure>

<h4 id="Phytium-DDMA驱动"><a href="#Phytium-DDMA驱动" class="headerlink" title="Phytium DDMA驱动"></a>Phytium DDMA驱动</h4><h5 id="设备树描述"><a href="#设备树描述" class="headerlink" title="设备树描述"></a>设备树描述</h5><ul>
<li><p>dma controller设备树描述</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ddma0: ddma@<span class="number">28003000</span> &#123;</span><br><span class="line">	compatible = <span class="string">&quot;phytium,ddma&quot;</span>;</span><br><span class="line">	reg = &lt;<span class="number">0x0</span> <span class="number">0x28003000</span> <span class="number">0x0</span> <span class="number">0x1000</span>&gt;;</span><br><span class="line">	interrupts = &lt;GIC_SPI <span class="number">75</span> IRQ_TYPE_LEVEL_HIGH&gt;;</span><br><span class="line">	<span class="meta">#dma-cells = <span class="meta-string">&lt;2&gt;</span>;			<span class="comment">// 用来表示dma client设备树dmas中属性的个数</span></span></span><br><span class="line">	dma-channels = &lt;<span class="number">8</span>&gt;;			<span class="comment">// dma 通道个数</span></span><br><span class="line">	clocks = &lt;&amp;sysclk_50mhz&gt;;</span><br><span class="line">	clock-names = <span class="string">&quot;core_clk&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ddma1: ddma@<span class="number">28004000</span> &#123;</span><br><span class="line">	compatible = <span class="string">&quot;phytium,ddma&quot;</span>;</span><br><span class="line">	reg = &lt;<span class="number">0x0</span> <span class="number">0x28004000</span> <span class="number">0x0</span> <span class="number">0x1000</span>&gt;;</span><br><span class="line">	interrupts = &lt;GIC_SPI <span class="number">76</span> IRQ_TYPE_LEVEL_HIGH&gt;;</span><br><span class="line">	<span class="meta">#dma-cells = <span class="meta-string">&lt;2&gt;</span>;</span></span><br><span class="line">	dma-channels = &lt;<span class="number">8</span>&gt;;</span><br><span class="line">	clocks = &lt;&amp;sysclk_50mhz&gt;;</span><br><span class="line">	clock-names = <span class="string">&quot;core_clk&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>dma client设备树描述</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">spi2: spi@2803c000 &#123;</span><br><span class="line">	compatible = <span class="string">&quot;phytium,spi&quot;</span>;</span><br><span class="line">	reg = &lt;0x0 0x2803c000 0x0 0x1000&gt;;</span><br><span class="line">	interrupts = &lt;GIC_SPI 161 IRQ_TYPE_LEVEL_HIGH&gt;;</span><br><span class="line">	clocks = &lt;&amp;sysclk_48mhz&gt;;</span><br><span class="line">	num-cs = &lt;4&gt;;</span><br><span class="line">	<span class="comment">#address-cells = &lt;1&gt;;</span></span><br><span class="line">	<span class="comment">#size-cells = &lt;0&gt;;</span></span><br><span class="line">	dmas = &lt;&amp;ddma0 0 8&gt;,</span><br><span class="line">			&lt;&amp;ddma0 1 21&gt;;</span><br><span class="line">	dma-names = <span class="string">&quot;tx&quot;</span>, <span class="string">&quot;rx&quot;</span>;</span><br><span class="line">	status = <span class="string">&quot;disabled&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="ddma驱动相关结构体"><a href="#ddma驱动相关结构体" class="headerlink" title="ddma驱动相关结构体"></a>ddma驱动相关结构体</h5><p><code>struct phytium_ddma_device</code>用于描述ddma控制器</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct phytium_ddma_device - the struct holding info describing DDMA device</span></span><br><span class="line"><span class="comment"> * @dma_dev: an instance for struct dma_device</span></span><br><span class="line"><span class="comment"> * @irq: the irq that DDMA using</span></span><br><span class="line"><span class="comment"> * @base: the mapped register I/O base of this DDMA</span></span><br><span class="line"><span class="comment"> * @core_clk: DDMA clock</span></span><br><span class="line"><span class="comment"> * @dma_channels: the number of DDMA physical channels</span></span><br><span class="line"><span class="comment"> * @chan: the phyical channels of DDMA</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">phytium_ddma_device</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dma_device</span> <span class="title">dma_dev</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span></span><br><span class="line">	<span class="keyword">int</span>	irq;</span><br><span class="line">	<span class="keyword">void</span> __iomem *base;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">clk</span> *<span class="title">core_clk</span>;</span></span><br><span class="line">	u32 dma_channels;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">phytium_ddma_chan</span> *<span class="title">chan</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>phytium_ddma_chan</code>用于描述一个ddma 物理通道</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct phytium_ddma_chan - the struct holding info describing dma channel</span></span><br><span class="line"><span class="comment"> * @vchan: virtual dma channel</span></span><br><span class="line"><span class="comment"> * @base: the mapped register I/O of dma physical channel</span></span><br><span class="line"><span class="comment"> * @id: the id of ddma physical channel</span></span><br><span class="line"><span class="comment"> * @desc: the transform request descriptor</span></span><br><span class="line"><span class="comment"> * @dma_config: config parameters for dma channel</span></span><br><span class="line"><span class="comment"> * @busy: the channel busy flag, this flag set when channel is tansferring</span></span><br><span class="line"><span class="comment"> * @is_used: the channel bind flag, this flag set when channel binded</span></span><br><span class="line"><span class="comment"> * @next_sg: the index of next scatter-gatter</span></span><br><span class="line"><span class="comment"> * @paddr: used to align data between dma provider and consumer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">phytium_ddma_chan</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">virt_dma_chan</span> <span class="title">vchan</span>;</span></span><br><span class="line">	<span class="keyword">void</span> __iomem *base;</span><br><span class="line">	u32 id;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">phytium_ddma_desc</span> *<span class="title">desc</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dma_slave_config</span> <span class="title">dma_config</span>;</span></span><br><span class="line">	<span class="keyword">bool</span> busy;</span><br><span class="line">	<span class="keyword">bool</span> is_used;</span><br><span class="line">	u32 next_sg;</span><br><span class="line">	<span class="keyword">dma_addr_t</span> paddr;</span><br><span class="line">	<span class="keyword">char</span> *buf;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>struct phytium_ddma_desc</code>dma传输时使用的描述符，里面记录了本次传输的数据</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct phytium_ddma_desc - the struct holding info describing ddma request</span></span><br><span class="line"><span class="comment"> * descriptor</span></span><br><span class="line"><span class="comment"> * @vdesc: ddma request descriptor</span></span><br><span class="line"><span class="comment"> * @num_sgs: the size of scatter-gather list</span></span><br><span class="line"><span class="comment"> * @sg_req: use to save scatter-gather list info</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">phytium_ddma_desc</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">virt_dma_desc</span> <span class="title">vdesc</span>;</span></span><br><span class="line">	u32 num_sgs;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">phytium_ddma_sg_req</span> <span class="title">sg_req</span>[];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>struct phytium_ddma_sg_req</code>用于记录当前传输的scatter-gather信息，源数据地址、设备数据寄存器地址、传输长度等</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct phytium_ddma_sg_req - scatter-gatter list data info</span></span><br><span class="line"><span class="comment"> * @len: number of bytes to transform</span></span><br><span class="line"><span class="comment"> * @mem_addr_l: bus address low 32bit</span></span><br><span class="line"><span class="comment"> * @mem_addr_h: bus address high 32bit</span></span><br><span class="line"><span class="comment"> * @dev_addr: dma cousumer data reg addr</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">phytium_ddma_sg_req</span> &#123;</span></span><br><span class="line">	u32 len;</span><br><span class="line">	u32 mem_addr_l;</span><br><span class="line">	u32 mem_addr_h;</span><br><span class="line">	u32 dev_addr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="pl011-DMA-device驱动"><a href="#pl011-DMA-device驱动" class="headerlink" title="pl011 DMA device驱动"></a>pl011 DMA device驱动</h4><h5 id="pl011-uart-rx逻辑"><a href="#pl011-uart-rx逻辑" class="headerlink" title="pl011 uart rx逻辑"></a>pl011 uart rx逻辑</h5><p>pl011 串口RX逻辑主要借助pl011的串口接收超时中断来进行数据接收，如pl011的手册描述，当rx fifo中不为空且连续32个bit的时间内没收到任何数据则产生接收超时中断，在超时中断中先对dma rx通道进行暂停，并检查dma实际传输了多少长度的数据，将实际传输的数据存入tty缓冲区，再把fifo中剩下的数据读出来，也存入tty缓冲区，这样完成了一次接收，具体代码位于<code>pl011_dma_rx_irq()</code><br><img src="https://raw.githubusercontent.com/JackHuang021/images/master/20230615143556.png"></p>
<h5 id="pl011-uart-tx逻辑"><a href="#pl011-uart-tx逻辑" class="headerlink" title="pl011 uart tx逻辑"></a>pl011 uart tx逻辑</h5><p>当串口发送中断触发时（发送fifo中的数据低于设定的触发值）就会进入发送逻辑，dma模式下uart有数据需要发送时会调用<code>pl011_dma_tx_irq()</code>走dma的一套数据发送流程进行发送，位于<code>pl011_dma_tx_refill()</code>中</p>
<h4 id="SPI功能测试"><a href="#SPI功能测试" class="headerlink" title="SPI功能测试"></a>SPI功能测试</h4><p>使用spidev-test进行spi硬件回环测试</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@Ubuntu:~<span class="comment"># spidev_test -D /dev/spidev0.0 -v</span></span><br><span class="line">spi mode: 0x0</span><br><span class="line">bits per word: 8</span><br><span class="line">max speed: 500000 Hz (500 kHz)</span><br><span class="line">TX | FF FF FF FF FF FF 40 00 00 00 00 95 FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF F0 0D  |......@.........................|</span><br><span class="line">RX | FF FF FF FF FF FF 40 00 00 00 00 95 FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF F0 0D  |......@.........................|</span><br></pre></td></tr></table></figure>

<h5 id="spidev-test测试"><a href="#spidev-test测试" class="headerlink" title="spidev_test测试"></a>spidev_test测试</h5><p>测试命令：<code>spidev_test -s &lt;speed&gt; -D /dev/spidev0.0 -S &lt;length&gt; -I &lt;iterations&gt;</code></p>
<ul>
<li><p>E2000D demo板测试数据</p>
<table>
<thead>
<tr>
<th align="center">单次传输字节长度</th>
<th align="center">DMA传输速度</th>
<th align="center">中断传输速度</th>
</tr>
</thead>
<tbody><tr>
<td align="center">64KB</td>
<td align="center">15.8Mbps</td>
<td align="center">10.6Mbps</td>
</tr>
<tr>
<td align="center">1KB</td>
<td align="center">15.2Mbps</td>
<td align="center">12Mbps</td>
</tr>
<tr>
<td align="center">512B</td>
<td align="center">14.4Mbps</td>
<td align="center">11.8Mbps</td>
</tr>
<tr>
<td align="center">128B</td>
<td align="center">11.1Mbps</td>
<td align="center">10.8Mbps</td>
</tr>
<tr>
<td align="center">8B</td>
<td align="center">3.1Mbps</td>
<td align="center">3.5Mbps</td>
</tr>
</tbody></table>
</li>
<li><p>树莓派4测试数据</p>
<table>
<thead>
<tr>
<th align="center">测试用例</th>
<th align="center">DMA传输速度</th>
<th align="center">中断传输速度</th>
</tr>
</thead>
<tbody><tr>
<td align="center">25MHz 单次64KB</td>
<td align="center">24.6Mbps</td>
<td align="center">22.6Mbps</td>
</tr>
<tr>
<td align="center">250MHz 单次64KB</td>
<td align="center">90.2Mbps</td>
<td align="center">29.1Mbps</td>
</tr>
</tbody></table>
</li>
</ul>
<h5 id="外接flash-mtd-speedtest速度测试"><a href="#外接flash-mtd-speedtest速度测试" class="headerlink" title="外接flash mtd_speedtest速度测试"></a>外接flash mtd_speedtest速度测试</h5><ul>
<li>spi中断传输模式<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@Ubuntu:~<span class="comment"># echo 7 &gt; /proc/sys/kernel/printk</span></span><br><span class="line">root@Ubuntu:~<span class="comment"># modprobe mtd_speedtest dev=0 count=100</span></span><br><span class="line">[ 1393.267903] </span><br><span class="line">[ 1393.269405] =================================================</span><br><span class="line">[ 1393.275203] mtd_speedtest: MTD device: 0    count: 100</span><br><span class="line">[ 1393.280379] mtd_speedtest: not NAND flash, assume page size is 512 bytes.</span><br><span class="line">[ 1393.287182] mtd_speedtest: MTD device size 16777216, eraseblock size 4096, page size 512, count of er0</span><br><span class="line">[ 1406.236226] mtd_speedtest: testing eraseblock write speed</span><br><span class="line">[ 1407.918432] mtd_speedtest: eraseblock write speed is 238 KiB/s</span><br><span class="line">[ 1407.924276] mtd_speedtest: testing eraseblock <span class="built_in">read</span> speed</span><br><span class="line">[ 1408.224498] mtd_speedtest: eraseblock <span class="built_in">read</span> speed is 1360 KiB/s</span><br><span class="line">[ 1420.949754] mtd_speedtest: testing page write speed</span><br><span class="line">[ 1422.628841] mtd_speedtest: page write speed is 238 KiB/s</span><br><span class="line">[ 1422.634163] mtd_speedtest: testing page <span class="built_in">read</span> speed</span><br><span class="line">[ 1422.955827] mtd_speedtest: page <span class="built_in">read</span> speed is 1265 KiB/s</span><br><span class="line">[ 1435.536738] mtd_speedtest: testing 2 page write speed</span><br><span class="line">[ 1437.265931] mtd_speedtest: 2 page write speed is 232 KiB/s</span><br><span class="line">[ 1437.271429] mtd_speedtest: testing 2 page <span class="built_in">read</span> speed</span><br><span class="line">[ 1437.585886] mtd_speedtest: 2 page <span class="built_in">read</span> speed is 1294 KiB/s</span><br><span class="line">[ 1437.591385] mtd_speedtest: Testing erase speed</span><br><span class="line">[ 1450.136398] mtd_speedtest: erase speed is 31 KiB/s</span><br><span class="line">[ 1450.141203] mtd_speedtest: Testing 2x multi-block erase speed</span><br><span class="line">[ 1462.805642] mtd_speedtest: 2x multi-block erase speed is 31 KiB/s</span><br><span class="line">[ 1462.811747] mtd_speedtest: Testing 4x multi-block erase speed</span><br><span class="line">[ 1475.535328] mtd_speedtest: 4x multi-block erase speed is 31 KiB/s</span><br><span class="line">[ 1475.541432] mtd_speedtest: Testing 8x multi-block erase speed</span><br><span class="line">[ 1488.202989] mtd_speedtest: 8x multi-block erase speed is 31 KiB/s</span><br><span class="line">[ 1488.209098] mtd_speedtest: Testing 16x multi-block erase speed</span><br><span class="line">[ 1500.921395] mtd_speedtest: 16x multi-block erase speed is 31 KiB/s</span><br><span class="line">[ 1500.927592] mtd_speedtest: Testing 32x multi-block erase speed</span><br><span class="line">[ 1513.647523] mtd_speedtest: 32x multi-block erase speed is 31 KiB/s</span><br><span class="line">[ 1513.653714] mtd_speedtest: Testing 64x multi-block erase speed</span><br><span class="line">[ 1526.322498] mtd_speedtest: 64x multi-block erase speed is 31 KiB/s</span><br><span class="line">[ 1526.328691] mtd_speedtest: finished</span><br><span class="line">[ 1526.332216] =================================================</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="外接flash-dd读写测试"><a href="#外接flash-dd读写测试" class="headerlink" title="外接flash dd读写测试"></a>外接flash dd读写测试</h5><ul>
<li>spi中断传输模式<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 写入测试</span></span><br><span class="line"><span class="attribute">root</span>@Ubuntu:~# time dd if=/dev/zero of=/dev/mtd<span class="number">0</span> bs=<span class="number">1024</span>k count=<span class="number">10</span></span><br><span class="line"><span class="attribute">10</span>+<span class="number">0</span> records in</span><br><span class="line"><span class="attribute">10</span>+<span class="number">0</span> records out</span><br><span class="line"><span class="attribute">10485760</span> bytes (<span class="number">10</span> MB, <span class="number">10</span> MiB) copied, <span class="number">43</span>.<span class="number">2331</span> s, <span class="number">243</span> kB/s</span><br><span class="line"></span><br><span class="line"><span class="attribute">real</span>    <span class="number">0</span>m<span class="number">43</span>.<span class="number">247</span>s</span><br><span class="line"><span class="attribute">user</span>    <span class="number">0</span>m<span class="number">0</span>.<span class="number">001</span>s</span><br><span class="line"><span class="attribute">sys</span>     <span class="number">0</span>m<span class="number">22</span>.<span class="number">231</span>s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读测试</span></span><br><span class="line"><span class="attribute">root</span>@Ubuntu:~# time dd if=/dev/mtd<span class="number">0</span> of=/dev/null bs=<span class="number">1024</span>k count=<span class="number">10</span></span><br><span class="line"><span class="attribute">10</span>+<span class="number">0</span> records in</span><br><span class="line"><span class="attribute">10</span>+<span class="number">0</span> records out</span><br><span class="line"><span class="attribute">10485760</span> bytes (<span class="number">10</span> MB, <span class="number">10</span> MiB) copied, <span class="number">8</span>.<span class="number">76685</span> s, <span class="number">1</span>.<span class="number">2</span> MB/s</span><br><span class="line"></span><br><span class="line"><span class="attribute">real</span>    <span class="number">0</span>m<span class="number">8</span>.<span class="number">773</span>s</span><br><span class="line"><span class="attribute">user</span>    <span class="number">0</span>m<span class="number">0</span>.<span class="number">004</span>s</span><br><span class="line"><span class="attribute">sys</span>     <span class="number">0</span>m<span class="number">0</span>.<span class="number">011</span>s</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="串口功能测试"><a href="#串口功能测试" class="headerlink" title="串口功能测试"></a>串口功能测试</h4><p>测试工具： </p>
<ul>
<li><a href="https://github.com/carloscn/tinyserial.git">tinyserial v1.4</a></li>
<li><a href="https://github.com/cbrake/linux-serial-test.git">linux-serial-test</a></li>
</ul>
<p>4Mbps波特率回环测试，tx和rx数据能对齐<br><img src="https://raw.githubusercontent.com/JackHuang021/images/master/%E4%B8%B2%E5%8F%A3DMA%204Mbps%E4%BC%A0%E8%BE%93.png"></p>
<p>4Mbps发送单个字节（0x55）波形<br><img src="https://raw.githubusercontent.com/JackHuang021/images/master/002.BMP"></p>
<h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><blockquote>
<p><a href="http://www.wowotech.net/tag/dma">http://www.wowotech.net/tag/dma</a><br><a href="https://www.jianshu.com/p/e1b622234d13">https://www.jianshu.com/p/e1b622234d13</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>DMA</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux notify机制</title>
    <url>/archives/2f609589.html</url>
    <content><![CDATA[<p>在linux内核中，各个子系统之间有很强的相互关系，某些子系统可能对其他子系统产生的事件比较感兴趣，因此内核引进了notifier机制。内核实现notifier机制的代码位于<code>kernel/notifier.c</code></p>
<span id="more"></span>
<p>内核使用<code>struct notifier_block</code>结构代表一个notifer</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/linux/notifier.h</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span>	<span class="title">int</span> <span class="params">(*<span class="keyword">notifier_fn_t</span>)</span><span class="params">(struct notifier_block *nb,</span></span></span><br><span class="line"><span class="params"><span class="function">			<span class="keyword">unsigned</span> <span class="keyword">long</span> action, <span class="keyword">void</span> *data)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">notifier_block</span> &#123;</span></span><br><span class="line">    <span class="comment">// 代表时间发生之后调用的回调函数</span></span><br><span class="line">	<span class="keyword">notifier_fn_t</span> notifier_call;</span><br><span class="line">    <span class="comment">// 用来链接同一个类型的notifier</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">notifier_block</span> __<span class="title">rcu</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="comment">// notifier chain的优先级，对应的数字越大优先级越高</span></span><br><span class="line">	<span class="keyword">int</span> priority;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>内核同时也提供了四种不同类型的notifier chain</p>
<ul>
<li><p>原子通知链（atomic notifier chains）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/linux/notifier.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">atomic_notifier_head</span> &#123;</span></span><br><span class="line">	<span class="keyword">spinlock_t</span> lock;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">notifier_block</span> __<span class="title">rcu</span> *<span class="title">head</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>可阻塞通知链（blocking notifier chains）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/linux/notifier.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">blocking_notifier_head</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rw_semaphore</span> <span class="title">rwsem</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">notifier_block</span> __<span class="title">rcu</span> *<span class="title">head</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>原始通知链（raw notifier chains）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/linux/notifier.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">raw_notifier_head</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">notifier_block</span> __<span class="title">rcu</span> *<span class="title">head</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>SRCU通知链（SRCU notifier chains）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/linux/notifier.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">srcu_notifier_head</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">mutex</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">srcu_struct</span> <span class="title">srcu</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">notifier_block</span> __<span class="title">rcu</span> *<span class="title">head</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>通知链和notifier之间的组织关系如下<br><img src="https://raw.githubusercontent.com/JackHuang021/images/master/20230907193526.png"></p>
<p>内核提供了一套宏来初始化各个类型的通知链</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/linux/notifier.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ATOMIC_INIT_NOTIFIER_HEAD(name) do &#123;	\</span></span><br><span class="line"><span class="meta">		spin_lock_init(&amp;(name)-&gt;lock);	\</span></span><br><span class="line"><span class="meta">		(name)-&gt;head = NULL;		\</span></span><br><span class="line"><span class="meta">	&#125; while (0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BLOCKING_INIT_NOTIFIER_HEAD(name) do &#123;	\</span></span><br><span class="line"><span class="meta">		init_rwsem(&amp;(name)-&gt;rwsem);	\</span></span><br><span class="line"><span class="meta">		(name)-&gt;head = NULL;		\</span></span><br><span class="line"><span class="meta">	&#125; while (0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RAW_INIT_NOTIFIER_HEAD(name) do &#123;	\</span></span><br><span class="line"><span class="meta">		(name)-&gt;head = NULL;		\</span></span><br><span class="line"><span class="meta">	&#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ATOMIC_NOTIFIER_INIT(name) &#123;				\</span></span><br><span class="line"><span class="meta">		.lock = __SPIN_LOCK_UNLOCKED(name.lock),	\</span></span><br><span class="line"><span class="meta">		.head = NULL &#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BLOCKING_NOTIFIER_INIT(name) &#123;				\</span></span><br><span class="line"><span class="meta">		.rwsem = __RWSEM_INITIALIZER((name).rwsem),	\</span></span><br><span class="line"><span class="meta">		.head = NULL &#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RAW_NOTIFIER_INIT(name)	&#123;				\</span></span><br><span class="line"><span class="meta">		.head = NULL &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SRCU_NOTIFIER_INIT(name, pcpu)				\</span></span><br><span class="line"><span class="meta">	&#123;							\</span></span><br><span class="line"><span class="meta">		.mutex = __MUTEX_INITIALIZER(name.mutex),	\</span></span><br><span class="line"><span class="meta">		.head = NULL,					\</span></span><br><span class="line"><span class="meta">		.srcu = __SRCU_STRUCT_INIT(name.srcu, pcpu),	\</span></span><br><span class="line"><span class="meta">	&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ATOMIC_NOTIFIER_HEAD(name)				\</span></span><br><span class="line"><span class="meta">	struct atomic_notifier_head name =			\</span></span><br><span class="line"><span class="meta">		ATOMIC_NOTIFIER_INIT(name)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BLOCKING_NOTIFIER_HEAD(name)				\</span></span><br><span class="line"><span class="meta">	struct blocking_notifier_head name =			\</span></span><br><span class="line"><span class="meta">		BLOCKING_NOTIFIER_INIT(name)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RAW_NOTIFIER_HEAD(name)					\</span></span><br><span class="line"><span class="meta">	struct raw_notifier_head name =				\</span></span><br><span class="line"><span class="meta">		RAW_NOTIFIER_INIT(name)</span></span><br></pre></td></tr></table></figure>

<p>内核提供了最基本的注册通知链的函数，四个不同类型的通知链初始化通过调用这个基本的注册函数来进行注册</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/notifier.c</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *	Notifier chain core routines.  The exported routines below</span></span><br><span class="line"><span class="comment"> *	are layered on top of these, with appropriate locking added.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">notifier_chain_register</span><span class="params">(struct notifier_block **nl,</span></span></span><br><span class="line"><span class="params"><span class="function">				   struct notifier_block *n,</span></span></span><br><span class="line"><span class="params"><span class="function">				   <span class="keyword">bool</span> unique_priority)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 遍历nl通知链表，根据优先级大小将n插入到通知链表中</span></span><br><span class="line">	<span class="keyword">while</span> ((*nl) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (unlikely((*nl) == n)) &#123;</span><br><span class="line">			WARN(<span class="number">1</span>, <span class="string">&quot;notifier callback %ps already registered&quot;</span>,</span><br><span class="line">			     n-&gt;notifier_call);</span><br><span class="line">			<span class="keyword">return</span> -EEXIST;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (n-&gt;priority &gt; (*nl)-&gt;priority)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">if</span> (n-&gt;priority == (*nl)-&gt;priority &amp;&amp; unique_priority)</span><br><span class="line">			<span class="keyword">return</span> -EBUSY;</span><br><span class="line">		nl = &amp;((*nl)-&gt;next);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 插入到</span></span><br><span class="line">	n-&gt;next = *nl;</span><br><span class="line">	rcu_assign_pointer(*nl, n);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">notifier_chain_unregister</span><span class="params">(struct notifier_block **nl,</span></span></span><br><span class="line"><span class="params"><span class="function">		struct notifier_block *n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> ((*nl) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((*nl) == n) &#123;</span><br><span class="line">			rcu_assign_pointer(*nl, n-&gt;next);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		nl = &amp;((*nl)-&gt;next);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> -ENOENT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来看一下如何发送一个事件到通知链上的notifier，内核提供了一个基本的实现<code>notifier_call_chain()</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * notifier_call_chain - Informs the registered notifiers about an event.</span></span><br><span class="line"><span class="comment"> *	@nl:		Pointer to head of the blocking notifier chain</span></span><br><span class="line"><span class="comment"> *	@val:		Value passed unmodified to notifier function</span></span><br><span class="line"><span class="comment"> *	@v:		Pointer passed unmodified to notifier function</span></span><br><span class="line"><span class="comment"> *	@nr_to_call:	Number of notifier functions to be called. Don&#x27;t care</span></span><br><span class="line"><span class="comment"> *			value of this parameter is -1.</span></span><br><span class="line"><span class="comment"> *	@nr_calls:	Records the number of notifications sent. Don&#x27;t care</span></span><br><span class="line"><span class="comment"> *			value of this field is NULL.</span></span><br><span class="line"><span class="comment"> *	@returns:	notifier_call_chain returns the value returned by the</span></span><br><span class="line"><span class="comment"> *			last notifier function called.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">notifier_call_chain</span><span class="params">(struct notifier_block **nl,</span></span></span><br><span class="line"><span class="params"><span class="function">			       <span class="keyword">unsigned</span> <span class="keyword">long</span> val, <span class="keyword">void</span> *v,</span></span></span><br><span class="line"><span class="params"><span class="function">			       <span class="keyword">int</span> nr_to_call, <span class="keyword">int</span> *nr_calls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret = NOTIFY_DONE;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">notifier_block</span> *<span class="title">nb</span>, *<span class="title">next_nb</span>;</span></span><br><span class="line"></span><br><span class="line">	nb = rcu_dereference_raw(*nl);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历整个通知链，让通知链上的notifier全部调用一次回调函数</span></span><br><span class="line">	<span class="keyword">while</span> (nb &amp;&amp; nr_to_call) &#123;</span><br><span class="line">		next_nb = rcu_dereference_raw(nb-&gt;next);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_NOTIFIERS</span></span><br><span class="line">		<span class="keyword">if</span> (unlikely(!func_ptr_is_kernel_text(nb-&gt;notifier_call))) &#123;</span><br><span class="line">			WARN(<span class="number">1</span>, <span class="string">&quot;Invalid notifier called!&quot;</span>);</span><br><span class="line">			nb = next_nb;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">		ret = nb-&gt;notifier_call(nb, val, v);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (nr_calls)</span><br><span class="line">			(*nr_calls)++;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (ret &amp; NOTIFY_STOP_MASK)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		nb = next_nb;</span><br><span class="line">		nr_to_call--;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">NOKPROBE_SYMBOL(notifier_call_chain);</span><br></pre></td></tr></table></figure>

<p>原子通知链相关API实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/notifier.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册一个notifier block到通知链</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *	atomic_notifier_chain_register - Add notifier to an atomic notifier chain</span></span><br><span class="line"><span class="comment"> *	@nh: Pointer to head of the atomic notifier chain</span></span><br><span class="line"><span class="comment"> *	@n: New entry in notifier chain</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *	Adds a notifier to an atomic notifier chain.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *	Returns 0 on success, %-EEXIST on error.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">atomic_notifier_chain_register</span><span class="params">(struct atomic_notifier_head *nh,</span></span></span><br><span class="line"><span class="params"><span class="function">		struct notifier_block *n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">	spin_lock_irqsave(&amp;nh-&gt;lock, flags);</span><br><span class="line">	ret = notifier_chain_register(&amp;nh-&gt;head, n, <span class="literal">false</span>);</span><br><span class="line">	spin_unlock_irqrestore(&amp;nh-&gt;lock, flags);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(atomic_notifier_chain_register);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从通知链删除一个notifier</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *	atomic_notifier_chain_unregister - Remove notifier from an atomic notifier chain</span></span><br><span class="line"><span class="comment"> *	@nh: Pointer to head of the atomic notifier chain</span></span><br><span class="line"><span class="comment"> *	@n: Entry to remove from notifier chain</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *	Removes a notifier from an atomic notifier chain.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *	Returns zero on success or %-ENOENT on failure.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">atomic_notifier_chain_unregister</span><span class="params">(struct atomic_notifier_head *nh,</span></span></span><br><span class="line"><span class="params"><span class="function">		struct notifier_block *n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">	spin_lock_irqsave(&amp;nh-&gt;lock, flags);</span><br><span class="line">	ret = notifier_chain_unregister(&amp;nh-&gt;head, n);</span><br><span class="line">	spin_unlock_irqrestore(&amp;nh-&gt;lock, flags);</span><br><span class="line">	synchronize_rcu();</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(atomic_notifier_chain_unregister);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *	atomic_notifier_call_chain - Call functions in an atomic notifier chain</span></span><br><span class="line"><span class="comment"> *	@nh: Pointer to head of the atomic notifier chain</span></span><br><span class="line"><span class="comment"> *	@val: Value passed unmodified to notifier function</span></span><br><span class="line"><span class="comment"> *	@v: Pointer passed unmodified to notifier function</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *	Calls each function in a notifier chain in turn.  The functions</span></span><br><span class="line"><span class="comment"> *	run in an atomic context, so they must not block.</span></span><br><span class="line"><span class="comment"> *	This routine uses RCU to synchronize with changes to the chain.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *	If the return value of the notifier can be and&#x27;ed</span></span><br><span class="line"><span class="comment"> *	with %NOTIFY_STOP_MASK then atomic_notifier_call_chain()</span></span><br><span class="line"><span class="comment"> *	will return immediately, with the return value of</span></span><br><span class="line"><span class="comment"> *	the notifier function which halted execution.</span></span><br><span class="line"><span class="comment"> *	Otherwise the return value is the return value</span></span><br><span class="line"><span class="comment"> *	of the last notifier function called.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">atomic_notifier_call_chain</span><span class="params">(struct atomic_notifier_head *nh,</span></span></span><br><span class="line"><span class="params"><span class="function">			       <span class="keyword">unsigned</span> <span class="keyword">long</span> val, <span class="keyword">void</span> *v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">	rcu_read_lock();</span><br><span class="line">	ret = notifier_call_chain(&amp;nh-&gt;head, val, v, <span class="number">-1</span>, <span class="literal">NULL</span>);</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(atomic_notifier_call_chain);</span><br><span class="line">NOKPROBE_SYMBOL(atomic_notifier_call_chain);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>notifier</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux Cpufreq框架</title>
    <url>/archives/fbf46cf3.html</url>
    <content><![CDATA[<h3 id="cpufreq动态调频"><a href="#cpufreq动态调频" class="headerlink" title="cpufreq动态调频"></a>cpufreq动态调频</h3><h4 id="cpufreq概述"><a href="#cpufreq概述" class="headerlink" title="cpufreq概述"></a>cpufreq概述</h4><p>Linux Kernel主要通过三类机制来实现SMP（Symmetric Multiprocessing，对称多核）系统CPU core的电源管理：</p>
<ul>
<li>cpu hotplug: 根据应用场景来up&#x2F;down CPU</li>
<li>cpuidle framework: 当cpu上没有可执行任务时，就会进入空闲状态</li>
<li>cpufreq framework: 根据使用场景和系统负荷来调整CPU的电压和频率</li>
</ul>
<span id="more"></span>
<p>cpufreq framework的核心功能，是通过调整CPU core的电压或频率，兼顾系统的性能和功耗。在不需要高性能时，降低电压或频率，以降低功耗；在需要高性能时，提高电压或频率，以提高性能。</p>
<p>cpufreq framework中的几个重要概念：</p>
<ol>
<li>policy（策略）：同一个power domain CPU动态调频策略，包含了当前使用的governor和cpufreq driver</li>
<li>governor（调节器）：决定如何计算合适的频率或电压</li>
<li>cpufreq driver（调频驱动）：实现真正的调频执行工作（与平台相关）</li>
</ol>
<p>除此之外，cpufreq还包含cpufreq stats, cpufreq qos, cpufreq notifier等辅助模块，其主要功能如下：</p>
<ol>
<li>cpufreq stats：用于搜集cpufreq的一些统计数据，如CPU在每个频点下的运行时间，总的频率切换次数等</li>
<li>cpufreq qos：用于cpufreq频率限制值发生改变时，向cpufreq模块发送一个通知，将频率限制值调整到新的值</li>
<li>cpufreq notifer：对CPU频率切换或policy对应governor发生改变感兴趣的模块，可以向cpufreq注册一个通知，当以上事件发生时，cpufreq将会向其发送相关通知</li>
</ol>
<p>常用的governor类型</p>
<ol>
<li>Performance：总是将CPU置于最高性能的状态，即硬件所支持的最高频率、电压</li>
<li>Powersaving：总是将CPU置于最节能的状态，即硬件所支持的最低频率、电压</li>
<li>Ondemand：设置CPU负载的阈值T，当负载低于T时，调节至一个刚好能够满足当前负载需求的最低频&#x2F;最低压；当负载高于T时，立即提升到最高性能状态</li>
<li>Conservative：跟Ondemand策略类似，设置CPU负载的阈值T，当负载低于T时，调节至一个刚好能够满足当前负载需求的最低频&#x2F;最低压；但当负载高于T时，不是立即设置为最高性能状态，而是逐级升高主频&#x2F;电压</li>
<li>Userspace：将控制接口通过sysfs开放给用户，由用户进行自定义策略</li>
<li>Schedutil：这是从Linux-4.7版本开始才引入的策略，其原理是根据调度器所提供的CPU利用率信息进行电压&#x2F;频率调节，EAS使用schedutil进行调频</li>
</ol>
<p>sysfs用户层接口，目录位于<code>/sys/devices/system/cpu/cpufreq/policy</code><br><img src="https://raw.githubusercontent.com/JackHuang021/images/master/20221124110212.png"></p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">cpuinfo_max_freq</td>
<td align="left">硬件所支持的最高频率</td>
</tr>
<tr>
<td align="left">cpuinfo_min_freq</td>
<td align="left">硬件所支持的最低频率</td>
</tr>
<tr>
<td align="left">affected_cpus</td>
<td align="left">该policy影响到哪些cpu（没显示offline状态的cpu）</td>
</tr>
<tr>
<td align="left">related_cpus</td>
<td align="left">该policy影响到的所有cpu，包括offline状态的cpu</td>
</tr>
<tr>
<td align="left">scaling_max_freq</td>
<td align="left">该policy支持调整的最高频率</td>
</tr>
<tr>
<td align="left">scaling_min_freq</td>
<td align="left">该policy支持调整的最低频率</td>
</tr>
<tr>
<td align="left">scaling_cur_freq</td>
<td align="left">policy当前设置的频率</td>
</tr>
<tr>
<td align="left">scaling_available_governors</td>
<td align="left">当前系统支持的governor</td>
</tr>
<tr>
<td align="left">scaling_available_frequencies</td>
<td align="left">支持的调频频率</td>
</tr>
<tr>
<td align="left">scaling_driver</td>
<td align="left">当前使用的调频驱动</td>
</tr>
<tr>
<td align="left">scaling_governor</td>
<td align="left">当前使用的governor</td>
</tr>
<tr>
<td align="left">scaling_setspeed</td>
<td align="left">在userspace模式下才能使用，手动设置频率</td>
</tr>
</tbody></table>
<h4 id="cpufreq软件架构"><a href="#cpufreq软件架构" class="headerlink" title="cpufreq软件架构"></a>cpufreq软件架构</h4><p><img src="https://raw.githubusercontent.com/JackHuang021/images/master/20230103092146.png"><br>cpufreq core（可以理解为对policy的操作）：把一些公共的逻辑和接口代码抽象出来</p>
<ul>
<li><code>cpufreq</code>作为所有cpu设备的一个功能，注册到了<code>cpu_subsys</code>总线上</li>
<li>对上以sysfs的形式向用户空间提供统一的接口，以notifier的形式向其他driver提供频率变化的通知</li>
<li>对下提供CPU频率和电压控制的驱动框架，方便底层driver的开发，同时提供governor框架，用于实现不同的频率调整机制</li>
<li>内部封装各种逻辑，主要围绕<code>struct cpufreq_policy</code> <code>struct cpufreq_driver</code> <code>struct cpufreq_governor</code>三个数据结构进行</li>
</ul>
<p>kernel使用<code>struct cpufreq_policy</code>用来抽象cpufreq，它代表了一个CPU簇的cpufreq的属性</p>
<p><code>cpufreq_policy</code>结构体</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cpufreq_cpuinfo</span> &#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		max_freq;			<span class="comment">// cpu最大频率</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		min_freq;			<span class="comment">// cpu最小频率</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* in 10^(-9) s = nanoseconds */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		transition_latency;	<span class="comment">// cpu频率转换时间 单位：ns</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cpufreq_policy</span> &#123;</span></span><br><span class="line">	<span class="comment">/* CPUs sharing clock, require sw coordination */</span></span><br><span class="line">	<span class="keyword">cpumask_var_t</span>		cpus;	<span class="comment">/* Online CPUs only */</span></span><br><span class="line">	<span class="keyword">cpumask_var_t</span>		related_cpus; <span class="comment">/* Online + Offline CPUs */</span></span><br><span class="line">	<span class="keyword">cpumask_var_t</span>		real_cpus; <span class="comment">/* Related and present */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		shared_type; <span class="comment">/* ACPI: ANY or ALL affected CPUs</span></span><br><span class="line"><span class="comment">						should set cpufreq */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		cpu;    <span class="comment">/* cpu managing this policy, must be online */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">clk</span>		*<span class="title">clk</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cpufreq_cpuinfo</span>	<span class="title">cpuinfo</span>;</span><span class="comment">/* see above */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		min;    <span class="comment">/* in kHz */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		max;    <span class="comment">/* in kHz */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		cur;    <span class="comment">/* in kHz, only needed if cpufreq</span></span><br><span class="line"><span class="comment">					 * governors are used */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cpufreq_governor</span>	*<span class="title">governor</span>;</span> <span class="comment">/* see below */</span></span><br><span class="line">	<span class="keyword">void</span>			*governor_data;</span><br><span class="line">	<span class="keyword">char</span>			last_governor[CPUFREQ_NAME_LEN]; <span class="comment">/* last governor used */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span>	<span class="title">update</span>;</span> <span class="comment">/* if update_policy() needs to be</span></span><br><span class="line"><span class="comment">					 * called, but you&#x27;re in IRQ context */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cpufreq_user_policy</span> <span class="title">user_policy</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cpufreq_frequency_table</span>	*<span class="title">freq_table</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">cpufreq_table_sorting</span> <span class="title">freq_table_sorted</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>        <span class="title">policy_list</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kobject</span>		<span class="title">kobj</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">completion</span>	<span class="title">kobj_unregister</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Preferred average time interval between consecutive invocations of</span></span><br><span class="line"><span class="comment">	 * the driver to set the frequency for this policy.  To be set by the</span></span><br><span class="line"><span class="comment">	 * scaling driver (0, which is the default, means no preference).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		transition_delay_us;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Remote DVFS flag (Not added to the driver structure as we don&#x27;t want</span></span><br><span class="line"><span class="comment">	 * to access another structure from scheduler hotpath).</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Should be set if CPUs can do DVFS on behalf of other CPUs from</span></span><br><span class="line"><span class="comment">	 * different cpufreq policies.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">bool</span>			dvfs_possible_from_any_cpu;</span><br><span class="line"></span><br><span class="line">	 <span class="comment">/* Cached frequency lookup from cpufreq_driver_resolve_freq. */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> cached_target_freq;</span><br><span class="line">	<span class="keyword">int</span> cached_resolved_idx;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* cpufreq-stats */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cpufreq_stats</span>	*<span class="title">stats</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* For cpufreq driver&#x27;s internal use */</span></span><br><span class="line">	<span class="keyword">void</span>			*driver_data;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>driver/cpufreq/cpufreq.c</code>中定义了一个全局的percpu变量</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">DEFINE_PER_CPU</span><span class="params">(struct cpufreq_policy *, cpufreq_cpu_data)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这里对应E2000 sysfs中3个policy文件夹，两个小核使用1个policy，另外两个大核分别对应1个policy<br><img src="https://raw.githubusercontent.com/JackHuang021/images/master/20230103094857.png"></p>
<h4 id="cpufreq初始化"><a href="#cpufreq初始化" class="headerlink" title="cpufreq初始化"></a>cpufreq初始化</h4><h5 id="内核配置"><a href="#内核配置" class="headerlink" title="内核配置"></a>内核配置</h5><p>在kconfig中(CPU Power Management -&gt; CPU Frequency scaling)可以对cpufreq进行配置，可以配置支持的governor及系统默认的governor，以及cpufreq调频driver，例如Phytium E2000 5.10内核的配置如下，默认使用schedutil governor，根据调度器所提供的CPU利用率信息进行电压&#x2F;频率调节，EAS能源感知依赖该governor工作：<br><img src="https://raw.githubusercontent.com/JackHuang021/images/master/20230105110139.png"></p>
<h5 id="OPP表初始化"><a href="#OPP表初始化" class="headerlink" title="OPP表初始化"></a>OPP表初始化</h5><p>OPP表的定义：域中每个设备支持的电压和频率的离散元组的集合称为Operating Performance Points（OPP）,内核设备树opp文档<code>Documentation/devicetree/bindings/opp/opp.txt</code>  </p>
<p>假设一个CPU设备支持如下的电压和频率关系：<br>{300MHz at minimum voltage of 1V}<br>{800MHz at minimum voltage of 1.2V}<br>{1GHz at minimum voltage of 1.3V}<br>用OPP表示就可以用{Hz,  uV}方式表示如下:<br>{300000000, 1000000}<br>{800000000, 1200000}<br>{1000000000, 1300000}</p>
<p>Linux内核使用opp layer库来管理opp table，具体的结构如下：</p>
<p>Linux内核使用<code>struct dev_pm_opp</code>结构表示设备的一OPP</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// drivers/opp/opp.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dev_pm_opp</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">node</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kref</span> <span class="title">kref</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">bool</span> available;</span><br><span class="line">	<span class="keyword">bool</span> dynamic;</span><br><span class="line">	<span class="keyword">bool</span> turbo;</span><br><span class="line">	<span class="keyword">bool</span> suspend;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> pstate;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> rate;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> level;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dev_pm_opp_supply</span> *<span class="title">supplies</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dev_pm_opp_icc_bw</span> *<span class="title">bandwidth</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> clock_latency_ns;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dev_pm_opp</span> **<span class="title">required_opps</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">opp_table</span> *<span class="title">opp_table</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">np</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_FS</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">dentry</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Linux内核opp layer库的结构如下<br><img src="https://raw.githubusercontent.com/JackHuang021/images/master/20230307162438.png"></p>
<p>这里初始化的就是各个性能域（即不同cluster）的OPP表，在E2000平台中是通过SCMI的Performace domain management protocol协议获取PERFORMANCE_DESCRIBE_LEVELS这个参数表，具体的协议实现源码在<code>drivers/firmware/arm_scmi/perf.c</code>里面，<code>perf.c</code>实现了SCMI的Performance domain managment protocol，scmi cpufreq_drvier也是通过<code>perf_ops</code>函数集进行调频</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/linux/scmi_protocol.h</span></span><br><span class="line"><span class="comment">// 抽象描述scmi协议的结构体，相应的ops操作集对应scmi的一个协议</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">scmi_handle</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">scmi_revision_info</span> *<span class="title">version</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">scmi_perf_ops</span> *<span class="title">perf_ops</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">scmi_clk_ops</span> *<span class="title">clk_ops</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">scmi_power_ops</span> *<span class="title">power_ops</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">scmi_sensor_ops</span> *<span class="title">sensor_ops</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">scmi_reset_ops</span> *<span class="title">reset_ops</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">scmi_notify_ops</span> *<span class="title">notify_ops</span>;</span></span><br><span class="line">	<span class="comment">/* for protocol internal use */</span></span><br><span class="line">	<span class="comment">// perf_priv存放括performance domain数据，包含opp表等</span></span><br><span class="line">	<span class="keyword">void</span> *perf_priv;</span><br><span class="line">	<span class="keyword">void</span> *clk_priv;</span><br><span class="line">	<span class="keyword">void</span> *power_priv;</span><br><span class="line">	<span class="keyword">void</span> *sensor_priv;</span><br><span class="line">	<span class="keyword">void</span> *reset_priv;</span><br><span class="line">	<span class="keyword">void</span> *notify_priv;</span><br><span class="line">	<span class="keyword">void</span> *system_priv;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// include/linux/scmi_protocol.h</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct scmi_perf_ops - represents the various operations provided</span></span><br><span class="line"><span class="comment"> *	by SCMI Performance Protocol</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @limits_set: sets limits on the performance level of a domain</span></span><br><span class="line"><span class="comment"> * @limits_get: gets limits on the performance level of a domain</span></span><br><span class="line"><span class="comment"> * @level_set: sets the performance level of a domain</span></span><br><span class="line"><span class="comment"> * @level_get: gets the performance level of a domain</span></span><br><span class="line"><span class="comment"> * @device_domain_id: gets the scmi domain id for a given device</span></span><br><span class="line"><span class="comment"> * @transition_latency_get: gets the DVFS transition latency for a given device</span></span><br><span class="line"><span class="comment"> * @device_opps_add: adds all the OPPs for a given device</span></span><br><span class="line"><span class="comment"> * @freq_set: sets the frequency for a given device using sustained frequency</span></span><br><span class="line"><span class="comment"> *	to sustained performance level mapping</span></span><br><span class="line"><span class="comment"> * @freq_get: gets the frequency for a given device using sustained frequency</span></span><br><span class="line"><span class="comment"> *	to sustained performance level mapping</span></span><br><span class="line"><span class="comment"> * @est_power_get: gets the estimated power cost for a given performance domain</span></span><br><span class="line"><span class="comment"> *	at a given frequency</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">scmi_perf_ops</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> (*limits_set)(<span class="keyword">const</span> struct scmi_handle *handle, u32 domain,</span><br><span class="line">			  u32 max_perf, u32 min_perf);</span><br><span class="line">	<span class="keyword">int</span> (*limits_get)(<span class="keyword">const</span> struct scmi_handle *handle, u32 domain,</span><br><span class="line">			  u32 *max_perf, u32 *min_perf);</span><br><span class="line">	<span class="keyword">int</span> (*level_set)(<span class="keyword">const</span> struct scmi_handle *handle, u32 domain,</span><br><span class="line">			 u32 level, <span class="keyword">bool</span> poll);</span><br><span class="line">	<span class="keyword">int</span> (*level_get)(<span class="keyword">const</span> struct scmi_handle *handle, u32 domain,</span><br><span class="line">			 u32 *level, <span class="keyword">bool</span> poll);</span><br><span class="line">	<span class="keyword">int</span> (*device_domain_id)(struct device *dev);</span><br><span class="line">	<span class="keyword">int</span> (*transition_latency_get)(<span class="keyword">const</span> struct scmi_handle *handle,</span><br><span class="line">				      struct device *dev);</span><br><span class="line">	<span class="keyword">int</span> (*device_opps_add)(<span class="keyword">const</span> struct scmi_handle *handle,</span><br><span class="line">			       struct device *dev);</span><br><span class="line">	<span class="keyword">int</span> (*freq_set)(<span class="keyword">const</span> struct scmi_handle *handle, u32 domain,</span><br><span class="line">			<span class="keyword">unsigned</span> <span class="keyword">long</span> rate, <span class="keyword">bool</span> poll);</span><br><span class="line">	<span class="keyword">int</span> (*freq_get)(<span class="keyword">const</span> struct scmi_handle *handle, u32 domain,</span><br><span class="line">			<span class="keyword">unsigned</span> <span class="keyword">long</span> *rate, <span class="keyword">bool</span> poll);</span><br><span class="line">	<span class="keyword">int</span> (*est_power_get)(<span class="keyword">const</span> struct scmi_handle *handle, u32 domain,</span><br><span class="line">			     <span class="keyword">unsigned</span> <span class="keyword">long</span> *rate, <span class="keyword">unsigned</span> <span class="keyword">long</span> *power);</span><br><span class="line">	<span class="keyword">bool</span> (*fast_switch_possible)(<span class="keyword">const</span> struct scmi_handle *handle,</span><br><span class="line">				     struct device *dev);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// scmi performance domain management protocol(性能域管理相关协议 0x13), messageid: 0x03</span></span><br><span class="line"><span class="comment">// scmi opp结构体定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">scmi_opp</span> &#123;</span></span><br><span class="line">	u32 perf;		<span class="comment">// 性能级别，单位KHz</span></span><br><span class="line">	u32 power;		<span class="comment">// 当前性能级别的功耗</span></span><br><span class="line">	u32 trans_latency_us;	<span class="comment">// 切换延时</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// drivers/firmware/arm_scmi/perf.c</span></span><br><span class="line"><span class="comment">// scmi performance domain management protocol(性能域管理相关协议 0x13)对应操作函数集</span></span><br><span class="line"><span class="comment">// scmi cpufreq_driver 主要利用这个函数集进行调频相关操作</span></span><br><span class="line"><span class="comment">// 对应Performace domain management protocol各个message_id</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">scmi_perf_ops</span> <span class="title">perf_ops</span> =</span> &#123;</span><br><span class="line">	.limits_set = scmi_perf_limits_set,</span><br><span class="line">	.limits_get = scmi_perf_limits_get,</span><br><span class="line">	.level_set = scmi_perf_level_set,</span><br><span class="line">	.level_get = scmi_perf_level_get,</span><br><span class="line">	.device_domain_id = scmi_dev_domain_id,</span><br><span class="line">	.transition_latency_get = scmi_dvfs_transition_latency_get,</span><br><span class="line">	.device_opps_add = scmi_dvfs_device_opps_add,</span><br><span class="line">	.freq_set = scmi_dvfs_freq_set,</span><br><span class="line">	.freq_get = scmi_dvfs_freq_get,</span><br><span class="line">	.est_power_get = scmi_dvfs_est_power_get,</span><br><span class="line">	.fast_switch_possible = scmi_fast_switch_possible,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在这个宏进行SCMI performance domain management protocol协议的初始化</span></span><br><span class="line">DEFINE_SCMI_PROTOCOL_REGISTER_UNREGISTER(SCMI_PROTOCOL_PERF, perf)</span><br><span class="line"></span><br><span class="line"><span class="comment">// drivers/firmware/arm_scmi/common.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFINE_SCMI_PROTOCOL_REGISTER_UNREGISTER(id, name) \</span></span><br><span class="line"><span class="meta">int __init scmi_##name##_register(void) \</span></span><br><span class="line"><span class="meta">&#123; \</span></span><br><span class="line"><span class="meta">	return scmi_protocol_register((id), &amp;scmi_##name##_protocol_init); \</span></span><br><span class="line"><span class="meta">&#125; \</span></span><br><span class="line"><span class="meta">\</span></span><br><span class="line"><span class="meta">void __exit scmi_##name##_unregister(void) \</span></span><br><span class="line"><span class="meta">&#123; \</span></span><br><span class="line"><span class="meta">	scmi_protocol_unregister((id)); \</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="comment">// 展开该宏</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> __init <span class="title">scmi_perf_register</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> scmi_protocol_register(SCMI_PROTOCOL_PER, &amp;scmi_perf_protocol_init);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化过程中调用了scmi_perf_protocol_init();</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">scmi_perf_protocol_init</span><span class="params">(struct scmi_handle *handle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> domain;</span><br><span class="line">	u32 version;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">scmi_perf_info</span> *<span class="title">pinfo</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取当前perf domain management协议版本</span></span><br><span class="line">	scmi_version_get(handle, SCMI_PROTOCOL_PERF, &amp;version);</span><br><span class="line"></span><br><span class="line">	dev_dbg(handle-&gt;dev, <span class="string">&quot;Performance Version %d.%d\n&quot;</span>,</span><br><span class="line">		PROTOCOL_REV_MAJOR(version), PROTOCOL_REV_MINOR(version));</span><br><span class="line"></span><br><span class="line">	pinfo = devm_kzalloc(handle-&gt;dev, <span class="keyword">sizeof</span>(*pinfo), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!pinfo)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	<span class="comment">// 通过PROTOCOL_ATTRIBUTES(0x01)这个命令获取domain id个数</span></span><br><span class="line">	<span class="comment">// 还有share memory的地址和长度</span></span><br><span class="line">	scmi_perf_attributes_get(handle, pinfo);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 分配perf_dom_info结构体内存，这里面的opp成员会存放OPP表</span></span><br><span class="line">	<span class="comment">// 对于E2000Q这里会分配3个大小的dom_info</span></span><br><span class="line">	pinfo-&gt;dom_info = devm_kcalloc(handle-&gt;dev, pinfo-&gt;num_domains,</span><br><span class="line">				       <span class="keyword">sizeof</span>(*pinfo-&gt;dom_info), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!pinfo-&gt;dom_info) </span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 遍历每个performance_domain，获取performance domain的属性和performance level参数</span></span><br><span class="line">	<span class="keyword">for</span> (domain = <span class="number">0</span>; domain &lt; pinfo-&gt;num_domains; domain++) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">perf_dom_info</span> *<span class="title">dom</span> =</span> pinfo-&gt;dom_info + domain;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 获取performance domain属性</span></span><br><span class="line">		scmi_perf_domain_attributes_get(handle, domain, dom);</span><br><span class="line">		<span class="comment">// 获取performance level参数即opp表</span></span><br><span class="line">		<span class="comment">// 填充perf_dom_info内的opp结构体</span></span><br><span class="line">		scmi_perf_describe_levels_get(handle, domain, dom);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (dom-&gt;perf_fastchannels)</span><br><span class="line">			scmi_perf_domain_init_fc(handle, domain, &amp;dom-&gt;fc_info);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	scmi_register_protocol_events(handle,</span><br><span class="line">				      SCMI_PROTOCOL_PERF, SCMI_PROTO_QUEUE_SZ,</span><br><span class="line">				      &amp;perf_event_ops, perf_events,</span><br><span class="line">				      ARRAY_SIZE(perf_events),</span><br><span class="line">				      pinfo-&gt;num_domains);</span><br><span class="line"></span><br><span class="line">	pinfo-&gt;version = version;</span><br><span class="line">	handle-&gt;perf_ops = &amp;perf_ops;</span><br><span class="line">	<span class="comment">// perf_priv保存performance domain信息，后续会用到perf_priv</span></span><br><span class="line">	handle-&gt;perf_priv = pinfo;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在初始化阶段，<code>scmi_perf_protocol_init</code>只会将固件里面的perf domains信息保存到handle-&gt;perf_priv里面，此时还并没有将opp表注册到cpu设备上</p>
<p>接下来在scmi调频驱动初始化的过程中，会调用scmi的device_opps_add()接口初始化，即调用<code>scmi_dvfs_device_opps_add()</code>，在这个里面才会生成cpu的opp_table</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">scmi_dvfs_device_opps_add</span><span class="params">(<span class="keyword">const</span> struct scmi_handle *handle,</span></span></span><br><span class="line"><span class="params"><span class="function">				     struct device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> idx, ret, domain;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> freq;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">scmi_opp</span> *<span class="title">opp</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">perf_dom_info</span> *<span class="title">dom</span>;</span></span><br><span class="line">	<span class="comment">// 获取pref_priv地址，在这里面取opp数据</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">scmi_perf_info</span> *<span class="title">pi</span> =</span> handle-&gt;perf_priv;</span><br><span class="line">	<span class="comment">// 这个domain是从设备树里面取到的，设备树cpu节点的clock属性会带一个domain编号</span></span><br><span class="line">	domain = scmi_dev_domain_id(dev);</span><br><span class="line">	<span class="keyword">if</span> (domain &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> domain;</span><br><span class="line">	<span class="comment">// 取当前CPU的perf domain信息</span></span><br><span class="line">	dom = pi-&gt;dom_info + domain;</span><br><span class="line">	<span class="comment">// struct perf_dom_info结构体里面一共16个opp表</span></span><br><span class="line">	<span class="comment">// 这里没对opp进行限制，可能有数组越界的问题</span></span><br><span class="line">	<span class="keyword">for</span> (opp = dom-&gt;opp, idx = <span class="number">0</span>; idx &lt; dom-&gt;opp_count; idx++, opp++) &#123;</span><br><span class="line">		freq = opp-&gt;perf * dom-&gt;mult_factor;</span><br><span class="line">		<span class="comment">// 这里面第一次会为opp_table分配内存，这里只将频率加进opp table里了</span></span><br><span class="line">		ret = dev_pm_opp_add(dev, freq, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">			dev_warn(dev, <span class="string">&quot;failed to add opp %luHz\n&quot;</span>, freq);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">while</span> (idx-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">				freq = (--opp)-&gt;perf * dom-&gt;mult_factor;</span><br><span class="line">				dev_pm_opp_remove(dev, freq);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> ret;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>详细看一下<code>dev_pm_opp_add()</code>的过程</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// drviers/opp/opp.h</span></span><br><span class="line"><span class="comment">// opp_table结构体的定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">opp_table</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">node</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">blocking_notifier_head</span> <span class="title">head</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">dev_list</span>;</span>			<span class="comment">// 共享该opp表的设备链表</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">opp_list</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kref</span> <span class="title">kref</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">lock</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">np</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> clock_latency_ns_max;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* For backward compatibility with v1 bindings */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> voltage_tolerance_v1;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> parsed_static_opps;</span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">opp_table_access</span> <span class="title">shared_opp</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dev_pm_opp</span> *<span class="title">suspend_opp</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">genpd_virt_dev_lock</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> **<span class="title">genpd_virt_devs</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">opp_table</span> **<span class="title">required_opp_tables</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> required_opp_count;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> *supported_hw;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> supported_hw_count;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *prop_name;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">clk</span> *<span class="title">clk</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">regulator</span> **<span class="title">regulators</span>;</span></span><br><span class="line">	<span class="keyword">int</span> regulator_count;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">icc_path</span> **<span class="title">paths</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> path_count;</span><br><span class="line">	<span class="keyword">bool</span> enabled;</span><br><span class="line">	<span class="keyword">bool</span> genpd_performance_state;</span><br><span class="line">	<span class="keyword">bool</span> is_genpd;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> (*set_opp)(struct dev_pm_set_opp_data *data);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dev_pm_set_opp_data</span> *<span class="title">set_opp_data</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_FS</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">dentry</span>;</span></span><br><span class="line">	<span class="keyword">char</span> dentry_name[NAME_MAX];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// drivers/opp/core.c</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The root of the list of all opp-tables. All opp_table structures branch off</span></span><br><span class="line"><span class="comment"> * from here, with each opp_table containing the list of opps it supports in</span></span><br><span class="line"><span class="comment"> * various states of availability.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// opp_tables是opp_table链表的头节点</span></span><br><span class="line">LIST_HEAD(opp_tables);</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">opp_device</span> *_<span class="title">find_opp_dev</span>(<span class="title">const</span> <span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>,</span></span><br><span class="line"><span class="class">							<span class="keyword">struct</span> <span class="title">opp_table</span> *<span class="title">opp_table</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">opp_device</span> *<span class="title">opp_dev</span>;</span></span><br><span class="line">	<span class="comment">// 从opp_table的dev_list中的dev与当前dev进行对比</span></span><br><span class="line">	list_for_each_entry(opp_dev, &amp;opp_table-&gt;dev_list, node)</span><br><span class="line">		<span class="keyword">if</span> (opp_dev-&gt;dev == dev)</span><br><span class="line">			<span class="keyword">return</span> opp_dev;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">opp_table</span> *_<span class="title">find_opp_table_unlocked</span>(<span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">opp_table</span> *<span class="title">opp_table</span>;</span></span><br><span class="line">	<span class="keyword">bool</span> found;</span><br><span class="line">	<span class="comment">// 在opp_tables中进行遍历查找当前设备对应的opp_table</span></span><br><span class="line">	list_for_each_entry(opp_table, &amp;opp_tables, node) &#123;</span><br><span class="line">		mutex_lock(&amp;opp_table-&gt;lock);</span><br><span class="line">		found = !!_find_opp_dev(dev, opp_table);</span><br><span class="line">		mutex_unlock(&amp;opp_table-&gt;lock);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (found) &#123;</span><br><span class="line">			<span class="comment">// opp_table的引用计数加一</span></span><br><span class="line">			_get_opp_table_kref(opp_table);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> opp_table;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ERR_PTR(-ENODEV);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">opp_table</span> *_<span class="title">opp_get_opp_table</span>(<span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>, <span class="title">int</span> <span class="title">index</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">opp_table</span> *<span class="title">opp_table</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Hold our table modification lock here */</span></span><br><span class="line">	mutex_lock(&amp;opp_table_lock);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 第一次运行到这里的时候，应该是找不到opp_table的，需要进行创建</span></span><br><span class="line">	opp_table = _find_opp_table_unlocked(dev);</span><br><span class="line">	<span class="keyword">if</span> (!IS_ERR(opp_table))</span><br><span class="line">		<span class="keyword">goto</span> unlock;</span><br><span class="line"></span><br><span class="line">	opp_table = _managed_opp(dev, index);</span><br><span class="line">	<span class="keyword">if</span> (opp_table) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!_add_opp_dev_unlocked(dev, opp_table)) &#123;</span><br><span class="line">			dev_pm_opp_put_opp_table(opp_table);</span><br><span class="line">			opp_table = ERR_PTR(-ENOMEM);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">goto</span> unlock;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 对该设备创建opp表</span></span><br><span class="line">	opp_table = _allocate_opp_table(dev, index);</span><br><span class="line"></span><br><span class="line">unlock:</span><br><span class="line">	mutex_unlock(&amp;opp_table_lock);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> opp_table;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">struct opp_table *<span class="title">dev_pm_opp_get_opp_table</span><span class="params">(struct device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> _opp_get_opp_table(dev, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dev_pm_opp_add</span><span class="params">(struct device *dev, <span class="keyword">unsigned</span> <span class="keyword">long</span> freq, <span class="keyword">unsigned</span> <span class="keyword">long</span> u_volt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">opp_table</span> *<span class="title">opp_table</span>;</span></span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">	opp_table = dev_pm_opp_get_opp_table(dev);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(opp_table)) </span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(opp_table);</span><br><span class="line">	</span><br><span class="line">	opp_table-&gt;regulator_count = <span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">	ret = _opp_add_v1(opp_table, dev, freq, u_volt, <span class="literal">true</span>);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		dev_pm_opp_put_opp_table(opp_table);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终获取得到的OPP表如下<br><img src="https://raw.githubusercontent.com/JackHuang021/images/master/20230222105334.png"></p>
<h5 id="cpufreq初始化过程"><a href="#cpufreq初始化过程" class="headerlink" title="cpufreq初始化过程"></a>cpufreq初始化过程</h5><p>cpufreq被注册cpu_subsys总线上</p>
<p>cpufreq的初始化从cpufreq_drvier注册开始，<code>cpufreq_register_driver()</code>函数为cpufreq驱动注册的入口，驱动程序通过调用该函数进行初始化，传入相关的<code>struct cpufreq_driver</code>，<code>cpufreq_register_driver()</code>会调用<code>subsys_interface_register()</code>最终执行回调函数<code>cpufreq_add_dev</code>，然后调用<code>cpufreq_online()</code>走初始化流程</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cpufreq_drvier结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cpufreq_driver</span> &#123;</span></span><br><span class="line">	<span class="keyword">char</span>		name[CPUFREQ_NAME_LEN];</span><br><span class="line">	u16		    flags;</span><br><span class="line">	<span class="keyword">void</span>		*driver_data;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* needed by all drivers */</span></span><br><span class="line">	<span class="keyword">int</span>		(*init)(struct cpufreq_policy *policy);</span><br><span class="line">	<span class="keyword">int</span>		(*verify)(struct cpufreq_policy_data *policy);</span><br><span class="line">	<span class="comment">// 调频接口</span></span><br><span class="line">	<span class="keyword">int</span>		(*target_index)(struct cpufreq_policy *policy,</span><br><span class="line">					<span class="keyword">unsigned</span> <span class="keyword">int</span> index);</span><br><span class="line">	<span class="function"><span class="keyword">unsigned</span> <span class="title">int</span>	<span class="params">(*fast_switch)</span><span class="params">(struct cpufreq_policy *policy,</span></span></span><br><span class="line"><span class="params"><span class="function">				       <span class="keyword">unsigned</span> <span class="keyword">int</span> target_freq)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* should be defined, if possible */</span></span><br><span class="line">	<span class="comment">// 获取频率接口</span></span><br><span class="line">	<span class="function"><span class="keyword">unsigned</span> <span class="title">int</span>	<span class="params">(*get)</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> cpu)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Called to update policy limits on firmware notifications. */</span></span><br><span class="line">	<span class="keyword">void</span>		(*update_limits)(<span class="keyword">unsigned</span> <span class="keyword">int</span> cpu);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span>		(*online)(struct cpufreq_policy *policy);</span><br><span class="line">	<span class="keyword">int</span>		(*offline)(struct cpufreq_policy *policy);</span><br><span class="line">	<span class="keyword">int</span>		(*<span class="built_in">exit</span>)(struct cpufreq_policy *policy);</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">freq_attr</span> **<span class="title">attr</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// driver/base/cpu.c</span></span><br><span class="line"><span class="comment">// cpu subsys总线，cpufreq就是以subsys_interface挂在该总线下</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> <span class="title">cpu_subsys</span> =</span> &#123;</span><br><span class="line">	.name = <span class="string">&quot;cpu&quot;</span>,</span><br><span class="line">	.dev_name = <span class="string">&quot;cpu&quot;</span>,</span><br><span class="line">	.match = cpu_subsys_match,</span><br><span class="line">	.online = cpu_subsys_online,</span><br><span class="line">	.offline = cpu_subsys_offline,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// driver/cpufreq/cpufreq.c</span></span><br><span class="line"><span class="comment">// 指向当前使用的cpufreq_driver</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">cpufreq_driver</span> *<span class="title">cpufreq_driver</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// cpufreq subsys接口，用来挂到CPU subsys总线上</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">subsys_interface</span> <span class="title">cpufreq_interface</span> =</span> &#123;</span><br><span class="line">	.name		= <span class="string">&quot;cpufreq&quot;</span>,</span><br><span class="line">	.subsys		= &amp;cpu_subsys,</span><br><span class="line">	.add_dev	= cpufreq_add_dev,</span><br><span class="line">	.remove_dev	= cpufreq_remove_dev,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// scmi cpufreq_driver结构体定义</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">cpufreq_driver</span> <span class="title">scmi_cpufreq_driver</span> =</span> &#123;</span><br><span class="line">	.name	= <span class="string">&quot;scmi&quot;</span>,</span><br><span class="line">	.flags	= CPUFREQ_STICKY | CPUFREQ_HAVE_GOVERNOR_PER_POLICY |</span><br><span class="line">		  CPUFREQ_NEED_INITIAL_FREQ_CHECK,</span><br><span class="line">	.verify	= cpufreq_generic_frequency_table_verify,</span><br><span class="line">	.attr	= cpufreq_generic_attr,</span><br><span class="line">	.target_index	= scmi_cpufreq_set_target,</span><br><span class="line">	.fast_switch	= scmi_cpufreq_fast_switch,</span><br><span class="line">	.get	= scmi_cpufreq_get_rate,</span><br><span class="line">	.init	= scmi_cpufreq_init,</span><br><span class="line">	.<span class="built_in">exit</span>	= scmi_cpufreq_exit,</span><br><span class="line">	.ready	= scmi_cpufreq_ready,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为每个cluster定义一个cpufreq_policy结构体，对每个cluster上的CPU进行调频管理</span></span><br><span class="line"><span class="comment">// 其中又分别进行cpufreq_driver的初始化和governor的初始化</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">DEFINE_PER_CPU</span><span class="params">(struct cpufreq_policy *, cpufreq_cpu_data)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指向当前注册的cpufreq driver</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">cpufreq_driver</span> *<span class="title">cpufreq_driver</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// cpufreq驱动框架初始化过程，整个过程都围绕着policy这个结构体进行，逐步进行初始化</span></span><br><span class="line">cpufreq_register_driver(&amp;scmi_cpufreq_driver);</span><br><span class="line">	subsys_interface_register(&amp;cpufreq_interface);</span><br><span class="line">		cpufreq_add_dev(dev, sif);</span><br><span class="line">			cpufreq_online(cpu);</span><br><span class="line">				<span class="comment">// 初步初始化policy</span></span><br><span class="line">				<span class="comment">// cpumask初始化</span></span><br><span class="line">				<span class="comment">// policy-&gt;kobj kobject初始化</span></span><br><span class="line">				<span class="comment">// policy-&gt;constraints 频率限制初始化</span></span><br><span class="line">				<span class="comment">// 注册频率限制通知接口，频率最大最小值变化时会调用接口</span></span><br><span class="line">				policy = cpufreq_policy_alloc(cpu);</span><br><span class="line">				<span class="comment">// 调用cpufreq_drvier init接口，完善policy结构体</span></span><br><span class="line">				<span class="comment">// 将opp表添加到对应的device，通过dev_pm_opp_add接口</span></span><br><span class="line">				<span class="comment">// 生成频率表 freq_table</span></span><br><span class="line">				cpufreq_driver-&gt;init(policy) -&gt; scmi_cpufreq_init(policy)</span><br><span class="line">				cpufreq_table_validate_and_sort(policy);</span><br><span class="line">				<span class="comment">// 创建/sys/device/system/cpu/cpux目录下的cpufreq符号链接</span></span><br><span class="line">				add_cpu_dev_symlink();</span><br><span class="line">				freq_qos_and_request();</span><br><span class="line">				blocking_notifier_call_chain();</span><br><span class="line">				<span class="comment">// CPU进行频率调整，使当前运行频率在频率表中</span></span><br><span class="line">				<span class="comment">// 初始化的时候会进行一次调整</span></span><br><span class="line">				__cpufreq_driver_target();</span><br><span class="line">				<span class="comment">// 创建sys节点，/sys/device/system/cpu/cpufreq/policyx目录下的一些可选属性</span></span><br><span class="line">				cpufreq_add_dev_interface(policy);</span><br><span class="line">				cpufreq_stats_create_table(policy);</span><br><span class="line">				list_add(&amp;policy-&gt;polic_list, &amp;cpufreq_policy_list);</span><br><span class="line">				<span class="comment">// 使用默认governor初始化policy</span></span><br><span class="line">				cpufreq_init_policy();</span><br></pre></td></tr></table></figure>

<p>来看一下<code>subsys_interface_register()</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// drivers/base/bus.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">subsys_interface_register</span><span class="params">(struct subsystem_interface *sif)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> *<span class="title">subsys</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">subsys_dev_iter</span> <span class="title">iter</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!sif || !sif-&gt;subsys)</span><br><span class="line">		<span class="keyword">return</span> -ENODEV;</span><br><span class="line"></span><br><span class="line">	subsys = bus_get(sif-&gt;subsys);</span><br><span class="line">	<span class="keyword">if</span> (!subsys)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	mutex_lock(&amp;subsys-&gt;p-&gt;mutex);</span><br><span class="line">	<span class="comment">// 将cpufreq_interface添加到cpu_subsys总线的interfaces上</span></span><br><span class="line">	<span class="comment">// interfaces是一个list_head链表</span></span><br><span class="line">	list_add_tail(&amp;sif-&gt;node, &amp;subsys-&gt;p-&gt;interfaces);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 遍历cpu_subsys总线</span></span><br><span class="line">	<span class="comment">// subsys_dev_iter是对klist 迭代器的一个封装</span></span><br><span class="line">	<span class="comment">// 这里遍历的对象是struct device私有数据的knode_bus</span></span><br><span class="line">	<span class="comment">// knode_bus节点是挂载到klist_device这个链表上</span></span><br><span class="line">	<span class="keyword">if</span> (sif-&gt;add_dev) &#123;</span><br><span class="line">		subsys_dev_iter_init(&amp;iter, subsys, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">		<span class="comment">// 从knode_bus取得device指针</span></span><br><span class="line">		<span class="keyword">while</span> ((dev = subsys_dev_iter_next(&amp;iter)))</span><br><span class="line">			sif-&gt;add_dev(dev, sif);</span><br><span class="line">		subsys_dev_iter_exit(&amp;iter);</span><br><span class="line">	&#125;</span><br><span class="line">	mutex_unlock(&amp;subsys-&gt;p-&gt;mutex);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再来看看cpufreq_online()</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">cpufreq_online</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> cpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cpufreq_policy</span> *<span class="title">policy</span>;</span></span><br><span class="line">	<span class="keyword">bool</span> new_policy;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> j;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">	pr_debug(<span class="string">&quot;%s: bringing CPU%u online\n&quot;</span>, __func__, cpu);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Check if this CPU already has a policy to manage it */</span></span><br><span class="line">	<span class="comment">// cpufreq_cpu_data是类型为policy指针的precpu变量</span></span><br><span class="line">	<span class="comment">// 这是是取得policy指针</span></span><br><span class="line">	policy = per_cpu(cpufreq_cpu_data, cpu);</span><br><span class="line">	<span class="keyword">if</span> (policy) &#123;</span><br><span class="line">		<span class="comment">// 假如该cpu不在该policy的related_cpus里面则是有问题的</span></span><br><span class="line">		WARN_ON(!cpumask_test_cpu(cpu, policy-&gt;related_cpus));</span><br><span class="line">		<span class="comment">// 判断当前policy还有没有online CPU</span></span><br><span class="line">		<span class="keyword">if</span> (!policy_is_inactive(policy))</span><br><span class="line">			<span class="comment">// 将当前cpu加入到policy-&gt;cpu online CPU里面</span></span><br><span class="line">			<span class="keyword">return</span> cpufreq_add_policy_cpu(policy, cpu);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* This is the only online CPU for the policy.  Start over. */</span></span><br><span class="line">		new_policy = <span class="literal">false</span>;</span><br><span class="line">		down_write(&amp;policy-&gt;rwsem);</span><br><span class="line">		policy-&gt;cpu = cpu;</span><br><span class="line">		policy-&gt;governor = <span class="literal">NULL</span>;</span><br><span class="line">		up_write(&amp;policy-&gt;rwsem);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 第一次开机的时候需要分配policy内存</span></span><br><span class="line">		new_policy = <span class="literal">true</span>;</span><br><span class="line">		policy = cpufreq_policy_alloc(cpu);</span><br><span class="line">		<span class="keyword">if</span> (!policy)</span><br><span class="line">			<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// scmi调频驱动没有实现online接口</span></span><br><span class="line">	<span class="keyword">if</span> (!new_policy &amp;&amp; cpufreq_driver-&gt;online) &#123;</span><br><span class="line">		ret = cpufreq_driver-&gt;online(policy);</span><br><span class="line">		<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">			pr_debug(<span class="string">&quot;%s: %d: initialization failed\n&quot;</span>, __func__,</span><br><span class="line">				 __LINE__);</span><br><span class="line">			<span class="keyword">goto</span> out_exit_policy;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Recover policy-&gt;cpus using related_cpus */</span></span><br><span class="line">		cpumask_copy(policy-&gt;cpus, policy-&gt;related_cpus);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		cpumask_copy(policy-&gt;cpus, cpumask_of(cpu));</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Call driver. From then on the cpufreq must be able</span></span><br><span class="line"><span class="comment">		 * to accept all calls to -&gt;verify and -&gt;setpolicy for this CPU.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="comment">// cpufreq_driver是在cpufreq_register_driver()中进行赋值的</span></span><br><span class="line">		<span class="comment">// 调频驱动初始化</span></span><br><span class="line">		ret = cpufreq_driver-&gt;init(policy);</span><br><span class="line">		<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">			pr_debug(<span class="string">&quot;%s: %d: initialization failed\n&quot;</span>, __func__,</span><br><span class="line">				 __LINE__);</span><br><span class="line">			<span class="keyword">goto</span> out_free_policy;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		ret = cpufreq_table_validate_and_sort(policy);</span><br><span class="line">		<span class="keyword">if</span> (ret)</span><br><span class="line">			<span class="keyword">goto</span> out_exit_policy;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* related_cpus should at least include policy-&gt;cpus. */</span></span><br><span class="line">		cpumask_copy(policy-&gt;related_cpus, policy-&gt;cpus);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	down_write(&amp;policy-&gt;rwsem);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * affected cpus must always be the one, which are online. We aren&#x27;t</span></span><br><span class="line"><span class="comment">	 * managing offline cpus here.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	cpumask_and(policy-&gt;cpus, policy-&gt;cpus, cpu_online_mask);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (new_policy) &#123;</span><br><span class="line">		for_each_cpu(j, policy-&gt;related_cpus) &#123;</span><br><span class="line">			per_cpu(cpufreq_cpu_data, j) = policy;</span><br><span class="line">			add_cpu_dev_symlink(policy, j);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		policy-&gt;min_freq_req = kzalloc(<span class="number">2</span> * <span class="keyword">sizeof</span>(*policy-&gt;min_freq_req),</span><br><span class="line">					       GFP_KERNEL);</span><br><span class="line">		<span class="keyword">if</span> (!policy-&gt;min_freq_req)</span><br><span class="line">			<span class="keyword">goto</span> out_destroy_policy;</span><br><span class="line"></span><br><span class="line">		ret = freq_qos_add_request(&amp;policy-&gt;constraints,</span><br><span class="line">					   policy-&gt;min_freq_req, FREQ_QOS_MIN,</span><br><span class="line">					   policy-&gt;min);</span><br><span class="line">		<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * So we don&#x27;t call freq_qos_remove_request() for an</span></span><br><span class="line"><span class="comment">			 * uninitialized request.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			kfree(policy-&gt;min_freq_req);</span><br><span class="line">			policy-&gt;min_freq_req = <span class="literal">NULL</span>;</span><br><span class="line">			<span class="keyword">goto</span> out_destroy_policy;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * This must be initialized right here to avoid calling</span></span><br><span class="line"><span class="comment">		 * freq_qos_remove_request() on uninitialized request in case</span></span><br><span class="line"><span class="comment">		 * of errors.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		policy-&gt;max_freq_req = policy-&gt;min_freq_req + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		ret = freq_qos_add_request(&amp;policy-&gt;constraints,</span><br><span class="line">					   policy-&gt;max_freq_req, FREQ_QOS_MAX,</span><br><span class="line">					   policy-&gt;max);</span><br><span class="line">		<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			policy-&gt;max_freq_req = <span class="literal">NULL</span>;</span><br><span class="line">			<span class="keyword">goto</span> out_destroy_policy;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		blocking_notifier_call_chain(&amp;cpufreq_policy_notifier_list,</span><br><span class="line">				CPUFREQ_CREATE_POLICY, policy);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (cpufreq_driver-&gt;get &amp;&amp; has_target()) &#123;</span><br><span class="line">		policy-&gt;cur = cpufreq_driver-&gt;get(policy-&gt;cpu);</span><br><span class="line">		<span class="keyword">if</span> (!policy-&gt;cur) &#123;</span><br><span class="line">			pr_err(<span class="string">&quot;%s: -&gt;get() failed\n&quot;</span>, __func__);</span><br><span class="line">			<span class="keyword">goto</span> out_destroy_policy;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Sometimes boot loaders set CPU frequency to a value outside of</span></span><br><span class="line"><span class="comment">	 * frequency table present with cpufreq core. In such cases CPU might be</span></span><br><span class="line"><span class="comment">	 * unstable if it has to run on that frequency for long duration of time</span></span><br><span class="line"><span class="comment">	 * and so its better to set it to a frequency which is specified in</span></span><br><span class="line"><span class="comment">	 * freq-table. This also makes cpufreq stats inconsistent as</span></span><br><span class="line"><span class="comment">	 * cpufreq-stats would fail to register because current frequency of CPU</span></span><br><span class="line"><span class="comment">	 * isn&#x27;t found in freq-table.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Because we don&#x27;t want this change to effect boot process badly, we go</span></span><br><span class="line"><span class="comment">	 * for the next freq which is &gt;= policy-&gt;cur (&#x27;cur&#x27; must be set by now,</span></span><br><span class="line"><span class="comment">	 * otherwise we will end up setting freq to lowest of the table as &#x27;cur&#x27;</span></span><br><span class="line"><span class="comment">	 * is initialized to zero).</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * We are passing target-freq as &quot;policy-&gt;cur - 1&quot; otherwise</span></span><br><span class="line"><span class="comment">	 * __cpufreq_driver_target() would simply fail, as policy-&gt;cur will be</span></span><br><span class="line"><span class="comment">	 * equal to target-freq.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> ((cpufreq_driver-&gt;flags &amp; CPUFREQ_NEED_INITIAL_FREQ_CHECK)</span><br><span class="line">	    &amp;&amp; has_target()) &#123;</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">int</span> old_freq = policy-&gt;cur;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Are we running at unknown frequency ? */</span></span><br><span class="line">		ret = cpufreq_frequency_table_get_index(policy, old_freq);</span><br><span class="line">		<span class="keyword">if</span> (ret == -EINVAL) &#123;</span><br><span class="line">			ret = __cpufreq_driver_target(policy, old_freq - <span class="number">1</span>,</span><br><span class="line">						      CPUFREQ_RELATION_L);</span><br><span class="line"></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * Reaching here after boot in a few seconds may not</span></span><br><span class="line"><span class="comment">			 * mean that system will remain stable at &quot;unknown&quot;</span></span><br><span class="line"><span class="comment">			 * frequency for longer duration. Hence, a BUG_ON().</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			BUG_ON(ret);</span><br><span class="line">			pr_info(<span class="string">&quot;%s: CPU%d: Running at unlisted initial frequency: %u KHz, changing to: %u KHz\n&quot;</span>,</span><br><span class="line">				__func__, policy-&gt;cpu, old_freq, policy-&gt;cur);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (new_policy) &#123;</span><br><span class="line">		ret = cpufreq_add_dev_interface(policy);</span><br><span class="line">		<span class="keyword">if</span> (ret)</span><br><span class="line">			<span class="keyword">goto</span> out_destroy_policy;</span><br><span class="line"></span><br><span class="line">		cpufreq_stats_create_table(policy);</span><br><span class="line"></span><br><span class="line">		write_lock_irqsave(&amp;cpufreq_driver_lock, flags);</span><br><span class="line">		list_add(&amp;policy-&gt;policy_list, &amp;cpufreq_policy_list);</span><br><span class="line">		write_unlock_irqrestore(&amp;cpufreq_driver_lock, flags);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ret = cpufreq_init_policy(policy);</span><br><span class="line">	<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">		pr_err(<span class="string">&quot;%s: Failed to initialize policy for cpu: %d (%d)\n&quot;</span>,</span><br><span class="line">		       __func__, cpu, ret);</span><br><span class="line">		<span class="keyword">goto</span> out_destroy_policy;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	up_write(&amp;policy-&gt;rwsem);</span><br><span class="line"></span><br><span class="line">	kobject_uevent(&amp;policy-&gt;kobj, KOBJ_ADD);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Callback for handling stuff after policy is ready */</span></span><br><span class="line">	<span class="keyword">if</span> (cpufreq_driver-&gt;ready)</span><br><span class="line">		cpufreq_driver-&gt;ready(policy);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (cpufreq_thermal_control_enabled(cpufreq_driver))</span><br><span class="line">		policy-&gt;cdev = of_cpufreq_cooling_register(policy);</span><br><span class="line"></span><br><span class="line">	pr_debug(<span class="string">&quot;initialization complete\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">out_destroy_policy:</span><br><span class="line">	for_each_cpu(j, policy-&gt;real_cpus)</span><br><span class="line">		remove_cpu_dev_symlink(policy, get_cpu_device(j));</span><br><span class="line"></span><br><span class="line">	up_write(&amp;policy-&gt;rwsem);</span><br><span class="line"></span><br><span class="line">out_exit_policy:</span><br><span class="line">	<span class="keyword">if</span> (cpufreq_driver-&gt;<span class="built_in">exit</span>)</span><br><span class="line">		cpufreq_driver-&gt;<span class="built_in">exit</span>(policy);</span><br><span class="line"></span><br><span class="line">out_free_policy:</span><br><span class="line">	cpufreq_policy_free(policy);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="cpufreq-drviver初始化"><a href="#cpufreq-drviver初始化" class="headerlink" title="cpufreq drviver初始化"></a>cpufreq drviver初始化</h5><p>在cpufreq_online()中调用全局变量cpufreq_driver-&gt;init(policy)进行调频驱动的初始化，下面是scmi调频驱动的初始化过程</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">scmi_cpufreq_init</span><span class="params">(struct cpufreq_policy *policy)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret, nr_opp;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> latency;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">cpu_dev</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">scmi_data</span> *<span class="title">priv</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cpufreq_frequency_table</span> *<span class="title">freq_table</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">em_data_callback</span> <span class="title">em_cb</span> =</span> EM_DATA_CB(scmi_get_cpu_power);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取CPU device结构体即对应percpu变量cpu_sys_devices</span></span><br><span class="line">	cpu_dev = get_cpu_device(policy-&gt;cpu);</span><br><span class="line">	<span class="keyword">if</span> (!cpu_dev) &#123;</span><br><span class="line">		pr_err(<span class="string">&quot;failed to get cpu%d device\n&quot;</span>, policy-&gt;cpu);</span><br><span class="line">		<span class="keyword">return</span> -ENODEV;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 调用scmi_dvfs_device_opps_add()生成opp表</span></span><br><span class="line">	ret = handle-&gt;perf_ops-&gt;device_opps_add(handle, cpu_dev);</span><br><span class="line">	<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">		dev_warn(cpu_dev, <span class="string">&quot;failed to add opps to the device\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 遍历可用的cpu，对比cpu_dev的domain_id，若是相同的话加入到policy-&gt;cpus里面</span></span><br><span class="line">	ret = scmi_get_sharing_cpus(cpu_dev, policy-&gt;cpus);</span><br><span class="line">	<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">		dev_warn(cpu_dev, <span class="string">&quot;failed to get sharing cpumask\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 将opp表添加到sharing cpus里面</span></span><br><span class="line">	ret = dev_pm_opp_set_sharing_cpus(cpu_dev, policy-&gt;cpus);</span><br><span class="line">	<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">		dev_err(cpu_dev, <span class="string">&quot;%s: failed to mark OPPs as shared: %d\n&quot;</span>,</span><br><span class="line">			__func__, ret);</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	nr_opp = dev_pm_opp_get_opp_count(cpu_dev);</span><br><span class="line">	<span class="keyword">if</span> (nr_opp &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">		dev_dbg(cpu_dev, <span class="string">&quot;OPP table is not ready, deferring probe\n&quot;</span>);</span><br><span class="line">		ret = -EPROBE_DEFER;</span><br><span class="line">		<span class="keyword">goto</span> out_free_opp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	priv = kzalloc(<span class="keyword">sizeof</span>(*priv), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!priv) &#123;</span><br><span class="line">		ret = -ENOMEM;</span><br><span class="line">		<span class="keyword">goto</span> out_free_opp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// cpufreq</span></span><br><span class="line">	ret = dev_pm_opp_init_cpufreq_table(cpu_dev, &amp;freq_table);</span><br><span class="line">	<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">		dev_err(cpu_dev, <span class="string">&quot;failed to init cpufreq table: %d\n&quot;</span>, ret);</span><br><span class="line">		<span class="keyword">goto</span> out_free_priv;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	priv-&gt;cpu_dev = cpu_dev;</span><br><span class="line">	priv-&gt;domain_id = handle-&gt;perf_ops-&gt;device_domain_id(cpu_dev);</span><br><span class="line">	<span class="comment">// driver_data保存了调频驱动的一些数据，这里只有cpu编号和domain id号</span></span><br><span class="line">	policy-&gt;driver_data = priv;</span><br><span class="line">	policy-&gt;freq_table = freq_table;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* SCMI allows DVFS request for any domain from any CPU */</span></span><br><span class="line">	policy-&gt;dvfs_possible_from_any_cpu = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	latency = handle-&gt;perf_ops-&gt;transition_latency_get(handle, cpu_dev);</span><br><span class="line">	<span class="keyword">if</span> (!latency)</span><br><span class="line">		latency = CPUFREQ_ETERNAL;</span><br><span class="line"></span><br><span class="line">	policy-&gt;cpuinfo.transition_latency = latency;</span><br><span class="line"></span><br><span class="line">	policy-&gt;fast_switch_possible =</span><br><span class="line">		handle-&gt;perf_ops-&gt;fast_switch_possible(handle, cpu_dev);</span><br><span class="line"></span><br><span class="line">	em_dev_register_perf_domain(cpu_dev, nr_opp, &amp;em_cb, policy-&gt;cpus);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">out_free_priv:</span><br><span class="line">	kfree(priv);</span><br><span class="line">out_free_opp:</span><br><span class="line">	dev_pm_opp_remove_all_dynamic(cpu_dev);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>频率表初始化过程</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cpufreq_frequency_table</span> &#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> flags;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> driver_data;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> frequency;		<span class="comment">/* KHz */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// drivers/opp/cpu.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dev_pm_opp_init_cpufreq_table</span><span class="params">(struct device *dev,</span></span></span><br><span class="line"><span class="params"><span class="function">				  struct cpufreq_frequency_table **table)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dev_pm_opp</span> *<span class="title">opp</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cpufreq_frequency_table</span> *<span class="title">freq_table</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">int</span> i, max_opps, ret = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> rate;</span><br><span class="line"></span><br><span class="line">	max_opps = dev_pm_opp_get_opp_count(dev);</span><br><span class="line">	<span class="keyword">if</span> (max_opps &lt;= <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> max_opps ? max_opps : -ENODATA;</span><br><span class="line"></span><br><span class="line">	freq_table = kcalloc((max_opps + <span class="number">1</span>), <span class="keyword">sizeof</span>(*freq_table), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!freq_table)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>, rate = <span class="number">0</span>; i &lt; max_opps; i++, rate++) &#123;</span><br><span class="line">		<span class="comment">/* find next rate */</span></span><br><span class="line">		opp = dev_pm_opp_find_freq_ceil(dev, &amp;rate);</span><br><span class="line">		<span class="keyword">if</span> (IS_ERR(opp)) &#123;</span><br><span class="line">			ret = PTR_ERR(opp);</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">		&#125;</span><br><span class="line">		freq_table[i].driver_data = i;</span><br><span class="line">		freq_table[i].frequency = rate / <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Is Boost/turbo opp ? */</span></span><br><span class="line">		<span class="keyword">if</span> (dev_pm_opp_is_turbo(opp))</span><br><span class="line">			freq_table[i].flags = CPUFREQ_BOOST_FREQ;</span><br><span class="line"></span><br><span class="line">		dev_pm_opp_put(opp);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	freq_table[i].driver_data = i;</span><br><span class="line">	freq_table[i].frequency = CPUFREQ_TABLE_END;</span><br><span class="line"></span><br><span class="line">	*table = &amp;freq_table[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		kfree(freq_table);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="governor初始化过程"><a href="#governor初始化过程" class="headerlink" title="governor初始化过程"></a>governor初始化过程</h5><p>cpufreq governor的初始化过程，在cpufreq_init_policy(policy)中进行，这里以ondemand为例进行分析</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/linux/cpufreq.h</span></span><br><span class="line"><span class="comment">// 内核governor描述结构体，形成链表</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cpufreq_governor</span> &#123;</span></span><br><span class="line">	<span class="keyword">char</span>	name[CPUFREQ_NAME_LEN];</span><br><span class="line">	<span class="keyword">int</span>	(*init)(struct cpufreq_policy *policy);</span><br><span class="line">	<span class="keyword">void</span>	(*<span class="built_in">exit</span>)(struct cpufreq_policy *policy);</span><br><span class="line">	<span class="keyword">int</span>	(*start)(struct cpufreq_policy *policy);</span><br><span class="line">	<span class="keyword">void</span>	(*stop)(struct cpufreq_policy *policy);</span><br><span class="line">	<span class="keyword">void</span>	(*limits)(struct cpufreq_policy *policy);</span><br><span class="line">	<span class="keyword">ssize_t</span>	(*show_setspeed)	(struct cpufreq_policy *policy,</span><br><span class="line">					 <span class="keyword">char</span> *buf);</span><br><span class="line">	<span class="keyword">int</span>	(*store_setspeed)	(struct cpufreq_policy *policy,</span><br><span class="line">					 <span class="keyword">unsigned</span> <span class="keyword">int</span> freq);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">governor_list</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">module</span>		*<span class="title">owner</span>;</span></span><br><span class="line">	u8			flags;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Common Governor data across policies */</span></span><br><span class="line"><span class="comment">// 抽象出的ondemand governor结构体</span></span><br><span class="line"><span class="comment">// drivers/cpufreq/cpufreq_governor.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dbs_governor</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cpufreq_governor</span> <span class="title">gov</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kobj_type</span> <span class="title">kobj_type</span>;</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Common data for platforms that don&#x27;t set</span></span><br><span class="line"><span class="comment">	 * CPUFREQ_HAVE_GOVERNOR_PER_POLICY</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dbs_data</span> *<span class="title">gdbs_data</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">unsigned</span> <span class="title">int</span> <span class="params">(*gov_dbs_update)</span><span class="params">(struct cpufreq_policy *policy)</span></span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">policy_dbs_info</span> *(*<span class="title">alloc</span>)(<span class="title">void</span>);</span></span><br><span class="line">	<span class="keyword">void</span> (*<span class="built_in">free</span>)(struct policy_dbs_info *policy_dbs);</span><br><span class="line">	<span class="keyword">int</span> (*init)(struct dbs_data *dbs_data);</span><br><span class="line">	<span class="keyword">void</span> (*<span class="built_in">exit</span>)(struct dbs_data *dbs_data);</span><br><span class="line">	<span class="keyword">void</span> (*start)(struct cpufreq_policy *policy);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Governor demand based switching data (per-policy or global). */</span></span><br><span class="line"><span class="comment">// ondemand计算频率使用的相关参数，包括阈值 采样率等，默认阈值是负载的80%</span></span><br><span class="line"><span class="comment">// dbs(demand based switching)按需切换</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dbs_data</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gov_attr_set</span> <span class="title">attr_set</span>;</span></span><br><span class="line">	<span class="keyword">void</span> *tuners;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> ignore_nice_load;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> sampling_rate;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> sampling_down_factor;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> up_threshold;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> io_is_busy;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Common to all CPUs of a policy */</span></span><br><span class="line"><span class="comment">// driver/cpufreq/cpufreq_governor.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">policy_dbs_info</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cpufreq_policy</span> *<span class="title">policy</span>;</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Per policy mutex that serializes load evaluation from limit-change</span></span><br><span class="line"><span class="comment">	 * and work-handler.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">update_mutex</span>;</span></span><br><span class="line"></span><br><span class="line">	u64 last_sample_time;</span><br><span class="line">	s64 sample_delay_ns;</span><br><span class="line">	<span class="keyword">atomic_t</span> work_count;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_work</span> <span class="title">irq_work</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">work</span>;</span></span><br><span class="line">	<span class="comment">/* dbs_data may be shared between multiple policy objects */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dbs_data</span> *<span class="title">dbs_data</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">	<span class="comment">/* Multiplier for increasing sample delay temporarily. */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> rate_mult;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> idle_periods;	<span class="comment">/* For conservative */</span></span><br><span class="line">	<span class="comment">/* Status indicators */</span></span><br><span class="line">	<span class="keyword">bool</span> is_shared;		<span class="comment">/* This object is used by multiple CPUs */</span></span><br><span class="line">	<span class="keyword">bool</span> work_in_progress;	<span class="comment">/* Work is being queued up or in progress */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// drivers/cpufreq/cpufreq_governor.h</span></span><br><span class="line"><span class="comment">// governor初始化宏</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CPUFREQ_DBS_GOVERNOR_INITIALIZER(_name_)			\</span></span><br><span class="line"><span class="meta">	&#123;								\</span></span><br><span class="line"><span class="meta">		.name = _name_,						\</span></span><br><span class="line"><span class="meta">		.flags = CPUFREQ_GOV_DYNAMIC_SWITCHING,			\</span></span><br><span class="line"><span class="meta">		.owner = THIS_MODULE,					\</span></span><br><span class="line"><span class="meta">		.init = cpufreq_dbs_governor_init,			\</span></span><br><span class="line"><span class="meta">		.exit = cpufreq_dbs_governor_exit,			\</span></span><br><span class="line"><span class="meta">		.start = cpufreq_dbs_governor_start,			\</span></span><br><span class="line"><span class="meta">		.stop = cpufreq_dbs_governor_stop,			\</span></span><br><span class="line"><span class="meta">		.limits = cpufreq_dbs_governor_limits,			\</span></span><br><span class="line"><span class="meta">	&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ondemand governor定义</span></span><br><span class="line"><span class="comment">// driver/cpufreq/cpufreq_ondemand.c</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">dbs_governor</span> <span class="title">od_dbs_gov</span> =</span> &#123;</span><br><span class="line">	.gov = CPUFREQ_DBS_GOVERNOR_INITIALIZER(<span class="string">&quot;ondemand&quot;</span>),</span><br><span class="line">	.kobj_type = &#123; .default_attrs = od_attributes &#125;,</span><br><span class="line">	.gov_dbs_update = od_dbs_update,</span><br><span class="line">	.alloc = od_alloc,</span><br><span class="line">	.<span class="built_in">free</span> = od_free,</span><br><span class="line">	.init = od_init,</span><br><span class="line">	.<span class="built_in">exit</span> = od_exit,</span><br><span class="line">	.start = od_start,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化governor</span></span><br><span class="line"><span class="comment">// 该函数会在governor模块驱动的入口函数调用</span></span><br><span class="line"><span class="comment">// 只要编译该模块，就会注册到cpufreq framework中</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CPU_FREQ_GOV_ONDEMAND	(od_dbs_gov.gov)</span></span><br><span class="line">cpufreq_governor_init(CPU_FREQ_GOV_ONDEMAND);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> cpufreq_governor_init(__governor)			\</span></span><br><span class="line"><span class="meta">static int __init __governor##_init(void)			\</span></span><br><span class="line"><span class="meta">&#123;								\</span></span><br><span class="line"><span class="meta">	return cpufreq_register_governor(&amp;__governor);	\</span></span><br><span class="line"><span class="meta">&#125;								\</span></span><br><span class="line"><span class="meta">core_initcall(__governor##_init)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在cpufreq_online()中调用默认governor对policy进行完善，启动当前governor</span></span><br><span class="line">cpufreq_init_policy(policy);</span><br><span class="line">	gov = get_governor(default_governor);</span><br><span class="line">	<span class="comment">// 设置新的governor</span></span><br><span class="line">	cpufreq_set_policy(policy, gov, pol);</span><br><span class="line">		cpufreq_init_governor(policy);</span><br><span class="line">			policy-&gt;governor-&gt;init();  -&gt; cpufreq_dbs_governor_init(policy);</span><br><span class="line">				gov-&gt;init(dbs_data); -&gt; odinit(dbs_data);</span><br><span class="line">		cpufreq_start_governor(policy);</span><br><span class="line">			policy-&gt;governor-&gt;start(); -&gt; cpufreq_dbs_governor_start(policy);</span><br><span class="line">				<span class="comment">// 设置governor回调函数， 以ondemand为例</span></span><br><span class="line">				gov_set_update_util(policy_dbs, sampling_rate);</span><br><span class="line">					cpufreq_add_update_util_hook(cpu, &amp;cdbs-&gt;updata_util,</span><br><span class="line">									dbs_update_util_handler);</span><br></pre></td></tr></table></figure>
<p>启动governor中比较重要的是设置调频回调函数,该函数是真正调频时计算合适频率的函数</p>
<h4 id="ondemand调节器"><a href="#ondemand调节器" class="headerlink" title="ondemand调节器"></a>ondemand调节器</h4><p>ondemand调节器也会根据当前的CPU负载来进行CPU频率计算，ondemand工作过程如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/linux/sched/cpufreq.h</span></span><br><span class="line"><span class="comment">// CPU利用率变化时会调用func重新计算频率</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">update_util_data</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> (*func)(struct update_util_data *data, u64 time, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// drivers/cpufreq/cpufreq_governor.c</span></span><br><span class="line"><span class="comment">// 设置governor回调函数update_util_data-&gt;func = dbs_update_util_handler</span></span><br><span class="line">cpufreq_dbs_governor_start()</span><br><span class="line">    gov_set_update_util(policy_dbs, sampling_rate);</span><br><span class="line">		cpufreq_add_update_util_hook(cpu, &amp;cdbs-&gt;update_util,</span><br><span class="line">                                    dbs_update_util_handler);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * cpufreq_update_util - Take a note about CPU utilization changes.</span></span><br><span class="line"><span class="comment"> * @rq: Runqueue to carry out the update for.</span></span><br><span class="line"><span class="comment"> * @flags: Update reason flags.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function is called by the scheduler on the CPU whose utilization is</span></span><br><span class="line"><span class="comment"> * being updated.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * It can only be called from RCU-sched read-side critical sections.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The way cpufreq is currently arranged requires it to evaluate the CPU</span></span><br><span class="line"><span class="comment"> * performance state (frequency/voltage) on a regular basis to prevent it from</span></span><br><span class="line"><span class="comment"> * being stuck in a completely inadequate performance level for too long.</span></span><br><span class="line"><span class="comment"> * That is not guaranteed to happen if the updates are only triggered from CFS</span></span><br><span class="line"><span class="comment"> * and DL, though, because they may not be coming in if only RT tasks are</span></span><br><span class="line"><span class="comment"> * active all the time (or there are RT tasks only).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * As a workaround for that issue, this function is called periodically by the</span></span><br><span class="line"><span class="comment"> * RT sched class to trigger extra cpufreq updates to prevent it from stalling,</span></span><br><span class="line"><span class="comment"> * but that really is a band-aid.  Going forward it should be replaced with</span></span><br><span class="line"><span class="comment"> * solutions targeted more specifically at RT tasks.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// kernel/sched/sched.h</span></span><br><span class="line"><span class="comment">// 当cpufreq_update_util()被调用时执行上面设置的回调函数update_util_data-&gt;func</span></span><br><span class="line"><span class="comment">// 为了考虑RT任务的影响，目前在RT调度中会周期性调用该函数，避免CPU频率更新不及时</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">cpufreq_update_util</span><span class="params">(struct rq *rq, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">update_util_data</span> *<span class="title">data</span>;</span></span><br><span class="line">    data = rcu_dereference_sched(*per_cpu_ptr(&amp;cpufreq_update_util_data,</span><br><span class="line">                                cpu_of(rq)));</span><br><span class="line">    <span class="keyword">if</span> (data)</span><br><span class="line">        data-&gt;func(data, rq_clock(rq), flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// drivers/cpufreq/cpufreq_governor.c</span></span><br><span class="line"><span class="comment">// data: 为了后续计算过程能够使用container_of取到cpu_dbs_info地址</span></span><br><span class="line"><span class="comment">// time: 运行队列更新的时间</span></span><br><span class="line"><span class="comment">// flags: 更新的原因标志</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dbs_update_util_handler</span><span class="params">(struct update_util_data *data, u64 time,</span></span></span><br><span class="line"><span class="params"><span class="function">				    <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cpu_dbs_info</span> *<span class="title">cdbs</span> =</span> container_of(data, struct cpu_dbs_info, update_util);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">policy_dbs_info</span> *<span class="title">policy_dbs</span> =</span> cdbs-&gt;policy_dbs;</span><br><span class="line">	u64 delta_ns, lst;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查当前工作的CPU可否对该policy对应的CPU进行调频，E2000是支持的</span></span><br><span class="line">	<span class="keyword">if</span> (!cpufreq_this_cpu_can_update(policy_dbs-&gt;policy))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The work may not be allowed to be queued up right now.</span></span><br><span class="line"><span class="comment">	 * Possible reasons:</span></span><br><span class="line"><span class="comment">	 * - Work has already been queued up or is in progress.</span></span><br><span class="line"><span class="comment">	 * - It is too early (too little time from the previous sample).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (policy_dbs-&gt;work_in_progress)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If the reads below are reordered before the check above, the value</span></span><br><span class="line"><span class="comment">	 * of sample_delay_ns used in the computation may be stale.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">// 判断更新的时间间隔，假如小于smaple_delay_ns直接返回</span></span><br><span class="line">	smp_rmb();</span><br><span class="line">	lst = READ_ONCE(policy_dbs-&gt;last_sample_time);</span><br><span class="line">	delta_ns = time - lst;</span><br><span class="line">	<span class="keyword">if</span> ((s64)delta_ns &lt; policy_dbs-&gt;sample_delay_ns)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If the policy is not shared, the irq_work may be queued up right away</span></span><br><span class="line"><span class="comment">	 * at this point.  Otherwise, we need to ensure that only one of the</span></span><br><span class="line"><span class="comment">	 * CPUs sharing the policy will do that.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">// 若policy是被多个CPU共享的，那么要判断一下是不是已经有CPU对其进行处理过了</span></span><br><span class="line">	<span class="keyword">if</span> (policy_dbs-&gt;is_shared) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!atomic_add_unless(&amp;policy_dbs-&gt;work_count, <span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * If another CPU updated last_sample_time in the meantime, we</span></span><br><span class="line"><span class="comment">		 * shouldn&#x27;t be here, so clear the work counter and bail out.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (unlikely(lst != READ_ONCE(policy_dbs-&gt;last_sample_time))) &#123;</span><br><span class="line">			atomic_set(&amp;policy_dbs-&gt;work_count, <span class="number">0</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新标志位</span></span><br><span class="line">	policy_dbs-&gt;last_sample_time = time;</span><br><span class="line">	policy_dbs-&gt;work_in_progress = <span class="literal">true</span>;</span><br><span class="line">	irq_work_queue(&amp;policy_dbs-&gt;irq_work);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// drivers/cpufreq/cpufreq_governor.c</span></span><br><span class="line"><span class="comment">// init_irq_work(&amp;policy_dbs-&gt;irq_work, dbs_irq_work)</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dbs_irq_work</span><span class="params">(struct irq_work *irq_work)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">policy_dbs_info</span> *<span class="title">policy_dbs</span>;</span></span><br><span class="line"></span><br><span class="line">	policy_dbs = container_of(irq_work, struct policy_dbs_info, irq_work);</span><br><span class="line">    <span class="comment">// 调度policy_dbs-&gt;work执行</span></span><br><span class="line">	schedule_work_on(smp_processor_id(), &amp;policy_dbs-&gt;work);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// drivers/cpufreq/cpufreq_governor.c</span></span><br><span class="line"><span class="comment">// INIT_WORK(&amp;policy_dbs-&gt;work, dbs_work_handler)</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dbs_work_handler</span><span class="params">(struct work_struct *work)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">policy_dbs_info</span> *<span class="title">policy_dbs</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cpufreq_policy</span> *<span class="title">policy</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dbs_governor</span> *<span class="title">gov</span>;</span></span><br><span class="line"></span><br><span class="line">	policy_dbs = container_of(work, struct policy_dbs_info, work);</span><br><span class="line">	policy = policy_dbs-&gt;policy;</span><br><span class="line">	gov = dbs_governor_of(policy);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Make sure cpufreq_governor_limits() isn&#x27;t evaluating load or the</span></span><br><span class="line"><span class="comment">	 * ondemand governor isn&#x27;t updating the sampling rate in parallel.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">// 调用gov-&gt;gov_dbs_update()接口</span></span><br><span class="line">	mutex_lock(&amp;policy_dbs-&gt;update_mutex);</span><br><span class="line">	gov_update_sample_delay(policy_dbs, gov-&gt;gov_dbs_update(policy));</span><br><span class="line">	mutex_unlock(&amp;policy_dbs-&gt;update_mutex);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Allow the utilization update handler to queue up more work. */</span></span><br><span class="line">	atomic_set(&amp;policy_dbs-&gt;work_count, <span class="number">0</span>);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If the update below is reordered with respect to the sample delay</span></span><br><span class="line"><span class="comment">	 * modification, the utilization update handler may end up using a stale</span></span><br><span class="line"><span class="comment">	 * sample delay value.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	smp_wmb();</span><br><span class="line">	policy_dbs-&gt;work_in_progress = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// drivers/cpufreq/cpufreq_ondemand.c</span></span><br><span class="line"><span class="comment">// ondemand回调函数，按照CPU负载计算频率</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">od_dbs_update</span><span class="params">(struct cpufreq_policy *policy)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">policy_dbs_info</span> *<span class="title">policy_dbs</span> =</span> policy-&gt;governor_data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dbs_data</span> *<span class="title">dbs_data</span> =</span> policy_dbs-&gt;dbs_data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">od_policy_dbs_info</span> *<span class="title">dbs_info</span> =</span> to_dbs_info(policy_dbs);</span><br><span class="line">	<span class="keyword">int</span> sample_type = dbs_info-&gt;sample_type;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Common NORMAL_SAMPLE setup */</span></span><br><span class="line">	dbs_info-&gt;sample_type = OD_NORMAL_SAMPLE;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * OD_SUB_SAMPLE doesn&#x27;t make sense if sample_delay_ns is 0, so ignore</span></span><br><span class="line"><span class="comment">	 * it then.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (sample_type == OD_SUB_SAMPLE &amp;&amp; policy_dbs-&gt;sample_delay_ns &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		__cpufreq_driver_target(policy, dbs_info-&gt;freq_lo,</span><br><span class="line">					CPUFREQ_RELATION_H);</span><br><span class="line">		<span class="keyword">return</span> dbs_info-&gt;freq_lo_delay_us;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	od_update(policy);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dbs_info-&gt;freq_lo) &#123;</span><br><span class="line">		<span class="comment">/* Setup SUB_SAMPLE */</span></span><br><span class="line">		dbs_info-&gt;sample_type = OD_SUB_SAMPLE;</span><br><span class="line">		<span class="keyword">return</span> dbs_info-&gt;freq_hi_delay_us;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> dbs_data-&gt;sampling_rate * policy_dbs-&gt;rate_mult;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Every sampling_rate, we check, if current idle time is less than 20%</span></span><br><span class="line"><span class="comment"> * (default), then we try to increase frequency. Else, we adjust the frequency</span></span><br><span class="line"><span class="comment"> * proportional to load.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// drivers/cpufreq/cpufreq_ondemand.c</span></span><br><span class="line"><span class="comment">// 根据CPU负载，调整频率</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">od_update</span><span class="params">(struct cpufreq_policy *policy)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">policy_dbs_info</span> *<span class="title">policy_dbs</span> =</span> policy-&gt;governor_data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">od_policy_dbs_info</span> *<span class="title">dbs_info</span> =</span> to_dbs_info(policy_dbs);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dbs_data</span> *<span class="title">dbs_data</span> =</span> policy_dbs-&gt;dbs_data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">od_dbs_tuners</span> *<span class="title">od_tuners</span> =</span> dbs_data-&gt;tuners;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> load = dbs_update(policy);</span><br><span class="line"></span><br><span class="line">	dbs_info-&gt;freq_lo = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Check for frequency increase */</span></span><br><span class="line">    <span class="comment">// 检查当前的CPU负载，负载大于80%（也可以在sysfs中设置）</span></span><br><span class="line">	<span class="keyword">if</span> (load &gt; dbs_data-&gt;up_threshold) &#123;</span><br><span class="line">		<span class="comment">/* If switching to max speed, apply sampling_down_factor */</span></span><br><span class="line">		<span class="keyword">if</span> (policy-&gt;cur &lt; policy-&gt;max)</span><br><span class="line">			policy_dbs-&gt;rate_mult = dbs_data-&gt;sampling_down_factor;</span><br><span class="line">		dbs_freq_increase(policy, policy-&gt;max);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">/* Calculate the next frequency proportional to load */</span></span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">int</span> freq_next, min_f, max_f;</span><br><span class="line"></span><br><span class="line">		min_f = policy-&gt;cpuinfo.min_freq;</span><br><span class="line">		max_f = policy-&gt;cpuinfo.max_freq;</span><br><span class="line">        <span class="comment">// 按照CPU负载计算调频频率</span></span><br><span class="line">		freq_next = min_f + load * (max_f - min_f) / <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* No longer fully busy, reset rate_mult */</span></span><br><span class="line">		policy_dbs-&gt;rate_mult = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 为了进一步节省电力，在计算出的新频率上再乘以一个powersave_bias设定的百分比</span></span><br><span class="line">        <span class="comment">// powersave_bias的值从0-1000，每一步表示0.1%</span></span><br><span class="line">		<span class="keyword">if</span> (od_tuners-&gt;powersave_bias)</span><br><span class="line">			freq_next = od_ops.powersave_bias_target(policy,</span><br><span class="line">								 freq_next,</span><br><span class="line">								 CPUFREQ_RELATION_L);</span><br><span class="line">		<span class="comment">// 频率调整</span></span><br><span class="line">		__cpufreq_driver_target(policy, freq_next, CPUFREQ_RELATION_C);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// drivers/cpufreq/cpufreq_governor.c</span></span><br><span class="line"><span class="comment">// 计算当前域CPU负载 cpu_load = 100 * (time_elapsed - idle_time) / time_elapsed</span></span><br><span class="line"><span class="comment">// 返回当前域中最大的CPU负载</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">dbs_update</span><span class="params">(struct cpufreq_policy *policy)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">policy_dbs_info</span> *<span class="title">policy_dbs</span> =</span> policy-&gt;governor_data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dbs_data</span> *<span class="title">dbs_data</span> =</span> policy_dbs-&gt;dbs_data;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> ignore_nice = dbs_data-&gt;ignore_nice_load;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> max_load = <span class="number">0</span>, idle_periods = UINT_MAX;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> sampling_rate, io_busy, j;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Sometimes governors may use an additional multiplier to increase</span></span><br><span class="line"><span class="comment">	 * sample delays temporarily.  Apply that multiplier to sampling_rate</span></span><br><span class="line"><span class="comment">	 * so as to keep the wake-up-from-idle detection logic a bit</span></span><br><span class="line"><span class="comment">	 * conservative.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	sampling_rate = dbs_data-&gt;sampling_rate * policy_dbs-&gt;rate_mult;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * For the purpose of ondemand, waiting for disk IO is an indication</span></span><br><span class="line"><span class="comment">	 * that you&#x27;re performance critical, and not that the system is actually</span></span><br><span class="line"><span class="comment">	 * idle, so do not add the iowait time to the CPU idle time then.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	io_busy = dbs_data-&gt;io_is_busy;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Get Absolute Load */</span></span><br><span class="line">    <span class="comment">// 计算当前policy中CPU的最大负载</span></span><br><span class="line">	for_each_cpu(j, policy-&gt;cpus) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">cpu_dbs_info</span> *<span class="title">j_cdbs</span> =</span> &amp;per_cpu(cpu_dbs, j);</span><br><span class="line">		u64 update_time, cur_idle_time;</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">int</span> idle_time, time_elapsed;</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">int</span> load;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取当前idle时间</span></span><br><span class="line">		cur_idle_time = get_cpu_idle_time(j, &amp;update_time, io_busy);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// time_elapsed = 本次总运行时间 - 上次总运行时间</span></span><br><span class="line">		time_elapsed = update_time - j_cdbs-&gt;prev_update_time;</span><br><span class="line">		j_cdbs-&gt;prev_update_time = update_time;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 计算本次时间间隔内的idle_time</span></span><br><span class="line">        <span class="comment">// idle_time = 本次idle时间 - 上次idle时间</span></span><br><span class="line">		idle_time = cur_idle_time - j_cdbs-&gt;prev_cpu_idle;</span><br><span class="line">		j_cdbs-&gt;prev_cpu_idle = cur_idle_time;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (ignore_nice) &#123;</span><br><span class="line">			u64 cur_nice = kcpustat_field(&amp;kcpustat_cpu(j), CPUTIME_NICE, j);</span><br><span class="line"></span><br><span class="line">			idle_time += div_u64(cur_nice - j_cdbs-&gt;prev_cpu_nice, NSEC_PER_USEC);</span><br><span class="line">			j_cdbs-&gt;prev_cpu_nice = cur_nice;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 这里主要是对各种比较罕见的情况进行临时处理</span></span><br><span class="line">		<span class="keyword">if</span> (unlikely(!time_elapsed)) &#123;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * That can only happen when this function is called</span></span><br><span class="line"><span class="comment">			 * twice in a row with a very short interval between the</span></span><br><span class="line"><span class="comment">			 * calls, so the previous load value can be used then.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			load = j_cdbs-&gt;prev_load;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (unlikely((<span class="keyword">int</span>)idle_time &gt; <span class="number">2</span> * sampling_rate &amp;&amp;</span><br><span class="line">				    j_cdbs-&gt;prev_load)) &#123;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * If the CPU had gone completely idle and a task has</span></span><br><span class="line"><span class="comment">			 * just woken up on this CPU now, it would be unfair to</span></span><br><span class="line"><span class="comment">			 * calculate &#x27;load&#x27; the usual way for this elapsed</span></span><br><span class="line"><span class="comment">			 * time-window, because it would show near-zero load,</span></span><br><span class="line"><span class="comment">			 * irrespective of how CPU intensive that task actually</span></span><br><span class="line"><span class="comment">			 * was. This is undesirable for latency-sensitive bursty</span></span><br><span class="line"><span class="comment">			 * workloads.</span></span><br><span class="line"><span class="comment">			 *</span></span><br><span class="line"><span class="comment">			 * To avoid this, reuse the &#x27;load&#x27; from the previous</span></span><br><span class="line"><span class="comment">			 * time-window and give this task a chance to start with</span></span><br><span class="line"><span class="comment">			 * a reasonably high CPU frequency. However, that</span></span><br><span class="line"><span class="comment">			 * shouldn&#x27;t be over-done, lest we get stuck at a high</span></span><br><span class="line"><span class="comment">			 * load (high frequency) for too long, even when the</span></span><br><span class="line"><span class="comment">			 * current system load has actually dropped down, so</span></span><br><span class="line"><span class="comment">			 * clear prev_load to guarantee that the load will be</span></span><br><span class="line"><span class="comment">			 * computed again next time.</span></span><br><span class="line"><span class="comment">			 *</span></span><br><span class="line"><span class="comment">			 * Detecting this situation is easy: an unusually large</span></span><br><span class="line"><span class="comment">			 * &#x27;idle_time&#x27; (as compared to the sampling rate)</span></span><br><span class="line"><span class="comment">			 * indicates this scenario.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			load = j_cdbs-&gt;prev_load;</span><br><span class="line">			j_cdbs-&gt;prev_load = <span class="number">0</span>;</span><br><span class="line">		<span class="comment">// 程序正常会运行到这里进行负载计算</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (time_elapsed &gt;= idle_time) &#123;</span><br><span class="line">				load = <span class="number">100</span> * (time_elapsed - idle_time) / time_elapsed;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">/*</span></span><br><span class="line"><span class="comment">				 * That can happen if idle_time is returned by</span></span><br><span class="line"><span class="comment">				 * get_cpu_idle_time_jiffy().  In that case</span></span><br><span class="line"><span class="comment">				 * idle_time is roughly equal to the difference</span></span><br><span class="line"><span class="comment">				 * between time_elapsed and &quot;busy time&quot; obtained</span></span><br><span class="line"><span class="comment">				 * from CPU statistics.  Then, the &quot;busy time&quot;</span></span><br><span class="line"><span class="comment">				 * can end up being greater than time_elapsed</span></span><br><span class="line"><span class="comment">				 * (for example, if jiffies_64 and the CPU</span></span><br><span class="line"><span class="comment">				 * statistics are updated by different CPUs),</span></span><br><span class="line"><span class="comment">				 * so idle_time may in fact be negative.  That</span></span><br><span class="line"><span class="comment">				 * means, though, that the CPU was busy all</span></span><br><span class="line"><span class="comment">				 * the time (on the rough average) during the</span></span><br><span class="line"><span class="comment">				 * last sampling interval and 100 can be</span></span><br><span class="line"><span class="comment">				 * returned as the load.</span></span><br><span class="line"><span class="comment">				 */</span></span><br><span class="line">				load = (<span class="keyword">int</span>)idle_time &lt; <span class="number">0</span> ? <span class="number">100</span> : <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			j_cdbs-&gt;prev_load = load;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (unlikely((<span class="keyword">int</span>)idle_time &gt; <span class="number">2</span> * sampling_rate)) &#123;</span><br><span class="line">			<span class="keyword">unsigned</span> <span class="keyword">int</span> periods = idle_time / sampling_rate;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (periods &lt; idle_periods)</span><br><span class="line">				idle_periods = periods;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 取当前policy中CPU负载最大的值</span></span><br><span class="line">		<span class="keyword">if</span> (load &gt; max_load)</span><br><span class="line">			max_load = load;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	policy_dbs-&gt;idle_periods = idle_periods;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> max_load;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="schedutil调节器"><a href="#schedutil调节器" class="headerlink" title="schedutil调节器"></a>schedutil调节器</h4><p><img src="https://raw.githubusercontent.com/JackHuang021/images/master/20230103174117.png"><br>sugov（schedutil governor）作为一种内核调频策略模块，它主要是根据当前CPU的利用率进行调频。因此，sugov会注册一个callback函数（sugov_update_shared&#x2F;sugov_update_single)到调度器负载跟踪模块，当CPU util发生变化的时候就会调用该callback函数，检查一下当前CPU频率是否和当前的CPU util匹配，如果不匹配，那么就进行升频或者降频。</p>
<p><code>sugov_tunables</code>结构体，用来描述sugov的可调参数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sugov_tunables结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sugov_tunables</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gov_attr_set</span> <span class="title">attr_set</span>;</span></span><br><span class="line">	<span class="comment">// 目前sugov只有这一个可调参数，该参数用来限制连续调频的间隔时间</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> rate_limit_us;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>sugov_policy</code>结构体，sugov为每个cluster构建了该数据结构，记录每个cluster的调频数据信息</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sugov_policy结构体，为每个簇构建了该数据结构，记录每个簇的调频数据信息</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sugov_policy</span> &#123;</span></span><br><span class="line">	<span class="comment">// 指向cpufreq framework层的policy对象</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cpufreq_policy</span>	*<span class="title">policy</span>;</span></span><br><span class="line">	<span class="comment">// sugov的可调参数</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sugov_tunables</span>	*<span class="title">tunables</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">tunables_hook</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">raw_spinlock_t</span>		update_lock;	<span class="comment">/* For shared policies */</span></span><br><span class="line">	<span class="comment">// 记录上次进行频率调整的时间点</span></span><br><span class="line">	u64			last_freq_update_time;</span><br><span class="line">	<span class="comment">// 最小调频时间间隔</span></span><br><span class="line">	s64			freq_update_delay_ns;</span><br><span class="line">	<span class="comment">// 下一个需要调整到的频率值，回调函数主要是计算这个参数</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		next_freq;</span><br><span class="line">	<span class="comment">// 根据CPU util计算出来的原始频率，在频率表中向上找最接近的频率进行调整</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		cached_raw_freq;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* The next fields are only needed if fast switch cannot be used: */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span>			<span class="title">irq_work</span> <span class="title">irq_work</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span>			<span class="title">kthread_work</span> <span class="title">work</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span>			<span class="title">mutex</span> <span class="title">work_lock</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span>			<span class="title">kthread_worker</span> <span class="title">worker</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>	*<span class="title">thread</span>;</span></span><br><span class="line">	<span class="keyword">bool</span>			work_in_progress;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">bool</span>			limits_changed;</span><br><span class="line">	<span class="keyword">bool</span>			need_freq_update;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>sugov_cpu</code>结构体，sugov为每个cpu构建了该数据结构，记录每个CPU的调频数据信息</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sugov_cpu</span> &#123;</span></span><br><span class="line">	<span class="comment">// 保存了cpu util变化后的回调函数</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">update_util_data</span>	<span class="title">update_util</span>;</span></span><br><span class="line">	<span class="comment">// 该sugov_cpu对应的sugov_policy对象</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sugov_policy</span>	*<span class="title">sg_policy</span>;</span></span><br><span class="line">	<span class="comment">// 对应的CPU id</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		cpu;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">bool</span>			iowait_boost_pending;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		iowait_boost;</span><br><span class="line">	<span class="comment">// 上一次cpu负载变化驱动调频的时间点，util更新的时间点</span></span><br><span class="line">	u64			last_update;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		bw_dl;</span><br><span class="line">	<span class="comment">// 该CPU的最大算力，即最大utilities，归一化到1024</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		max;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* The field below is for single-CPU policies only: */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NO_HZ_COMMON</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		saved_idle_calls;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>sugov初始化过程和ondemand初始化过程相似，当内核设定默认governor为sugov时，在<code>cpufreq_init_governor(policy);</code>中会调用<code>sugov_init()</code>初始化sugov，然后调用<code>sugov_start()</code>设置调频回调函数，每当CPU利用率发生变化的时候，调度器都会调用<code>cpufreq_update_util()</code>通知sugov，在<code>cpufreq_update_util()</code>被调用时，即任务调度后CPU当前的util发生变化，会调用sugov的回调函数进行调频，<code>sugov_update_shared()</code>当一个簇中有多个CPU调用该回调，遍历簇上的CPU找到当前最大util的CPU，然后根据该util映射到频率；<code>sugov_update_single()</code>即一个簇上单个CPU的情况直接根据该CPU util计算频率</p>
<p>调度事件的发生还是非常密集的，特别是在重载的情况下，很多任务可能执行若干个us就切换出去了。如果每次都计算CPU util看看是否需要调整频率，那么本身sugov就给系统带来较重的负荷，因此并非每次调频时机都会真正执行调频检查，sugov设置了一个最小调频间隔，小于这个间隔的调频请求会被过滤掉。</p>
<h5 id="schedutil频率计算过程"><a href="#schedutil频率计算过程" class="headerlink" title="schedutil频率计算过程"></a>schedutil频率计算过程</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sugov_start会遍历该sugov policy（cluster）中的所有cpu</span></span><br><span class="line"><span class="comment">// 调用cpufreq_add_update_util_hook为sugov cpu注册调频回调函数，代码逻辑如下：</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sugov_start</span><span class="params">(struct cpufreq_policy *policy)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	...</span><br><span class="line">	for_each_cpu(cpu, policy-&gt;cpus) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">sugov_cpu</span> *<span class="title">sg_cpu</span> =</span> &amp;per_cpu(sugov_cpu, cpu);</span><br><span class="line">		<span class="comment">// 设置governor 计算回调函数，cpufreq_update_util()被调用时</span></span><br><span class="line">		<span class="comment">// 即任务调度后CPU当前的util发生变化，会调用sugov的回调函数进行调频计算</span></span><br><span class="line">		cpufreq_add_update_util_hook(cpu, &amp;sg_cpu-&gt;update_util,</span><br><span class="line">					     policy_is_shared(policy) ?</span><br><span class="line">							sugov_update_shared :</span><br><span class="line">							sugov_update_single);</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// schedutil频率计算过程</span></span><br><span class="line">sugov_update_single();</span><br><span class="line">	<span class="comment">// 调频最小间隔时间检查，小于设定时间，直接返回</span></span><br><span class="line">	sugov_should_update_freq();</span><br><span class="line">	util = sugov_get_util(sg_cpuu);</span><br><span class="line">		schedutil_cpu_util(sg_cpu-&gt;cpu, util, max, FREQUENCY_UTIL, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="comment">// 根据当前CPU的util映射到具体的频率上</span></span><br><span class="line">	next_f = get_next_freq(sg_policy, util, max);</span><br><span class="line">	<span class="comment">// 调用cpufreq_driver进行调频</span></span><br><span class="line">	sugov_deferred_update(sg_policy, time, next_f);</span><br><span class="line">		__cpufreq_driver_target()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算cpu当前的utility</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">schedutil_cpu_util</span><span class="params">(<span class="keyword">int</span> cpu, <span class="keyword">unsigned</span> <span class="keyword">long</span> util_cfs,</span></span></span><br><span class="line"><span class="params"><span class="function">					<span class="keyword">unsigned</span> <span class="keyword">long</span> max, <span class="keyword">enum</span> schedutil_type type,</span></span></span><br><span class="line"><span class="params"><span class="function">					struct task_struct *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> dl_util, util, irq;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span> =</span> cpu_rq(cpu);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!uclamp_is_used() &amp;&amp;</span><br><span class="line">	    type == FREQUENCY_UTIL &amp;&amp; rt_rq_is_runnable(&amp;rq-&gt;rt)) &#123;</span><br><span class="line">		<span class="keyword">return</span> max;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果CPU处理了过多的中断服务函数，irq负载已经高过CPU最大算力，直接返回最大算力</span></span><br><span class="line">	irq = cpu_util_irq(rq);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(irq &gt;= max))</span><br><span class="line">		<span class="keyword">return</span> max;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 累加了cfs和rt任务的utility</span></span><br><span class="line">	util = util_cfs + cpu_util_rt(rq);</span><br><span class="line">	<span class="keyword">if</span> (type == FREQUENCY_UTIL)</span><br><span class="line">		util = uclamp_rq_util_with(rq, util, p);</span><br><span class="line"></span><br><span class="line">	dl_util = cpu_util_dl(rq);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (util + dl_util &gt;= max)</span><br><span class="line">		<span class="keyword">return</span> max;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * OTOH, for energy computation we need the estimated running time, so</span></span><br><span class="line"><span class="comment">	 * include util_dl and ignore dl_bw.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (type == ENERGY_UTIL)</span><br><span class="line">		util += dl_util;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * There is still idle time; further improve the number by using the</span></span><br><span class="line"><span class="comment">	 * irq metric. Because IRQ/steal time is hidden from the task clock we</span></span><br><span class="line"><span class="comment">	 * need to scale the task numbers:</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 *              max - irq</span></span><br><span class="line"><span class="comment">	 *   U&#x27; = irq + --------- * U</span></span><br><span class="line"><span class="comment">	 *                 max</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">// irq会偷走一部分的cpu算力，从而让其capacity没有那么大。</span></span><br><span class="line">	<span class="comment">// 这里通过scale_irq_capacity对任务的utility进行调整</span></span><br><span class="line">	util = scale_irq_capacity(util, irq, max);</span><br><span class="line">	util += irq;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Bandwidth required by DEADLINE must always be granted while, for</span></span><br><span class="line"><span class="comment">	 * FAIR and RT, we use blocked utilization of IDLE CPUs as a mechanism</span></span><br><span class="line"><span class="comment">	 * to gracefully reduce the frequency when no tasks show up for longer</span></span><br><span class="line"><span class="comment">	 * periods of time.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Ideally we would like to set bw_dl as min/guaranteed freq and util +</span></span><br><span class="line"><span class="comment">	 * bw_dl as requested freq. However, cpufreq is not yet ready for such</span></span><br><span class="line"><span class="comment">	 * an interface. So, we only do the latter for now.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (type == FREQUENCY_UTIL)</span><br><span class="line">		util += cpu_bw_dl(rq);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> min(max, util);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据当前CPU计算的util映射对应频率</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">get_next_freq</span><span class="params">(struct sugov_policy *sg_policy,</span></span></span><br><span class="line"><span class="params"><span class="function">				  <span class="keyword">unsigned</span> <span class="keyword">long</span> util, <span class="keyword">unsigned</span> <span class="keyword">long</span> max)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cpufreq_policy</span> *<span class="title">policy</span> =</span> sg_policy-&gt;policy;</span><br><span class="line">	<span class="comment">// 先取得当前CPU的最大频率</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> freq = arch_scale_freq_invariant() ?</span><br><span class="line">				policy-&gt;cpuinfo.max_freq : policy-&gt;cur;</span><br><span class="line">	<span class="comment">// 计算当前util对应频率，计算公式: freq = (1.25) * freq * util / max</span></span><br><span class="line">	<span class="comment">// 这里冗余了25%的算力余量</span></span><br><span class="line">	freq = map_util_freq(util, freq, max);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 若计算出的freq和上次缓存的一样，则实际调整的next_freq计算后肯定也是一样的，直接返回</span></span><br><span class="line">	<span class="comment">// 上次记录的频率值</span></span><br><span class="line">	<span class="keyword">if</span> (freq == sg_policy-&gt;cached_raw_freq &amp;&amp; !sg_policy-&gt;need_freq_update)</span><br><span class="line">		<span class="keyword">return</span> sg_policy-&gt;next_freq;</span><br><span class="line"></span><br><span class="line">	sg_policy-&gt;cached_raw_freq = freq;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 根据当前算的freq，在CPU频率表上查找对应的频率</span></span><br><span class="line">	freq = cpufreq_driver_resolve_freq(policy, freq);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> freq;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="EAS能源感知调度"><a href="#EAS能源感知调度" class="headerlink" title="EAS能源感知调度"></a>EAS能源感知调度</h3><h4 id="EAS整体框架"><a href="#EAS整体框架" class="headerlink" title="EAS整体框架"></a>EAS整体框架</h4><p><img src="https://raw.githubusercontent.com/JackHuang021/images/master/20221216104706.png"></p>
<p>完全公平调度（Completely Fair Scheduler CFS）实现了面向吞吐量的的任务调度策略，EAS为这个调度器添加了一个基于能耗的调度策略，在优化CPU算力冗余的同时实现了节能，EAS在系统中、低度负载情况下工作，CFS在系统满负载情况下工作。</p>
<p>EAS在CPU调度领域，在为任务选核是起作用，目的是保证性能的情况下尽可能节省功耗，EAS涉及内核的几个子系统（任务调度、能源管理、CPU动态调频），EAS代码主要位于<code>kernel/sched/fair.c</code>，能源感知的任务调度需要调度器评估各个任务在CPU上运行带来的能耗影响</p>
<p>EAS全局控制开关<code>/proc/sys/kernel/sched_energy_aware</code></p>
<h4 id="CPU算力归一化过程"><a href="#CPU算力归一化过程" class="headerlink" title="CPU算力归一化过程"></a>CPU算力归一化过程</h4><p>当前，Linux无法凭自身算出CPU算力，因此必须要有把这个信息传递给Linux的方式，它是从<code>capacity-dmips-mhz</code> CPU 设备树binding中衍生计算出来的</p>
<p>归一化CPU capacity，<code>topology_normalize_cpu_scale()</code>定义在<code>drivers/base/arch_topology()</code>，这个capacity在schedutil调度中被<code>sugov_get_util()</code>函数读取</p>
<p><code>topology_normalize_cpu_scale()</code>在CPU初始化<code>parse_dt_topology()</code>中被调用，capacity归一化的前提条件是需要在设备树中CPU节点设置<code>capacity-dmips-mhz</code>属性，该属性表示不同CPU的计算能力，内核读取该属性设置CPU的<code>raw_capacity</code>为<code>capacity-dmips-mhz</code>，参考内核文档<code>Documentation/devicetree/bindings/arm/cpu-capacity.txt</code></p>
<blockquote>
<p>ARM推荐的测试CPU的性能工具：Dhrystone 2.1以上版本，可以通过单核跑分成绩作为<code>capacity-dmips-mhz</code>属性的参考，DMIPS： Dhrystone Million Instructions executed Per Second，表示了在Dhrystone这样一种测试方法下的MIPS，Dhrystone是一种整数运算测试程序。MIPS&#x2F;MHz，就是说每MHz频率能产生多大的MIPS，CPU性能通常由每秒百万指令（Millions of Instructions Per Second，MIPS）表示，设备树里表示为dmips&#x2F;mhz</p>
</blockquote>
<p>CPU算力归一化公式，并不是简单的将capacity-dmips-mhz归一化到capacity，CPU的频率也参与到了计算中<br><code> capacity = (own(capacity-dmips-mhz) * own(max_freq)) / (max(capacity-dmips-mhz) * max(max_freq)) * 1024</code></p>
<p>根据测试部测试的E2000QCPU单核性能数据，E2000Q的<code>capacity-dmips-mhz</code>属性值可以设置为如下，放大1000倍：<br><img src="https://raw.githubusercontent.com/JackHuang021/images/master/20230105152415.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 小核</span></span><br><span class="line">cpu_l0: cpu@<span class="number">0</span> &#123;</span><br><span class="line">	...</span><br><span class="line">	capacity-dmips-mhz = &lt;<span class="number">2850</span>&gt;;</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 大核</span></span><br><span class="line">cpu_b0: cpu@<span class="number">0</span> &#123;</span><br><span class="line">	...</span><br><span class="line">	capacity-dmips-mhz = &lt;<span class="number">5660</span>&gt;;</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>实际经过CPU算力归一化到1024之后，对应的小核CPU算力为386，大核为1024</p>
<h4 id="EAS代码相关结构体"><a href="#EAS代码相关结构体" class="headerlink" title="EAS代码相关结构体"></a>EAS代码相关结构体</h4><p>perf_domain结构表示一个CPU性能域，perf_domain和cpufreq_policy是一一对应的，性能域之间形成链，链表头存放在root_domain中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/sched/sched.h</span></span><br><span class="line"><span class="comment">// perf_comain 结构表示一个CPU性能域，perf_domain和cpufreq_policy是一一对应的</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">perf_domain</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">em_perf_domain</span> *<span class="title">em_pd</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">perf_domain</span> *<span class="title">next</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// cpumask_var_t解析</span></span><br><span class="line"><span class="comment">// include/uapi/linux/kernel.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __KERNEL_DIV_ROUND_UP(n, d) ((((n) + (d)) - 1) / (d))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// include/linux/kernel.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DIV_ROUND_UP	__KERNEL_DIV_ROUND_UP</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// include/linux/bits.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BITS_PER_BYTE 	8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// include/linux/bitops.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BITS_PER_TYPE(type) (sizeof(type) * BITS_PER_BYTE)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BITS_TO_LONGS(nr)	DIV_ROUND_UP(nr, BITS_PER_TYPE(long))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// include/linux/types.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DECLARE_BITMAP(name, bits) \</span></span><br><span class="line"><span class="meta">	unsigned long name[BITS_TO_LONGS(bits)]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// include/linux/threads.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_NR_CPUS 256</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NR_CPUS		CONFIG_NR_CPUS</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// include/linux/cpumask.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">cpumask</span> &#123;</span> DECLARE_BITMAP(bits, NR_CPUS); &#125; <span class="keyword">cpumask_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">cpumask</span> <span class="title">cpumask_var_t</span>[1];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 展开cpumask</span></span><br><span class="line"><span class="comment">// 该结构体用来表示当前系统中CPU的状态，每个CPU对应其中一位</span></span><br><span class="line"><span class="comment">// 这里内核配置最大支持256个CPU，所以定义了一个长度为4的long数组</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">cpumask</span> &#123;</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	unsigned long bits[BITS_TO_LONGS(256)];</span></span><br><span class="line"><span class="comment">	unsigned long bits[DIV_ROUND_UP(256, 64)];</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> bits[<span class="number">4</span>];</span><br><span class="line">&#125; <span class="keyword">cpumask_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// root_domain代表CPU性能域的一个总体数据结构，管理这些性能域</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">root_domain</span> &#123;</span></span><br><span class="line">	<span class="keyword">atomic_t</span>		refcount;</span><br><span class="line">	<span class="keyword">atomic_t</span>		rto_count;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span>		<span class="title">rcu</span>;</span></span><br><span class="line">	<span class="keyword">cpumask_var_t</span>		span;</span><br><span class="line">	<span class="keyword">cpumask_var_t</span>		online;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 该root_domain是否处于overload状态</span></span><br><span class="line">	<span class="keyword">int</span>			overload;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 该root_domain是否处于overutilized状态</span></span><br><span class="line">	<span class="keyword">int</span>			overutilized;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The bit corresponding to a CPU gets set here if such CPU has more</span></span><br><span class="line"><span class="comment">	 * than one runnable -deadline task (as it is below for RT tasks).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">cpumask_var_t</span>		dlo_mask;</span><br><span class="line">	<span class="keyword">atomic_t</span>		dlo_count;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dl_bw</span>		<span class="title">dl_bw</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cpudl</span>		<span class="title">cpudl</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_RT_PUSH_IPI</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * For IPI pull requests, loop across the rto_mask.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_work</span>		<span class="title">rto_push_work</span>;</span></span><br><span class="line">	<span class="keyword">raw_spinlock_t</span>		rto_lock;</span><br><span class="line">	<span class="comment">/* These are only updated and read within rto_lock */</span></span><br><span class="line">	<span class="keyword">int</span>			rto_loop;</span><br><span class="line">	<span class="keyword">int</span>			rto_cpu;</span><br><span class="line">	<span class="comment">/* These atomics are updated outside of a lock */</span></span><br><span class="line">	<span class="keyword">atomic_t</span>		rto_loop_next;</span><br><span class="line">	<span class="keyword">atomic_t</span>		rto_loop_start;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The &quot;RT overload&quot; flag: it gets set if a CPU has more than</span></span><br><span class="line"><span class="comment">	 * one runnable RT task.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">cpumask_var_t</span>		rto_mask;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cpupri</span>		<span class="title">cpupri</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 系统中算力最大的CPU的算力</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		max_cpu_capacity;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * NULL-terminated list of performance domains intersecting with the</span></span><br><span class="line"><span class="comment">	 * CPUs of the rd. Protected by RCU.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">// perf_domain单链表的表头</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">perf_domain</span> __<span class="title">rcu</span> *<span class="title">pd</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// include/linux/energy_model.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">em_perf_state</span> &#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> frequency;	<span class="comment">// CPU频点，单位KHz</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> power;		<span class="comment">// 此频点下的功耗</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> cost;			<span class="comment">// 此频点下的成本系数，等于 power * max_freq / freq</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">em_perf_domain</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">em_perf_state</span> *<span class="title">table</span>;</span>	<span class="comment">// CPU频点表</span></span><br><span class="line">	<span class="keyword">int</span> nr_perf_states;				<span class="comment">// 频点表中元素的个数</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> cpus[];			<span class="comment">// 此性能域中包括哪些CPU</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="perf-domain初始化"><a href="#perf-domain初始化" class="headerlink" title="perf_domain初始化"></a>perf_domain初始化</h4><p>start_kernel() -&gt; sched_init() -&gt; init_defrootdomain()</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/sched/core.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> __init <span class="title">sched_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">	init_defrootdmain();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// kernel/sched/topology.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">build_perf_domains</span><span class="params">(<span class="keyword">const</span> struct cpumask *cpu_map)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 这里nr_cpus即统计cpu_map里面当前CPU的个数</span></span><br><span class="line">	<span class="keyword">int</span> i, nr_pd = <span class="number">0</span>, nr_ps = <span class="number">0</span>, nr_cpus = cpumask_weight(cpu_map);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">perf_domain</span> *<span class="title">pd</span> =</span> <span class="literal">NULL</span>, *tmp;</span><br><span class="line">	<span class="keyword">int</span> cpu = cpumask_first(cpu_map);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">root_domain</span> *<span class="title">rd</span> =</span> cpu_rq(cpu)-&gt;rd;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cpufreq_policy</span> *<span class="title">policy</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cpufreq_governor</span> *<span class="title">gov</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!sysctl_sched_energy_aware)</span><br><span class="line">		<span class="keyword">goto</span> <span class="built_in">free</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* EAS is enabled for asymmetric CPU capacity topologies. */</span></span><br><span class="line">	<span class="keyword">if</span> (!per_cpu(sd_asym_cpucapacity, cpu)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (sched_debug()) &#123;</span><br><span class="line">			pr_info(<span class="string">&quot;rd %*pbl: CPUs do not have asymmetric capacities\n&quot;</span>,</span><br><span class="line">					cpumask_pr_args(cpu_map));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">goto</span> <span class="built_in">free</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* EAS definitely does *not* handle SMT */</span></span><br><span class="line">	<span class="keyword">if</span> (sched_smt_active()) &#123;</span><br><span class="line">		pr_warn(<span class="string">&quot;rd %*pbl: Disabling EAS, SMT is not supported\n&quot;</span>,</span><br><span class="line">			cpumask_pr_args(cpu_map));</span><br><span class="line">		<span class="keyword">goto</span> <span class="built_in">free</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	for_each_cpu(i, cpu_map) &#123;</span><br><span class="line">		<span class="comment">/* Skip already covered CPUs. */</span></span><br><span class="line">		<span class="keyword">if</span> (find_pd(pd, i))</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Do not attempt EAS if schedutil is not being used. */</span></span><br><span class="line">		policy = cpufreq_cpu_get(i);</span><br><span class="line">		<span class="keyword">if</span> (!policy)</span><br><span class="line">			<span class="keyword">goto</span> <span class="built_in">free</span>;</span><br><span class="line">		gov = policy-&gt;governor;</span><br><span class="line">		cpufreq_cpu_put(policy);</span><br><span class="line">		<span class="keyword">if</span> (gov != &amp;schedutil_gov) &#123;</span><br><span class="line">			<span class="keyword">if</span> (rd-&gt;pd)</span><br><span class="line">				pr_warn(<span class="string">&quot;rd %*pbl: Disabling EAS, schedutil is mandatory\n&quot;</span>,</span><br><span class="line">						cpumask_pr_args(cpu_map));</span><br><span class="line">			<span class="keyword">goto</span> <span class="built_in">free</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Create the new pd and add it to the local list. */</span></span><br><span class="line">		tmp = pd_init(i);</span><br><span class="line">		<span class="keyword">if</span> (!tmp)</span><br><span class="line">			<span class="keyword">goto</span> <span class="built_in">free</span>;</span><br><span class="line">		tmp-&gt;next = pd;</span><br><span class="line">		pd = tmp;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Count performance domains and performance states for the</span></span><br><span class="line"><span class="comment">		 * complexity check.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		nr_pd++;</span><br><span class="line">		nr_ps += em_pd_nr_perf_states(pd-&gt;em_pd);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Bail out if the Energy Model complexity is too high. */</span></span><br><span class="line">	<span class="keyword">if</span> (nr_pd * (nr_ps + nr_cpus) &gt; EM_MAX_COMPLEXITY) &#123;</span><br><span class="line">		WARN(<span class="number">1</span>, <span class="string">&quot;rd %*pbl: Failed to start EAS, EM complexity is too high\n&quot;</span>,</span><br><span class="line">						cpumask_pr_args(cpu_map));</span><br><span class="line">		<span class="keyword">goto</span> <span class="built_in">free</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	perf_domain_debug(cpu_map, pd);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Attach the new list of performance domains to the root domain. */</span></span><br><span class="line">	tmp = rd-&gt;pd;</span><br><span class="line">	rcu_assign_pointer(rd-&gt;pd, pd);</span><br><span class="line">	<span class="keyword">if</span> (tmp)</span><br><span class="line">		call_rcu(&amp;tmp-&gt;rcu, destroy_perf_domain_rcu);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> !!pd;</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>:</span><br><span class="line">	free_pd(pd);</span><br><span class="line">	tmp = rd-&gt;pd;</span><br><span class="line">	rcu_assign_pointer(rd-&gt;pd, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (tmp)</span><br><span class="line">		call_rcu(&amp;tmp-&gt;rcu, destroy_perf_domain_rcu);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>E2000Q 5.10内核，perf_domain_debug 打印信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[    2.574534] root_domain 0-3: pd3:&#123; cpus=3 nr_pstate=4 &#125;</span><br><span class="line">[    2.574540] freq: 250000, power: 79, cost: 632</span><br><span class="line">[    2.579072] freq: 500000, power: 197, cost: 788</span><br><span class="line">[    2.583690] freq: 1000000, power: 409, cost: 818</span><br><span class="line">[    2.588390] freq: 2000000, power: 839, cost: 839</span><br><span class="line">[    2.593094]  pd2:&#123; cpus=2 nr_pstate=4 &#125;</span><br><span class="line">[    2.593096] freq: 250000, power: 79, cost: 632</span><br><span class="line">[    2.601445] freq: 500000, power: 197, cost: 788</span><br><span class="line">[    2.606054] freq: 1000000, power: 409, cost: 818</span><br><span class="line">[    2.610749] freq: 2000000, power: 839, cost: 839</span><br><span class="line">[    2.615445]  pd0:&#123; cpus=0-1 nr_pstate=4 &#125;</span><br><span class="line">[    2.615447] freq: 187500, power: 1, cost: 8</span><br><span class="line">[    2.623709] freq: 375000, power: 9, cost: 36</span><br><span class="line">[    2.628058] freq: 750000, power: 55, cost: 110</span><br><span class="line">[    2.632579] freq: 1500000, power: 125, cost: 125</span><br></pre></td></tr></table></figure>

<p>root_domain的overload和overutilized说明：</p>
<ul>
<li>对于一个 CPU 而言，其处于 overload 状态则说明其 rq 上有大于等于2个任务</li>
<li>对于一个 CPU 而言，其处于 overutilized 状态说明该 cpu 的 utility 超过其 capacity（缺省预留20%的算力，另外，这里的 capacity 是用于cfs任务的算力）</li>
<li>对于 root domain，overload 表示至少有一个 cpu 处于 overload 状态。overutilized 表示至少有一个 cpu 处于 overutilized 状态</li>
<li>overutilized 状态非常重要，它决定了调度器是否启用EAS，只有在系统没有 overutilized 的情况下EAS才会生效。overload和newidle balance的频次控制相关，当系统在overload的情况下，newidle balance才会启动进行均衡。</li>
</ul>
<h4 id="EAS能量计算方法"><a href="#EAS能量计算方法" class="headerlink" title="EAS能量计算方法"></a>EAS能量计算方法</h4><p>CPU在某个performance state(ps)下的计算能力：<br>ps-&gt;cap &#x3D; ps-&gt;freq * scale_cpu &#x2F; cpu_max_freq	（1）</p>
<p>CPU在该频点performace state(ps)下的能量消耗：<br>cpu_nrg &#x3D; ps-&gt;power * cpu_util &#x2F; ps-&gt;cap  （2）</p>
<p>结合(1) (2)可以得出CPU在该ps下的能量消耗<br>    cpu_nrg &#x3D; ps-&gt;power * cpu_max_freq * cpu_util &#x2F; ps-&gt;freq * scale_cpu (3)</p>
<p>其中 ps-&gt;power * cpu_max_freq &#x2F; ps-&gt;freq 是一个固定数据存放在频点表的cost成员中</p>
<p>一个pd内的CPU，拥有相同的cost，所以一个pd内所有CPU的能量消耗可以表示为<br>pd_nrg &#x3D; ps-&gt;cost * sum(cpu_util) &#x2F; scale_cpu</p>
<h4 id="EAS的调度过程"><a href="#EAS的调度过程" class="headerlink" title="EAS的调度过程"></a>EAS的调度过程</h4><p>在任务被重新唤醒或者fork新建时，会通过<code>select_task_rq_fair()</code>将任务进行balance，达到充分利用CPU的目的。在<code>select_task_rq_fair()</code>，若任务是被重新唤醒就会调用<code>find_energy_efficient_cpu()</code>进行选核执行</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Predicts what cpu_util(@cpu) would return if @p was migrated (and enqueued)</span></span><br><span class="line"><span class="comment"> * to @dst_cpu.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">cpu_util_next</span><span class="params">(<span class="keyword">int</span> cpu, struct task_struct *p, <span class="keyword">int</span> dst_cpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cfs_rq</span> *<span class="title">cfs_rq</span> =</span> &amp;cpu_rq(cpu)-&gt;cfs;</span><br><span class="line">	<span class="comment">// 计算cfs的util</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> util_est, util = READ_ONCE(cfs_rq-&gt;avg.util_avg);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If @p migrates from @cpu to another, remove its contribution. Or,</span></span><br><span class="line"><span class="comment">	 * if @p migrates from another CPU to @cpu, add its contribution. In</span></span><br><span class="line"><span class="comment">	 * the other cases, @cpu is not impacted by the migration, so the</span></span><br><span class="line"><span class="comment">	 * util_avg should already be correct.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">// 在dst_cpu为-1的情况下</span></span><br><span class="line">	<span class="comment">// 若任务p运行在传入的CPU util = cfs_util - task_util(p)</span></span><br><span class="line">	<span class="keyword">if</span> (task_cpu(p) == cpu &amp;&amp; dst_cpu != cpu)</span><br><span class="line">		sub_positive(&amp;util, task_util(p));</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (task_cpu(p) != cpu &amp;&amp; dst_cpu == cpu)</span><br><span class="line">		util += task_util(p);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (sched_feat(UTIL_EST)) &#123;</span><br><span class="line">		util_est = READ_ONCE(cfs_rq-&gt;avg.util_est.enqueued);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * During wake-up, the task isn&#x27;t enqueued yet and doesn&#x27;t</span></span><br><span class="line"><span class="comment">		 * appear in the cfs_rq-&gt;avg.util_est.enqueued of any rq,</span></span><br><span class="line"><span class="comment">		 * so just add it (if needed) to &quot;simulate&quot; what will be</span></span><br><span class="line"><span class="comment">		 * cpu_util() after the task has been enqueued.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (dst_cpu == cpu)</span><br><span class="line">			util_est += _task_util_est(p);</span><br><span class="line"></span><br><span class="line">		util = max(util, util_est);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> min(util, capacity_orig_of(cpu));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * compute_energy(): Estimates the energy that @pd would consume if @p was</span></span><br><span class="line"><span class="comment"> * migrated to @dst_cpu. compute_energy() predicts what will be the utilization</span></span><br><span class="line"><span class="comment"> * landscape of @pd&#x27;s CPUs after the task migration, and uses the Energy Model</span></span><br><span class="line"><span class="comment"> * to compute what would be the energy if we decided to actually migrate that</span></span><br><span class="line"><span class="comment"> * task.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 计算任务迁移到dst_cpu后，整个pd，即此cluster的energy</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span></span></span><br><span class="line"><span class="function"><span class="title">compute_energy</span><span class="params">(struct task_struct *p, <span class="keyword">int</span> dst_cpu, struct perf_domain *pd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cpumask</span> *<span class="title">pd_mask</span> =</span> perf_domain_span(pd);</span><br><span class="line">	<span class="comment">// 获取该CPU的算力，这里取得的是归一化到1024的算力</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> cpu_cap = arch_scale_cpu_capacity(cpumask_first(pd_mask));</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> max_util = <span class="number">0</span>, sum_util = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> cpu;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 对此pd中每个online cpu都执行计算</span></span><br><span class="line">	for_each_cpu_and(cpu, pd_mask, cpu_online_mask) &#123;</span><br><span class="line">		<span class="comment">// 这里计算util_cfs，当dst_cpu传入为-1时，这里是没将p的util计算进去的</span></span><br><span class="line">		<span class="comment">// 这个地方比较关键，p的util有没有算到cpu的util里面去是在这一步决定的</span></span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> cpu_util, util_cfs = cpu_util_next(cpu, p, dst_cpu);</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">tsk</span> =</span> cpu == dst_cpu ? p : <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 返回该CPU下cfs+irq+rt+dl使用掉的CPU算力总和</span></span><br><span class="line">		<span class="comment">// 这一步计算没将任务p的util加进去</span></span><br><span class="line">		sum_util += schedutil_cpu_util(cpu, util_cfs, cpu_cap,</span><br><span class="line">					       ENERGY_UTIL, <span class="literal">NULL</span>);</span><br><span class="line">		<span class="comment">// 这一步计算将任务p的util加进去了</span></span><br><span class="line">		<span class="comment">// 这里计算cpu_util的原因就是需要预测下一次该perf_domain的频率</span></span><br><span class="line">		<span class="comment">// 计算的cpu_util是略微放大了的，需要进一步分析这个放大的操作</span></span><br><span class="line">		cpu_util = schedutil_cpu_util(cpu, util_cfs, cpu_cap,</span><br><span class="line">					      FREQUENCY_UTIL, tsk);</span><br><span class="line">		max_util = max(max_util, cpu_util);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 计算该pd下所有CPU的功耗和</span></span><br><span class="line">	<span class="keyword">return</span> em_cpu_energy(pd-&gt;em_pd, max_util, sum_util);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算该pd下所有CPU的功耗和</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">em_cpu_energy</span><span class="params">(struct em_perf_domain *pd,</span></span></span><br><span class="line"><span class="params"><span class="function">				<span class="keyword">unsigned</span> <span class="keyword">long</span> max_util, <span class="keyword">unsigned</span> <span class="keyword">long</span> sum_util)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> freq, scale_cpu;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">em_perf_state</span> *<span class="title">ps</span>;</span></span><br><span class="line">	<span class="keyword">int</span> i, cpu;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * In order to predict the performance state, map the utilization of</span></span><br><span class="line"><span class="comment">	 * the most utilized CPU of the performance domain to a requested</span></span><br><span class="line"><span class="comment">	 * frequency, like schedutil.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	cpu = cpumask_first(to_cpumask(pd-&gt;cpus));</span><br><span class="line">	scale_cpu = arch_scale_cpu_capacity(cpu);</span><br><span class="line">	ps = &amp;pd-&gt;table[pd-&gt;nr_perf_states - <span class="number">1</span>];</span><br><span class="line">	<span class="comment">// 这里将perf_domai计算出来的最大的CPU利用率来推测CPU接下来需要调频的频率</span></span><br><span class="line">	<span class="comment">// 这里可以将freq称为推测频率</span></span><br><span class="line">	<span class="comment">// 计算公式 freq = 1.25 * max_f * max_util / scale_cpu</span></span><br><span class="line">	<span class="comment">// 这里是在最大频率1.25倍进行计算的</span></span><br><span class="line">	freq = map_util_freq(max_util, ps-&gt;frequency, scale_cpu);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Find the lowest performance state of the Energy Model above the</span></span><br><span class="line"><span class="comment">	 * requested frequency.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">// 将该频率映射到频率表上</span></span><br><span class="line">	<span class="comment">// 因为freq是在1.5倍最大频率计算的，算出来的推测频率可能大于最大频率</span></span><br><span class="line">	<span class="comment">// 假如大于最大频率的话，for循环执行后ps指向的就是最大频率了</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; pd-&gt;nr_perf_states; i++) &#123;</span><br><span class="line">		ps = &amp;pd-&gt;table[i];</span><br><span class="line">		<span class="keyword">if</span> (ps-&gt;frequency &gt;= freq)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The capacity of a CPU in the domain at the performance state (ps)</span></span><br><span class="line"><span class="comment">	 * can be computed as:</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 *             ps-&gt;freq * scale_cpu</span></span><br><span class="line"><span class="comment">	 *   ps-&gt;cap = --------------------                          (1)</span></span><br><span class="line"><span class="comment">	 *                 cpu_max_freq</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * So, ignoring the costs of idle states (which are not available in</span></span><br><span class="line"><span class="comment">	 * the EM), the energy consumed by this CPU at that performance state</span></span><br><span class="line"><span class="comment">	 * is estimated as:</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 *             ps-&gt;power * cpu_util</span></span><br><span class="line"><span class="comment">	 *   cpu_nrg = --------------------                          (2)</span></span><br><span class="line"><span class="comment">	 *                   ps-&gt;cap</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * since &#x27;cpu_util / ps-&gt;cap&#x27; represents its percentage of busy time.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 *   <span class="doctag">NOTE:</span> Although the result of this computation actually is in</span></span><br><span class="line"><span class="comment">	 *         units of power, it can be manipulated as an energy value</span></span><br><span class="line"><span class="comment">	 *         over a scheduling period, since it is assumed to be</span></span><br><span class="line"><span class="comment">	 *         constant during that interval.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * By injecting (1) in (2), &#x27;cpu_nrg&#x27; can be re-expressed as a product</span></span><br><span class="line"><span class="comment">	 * of two terms:</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 *             ps-&gt;power * cpu_max_freq   cpu_util</span></span><br><span class="line"><span class="comment">	 *   cpu_nrg = ------------------------ * ---------          (3)</span></span><br><span class="line"><span class="comment">	 *                    ps-&gt;freq            scale_cpu</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * The first term is static, and is stored in the em_perf_state struct</span></span><br><span class="line"><span class="comment">	 * as &#x27;ps-&gt;cost&#x27;.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Since all CPUs of the domain have the same micro-architecture, they</span></span><br><span class="line"><span class="comment">	 * share the same &#x27;ps-&gt;cost&#x27;, and the same CPU capacity. Hence, the</span></span><br><span class="line"><span class="comment">	 * total energy of the domain (which is the simple sum of the energy of</span></span><br><span class="line"><span class="comment">	 * all of its CPUs) can be factorized as:</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 *            ps-&gt;cost * \Sum cpu_util</span></span><br><span class="line"><span class="comment">	 *   pd_nrg = ------------------------                       (4)</span></span><br><span class="line"><span class="comment">	 *                  scale_cpu</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">// 根据推测频率在频点表上对应的cost来算energy</span></span><br><span class="line">	<span class="comment">// 不同频率的cost是常数，在初始化时就已经计算出来</span></span><br><span class="line">	<span class="comment">// 计算cost的时候需要将该perf_domain上的所有util拿出来进行计算</span></span><br><span class="line">	<span class="comment">// 一个perf_domain下的频率是一样的，所以这里计算能耗直接用了sum_util</span></span><br><span class="line">	<span class="keyword">return</span> ps-&gt;cost * sum_util / scale_cpu;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 寻找工作能耗最低的CPU</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">find_energy_efficient_cpu</span><span class="params">(struct task_struct *p, <span class="keyword">int</span> prev_cpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> prev_delta = ULONG_MAX, best_delta = ULONG_MAX;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">root_domain</span> *<span class="title">rd</span> =</span> cpu_rq(smp_processor_id())-&gt;rd;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> cpu_cap, util, base_energy = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> cpu, best_energy_cpu = prev_cpu;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sched_domain</span> *<span class="title">sd</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">perf_domain</span> *<span class="title">pd</span>;</span></span><br><span class="line"></span><br><span class="line">	rcu_read_lock();</span><br><span class="line">	<span class="comment">// 从rd取pd的指针</span></span><br><span class="line">	pd = rcu_dereference(rd-&gt;pd);</span><br><span class="line">	<span class="keyword">if</span> (!pd || READ_ONCE(rd-&gt;overutilized))</span><br><span class="line">		<span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Energy-aware wake-up happens on the lowest sched_domain starting</span></span><br><span class="line"><span class="comment">	 * from sd_asym_cpucapacity spanning over this_cpu and prev_cpu.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	sd = rcu_dereference(*this_cpu_ptr(&amp;sd_asym_cpucapacity));</span><br><span class="line">	<span class="keyword">while</span> (sd &amp;&amp; !cpumask_test_cpu(prev_cpu, sched_domain_span(sd)))</span><br><span class="line">		sd = sd-&gt;parent;</span><br><span class="line">	<span class="keyword">if</span> (!sd)</span><br><span class="line">		<span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">	sync_entity_load_avg(&amp;p-&gt;se);</span><br><span class="line">	<span class="comment">// p的util为0，直接返回prev_cpu</span></span><br><span class="line">	<span class="keyword">if</span> (!task_util_est(p))</span><br><span class="line">		<span class="keyword">goto</span> unlock;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 遍历整个pd链表，计算p在不同pd下的能耗</span></span><br><span class="line">	<span class="keyword">for</span> (; pd; pd = pd-&gt;next) &#123;</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> cur_delta, spare_cap, max_spare_cap = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> base_energy_pd;</span><br><span class="line">		<span class="keyword">int</span> max_spare_cap_cpu = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Compute the &#x27;base&#x27; energy of the pd, without @p */</span></span><br><span class="line">		<span class="comment">// 计算不包括p的情况下此pd当前的energy</span></span><br><span class="line">		<span class="comment">// 这里传入dst_cpu为-1，计算的就是该perf_domain不包括任务P的util</span></span><br><span class="line">		<span class="comment">// 来进行频率推测，然后用来计算能耗</span></span><br><span class="line">		base_energy_pd = compute_energy(p, <span class="number">-1</span>, pd);</span><br><span class="line">		<span class="comment">// 不包括p的情况下系统的总energy</span></span><br><span class="line">		base_energy += base_energy_pd;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 遍历整个pd中的CPU，计算p放在该CPU上的功耗</span></span><br><span class="line">		for_each_cpu_and(cpu, perf_domain_span(pd), sched_domain_span(sd)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!cpumask_test_cpu(cpu, p-&gt;cpus_ptr))</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="comment">// 计算p放到此CPU后该CPU总共消耗的算力</span></span><br><span class="line">			util = cpu_util_next(cpu, p, cpu);</span><br><span class="line">			<span class="comment">// 这里取的是归一化后的CPU算力</span></span><br><span class="line">			cpu_cap = capacity_of(cpu);</span><br><span class="line">			spare_cap = cpu_cap;</span><br><span class="line">			<span class="comment">// 计算p放到此CPU后剩余的算力</span></span><br><span class="line">			lsub_positive(&amp;spare_cap, util);</span><br><span class="line"></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * Skip CPUs that cannot satisfy the capacity request.</span></span><br><span class="line"><span class="comment">			 * IOW, placing the task there would make the CPU</span></span><br><span class="line"><span class="comment">			 * overutilized. Take uclamp into account to see how</span></span><br><span class="line"><span class="comment">			 * much capacity we can get out of the CPU; this is</span></span><br><span class="line"><span class="comment">			 * aligned with schedutil_cpu_util().</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			util = uclamp_rq_util_with(cpu_rq(cpu), util, p);</span><br><span class="line">			<span class="comment">// CPU需要保留20%左右的算力，不满足需求后进行下一个CPU的探测</span></span><br><span class="line">			<span class="keyword">if</span> (!fits_capacity(util, cpu_cap))</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* Always use prev_cpu as a candidate. */</span></span><br><span class="line">			<span class="comment">// 若对比的这个CPU就是任务之前运行的CPU</span></span><br><span class="line">			<span class="keyword">if</span> (cpu == prev_cpu) &#123;</span><br><span class="line">				<span class="comment">// 计算p放在该cpu后整个pd的能量消耗</span></span><br><span class="line">				<span class="comment">// 这里传入的dst_cpu为之前p运行的CPU</span></span><br><span class="line">				<span class="comment">// 推测频率是在之前运行CPU进行推测，同时把P的util也计算到了</span></span><br><span class="line">				prev_delta = compute_energy(p, prev_cpu, pd);</span><br><span class="line">				<span class="comment">// 计算p放在该CPU后整个pd增加的能量消耗</span></span><br><span class="line">				prev_delta -= base_energy_pd;</span><br><span class="line">				<span class="comment">// 更新best_delta，取最优能耗</span></span><br><span class="line">				best_delta = min(best_delta, prev_delta);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * Find the CPU with the maximum spare capacity in</span></span><br><span class="line"><span class="comment">			 * the performance domain</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="comment">// 记录p放上去后剩余算力最大的CPU和最大的剩余算力</span></span><br><span class="line">			<span class="keyword">if</span> (spare_cap &gt; max_spare_cap) &#123;</span><br><span class="line">				max_spare_cap = spare_cap;</span><br><span class="line">				max_spare_cap_cpu = cpu;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Evaluate the energy impact of using this CPU. */</span></span><br><span class="line">		<span class="comment">// 同一个簇上的CPU取最大余量算力的那个CPU与其他簇的CPU做能量消耗对比</span></span><br><span class="line">		<span class="keyword">if</span> (max_spare_cap_cpu &gt;= <span class="number">0</span> &amp;&amp; max_spare_cap_cpu != prev_cpu) &#123;</span><br><span class="line">			<span class="comment">// 计算p放在算力剩余最大的CPU后整个pd的能量消耗</span></span><br><span class="line">			<span class="comment">// 这里传进去的dst_cpu肯定不会和当前任务p运行的CPU相同</span></span><br><span class="line">			<span class="comment">// 所以在cpu_util_next()中会把p的util加到cpu util上</span></span><br><span class="line">			cur_delta = compute_energy(p, max_spare_cap_cpu, pd);</span><br><span class="line">			<span class="comment">// 计算能量消耗增量</span></span><br><span class="line">			cur_delta -= base_energy_pd;</span><br><span class="line">			<span class="comment">// 如果当前能量增量优于p放在prev_cpu运行的能量消耗，则取该cpu运行p</span></span><br><span class="line">			<span class="keyword">if</span> (cur_delta &lt; best_delta) &#123;</span><br><span class="line">				best_delta = cur_delta;</span><br><span class="line">				best_energy_cpu = max_spare_cap_cpu;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">unlock:</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Pick the best CPU if prev_cpu cannot be used, or if it saves at</span></span><br><span class="line"><span class="comment">	 * least 6% of the energy used by prev_cpu.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">// 若prev_cpu找不到，就直接返回最优能耗cpu</span></span><br><span class="line">	<span class="keyword">if</span> (prev_delta == ULONG_MAX)</span><br><span class="line">		<span class="keyword">return</span> best_energy_cpu;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 若最优能耗比放在prev_cpu上运行的能耗还要低6.25%以上，则取最优能耗cpu</span></span><br><span class="line">	<span class="keyword">if</span> ((prev_delta - best_delta) &gt; ((prev_delta + base_energy) &gt;&gt; <span class="number">4</span>))</span><br><span class="line">		<span class="keyword">return</span> best_energy_cpu;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 否则不做改变，直接使用prev_cpu运行p</span></span><br><span class="line">	<span class="keyword">return</span> prev_cpu;</span><br><span class="line"></span><br><span class="line">fail:</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="EAS-Mainline"><a href="#EAS-Mainline" class="headerlink" title="EAS Mainline"></a>EAS Mainline</h3><p><a href="https://git.gitlab.arm.com/linux-arm/linux-power.git">https://git.gitlab.arm.com/linux-arm/linux-power.git</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Cpufreq</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux睡眠唤醒调试方法</title>
    <url>/archives/f183bd8.html</url>
    <content><![CDATA[<p>Linux中的挂起、休眠，一般是指以下四种状态：</p>
<ol>
<li>STI(suspend to idle)：是一种通用的、纯软件、轻量级系统睡眠状态</li>
<li>Standby(power-on suspend)：是一种适度的功耗节省状态，同时系统也可以比较快的唤醒</li>
<li>STR(suspend to ram)：提供了比较显著的功耗节省，系统中除了内存之外的部件都进入了低功耗状态</li>
<li>STD(suspend to disk)：提供最大程度的功耗节省<span id="more"></span></li>
</ol>
<table>
<thead>
<tr>
<th align="center">State</th>
<th align="center">ACPI state</th>
<th align="center">Label</th>
</tr>
</thead>
<tbody><tr>
<td align="center">STI</td>
<td align="center">S0</td>
<td align="center">s2idle&#x2F;freeze</td>
</tr>
<tr>
<td align="center">standby</td>
<td align="center">S1</td>
<td align="center">shallow&#x2F;standby</td>
</tr>
<tr>
<td align="center">STR</td>
<td align="center">S3</td>
<td align="center">deep</td>
</tr>
<tr>
<td align="center">STD</td>
<td align="center">S4</td>
<td align="center">disk</td>
</tr>
</tbody></table>
<blockquote>
<p>具体的状态描述可以参考内核文档<a href="https://www.kernel.org/doc/Documentation/power/states.txt">Documentation&#x2F;power&#x2F;states.txt</a></p>
</blockquote>
<h3 id="基础调试方法"><a href="#基础调试方法" class="headerlink" title="基础调试方法"></a>基础调试方法</h3><ol>
<li><p>关闭串口睡眠：在启动参数中增加<code>no_console_suspend ignore_loglevel</code>，S3调试日志如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@Ubuntu:~<span class="comment"># echo mem &gt; /sys/power/state</span></span><br><span class="line">[   74.403728] PM: <span class="built_in">suspend</span> entry (deep)</span><br><span class="line">[   74.411597] Filesystems sync: 0.004 seconds</span><br><span class="line">[   74.576746] Freezing user space processes ... (elapsed 0.003 seconds) <span class="keyword">done</span>.</span><br><span class="line">[   74.586948] OOM killer disabled.</span><br><span class="line">[   74.590196] Freezing remaining freezable tasks ... (elapsed 0.001 seconds) <span class="keyword">done</span>.</span><br><span class="line">[   74.604967] pcieport 0000:00:04.0: pciehp: Timeout on hotplug <span class="built_in">command</span> 0x1438 (issued 71912 msec ago)</span><br><span class="line">[   74.605025] pcieport 0000:00:05.0: pciehp: Timeout on hotplug <span class="built_in">command</span> 0x1438 (issued 71884 msec ago)</span><br><span class="line">[   74.617628] macb 3200c000.ethernet eth0: Link is Down</span><br><span class="line">[   74.629279] macb 3200c000.ethernet: gem-ptp-timer ptp clock unregistered.</span><br><span class="line">[   74.752892] pcieport 0000:00:01.0: pciehp: Timeout on hotplug <span class="built_in">command</span> 0x1438 (issued 72084 msec ago)</span><br><span class="line">[   76.636865] pcieport 0000:00:04.0: pciehp: Timeout on hotplug <span class="built_in">command</span> 0x0418 (issued 2020 msec ago)</span><br><span class="line">[   76.644855] pcieport 0000:00:05.0: pciehp: Timeout on hotplug <span class="built_in">command</span> 0x0418 (issued 2024 msec ago)</span><br><span class="line">[   76.784854] pcieport 0000:00:01.0: pciehp: Timeout on hotplug <span class="built_in">command</span> 0x0418 (issued 2024 msec ago)</span><br><span class="line">[   76.917236] Disabling non-boot CPUs ...</span><br></pre></td></tr></table></figure>
</li>
<li><p>在启动参数中加入<code>initcall_debug</code>，打印init函数的进入和返回log，可以定位哪个init函数运行失败或运行时间过长，S3调试日志如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@Ubuntu:~<span class="comment"># echo mem &gt; /sys/power/state</span></span><br><span class="line">[  409.072355] PM: <span class="built_in">suspend</span> entry (deep)</span><br><span class="line">[  409.087412] Filesystems sync: 0.011 seconds</span><br><span class="line">[  409.260860] Freezing user space processes ... (elapsed 0.003 seconds) <span class="keyword">done</span>.</span><br><span class="line">[  409.271298] OOM killer disabled.</span><br><span class="line">[  409.274561] Freezing remaining freezable tasks ... (elapsed 0.001 seconds) <span class="keyword">done</span>.</span><br><span class="line">[  409.284345] rtc rtc0: calling rtc_suspend+0x0/0x138 @ 840, parent: 0-0068</span><br><span class="line">[  409.291569] rtc rtc0: rtc_suspend+0x0/0x138 returned 0 after 317 usecs</span><br><span class="line">[  409.298209] mtd mtd1ro: calling mtd_cls_suspend+0x0/0x78 @ 840, parent: 10000000.lbc_nor</span><br><span class="line">[  409.306323] mtd mtd1ro: mtd_cls_suspend+0x0/0x78 returned 0 after 1 usecs</span><br><span class="line">[  409.313140] mtd mtd1: calling mtd_cls_suspend+0x0/0x78 @ 840, parent: 10000000.lbc_nor</span><br><span class="line">[  409.321075] mtd mtd1: mtd_cls_suspend+0x0/0x78 returned 0 after 1 usecs</span><br><span class="line">...</span><br><span class="line">[  412.886230] Disabling non-boot CPUs ...</span><br></pre></td></tr></table></figure>
</li>
<li><p>禁用异步suspend resume设备，排除设备驱动的pm问题<code>echo 0 &gt; /sys/power/pm_async</code>，在Linux异步对设备进行suspend resume时出现问题的情况下，可以禁用异步suspend resume来排查设备驱动pm问题</p>
</li>
</ol>
<h3 id="PM-DEBUG选项调试休眠唤醒"><a href="#PM-DEBUG选项调试休眠唤醒" class="headerlink" title="PM_DEBUG选项调试休眠唤醒"></a>PM_DEBUG选项调试休眠唤醒</h3><p>打开CONFIG_PM_DEBUG选项，使用<code>/sys/power/pm_test</code>来测试休眠、唤醒，pm_test里面一共有5种测试模式</p>
<ul>
<li>freezer：测试进程冻结</li>
<li>devices：测试进程冻结和设备驱动suspend和resume</li>
<li>platform：测试进程冻结、设备驱动suspend和resume、suspending platform global control methods</li>
<li>processors：测试进程冻结、设备驱动suspend resume、suspending platform global control methods、关闭nonboot CPU</li>
<li>core：测试进程冻结、设备驱动suspend resume、关闭nonboot CPU、suspending platform&#x2F;system devices</li>
</ul>
<p>使用该方法进行调试时，需要往<code>/sys/power/pm_test</code>中写入对应的测试模式，然后进行S3 S4休眠操作，休眠流程走完后，5秒后会自动唤醒系统，测试的时候可以从freezer devices platform…逐步进行测试</p>
<blockquote>
<p>详细描述可参考内核文档<a href="https://www.kernel.org/doc/Documentation/power/basic-pm-debugging.txt">basic-pm-debugging.txt</a></p>
</blockquote>
<p>freezer休眠唤醒调试日志</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@Ubuntu:/sys/power<span class="comment"># cat /proc/cmdline </span></span><br><span class="line">console=ttyAMA1,115200 audit=0 earlycon=pl011,0x2800d000 root=/dev/nvme0n1p2 rw no_console_suspend initcall_debug ignore_loglevel</span><br><span class="line">root@Ubuntu:/sys/power<span class="comment"># echo freezer &gt; pm_test</span></span><br><span class="line">root@Ubuntu:/sys/power<span class="comment"># echo mem &gt; state </span></span><br><span class="line">[ 1341.488023] PM: <span class="built_in">suspend</span> entry (deep)</span><br><span class="line">[ 1341.501723] Filesystems sync: 0.009 seconds</span><br><span class="line">[ 1341.624379] [drm] can not get n_m <span class="keyword">for</span> link_rate(270000) and sample_rate(0)</span><br><span class="line">[ 1341.779698] Freezing user space processes ... (elapsed 0.003 seconds) <span class="keyword">done</span>.</span><br><span class="line">[ 1341.790421] OOM killer disabled.</span><br><span class="line">[ 1341.793664] Freezing remaining freezable tasks ... (elapsed 0.001 seconds) <span class="keyword">done</span>.</span><br><span class="line">[ 1341.802539] PM: <span class="built_in">suspend</span> debug: Waiting <span class="keyword">for</span> 5 second(s).</span><br><span class="line">[ 1346.808159] OOM killer enabled.</span><br><span class="line">[ 1346.811304] Restarting tasks ... <span class="keyword">done</span>.</span><br><span class="line">[ 1346.817354] PM: <span class="built_in">suspend</span> <span class="built_in">exit</span></span><br><span class="line">root@Ubuntu:/sys/power<span class="comment"># </span></span><br></pre></td></tr></table></figure>

<p>devices休眠唤醒调试日志</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@Ubuntu:/sys/power<span class="comment"># cat /proc/cmdline </span></span><br><span class="line">console=ttyAMA1,115200 audit=0 earlycon=pl011,0x2800d000 root=/dev/nvme0n1p2 rw no_console_suspend initcall_debug loglevel=7</span><br><span class="line">root@Ubuntu:/sys/power<span class="comment"># echo devices &gt; pm_test</span></span><br><span class="line">root@Ubuntu:/sys/power<span class="comment"># echo mem &gt; state </span></span><br><span class="line"></span><br><span class="line">[ 1628.921417] PM: <span class="built_in">suspend</span> entry (deep)</span><br><span class="line">[ 1628.934839] Filesystems sync: 0.009 seconds</span><br><span class="line">[ 1629.066342] Freezing user space processes ... (elapsed 0.003 seconds) <span class="keyword">done</span>.</span><br><span class="line">[ 1629.076995] OOM killer disabled.</span><br><span class="line">[ 1629.080260] Freezing remaining freezable tasks ... (elapsed 0.001 seconds) <span class="keyword">done</span>.</span><br><span class="line">[ 1629.090074] rtc rtc0: calling rtc_suspend+0x0/0x138 @ 998, parent: 0-0068</span><br><span class="line">[ 1629.097263] rtc rtc0: rtc_suspend+0x0/0x138 returned 0 after 309 usecs</span><br><span class="line">[ 1629.103874] mtd mtd1ro: calling mtd_cls_suspend+0x0/0x78 @ 998, parent: 10000000.lbc_nor</span><br><span class="line">[ 1629.111983] mtd mtd1ro: mtd_cls_suspend+0x0/0x78 returned 0 after 0 usecs</span><br><span class="line">[ 1629.118818] mtd mtd1: calling mtd_cls_suspend+0x0/0x78 @ 998, parent: 10000000.lbc_nor</span><br><span class="line">[ 1629.126754] mtd mtd1: mtd_cls_suspend+0x0/0x78 returned 0 after 2 usecs</span><br><span class="line">...</span><br><span class="line">[ 1632.473232] PM: <span class="built_in">suspend</span> debug: Waiting <span class="keyword">for</span> 5 second(s).</span><br><span class="line">[ 1637.479347] reg-dummy reg-dummy: calling platform_pm_resume+0x0/0x60 @ 998, parent: platform</span><br><span class="line">[ 1637.487835] reg-dummy reg-dummy: platform_pm_resume+0x0/0x60 returned 0 after 0 usecs</span><br><span class="line">[ 1637.495697] regulator regulator.0: calling regulator_resume+0x0/0x190 @ 998, parent: reg-dummy</span><br><span class="line">[ 1637.504334] regulator regulator.0: regulator_resume+0x0/0x190 returned 0 after 1 usecs</span><br><span class="line">...</span><br><span class="line">[ 1639.619802] nvme 0000:01:00.0: pci_pm_resume+0x0/0xb8 returned 0 after 12 usecs</span><br><span class="line">[ 1639.628076] OOM killer enabled.</span><br><span class="line">[ 1639.631235] Restarting tasks ... <span class="keyword">done</span>.</span><br><span class="line">[ 1639.651582] PM: <span class="built_in">suspend</span> <span class="built_in">exit</span></span><br><span class="line">[ 1639.665907] nvme nvme0: Shutdown timeout <span class="built_in">set</span> to 8 seconds</span><br><span class="line">[ 1639.769959] nvme nvme0: 2/0/0 default/<span class="built_in">read</span>/poll queues</span><br><span class="line">[ 1641.640767] macb 3200c000.ethernet eth0: yt8521_read_status, phy addr: 0, link up, media: UTP, mii reg 0x11 = 0xbc00</span><br><span class="line">[ 1641.651931] macb 3200c000.ethernet eth0: unable to generate target frequency: 125000000 Hz</span><br><span class="line">[ 1641.661478] macb 3200c000.ethernet eth0: Link is Up - 1Gbps/Full - flow control off</span><br></pre></td></tr></table></figure>


<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>调试休眠和唤醒首先配置启动参数<code>no_console_suspend initcall_debug ignore_loglevel</code>，通过打印的日志信息基本上可以排查出问题原因</li>
<li>通过上面步骤无法排查出阻碍休眠的原因时，可以打开<code>CONFIG_PM_DEBUG</code>选项，往<code>/sys/power/pm_test</code>中写入freezer devices platform…逐步进行测试，观察哪个测试无法通过，可以对应查找问题</li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>suspend</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux workqueue实现</title>
    <url>/archives/c419f2e4.html</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>工作队列（workqueue）是除软中断softirq和tasklet以外最常用的一种中断下半部执行机制，由内核统一管理。<strong>工作队列把推迟执行的任务交给内核线程来执行，其运行在进程上下文，允许重新调度，睡眠，这个内核线程被称为worker thread</strong>工作队列解决了软中断和tasklet执行时间过长导致系统实时性下降的问题，同时避免了驱动模块自身创建线程导致内核线程过多的问题。</p>
<span id="more"></span>
<p>工作队列的设计思想：</p>
<ul>
<li>并行，多个work不要相互阻塞</li>
<li>节省资源，多个work尽量共享资源</li>
</ul>
<h3 id="CMWQ"><a href="#CMWQ" class="headerlink" title="CMWQ"></a>CMWQ</h3><p>为了实现设计思想，工作队列的设计实现也更新了很多版本，最新的workqueue实现叫做CMWQ（Concurrency Managed Workqueue），CMWQ提出了worker pool的概念，系统中存在若干worker pool，这些worker pool不和特定的workqueue关联，而是所有的workqueue共享</p>
<p>用户可以创建workqueue，但不创建worker pool，并通过flag来约束挂入该workqueue上的work的处理方式，workqueue会根据其flag将work交付给系统中的某个worker pool处理，根据<code>struct workqueue_struct</code>中的flags成员来判断work的去向</p>
<p>CMWQ的几个基本概念</p>
<ul>
<li>work：工作</li>
<li>workqueue：工作的集合，workqueue和work是一对多的关系</li>
<li>worker：工人，在代码中worker对应一个work_thread()内核线程</li>
<li>worker_pool：工人的集合，worker_pool和worker是一对多的关系</li>
<li>pwq（pool_workqueue）：中间人，负责建立起workqueue和worker_pool之间的关系，workqueue和pwq是一对多的关系，pwq和worker_pool是一对一的关系</li>
</ul>
<p>CMWQ创建线程池的策略，系统中的线程池thread pool包括两种，一种是和特定CPU绑定的线程池percpu thread pool，另一种是unbound thread pool：</p>
<ul>
<li>针对percpu thread pool，每个CPU包含两个这样的线程池，一个是普通优先级的normal thread pool，一个是高优先级的high priority pool</li>
<li>unbound thread pool，它可以运行在任意的CPU上，这种线程池是动态创建的，根据<code>struct workqueue_attrs *unbound_attrs;</code>这个属性来创建unbound thread pool</li>
</ul>
<p>CMWQ线程创建的策略：当thread pool中处于运行状态的worker thread等于0，并且有需要处理的work的时候，thread pool就会创建新的worker线程，当worker线程处于idle的时候，也不会立即销毁它，而是保持一段时间，如果这时候有创建新的worker需求的时候，那么直接wakeup idle的worker即可，一段时间过去仍然没有需要处理的work，那么该worker thread将会被销毁</p>
<h3 id="CMWQ相关结构体"><a href="#CMWQ相关结构体" class="headerlink" title="CMWQ相关结构体"></a>CMWQ相关结构体</h3><p>worker thread pool使用<code>struct worker_pool</code>结构体用来描述</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/workqueue.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Structure fields follow one of the following exclusion rules.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * I: Modifiable by initialization/destruction paths and read-only for</span></span><br><span class="line"><span class="comment"> *    everyone else.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * P: Preemption protected.  Disabling preemption is enough and should</span></span><br><span class="line"><span class="comment"> *    only be modified and accessed from the local cpu.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * L: pool-&gt;lock protected.  Access with pool-&gt;lock held.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * X: During normal operation, modification requires pool-&gt;lock and should</span></span><br><span class="line"><span class="comment"> *    be done only from local cpu.  Either disabling preemption on local</span></span><br><span class="line"><span class="comment"> *    cpu or grabbing pool-&gt;lock is enough for read access.  If</span></span><br><span class="line"><span class="comment"> *    POOL_DISASSOCIATED is set, it&#x27;s identical to L.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * A: wq_pool_attach_mutex protected.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * PL: wq_pool_mutex protected.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * PR: wq_pool_mutex protected for writes.  RCU protected for reads.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * PW: wq_pool_mutex and wq-&gt;mutex protected for writes.  Either for reads.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * PWR: wq_pool_mutex and wq-&gt;mutex protected for writes.  Either or</span></span><br><span class="line"><span class="comment"> *      RCU for reads.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * WQ: wq-&gt;mutex protected.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * WR: wq-&gt;mutex protected for writes.  RCU protected for reads.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * MD: wq_mayday_lock protected.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">worker_pool</span> &#123;</span></span><br><span class="line">	<span class="keyword">raw_spinlock_t</span>		lock;		<span class="comment">/* the pool lock */</span></span><br><span class="line">	<span class="keyword">int</span>			cpu;		<span class="comment">/* I: the associated cpu */</span></span><br><span class="line">	<span class="keyword">int</span>			node;		<span class="comment">/* I: the associated node ID */</span></span><br><span class="line">	<span class="keyword">int</span>			id;		<span class="comment">/* I: pool ID */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		flags;		<span class="comment">/* X: flags */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		watchdog_ts;	<span class="comment">/* L: watchdog timestamp */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The counter is incremented in a process context on the associated CPU</span></span><br><span class="line"><span class="comment">	 * w/ preemption disabled, and decremented or reset in the same context</span></span><br><span class="line"><span class="comment">	 * but w/ pool-&gt;lock held. The readers grab pool-&gt;lock and are</span></span><br><span class="line"><span class="comment">	 * guaranteed to see if the counter reached zero.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">int</span>			nr_running;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">worklist</span>;</span>	<span class="comment">/* L: list of pending works */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span>			nr_workers;	<span class="comment">/* L: total number of workers */</span></span><br><span class="line">	<span class="keyword">int</span>			nr_idle;	<span class="comment">/* L: currently idle workers */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">idle_list</span>;</span>	<span class="comment">/* L: list of idle workers */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span>	<span class="title">idle_timer</span>;</span>	<span class="comment">/* L: worker idle timeout */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span>	<span class="title">mayday_timer</span>;</span>	<span class="comment">/* L: SOS timer for workers */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* a workers is either on busy_hash or idle_list, or the manager */</span></span><br><span class="line">	DECLARE_HASHTABLE(busy_hash, BUSY_WORKER_HASH_ORDER);</span><br><span class="line">						<span class="comment">/* L: hash of busy workers */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">worker</span>		*<span class="title">manager</span>;</span>	<span class="comment">/* L: purely informational */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">workers</span>;</span>	<span class="comment">/* A: attached workers */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">completion</span>	*<span class="title">detach_completion</span>;</span> <span class="comment">/* all workers detached */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ida</span>		<span class="title">worker_ida</span>;</span>	<span class="comment">/* worker IDs for task name */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">workqueue_attrs</span>	*<span class="title">attrs</span>;</span>		<span class="comment">/* I: worker attributes */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span>	<span class="title">hash_node</span>;</span>	<span class="comment">/* PL: unbound_pool_hash node */</span></span><br><span class="line">	<span class="keyword">int</span>			refcnt;		<span class="comment">/* PL: refcnt for unbound pools */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Destruction of pool is RCU protected to allow dereferences</span></span><br><span class="line"><span class="comment">	 * from get_work_pool().</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span>		<span class="title">rcu</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>工作队列的工作任务是用<code>struct work_struct</code>描述的，是工作队列处理工作任务的最小单位</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 回调函数的定义</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">work_func_t</span>)</span><span class="params">(struct work_struct *work)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> &#123;</span></span><br><span class="line">	<span class="comment">// 该work的一些标志位，另外还存储了pool_workqueue的指针</span></span><br><span class="line">	<span class="keyword">atomic_long_t</span> data;</span><br><span class="line">	<span class="comment">// 将工作任务链接起来</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">entry</span>;</span></span><br><span class="line">	<span class="comment">// 处理工作任务的回调函数</span></span><br><span class="line">	<span class="keyword">work_func_t</span> func;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_LOCKDEP</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">lockdep_map</span> <span class="title">lockdep_map</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>pool_workqueue结构体，连接workqueue和worker pool的中介</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The per-pool workqueue.  While queued, the lower WORK_STRUCT_FLAG_BITS</span></span><br><span class="line"><span class="comment"> * of work_struct-&gt;data are used for flags and the remaining high bits</span></span><br><span class="line"><span class="comment"> * point to the pwq; thus, pwqs need to be aligned at two&#x27;s power of the</span></span><br><span class="line"><span class="comment"> * number of flag bits.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pool_workqueue</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">worker_pool</span>	*<span class="title">pool</span>;</span>		<span class="comment">/* I: the associated pool */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">workqueue_struct</span> *<span class="title">wq</span>;</span>		<span class="comment">/* I: the owning workqueue */</span></span><br><span class="line">	<span class="keyword">int</span>			work_color;	<span class="comment">/* L: current color */</span></span><br><span class="line">	<span class="keyword">int</span>			flush_color;	<span class="comment">/* L: flushing color */</span></span><br><span class="line">	<span class="keyword">int</span>			refcnt;		<span class="comment">/* L: reference count */</span></span><br><span class="line">	<span class="keyword">int</span>			nr_in_flight[WORK_NR_COLORS];</span><br><span class="line">						<span class="comment">/* L: nr of in_flight works */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * nr_active management and WORK_STRUCT_INACTIVE:</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * When pwq-&gt;nr_active &gt;= max_active, new work item is queued to</span></span><br><span class="line"><span class="comment">	 * pwq-&gt;inactive_works instead of pool-&gt;worklist and marked with</span></span><br><span class="line"><span class="comment">	 * WORK_STRUCT_INACTIVE.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * All work items marked with WORK_STRUCT_INACTIVE do not participate</span></span><br><span class="line"><span class="comment">	 * in pwq-&gt;nr_active and all work items in pwq-&gt;inactive_works are</span></span><br><span class="line"><span class="comment">	 * marked with WORK_STRUCT_INACTIVE.  But not all WORK_STRUCT_INACTIVE</span></span><br><span class="line"><span class="comment">	 * work items are in pwq-&gt;inactive_works.  Some of them are ready to</span></span><br><span class="line"><span class="comment">	 * run in pool-&gt;worklist or worker-&gt;scheduled.  Those work itmes are</span></span><br><span class="line"><span class="comment">	 * only struct wq_barrier which is used for flush_work() and should</span></span><br><span class="line"><span class="comment">	 * not participate in pwq-&gt;nr_active.  For non-barrier work item, it</span></span><br><span class="line"><span class="comment">	 * is marked with WORK_STRUCT_INACTIVE iff it is in pwq-&gt;inactive_works.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">int</span>			nr_active;	<span class="comment">/* L: nr of active works */</span></span><br><span class="line">	<span class="keyword">int</span>			max_active;	<span class="comment">/* L: max active works */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">inactive_works</span>;</span>	<span class="comment">/* L: inactive works */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">pwqs_node</span>;</span>	<span class="comment">/* WR: node on wq-&gt;pwqs */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">mayday_node</span>;</span>	<span class="comment">/* MD: node on wq-&gt;maydays */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Release of unbound pwq is punted to system_wq.  See put_pwq()</span></span><br><span class="line"><span class="comment">	 * and pwq_unbound_release_workfn() for details.  pool_workqueue</span></span><br><span class="line"><span class="comment">	 * itself is also RCU protected so that the first pwq can be</span></span><br><span class="line"><span class="comment">	 * determined without grabbing wq-&gt;mutex.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span>	<span class="title">unbound_release_work</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span>		<span class="title">rcu</span>;</span></span><br><span class="line">&#125; __aligned(<span class="number">1</span> &lt;&lt; WORK_STRUCT_FLAG_BITS);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>workqueue使用workqueue_struct结构体来实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The externally visible workqueue.  It relays the issued work items to</span></span><br><span class="line"><span class="comment"> * the appropriate worker_pool through its pool_workqueues.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">workqueue_struct</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">pwqs</span>;</span>		<span class="comment">/* WR: all pwqs of this wq */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">list</span>;</span>		<span class="comment">/* PR: list of all workqueues */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>		<span class="title">mutex</span>;</span>		<span class="comment">/* protects this wq */</span></span><br><span class="line">	<span class="keyword">int</span>			work_color;	<span class="comment">/* WQ: current work color */</span></span><br><span class="line">	<span class="keyword">int</span>			flush_color;	<span class="comment">/* WQ: current flush color */</span></span><br><span class="line">	<span class="keyword">atomic_t</span>		nr_pwqs_to_flush; <span class="comment">/* flush in progress */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">wq_flusher</span>	*<span class="title">first_flusher</span>;</span>	<span class="comment">/* WQ: first flusher */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">flusher_queue</span>;</span>	<span class="comment">/* WQ: flush waiters */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">flusher_overflow</span>;</span> <span class="comment">/* WQ: flush overflow list */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">maydays</span>;</span>	<span class="comment">/* MD: pwqs requesting rescue */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">worker</span>		*<span class="title">rescuer</span>;</span>	<span class="comment">/* MD: rescue worker */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span>			nr_drainers;	<span class="comment">/* WQ: drain in progress */</span></span><br><span class="line">	<span class="keyword">int</span>			saved_max_active; <span class="comment">/* WQ: saved pwq max_active */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">workqueue_attrs</span>	*<span class="title">unbound_attrs</span>;</span>	<span class="comment">/* PW: only for unbound wqs */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pool_workqueue</span>	*<span class="title">dfl_pwq</span>;</span>	<span class="comment">/* PW: only for unbound wqs */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SYSFS</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">wq_device</span>	*<span class="title">wq_dev</span>;</span>	<span class="comment">/* I: for sysfs interface */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_LOCKDEP</span></span><br><span class="line">	<span class="keyword">char</span>			*lock_name;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span>	<span class="title">key</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">lockdep_map</span>	<span class="title">lockdep_map</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">char</span>			name[WQ_NAME_LEN]; <span class="comment">/* I: workqueue name */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Destruction of workqueue_struct is RCU protected to allow walking</span></span><br><span class="line"><span class="comment">	 * the workqueues list without grabbing wq_pool_mutex.</span></span><br><span class="line"><span class="comment">	 * This is used to dump all workqueues from sysrq.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span>		<span class="title">rcu</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* hot fields used during command issue, aligned to cacheline */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		flags ____cacheline_aligned; <span class="comment">/* WQ: WQ_* flags */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pool_workqueue</span> __<span class="title">percpu</span> *<span class="title">cpu_pwqs</span>;</span> <span class="comment">/* I: per-cpu pwqs */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pool_workqueue</span> __<span class="title">rcu</span> *<span class="title">numa_pwq_tbl</span>[];</span> <span class="comment">/* PWR: unbound pwqs indexed by node */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>list: 系统中所有的workqueue会挂入到一个全局链表<code>static LIST_HEAD(workqueues);</code></li>
<li>cpu_pwqs：percpu workqueue指向percpu的pool_workqueue数据结构，用来维护workqueue和percpu thread pool之间的关系，每个CPU都有两个thread pool，normal和高优先级的线程池，cpu_pwqs指向哪一个pool_workqueue是和workqueue的flags相关的，如果标记有WQ_HIGHPRI，那么cpu_pwqs指向高优先级的线程池</li>
</ul>
<h3 id="woker-pool初始化"><a href="#woker-pool初始化" class="headerlink" title="woker pool初始化"></a>woker pool初始化</h3><p>CMWQ对worker pool分成了两类：</p>
<ul>
<li>percpu worker pool，给通用的workqueue使用，系统的规划是每个CPU创建两个worker pool，一个普通优先级(nice &#x3D; 0)，一个高优先级(nice &#x3D; HIGHPRI_NICE_LEVEL)，对应创建出来的worker线程nice值不一样</li>
<li>unbound woker pool，给WQ_UNBOUND类型的workqueue使用，unbound worker pool中的worer可以在多个CPU上调度，</li>
</ul>
<p>workqueue子系统的初始化分为两个阶段，<code>workqueue_init_early()</code>在<code>start_kernel()</code>中调用，在这个阶段主要是做一些基本的初始化工作，例如对percpu worker thread pool的一些基本初始化</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/workqueue.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里给定义了一个长度为2的worker_pool数组，即percpu worker pool</span></span><br><span class="line"><span class="comment">// 普通优先级的worker pool为worker_pool[0]</span></span><br><span class="line"><span class="comment">// 高优先级的worker pool为worker_pool[1]</span></span><br><span class="line"><span class="comment">/* the per-cpu worker pools */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">DEFINE_PER_CPU_SHARED_ALIGNED</span><span class="params">(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在workqueue_init_early()中会对percpu worker pool进行初始化工作</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * workqueue_init_early - early init for workqueue subsystem</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This is the first half of two-staged workqueue subsystem initialization</span></span><br><span class="line"><span class="comment"> * and invoked as soon as the bare basics - memory allocation, cpumasks and</span></span><br><span class="line"><span class="comment"> * idr are up.  It sets up all the data structures and system workqueues</span></span><br><span class="line"><span class="comment"> * and allows early boot code to create workqueues and queue/cancel work</span></span><br><span class="line"><span class="comment"> * items.  Actual work item execution starts only after kthreads can be</span></span><br><span class="line"><span class="comment"> * created and scheduled right before early initcalls.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> __init <span class="title">workqueue_init_early</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> std_nice[NR_STD_WORKER_POOLS] = &#123; <span class="number">0</span>, HIGHPRI_NICE_LEVEL &#125;;</span><br><span class="line">	<span class="keyword">int</span> i, cpu;</span><br><span class="line"></span><br><span class="line">	BUILD_BUG_ON(__alignof__(struct pool_workqueue) &lt; __alignof__(<span class="keyword">long</span> <span class="keyword">long</span>));</span><br><span class="line"></span><br><span class="line">	BUG_ON(!alloc_cpumask_var(&amp;wq_unbound_cpumask, GFP_KERNEL));</span><br><span class="line">	cpumask_copy(wq_unbound_cpumask, housekeeping_cpumask(HK_TYPE_WQ));</span><br><span class="line">	cpumask_and(wq_unbound_cpumask, wq_unbound_cpumask, housekeeping_cpumask(HK_TYPE_DOMAIN));</span><br><span class="line"></span><br><span class="line">	pwq_cache = KMEM_CACHE(pool_workqueue, SLAB_PANIC);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* initialize CPU pools */</span></span><br><span class="line">	for_each_possible_cpu(cpu) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">worker_pool</span> *<span class="title">pool</span>;</span></span><br><span class="line"></span><br><span class="line">		i = <span class="number">0</span>;</span><br><span class="line">		for_each_cpu_worker_pool(pool, cpu) &#123;</span><br><span class="line">			<span class="comment">// init_worker_pool()主要是对percpu worker_pool的成员进行初步初始化</span></span><br><span class="line">			BUG_ON(init_worker_pool(pool));</span><br><span class="line">			pool-&gt;cpu = cpu;</span><br><span class="line">			cpumask_copy(pool-&gt;attrs-&gt;cpumask, cpumask_of(cpu));</span><br><span class="line">			pool-&gt;attrs-&gt;nice = std_nice[i++];</span><br><span class="line">			pool-&gt;node = cpu_to_node(cpu);</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* alloc pool ID */</span></span><br><span class="line">			mutex_lock(&amp;wq_pool_mutex);</span><br><span class="line">			BUG_ON(worker_pool_assign_id(pool));</span><br><span class="line">			mutex_unlock(&amp;wq_pool_mutex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* create default unbound and ordered wq attrs */</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NR_STD_WORKER_POOLS; i++) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">workqueue_attrs</span> *<span class="title">attrs</span>;</span></span><br><span class="line"></span><br><span class="line">		BUG_ON(!(attrs = alloc_workqueue_attrs()));</span><br><span class="line">		<span class="comment">// 默认普通优先级worker pool的nice值为0</span></span><br><span class="line">		<span class="comment">// 高优先级的worker pool的nice值为-20</span></span><br><span class="line">		attrs-&gt;nice = std_nice[i];</span><br><span class="line">		unbound_std_wq_attrs[i] = attrs;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * An ordered wq should have only one pwq as ordering is</span></span><br><span class="line"><span class="comment">		 * guaranteed by max_active which is enforced by pwqs.</span></span><br><span class="line"><span class="comment">		 * Turn off NUMA so that dfl_pwq is used for all nodes.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		BUG_ON(!(attrs = alloc_workqueue_attrs()));</span><br><span class="line">		attrs-&gt;nice = std_nice[i];</span><br><span class="line">		attrs-&gt;no_numa = <span class="literal">true</span>;</span><br><span class="line">		ordered_wq_attrs[i] = attrs;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 系统创建了一些默认的workqueue以供使用</span></span><br><span class="line">	system_wq = alloc_workqueue(<span class="string">&quot;events&quot;</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	system_highpri_wq = alloc_workqueue(<span class="string">&quot;events_highpri&quot;</span>, WQ_HIGHPRI, <span class="number">0</span>);</span><br><span class="line">	system_long_wq = alloc_workqueue(<span class="string">&quot;events_long&quot;</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	system_unbound_wq = alloc_workqueue(<span class="string">&quot;events_unbound&quot;</span>, WQ_UNBOUND,</span><br><span class="line">					    WQ_UNBOUND_MAX_ACTIVE);</span><br><span class="line">	system_freezable_wq = alloc_workqueue(<span class="string">&quot;events_freezable&quot;</span>,</span><br><span class="line">					      WQ_FREEZABLE, <span class="number">0</span>);</span><br><span class="line">	system_power_efficient_wq = alloc_workqueue(<span class="string">&quot;events_power_efficient&quot;</span>,</span><br><span class="line">					      WQ_POWER_EFFICIENT, <span class="number">0</span>);</span><br><span class="line">	system_freezable_power_efficient_wq = alloc_workqueue(<span class="string">&quot;events_freezable_power_efficient&quot;</span>,</span><br><span class="line">					      WQ_FREEZABLE | WQ_POWER_EFFICIENT,</span><br><span class="line">					      <span class="number">0</span>);</span><br><span class="line">	BUG_ON(!system_wq || !system_highpri_wq || !system_long_wq ||</span><br><span class="line">	       !system_unbound_wq || !system_freezable_wq ||</span><br><span class="line">	       !system_power_efficient_wq ||</span><br><span class="line">	       !system_freezable_power_efficient_wq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>workqueue第二阶段的初始化，经过这一阶段的初始化，workqueue就能正常使用了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * workqueue_init - bring workqueue subsystem fully online</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This is the latter half of two-staged workqueue subsystem initialization</span></span><br><span class="line"><span class="comment"> * and invoked as soon as kthreads can be created and scheduled.</span></span><br><span class="line"><span class="comment"> * Workqueues have been created and work items queued on them, but there</span></span><br><span class="line"><span class="comment"> * are no kworkers executing the work items yet.  Populate the worker pools</span></span><br><span class="line"><span class="comment"> * with the initial workers and enable future kworker creations.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> __init <span class="title">workqueue_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">workqueue_struct</span> *<span class="title">wq</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">worker_pool</span> *<span class="title">pool</span>;</span></span><br><span class="line">	<span class="keyword">int</span> cpu, bkt;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * It&#x27;d be simpler to initialize NUMA in workqueue_init_early() but</span></span><br><span class="line"><span class="comment">	 * CPU to node mapping may not be available that early on some</span></span><br><span class="line"><span class="comment">	 * archs such as power and arm64.  As per-cpu pools created</span></span><br><span class="line"><span class="comment">	 * previously could be missing node hint and unbound pools NUMA</span></span><br><span class="line"><span class="comment">	 * affinity, fix them up.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Also, while iterating workqueues, create rescuers if requested.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	wq_numa_init();</span><br><span class="line"></span><br><span class="line">	mutex_lock(&amp;wq_pool_mutex);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 对于非NUMA架构的CPU这个node固定为0</span></span><br><span class="line">	for_each_possible_cpu(cpu) &#123;</span><br><span class="line">		for_each_cpu_worker_pool(pool, cpu) &#123;</span><br><span class="line">			pool-&gt;node = cpu_to_node(cpu);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	list_for_each_entry(wq, &amp;workqueues, <span class="built_in">list</span>) &#123;</span><br><span class="line">		wq_update_unbound_numa(wq, smp_processor_id(), <span class="literal">true</span>);</span><br><span class="line">		WARN(init_rescuer(wq),</span><br><span class="line">		     <span class="string">&quot;workqueue: failed to create early rescuer for %s&quot;</span>,</span><br><span class="line">		     wq-&gt;name);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	mutex_unlock(&amp;wq_pool_mutex);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* create the initial workers */</span></span><br><span class="line">	<span class="comment">// 针对percpu worker thread pool创建一个worker</span></span><br><span class="line">	for_each_online_cpu(cpu) &#123;</span><br><span class="line">		for_each_cpu_worker_pool(pool, cpu) &#123;</span><br><span class="line">			pool-&gt;flags &amp;= ~POOL_DISASSOCIATED;</span><br><span class="line">			BUG_ON(!create_worker(pool));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// unbound woker pool也需要创建一个worker</span></span><br><span class="line">	hash_for_each(unbound_pool_hash, bkt, pool, hash_node)</span><br><span class="line">		BUG_ON(!create_worker(pool));</span><br><span class="line"></span><br><span class="line">	wq_online = <span class="literal">true</span>;</span><br><span class="line">	wq_watchdog_init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来分析一下worker的创建过程</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * create_worker - create a new workqueue worker</span></span><br><span class="line"><span class="comment"> * @pool: pool the new worker will belong to</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Create and start a new worker which is attached to @pool.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * CONTEXT:</span></span><br><span class="line"><span class="comment"> * Might sleep.  Does GFP_KERNEL allocations.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return:</span></span><br><span class="line"><span class="comment"> * Pointer to the newly created worker.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct worker *<span class="title">create_worker</span><span class="params">(struct worker_pool *pool)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">worker</span> *<span class="title">worker</span>;</span></span><br><span class="line">	<span class="keyword">int</span> id;</span><br><span class="line">	<span class="keyword">char</span> id_buf[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* ID is needed to determine kthread name */</span></span><br><span class="line">	<span class="comment">// 这里用到了ida的分配机制</span></span><br><span class="line">	id = ida_alloc(&amp;pool-&gt;worker_ida, GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (id &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 为worker分配内存，进行一些成员的初始化</span></span><br><span class="line">	<span class="comment">// 这里分配内存使用到了kzalloc_node()实际也是为numa考虑的</span></span><br><span class="line">	worker = alloc_worker(pool-&gt;node);</span><br><span class="line">	<span class="keyword">if</span> (!worker)</span><br><span class="line">		<span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">	worker-&gt;id = id;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 线程名</span></span><br><span class="line">	<span class="keyword">if</span> (pool-&gt;cpu &gt;= <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">snprintf</span>(id_buf, <span class="keyword">sizeof</span>(id_buf), <span class="string">&quot;%d:%d%s&quot;</span>, pool-&gt;cpu, id,</span><br><span class="line">			 pool-&gt;attrs-&gt;nice &lt; <span class="number">0</span>  ? <span class="string">&quot;H&quot;</span> : <span class="string">&quot;&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">snprintf</span>(id_buf, <span class="keyword">sizeof</span>(id_buf), <span class="string">&quot;u%d:%d&quot;</span>, pool-&gt;id, id);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建线程，线程函数worker_thread</span></span><br><span class="line">	worker-&gt;task = kthread_create_on_node(worker_thread, worker, pool-&gt;node,</span><br><span class="line">					      <span class="string">&quot;kworker/%s&quot;</span>, id_buf);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(worker-&gt;task))</span><br><span class="line">		<span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">	set_user_nice(worker-&gt;task, pool-&gt;attrs-&gt;nice);</span><br><span class="line">	kthread_bind_mask(worker-&gt;task, pool-&gt;attrs-&gt;cpumask);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* successful, attach the worker to the pool */</span></span><br><span class="line">	<span class="comment">// 将worker挂到worker pool的workers链表下</span></span><br><span class="line">	worker_attach_to_pool(worker, pool);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* start the newly created worker */</span></span><br><span class="line">	raw_spin_lock_irq(&amp;pool-&gt;lock);</span><br><span class="line">	worker-&gt;pool-&gt;nr_workers++;</span><br><span class="line">	worker_enter_idle(worker);</span><br><span class="line">	wake_up_process(worker-&gt;task);</span><br><span class="line">	raw_spin_unlock_irq(&amp;pool-&gt;lock);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> worker;</span><br><span class="line"></span><br><span class="line">fail:</span><br><span class="line">	ida_free(&amp;pool-&gt;worker_ida, id);</span><br><span class="line">	kfree(worker);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于unbind workqueue的功耗节省：当workqueue收到一个要处理的work，如果该workqueue是unbound类型的话，那么该work由unbound thread pool处理并调度执行的策略交给系统的调度器模块来完成，对于scheduler而言，它会考虑CPU的idle状态，从而尽可能让CPU保持在idle状态，从而节省能耗。因此，如果一个workqueue有WQ_UNBOUND这样的flag，则说明该workqueue上挂入的work处理是考虑到power saving的。如果workqueue没有WQ_UNBOUND flag，则说明该workqueue是percpu的，这时候，调度哪一个CPU运行worker thread来处理work已经不是scheduler可以控制的了，这样，也就间接影响了功耗。</p>
<h3 id="workqueue创建过程"><a href="#workqueue创建过程" class="headerlink" title="workqueue创建过程"></a>workqueue创建过程</h3><p>workqueue的创建过程<code>alloc_workqueue()</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/workqueue.c</span></span><br><span class="line"><span class="function">struct workqueue_struct *<span class="title">alloc_workqueue</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *fmt,</span></span></span><br><span class="line"><span class="params"><span class="function">					 <span class="keyword">unsigned</span> <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">					 <span class="keyword">int</span> max_active, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">size_t</span> tbl_size = <span class="number">0</span>;</span><br><span class="line">	va_list args;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">workqueue_struct</span> *<span class="title">wq</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pool_workqueue</span> *<span class="title">pwq</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Unbound &amp;&amp; max_active == 1 used to imply ordered, which is no</span></span><br><span class="line"><span class="comment">	 * longer the case on NUMA machines due to per-node pools.  While</span></span><br><span class="line"><span class="comment">	 * alloc_ordered_workqueue() is the right way to create an ordered</span></span><br><span class="line"><span class="comment">	 * workqueue, keep the previous behavior to avoid subtle breakages</span></span><br><span class="line"><span class="comment">	 * on NUMA.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> ((flags &amp; WQ_UNBOUND) &amp;&amp; max_active == <span class="number">1</span>)</span><br><span class="line">		flags |= __WQ_ORDERED;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* see the comment above the definition of WQ_POWER_EFFICIENT */</span></span><br><span class="line">	<span class="comment">// 这里WQ_POWER_EFFICIENT标志和workqueue.power_efficient这个内核参数都可以让</span></span><br><span class="line">	<span class="comment">// workqueue编程unbind workqueue从而降低能耗</span></span><br><span class="line">	<span class="keyword">if</span> ((flags &amp; WQ_POWER_EFFICIENT) &amp;&amp; wq_power_efficient)</span><br><span class="line">		flags |= WQ_UNBOUND;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* allocate wq and format name */</span></span><br><span class="line">	<span class="comment">// 这里涉及到在NUMA中unbound workqueue的work thread在不同node之间迁移的问题</span></span><br><span class="line">	<span class="comment">// 在NUMA中，CPU访问不同node中的内存，访问速度是相差很大的</span></span><br><span class="line">	<span class="comment">// 实际上unbound workqueue实际上是创建了per node的pool_workqueue</span></span><br><span class="line">	<span class="keyword">if</span> (flags &amp; WQ_UNBOUND)</span><br><span class="line">		tbl_size = nr_node_ids * <span class="keyword">sizeof</span>(wq-&gt;numa_pwq_tbl[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">	wq = kzalloc(<span class="keyword">sizeof</span>(*wq) + tbl_size, GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!wq)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// unbound_attrs属性是给unbound workqueue来决定work的的分配的</span></span><br><span class="line">	<span class="keyword">if</span> (flags &amp; WQ_UNBOUND) &#123;</span><br><span class="line">		wq-&gt;unbound_attrs = alloc_workqueue_attrs();</span><br><span class="line">		<span class="keyword">if</span> (!wq-&gt;unbound_attrs)</span><br><span class="line">			<span class="keyword">goto</span> err_free_wq;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 这里是取max_active后面的参数用来给workqueue取名字</span></span><br><span class="line">	va_start(args, max_active);</span><br><span class="line">	vsnprintf(wq-&gt;name, <span class="keyword">sizeof</span>(wq-&gt;name), fmt, args);</span><br><span class="line">	va_end(args);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// max_active限制最大可以创建的worker thread的数目</span></span><br><span class="line">	<span class="comment">// 对于percpu workqueue最大可创建的worker thread是WQ_MAX_ACTIVE（512）</span></span><br><span class="line">	<span class="comment">// 对于unbound workqueue最大可创建的worker thread是CPU核心数的4倍WQ_UNBOUND_MAX_ACTIVE</span></span><br><span class="line">	max_active = max_active ?: WQ_DFL_ACTIVE;</span><br><span class="line">	max_active = wq_clamp_max_active(max_active, flags, wq-&gt;name);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* init wq */</span></span><br><span class="line">	<span class="comment">// 初始化workqueue的其他成员</span></span><br><span class="line">	wq-&gt;flags = flags;</span><br><span class="line">	wq-&gt;saved_max_active = max_active;</span><br><span class="line">	mutex_init(&amp;wq-&gt;mutex);</span><br><span class="line">	atomic_set(&amp;wq-&gt;nr_pwqs_to_flush, <span class="number">0</span>);</span><br><span class="line">	INIT_LIST_HEAD(&amp;wq-&gt;pwqs);</span><br><span class="line">	INIT_LIST_HEAD(&amp;wq-&gt;flusher_queue);</span><br><span class="line">	INIT_LIST_HEAD(&amp;wq-&gt;flusher_overflow);</span><br><span class="line">	INIT_LIST_HEAD(&amp;wq-&gt;maydays);</span><br><span class="line"></span><br><span class="line">	wq_init_lockdep(wq);</span><br><span class="line">	INIT_LIST_HEAD(&amp;wq-&gt;<span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (alloc_and_link_pwqs(wq) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> err_unreg_lockdep;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (wq_online &amp;&amp; init_rescuer(wq) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> err_destroy;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((wq-&gt;flags &amp; WQ_SYSFS) &amp;&amp; workqueue_sysfs_register(wq))</span><br><span class="line">		<span class="keyword">goto</span> err_destroy;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * wq_pool_mutex protects global freeze state and workqueues list.</span></span><br><span class="line"><span class="comment">	 * Grab it, adjust max_active and add the new @wq to workqueues</span></span><br><span class="line"><span class="comment">	 * list.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	mutex_lock(&amp;wq_pool_mutex);</span><br><span class="line"></span><br><span class="line">	mutex_lock(&amp;wq-&gt;mutex);</span><br><span class="line">	for_each_pwq(pwq, wq)</span><br><span class="line">		pwq_adjust_max_active(pwq);</span><br><span class="line">	mutex_unlock(&amp;wq-&gt;mutex);</span><br><span class="line"></span><br><span class="line">	list_add_tail_rcu(&amp;wq-&gt;<span class="built_in">list</span>, &amp;workqueues);</span><br><span class="line"></span><br><span class="line">	mutex_unlock(&amp;wq_pool_mutex);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> wq;</span><br><span class="line"></span><br><span class="line">err_unreg_lockdep:</span><br><span class="line">	wq_unregister_lockdep(wq);</span><br><span class="line">	wq_free_lockdep(wq);</span><br><span class="line">err_free_wq:</span><br><span class="line">	free_workqueue_attrs(wq-&gt;unbound_attrs);</span><br><span class="line">	kfree(wq);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">err_destroy:</span><br><span class="line">	destroy_workqueue(wq);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(alloc_workqueue);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 分配pool workqueue的内存，建立workqueue和pool workqueue的关系</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">alloc_and_link_pwqs</span><span class="params">(struct workqueue_struct *wq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">bool</span> highpri = wq-&gt;flags &amp; WQ_HIGHPRI;</span><br><span class="line">	<span class="keyword">int</span> cpu, ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// percpu workqueue的处理</span></span><br><span class="line">	<span class="keyword">if</span> (!(wq-&gt;flags &amp; WQ_UNBOUND)) &#123;</span><br><span class="line">		<span class="comment">// 为percpu workqueue分配一个pool_workqueue(用来连接worker pool和workqueue)</span></span><br><span class="line">		wq-&gt;cpu_pwqs = alloc_percpu(struct pool_workqueue);</span><br><span class="line">		<span class="keyword">if</span> (!wq-&gt;cpu_pwqs)</span><br><span class="line">			<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">		for_each_possible_cpu(cpu) &#123;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">pool_workqueue</span> *<span class="title">pwq</span> =</span></span><br><span class="line">				per_cpu_ptr(wq-&gt;cpu_pwqs, cpu);</span><br><span class="line">			<span class="comment">// 每个pool_workqueue都有一个对应的worker thread pool</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">worker_pool</span> *<span class="title">cpu_pools</span> =</span></span><br><span class="line">				per_cpu(cpu_worker_pools, cpu);</span><br><span class="line">			<span class="comment">// 初始化pool_workqueue</span></span><br><span class="line">			<span class="comment">// 最重要的是设置其对应的workqueue和woker_pool</span></span><br><span class="line">			<span class="comment">// 在这里pool_workqueue和woker pool，workqueue关联上了</span></span><br><span class="line">			init_pwq(pwq, wq, &amp;cpu_pools[highpri]);</span><br><span class="line"></span><br><span class="line">			mutex_lock(&amp;wq-&gt;mutex);</span><br><span class="line">			<span class="comment">// link_pwq主要是将pool_workqueue挂入它所属的workqueue链表中</span></span><br><span class="line">			link_pwq(pwq);</span><br><span class="line">			mutex_unlock(&amp;wq-&gt;mutex);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cpus_read_lock();</span><br><span class="line">	<span class="keyword">if</span> (wq-&gt;flags &amp; __WQ_ORDERED) &#123;</span><br><span class="line">		ret = apply_workqueue_attrs(wq, ordered_wq_attrs[highpri]);</span><br><span class="line">		<span class="comment">/* there should only be single pwq for ordering guarantee */</span></span><br><span class="line">		WARN(!ret &amp;&amp; (wq-&gt;pwqs.next != &amp;wq-&gt;dfl_pwq-&gt;pwqs_node ||</span><br><span class="line">			      wq-&gt;pwqs.prev != &amp;wq-&gt;dfl_pwq-&gt;pwqs_node),</span><br><span class="line">		     <span class="string">&quot;ordering guarantee broken for workqueue %s\n&quot;</span>, wq-&gt;name);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		ret = apply_workqueue_attrs(wq, unbound_std_wq_attrs[highpri]);</span><br><span class="line">	&#125;</span><br><span class="line">	cpus_read_unlock();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每个pool_workqueue都有一个对应的worker thread pool</span></span><br><span class="line"><span class="comment">// 对于percpu workqueue这里静态定义了如下的cpu_worker_pools</span></span><br><span class="line"><span class="comment">/* the per-cpu worker pools */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">DEFINE_PER_CPU_SHARED_ALIGNED</span><span class="params">(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="workqueue-API函数"><a href="#workqueue-API函数" class="headerlink" title="workqueue API函数"></a>workqueue API函数</h3><ol>
<li><code>bool flush_work(struct work_struct *work)</code><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/workqueue.c</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">wq_barrier</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span>	<span class="title">work</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">completion</span>	<span class="title">done</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>	*<span class="title">task</span>;</span>	<span class="comment">/* purely informational */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * flush_work - wait for a work to finish executing the last queueing instance</span></span><br><span class="line"><span class="comment"> * @work: the work to flush</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Wait until @work has finished execution.  @work is guaranteed to be idle</span></span><br><span class="line"><span class="comment"> * on return if it hasn&#x27;t been requeued since flush started.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return:</span></span><br><span class="line"><span class="comment"> * %true if flush_work() waited for the work to finish execution,</span></span><br><span class="line"><span class="comment"> * %false if it was already idle.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">flush_work</span><span class="params">(struct work_struct *work)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> __flush_work(work, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(flush_work);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">bool</span> __flush_work(struct work_struct *work, <span class="keyword">bool</span> from_cancel)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">wq_barrier</span> <span class="title">barr</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (WARN_ON(!wq_online))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (WARN_ON(!work-&gt;func))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	lock_map_acquire(&amp;work-&gt;lockdep_map);</span><br><span class="line">	lock_map_release(&amp;work-&gt;lockdep_map);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (start_flush_work(work, &amp;barr, from_cancel)) &#123;</span><br><span class="line">		wait_for_completion(&amp;barr.done);</span><br><span class="line">		destroy_work_on_stack(&amp;barr.work);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">start_flush_work</span><span class="params">(struct work_struct *work, struct wq_barrier *barr,</span></span></span><br><span class="line"><span class="params"><span class="function">			     <span class="keyword">bool</span> from_cancel)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">worker</span> *<span class="title">worker</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">worker_pool</span> *<span class="title">pool</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pool_workqueue</span> *<span class="title">pwq</span>;</span></span><br><span class="line"></span><br><span class="line">	might_sleep();</span><br><span class="line"></span><br><span class="line">	rcu_read_lock();</span><br><span class="line">	pool = get_work_pool(work);</span><br><span class="line">	<span class="keyword">if</span> (!pool) &#123;</span><br><span class="line">		rcu_read_unlock();</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	raw_spin_lock_irq(&amp;pool-&gt;lock);</span><br><span class="line">	<span class="comment">/* see the comment in try_to_grab_pending() with the same code */</span></span><br><span class="line">	pwq = get_work_pwq(work);</span><br><span class="line">	<span class="keyword">if</span> (pwq) &#123;</span><br><span class="line">		<span class="keyword">if</span> (unlikely(pwq-&gt;pool != pool))</span><br><span class="line">			<span class="keyword">goto</span> already_gone;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		worker = find_worker_executing_work(pool, work);</span><br><span class="line">		<span class="keyword">if</span> (!worker)</span><br><span class="line">			<span class="keyword">goto</span> already_gone;</span><br><span class="line">		pwq = worker-&gt;current_pwq;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	check_flush_dependency(pwq-&gt;wq, work);</span><br><span class="line"></span><br><span class="line">	insert_wq_barrier(pwq, barr, work, worker);</span><br><span class="line">	raw_spin_unlock_irq(&amp;pool-&gt;lock);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Force a lock recursion deadlock when using flush_work() inside a</span></span><br><span class="line"><span class="comment">	 * single-threaded or rescuer equipped workqueue.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * For single threaded workqueues the deadlock happens when the work</span></span><br><span class="line"><span class="comment">	 * is after the work issuing the flush_work(). For rescuer equipped</span></span><br><span class="line"><span class="comment">	 * workqueues the deadlock happens when the rescuer stalls, blocking</span></span><br><span class="line"><span class="comment">	 * forward progress.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!from_cancel &amp;&amp;</span><br><span class="line">	    (pwq-&gt;wq-&gt;saved_max_active == <span class="number">1</span> || pwq-&gt;wq-&gt;rescuer)) &#123;</span><br><span class="line">		lock_map_acquire(&amp;pwq-&gt;wq-&gt;lockdep_map);</span><br><span class="line">		lock_map_release(&amp;pwq-&gt;wq-&gt;lockdep_map);</span><br><span class="line">	&#125;</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">already_gone:</span><br><span class="line">	raw_spin_unlock_irq(&amp;pool-&gt;lock);</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p>变参函数宏</p>
<ul>
<li>va_list：定义在编译器的头文件中</li>
<li>va_start(args, fmt)：根据参数fmt的地址，获取fmt后面的参数地址，并保存在args指针变量中</li>
<li>va_end(args)：释放args指针，将其值赋为NULL</li>
</ul>
</blockquote>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://docs.kernel.org/translations/zh_CN/core-api/workqueue.html">https://docs.kernel.org/translations/zh_CN&#x2F;core-api&#x2F;workqueue.html</a></li>
<li></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>workqueue</tag>
      </tags>
  </entry>
  <entry>
    <title>git ssh代理设置</title>
    <url>/archives/da6c5b0b.html</url>
    <content><![CDATA[<p>最近发现在开启了代理后，使用git push, git fetch时还是偶尔会等待很久，有时候急需上传和拉取代码时卡住很是头痛</p>
<span id="more"></span>

<p>我一般使用ssh协议连接远程仓库，在ssh config（~&#x2F;.ssh&#x2F;config）中为github.com设置代理后问题解决了，记录一下</p>
<p>在<code>~/.ssh/config</code>中增加下面的内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">	HostName github.com</span><br><span class="line">	User git</span><br><span class="line">	ProxyCommand nc -v -x 127.0.0.1:1089 %h %p</span><br><span class="line"><span class="comment"># 根据代理的端口修改127.0.0.1:1089</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>ssh</tag>
        <tag>git</tag>
        <tag>proxy</tag>
      </tags>
  </entry>
</search>
