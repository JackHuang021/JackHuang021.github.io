<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>从零开始搭建Hexo博客</title>
    <url>/archives/39fb7b7f.html</url>
    <content><![CDATA[<h2 id="Hexo简介"><a href="#Hexo简介" class="headerlink" title="Hexo简介"></a>Hexo简介</h2><p>引用官网的介绍：A fast, simple &amp; powerful blog framework<br>Hexo是一款基于Node.js的静态博客框架，依赖少易于安装使用，可以方便的生成静态网页托管在GitHub上，是搭建博客的首选框架。</p>
<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>基于Ubuntu20.04安装Hexo配置Next主题</p>
<span id="more"></span>

<h3 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h3><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">sudo apt-<span class="builtin-name">get</span> install git</span><br></pre></td></tr></table></figure>
<p>安装完成后进行配置</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">config</span> --<span class="keyword">global</span> user<span class="variable">.email</span> <span class="string">&quot;you@example.com&quot;</span></span><br><span class="line">git <span class="keyword">config</span> --<span class="keyword">global</span> user<span class="variable">.name</span> <span class="string">&quot;Your Name&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h3><p>使用NVM（Node Version Manager）方式进行安装</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">curl -o- https:<span class="regexp">//</span>raw.githubusercontent.com<span class="regexp">/nvm-sh/</span>nvm<span class="regexp">/v0.35.2/i</span>nstall.sh | bash</span><br></pre></td></tr></table></figure>
<p>安装完成后关闭终端重新打开</p>
<h3 id="安装最新版本node"><a href="#安装最新版本node" class="headerlink" title="安装最新版本node"></a>安装最新版本node</h3><p>安装过程中可能会因为网络问题失败，可以尝试挂梯子,安装完成后更新自带npm</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">nvm install <span class="keyword">node</span></span><br><span class="line"><span class="title">npm</span> install npm -g</span><br></pre></td></tr></table></figure>

<h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><p>安装过程中可能会因为网络问题失败，可以多重试几次或挂梯子</p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-<span class="keyword">cli</span></span><br></pre></td></tr></table></figure>

<h3 id="安装Next主题"><a href="#安装Next主题" class="headerlink" title="安装Next主题"></a>安装Next主题</h3><p>Next主题是Hexo比较知名的第三方主题，极简风格，有相当多的使用者，维护也做得比较好<br>不过Next新旧版本的仓库地址不一样，目前最新的GitHub地址<a href="https://github.com/next-theme/hexo-theme-next.git">hexo-theme-next</a><br>Next主题安装比较简单，直接从仓库clone然后修改Hexo配置文件</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">cd blog</span><br><span class="line">git clone https:<span class="regexp">//gi</span>thub.com<span class="regexp">/next-theme/</span>hexo-theme-<span class="keyword">next</span> themes/<span class="keyword">next</span></span><br></pre></td></tr></table></figure>
<p>修改Hexo配置文件<code>_config.yml</code>，将站点主题改为Next，修改如下</p>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line"># Extensions</span><br><span class="line">## Plugins: https:<span class="comment">//hexo.io/plugins/</span></span><br><span class="line">## Themes: https:<span class="comment">//hexo.io/themes/</span></span><br><span class="line">theme: next</span><br></pre></td></tr></table></figure>

<p>全部安装完成后的版本信息如下</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">jack@linux:~/blog/source/_posts$ hexo -v</span></span><br><span class="line">INFO  Validating config</span><br><span class="line">INFO  ==================================</span><br><span class="line">  ███╗   ██╗███████╗██╗  ██╗████████╗</span><br><span class="line">  ████╗  ██║██╔════╝╚██╗██╔╝╚══██╔══╝</span><br><span class="line">  ██╔██╗ ██║█████╗   ╚███╔╝    ██║</span><br><span class="line">  ██║╚██╗██║██╔══╝   ██╔██╗    ██║</span><br><span class="line">  ██║ ╚████║███████╗██╔╝ ██╗   ██║</span><br><span class="line">  ╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝   ╚═╝</span><br><span class="line">========================================</span><br><span class="line">NexT version 8.11.1</span><br><span class="line"><span class="section">Documentation: https://theme-next.js.org</span></span><br><span class="line">========================================</span><br><span class="line"><span class="section">hexo: 5.4.2</span></span><br><span class="line"><span class="section">hexo-cli: 4.3.0</span></span><br><span class="line"><span class="section">os: linux 5.13.0-40-generic Ubuntu 20.04.4 LTS (Focal Fossa)</span></span><br><span class="line"><span class="section">node: 18.2.0</span></span><br><span class="line"><span class="section">v8: 10.1.124.8-node.13</span></span><br><span class="line"><span class="section">uv: 1.43.0</span></span><br><span class="line"><span class="section">zlib: 1.2.11</span></span><br><span class="line"><span class="section">brotli: 1.0.9</span></span><br><span class="line"><span class="section">ares: 1.18.1</span></span><br><span class="line"><span class="section">modules: 108</span></span><br><span class="line"><span class="section">nghttp2: 1.47.0</span></span><br><span class="line"><span class="section">napi: 8</span></span><br><span class="line"><span class="section">llhttp: 6.0.6</span></span><br><span class="line"><span class="section">openssl: 3.0.3+quic</span></span><br><span class="line"><span class="section">cldr: 41.0</span></span><br><span class="line"><span class="section">icu: 71.1</span></span><br><span class="line"><span class="section">tz: 2022a</span></span><br><span class="line"><span class="section">unicode: 14.0</span></span><br><span class="line"><span class="section">ngtcp2: 0.1.0-DEV</span></span><br><span class="line"><span class="section">nghttp3: 0.1.0-DEV</span></span><br></pre></td></tr></table></figure>

<h3 id="初步运行Hexo进行验证"><a href="#初步运行Hexo进行验证" class="headerlink" title="初步运行Hexo进行验证"></a>初步运行Hexo进行验证</h3><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">hexo init <span class="keyword">blog</span></span><br><span class="line"><span class="keyword"></span>cd <span class="keyword">blog</span></span><br><span class="line"><span class="keyword"></span>npm <span class="keyword">install</span></span><br><span class="line"><span class="keyword"></span>hexo server</span><br></pre></td></tr></table></figure>
<p>运行之后可以通过 <a href="http://localhost:4000/">http://localhost:4000</a> 进行访问</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">INFO  Validating config</span><br><span class="line">INFO  ==================================</span><br><span class="line"><span class="code">  ███╗   ██╗███████╗██╗  ██╗████████╗</span></span><br><span class="line"><span class="code">  ████╗  ██║██╔════╝╚██╗██╔╝╚══██╔══╝</span></span><br><span class="line"><span class="code">  ██╔██╗ ██║█████╗   ╚███╔╝    ██║</span></span><br><span class="line"><span class="code">  ██║╚██╗██║██╔══╝   ██╔██╗    ██║</span></span><br><span class="line"><span class="code">  ██║ ╚████║███████╗██╔╝ ██╗   ██║</span></span><br><span class="line"><span class="section">  ╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝   ╚═╝</span></span><br><span class="line"><span class="section">========================================</span></span><br><span class="line">NexT version 8.11.1</span><br><span class="line"><span class="section">Documentation: https://theme-next.js.org</span></span><br><span class="line"><span class="section">========================================</span></span><br><span class="line">INFO  Start processing</span><br><span class="line">INFO  Hexo is running at http://localhost:4000 . Press Ctrl+C to stop.</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/imageshexo_next_theme.png"></p>
<h3 id="部署GitHub远程服务器"><a href="#部署GitHub远程服务器" class="headerlink" title="部署GitHub远程服务器"></a>部署GitHub远程服务器</h3><h4 id="创建GitHub项目"><a href="#创建GitHub项目" class="headerlink" title="创建GitHub项目"></a>创建GitHub项目</h4><p>在GitHub上注册账号，注册后上传ssh公钥，便于后续的部署操作<br>创建一个与你用户名对应的项目<code>username.github.io</code>，例如我创建的项目地址为<code>https://github.com/JackHuang021/JackHuang021.github.io.git</code>  </p>
<h4 id="进行部署"><a href="#进行部署" class="headerlink" title="进行部署"></a>进行部署</h4><p>部署需要用到<code>hexo deploy</code>上传到GitHub仓库，这里需要下载部署插件，并修改hexo配置文件<code>_config.yml</code>，<br>我们很多的博客设置都可以在这个配置文件里面进行修改<br>首先安装Git部署插件</p>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cd</span> ~<span class="string">/blog</span></span><br><span class="line">npm install hex-deployer-git <span class="params">--save</span></span><br></pre></td></tr></table></figure>
<p>修改博客配置文件<code>_config.yml</code>，增加如下内容</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="meta"># Deployment</span></span><br><span class="line"><span class="meta">## Docs: https:<span class="comment">//hexo.io/docs/one-command-deployment</span></span></span><br><span class="line"><span class="symbol">deploy:</span></span><br><span class="line"><span class="symbol">  type:</span> git</span><br><span class="line"><span class="symbol">  repo:</span> git@github.com:JackHuang021/JackHuang021.github.io.git</span><br><span class="line"><span class="symbol">  branch:</span> master</span><br></pre></td></tr></table></figure>
<p>最后使用<code>hexo d</code>进行上传部署，现在访问<code>username.github.io</code>便可以看到博客页面了<br>后续更新博客设置或者文章的话需要再次进行上传部署<code>hexo g -d</code></p>
<h3 id="Hexo博客备份"><a href="#Hexo博客备份" class="headerlink" title="Hexo博客备份"></a>Hexo博客备份</h3><p>Hexo在进行部署时，是将页面内容解析后放在<code>.depoly_git</code>中进行上传GitHub仓库，博客内文章源文件并未进行上传，所以还需要手动将这些文件进行手动上传。目前比较常用的方法是在原GitHub仓库建立一条分支，将这些文件上传到该分支。</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cd</span> blog </span><br><span class="line">git init </span><br><span class="line">git submodule <span class="built_in">add</span> http<span class="variable">s:</span>//github.<span class="keyword">com</span>/<span class="keyword">next</span>-theme/hexo-theme-<span class="keyword">next</span>.git themes/<span class="keyword">next</span></span><br><span class="line">git <span class="built_in">add</span> .</span><br><span class="line">git commit -<span class="keyword">m</span> <span class="string">&quot;init blog backup&quot;</span></span><br><span class="line">git branch -<span class="keyword">m</span> master hexo</span><br><span class="line">git remote <span class="built_in">add</span> origin git@github.<span class="keyword">com</span>:JackHuang021/JackHuang021.github.io.git</span><br><span class="line">git push -<span class="keyword">u</span> origin hexo</span><br></pre></td></tr></table></figure>

<h3 id="恢复Hexo博客"><a href="#恢复Hexo博客" class="headerlink" title="恢复Hexo博客"></a>恢复Hexo博客</h3><ol>
<li>按照之前的步骤搭建Hexo环境</li>
<li>clone之前备份的hexo分支内容<code>git clone --recursive -b hexo git@github.com:JackHuang021/JackHuang021.github.io.git blog</code></li>
<li>下载npm依赖模块<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> blog</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure></li>
<li>clone master分支内容<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">cd blog</span><br><span class="line">git clone git@github<span class="selector-class">.com</span>:JackHuang021/JackHuang021<span class="selector-class">.github</span><span class="selector-class">.io</span><span class="selector-class">.git</span> <span class="selector-class">.deploy_git</span> </span><br></pre></td></tr></table></figure></li>
<li>正常更新、部署博客<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">hexo g</span></span><br><span class="line"><span class="attribute">hexo s</span></span><br><span class="line"><span class="attribute">hexo d</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="关于Hexo使用的思考"><a href="#关于Hexo使用的思考" class="headerlink" title="关于Hexo使用的思考"></a>关于Hexo使用的思考</h3><p>我觉得Hexo最大的特点就是便捷，借助GitHub可以在多台设备中无缝切换进行博客写作，服务器的维护工作基本不需要作者进行，换设备后直接搭建hexo环境，从GitHub拉取博客内容即可。</p>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
        <tag>博客搭建</tag>
        <tag>博客备份恢复</tag>
      </tags>
  </entry>
  <entry>
    <title>ssh使用密钥实现免密登录</title>
    <url>/archives/37d9659b.html</url>
    <content><![CDATA[<h3 id="本地ssh客户端准备ssh密钥"><a href="#本地ssh客户端准备ssh密钥" class="headerlink" title="本地ssh客户端准备ssh密钥"></a>本地ssh客户端准备ssh密钥</h3><p>ssh密钥默认保存路径<code>~/.ssh</code>，进入该目录查看是否已存在生成的密钥</p>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ls</span> -al ~<span class="string">/.ssh</span></span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220601093641.png"></p>
<span id="more"></span>
<p>如上图，<code>id_rsa.pub</code>和<code>qtc_id.pub</code>都是公钥<br>如果没有公钥，可以使用<code>ssh-keygen</code>生成</p>
<h3 id="上传ssh公钥到ssh服务器"><a href="#上传ssh公钥到ssh服务器" class="headerlink" title="上传ssh公钥到ssh服务器"></a>上传ssh公钥到ssh服务器</h3><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">ssh-<span class="keyword">copy</span>-id -i ~<span class="regexp">/.ssh/i</span>d_rsa.pub username@ip_address</span><br></pre></td></tr></table></figure>
<p>执行后会提示输入服务器用户密码</p>
<h3 id="测试ssh免密登录"><a href="#测试ssh免密登录" class="headerlink" title="测试ssh免密登录"></a>测试ssh免密登录</h3><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">ssh <span class="symbol">username@</span>ip_address</span><br></pre></td></tr></table></figure>
<p>如果可以直接登录，说明已经配置成功<br>都2022年了，不要在输入密码上再浪费更多时间了</p>
<h3 id="删除免密登录"><a href="#删除免密登录" class="headerlink" title="删除免密登录"></a>删除免密登录</h3><p>上传公钥后，服务端<code>.ssh/authorized_keys</code>文件中会添加一行内容，就是本地客户端的公钥，编辑该文件删除改行，即可禁用客户端免密登录<br><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220601094901.png"></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title>imx6ull OpenCV4.5 交叉编译</title>
    <url>/archives/e4359116.html</url>
    <content><![CDATA[<h4 id="交叉编译环境"><a href="#交叉编译环境" class="headerlink" title="交叉编译环境"></a>交叉编译环境</h4><ul>
<li>Ubuntu版本：Ubuntu20.04 64bits</li>
<li>交叉编译工具：arm-linux-gnueabihf-</li>
<li>硬件平台正点原子IMX6ULL (ALPHA)</li>
</ul>
<span id="more"></span>

<h4 id="准备源码和交叉编译工具链"><a href="#准备源码和交叉编译工具链" class="headerlink" title="准备源码和交叉编译工具链"></a>准备源码和交叉编译工具链</h4><p>Linux环境下的编译方法可以参考<a href="https://docs.opencv.org/4.x/d7/d9f/tutorial_linux_install.html">Opencv安装官网教程</a></p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">wget -O opencv.zip https:<span class="regexp">//gi</span>thub.com<span class="regexp">/opencv/</span>opencv<span class="regexp">/archive/</span><span class="number">4</span>.x.zip</span><br><span class="line">unzip opencv.zip</span><br></pre></td></tr></table></figure>
<p>交叉编译工具链版本<br><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220602095241.png"></p>
<h4 id="安装cmake和cmake-gui工具"><a href="#安装cmake和cmake-gui工具" class="headerlink" title="安装cmake和cmake-gui工具"></a>安装cmake和cmake-gui工具</h4><p>在命令行使用cmake工具确实很不方便，cmake-gui配置起来比较省时间<br><code>sudo apt-get install cmake cmake-qt-gui  cmake-curses-gui</code>  </p>
<h4 id="配置交叉编译环境"><a href="#配置交叉编译环境" class="headerlink" title="配置交叉编译环境"></a>配置交叉编译环境</h4><ol>
<li>运行cmake-gui<br><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220602100408.png">  </li>
<li>在第一个框输入OpenCV源码路径，在第二个框输入OpenCV编译目录  </li>
<li>点击<code>Configure</code>配置交叉编译环境<br><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220602100750.png"></li>
<li>选择<code>Spcify options for cross-compile</code>  </li>
<li>按照下图设置交叉编译工具链<br><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220602101028.png"></li>
<li>点击<code>Finish</code>回到cmake-gui主页面，勾选Advanced<br><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220602101237.png"></li>
</ol>
<h4 id="配置cmake选项"><a href="#配置cmake选项" class="headerlink" title="配置cmake选项"></a>配置cmake选项</h4><ol>
<li>在CMAKE_EXE_LINKER_FLAGS处添加上<code>-lpthread -lrt -ldl</code><br><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220602101546.png"></li>
<li>在CMAKE_INSTALL_PREFIX处指定安装目录，如果不指定，它会默认安装到Ubuntu系统目录<code>/usr/local</code>下。  </li>
<li>取消<code>BUILD_opencv_gapi</code>选项，不取消这个选项后续编译的时候会报错</li>
<li>再依次点击<code>Configure</code>， <code>Generate</code>，击了Generate后看到信息像如下图一样，表明生成成功，一般按照上面配置后基本都不会报错。<br><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220602102258.png"></li>
</ol>
<h4 id="编译OpenCV"><a href="#编译OpenCV" class="headerlink" title="编译OpenCV"></a>编译OpenCV</h4><ol>
<li>打开之前设置的imx6编译目录，该目录下有刚才生成的Makefile  </li>
<li>输入<code>make -j12</code>开始编译</li>
<li>编译完成后输入<code>make install</code>，OpenCV的库和头文件会安装到之前设置的<code>CMAKE_INSTALL_PREFIX</code>目录</li>
</ol>
<h4 id="编译过程中遇到的错误"><a href="#编译过程中遇到的错误" class="headerlink" title="编译过程中遇到的错误"></a>编译过程中遇到的错误</h4><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">/home/</span>tanyd<span class="regexp">/zdyz/</span>linaro494<span class="regexp">/arm-linux-gnueabihf/</span>libc<span class="regexp">/usr/i</span>nclude/features.h:<span class="number">311</span>:<span class="number">52</span>: error: operator <span class="string">&#x27;&amp;&amp;&#x27;</span> has no right operand <span class="comment">#if defined _FILE_OFFSET_BITS &amp;&amp; _FILE_OFFSET_BITS == 64</span></span><br></pre></td></tr></table></figure>
<p>解决方法： 在<code>#if defined</code>前面加上 <code>#define _FILE_OFFSET_BITS 64</code>  </p>
<h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><ol>
<li><a href="https://blog.csdn.net/qq_26943851/article/details/104434130">正点原子IMX6ULL移植OpenCV3.4.1</a></li>
<li><a href="https://blog.csdn.net/u011827554/article/details/123657141">imx6ull编译opencv4.4问题整理</a></li>
</ol>
]]></content>
      <categories>
        <category>OpenCV</category>
      </categories>
      <tags>
        <tag>imx6ull OpenCV 交叉编译</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu安装搜狗输入法的问题记录</title>
    <url>/archives/245a6c83.html</url>
    <content><![CDATA[<ul>
<li>最近在帮一个客户安装搜狗输入法时遇到了安装后无候选框的问题，记录一下该问题的解决办法，今天进入官网查看，官网已经修改安装指南，建议按照官网指南安装，本文截图来自搜狗官网</li>
</ul>
<h4 id="Ubuntu搜狗输入法下载"><a href="#Ubuntu搜狗输入法下载" class="headerlink" title="Ubuntu搜狗输入法下载"></a>Ubuntu搜狗输入法下载</h4><ul>
<li><a href="https://pinyin.sogou.com/linux?r=pinyin">搜狗输入法Linux版官网</a>，目前最新版本为V4.0.1</li>
<li><a href="https://pinyin.sogou.com/linux/guide">搜狗输入法Linux版安装指南</a></li>
</ul>
<span id="more"></span>

<h4 id="Ubuntu20-04安装步骤"><a href="#Ubuntu20-04安装步骤" class="headerlink" title="Ubuntu20.04安装步骤"></a>Ubuntu20.04安装步骤</h4><ol>
<li>添加中文语言支持，打开 系统设置——区域和语言——管理已安装的语言——在“语言”tab下——点击“添加或删除语言”<br><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220606092214.png"></li>
<li>弹出“已安装语言”窗口，勾选中文（简体），点击应用<br><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220606092221.png"></li>
<li>安装fcitx输入法框架<code>sudo apt-get install fcitx</code></li>
<li>卸载系统ibus输入法框架<code>sudo apt purge ibus</code></li>
<li>回到“语言支持”窗口，在键盘输入法系统中，选择<code>fcitx</code><br><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220606092226.png"></li>
<li>通过命令行安装搜狗输入法<code>sudo dpkg -i sogoupinyin_版本号_amd64.deb</code>，如果安装过程中提示缺少相关依赖，则执行如下命令解决：<code>sudo apt -f install</code></li>
<li>安装输入法依赖<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">sudo</span> apt install libqt<span class="number">5</span>qml<span class="number">5</span> libqt<span class="number">5</span>quick<span class="number">5</span> libqt<span class="number">5</span>quickwidgets<span class="number">5</span> qml-module-qtquick<span class="number">2</span></span><br><span class="line"><span class="attribute">sudo</span> apt install libgsettings-qt<span class="number">1</span></span><br></pre></td></tr></table></figure></li>
<li>点击“应用到整个系统”，关闭窗口，重启电脑</li>
<li>查看状态栏右上角，可以看到“搜狗”字样，在输入窗口即可使用搜狗输入法。没有“搜狗”字样，选择配置，将搜狗加入输入法列表即可。<br><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220606094224.png"><br><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220606094237.png"><br><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220606094048.png"></li>
</ol>
<h4 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h4><ul>
<li>安装完成后输入候选框不出现，只能输入英文</li>
<li>解决办法，安装qt依赖库可以解决<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">sudo</span> apt install libqt<span class="number">5</span>qml<span class="number">5</span> libqt<span class="number">5</span>quick<span class="number">5</span> libqt<span class="number">5</span>quickwidgets<span class="number">5</span> qml-module-qtquick<span class="number">2</span></span><br><span class="line"><span class="attribute">sudo</span> apt install libgsettings-qt<span class="number">1</span></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>搜狗输入法</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCV图像容器Mat</title>
    <url>/archives/d2c86892.html</url>
    <content><![CDATA[<h4 id="图像的存储"><a href="#图像的存储" class="headerlink" title="图像的存储"></a>图像的存储</h4><p><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220608085010.png"><br>借助官方这张很有代表性的图片，在计算机中以像素值的方式存储图像中的每个像素点，所有像素值以类似矩阵的二维数组形式进行存储。官网给OpenCV的定义：OpenCV是一个计算机视觉库，主要的目的就是在这些像素值上进行处理、计算，所以首先就需要学习OpenCV是怎么存储、处理这些图像的。</p>
<span id="more"></span>

<h4 id="Mat介绍"><a href="#Mat介绍" class="headerlink" title="Mat介绍"></a>Mat介绍</h4><ul>
<li>OpenCV起始于2001年，最开始是基于C语言编写，图像存储在C结构体<code>IplImage</code>。</li>
<li>OpenCV2.0基于C++进行重写，图像以Mat类进行存储。</li>
<li>Mat类包含两部分数据：  <ol>
<li>图像数据头部分，包含图像尺寸、存储方式、图像数据指针等信息</li>
<li>图像数据部分</li>
</ol>
</li>
<li>每个Mat对象都独立的保存数据头部分，但是可能共享图像数据部分。</li>
<li>Mat的拷贝构造只会拷贝数据头部分，数据部分不会进行拷贝。  <figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">Mat A, C;                          <span class="comment">// creates just the header parts</span></span><br><span class="line">A = imread<span class="comment">(argv[1], IMREAD_COLOR)</span>; <span class="comment">// here we&#x27;ll know the method used (allocate matrix)</span></span><br><span class="line">Mat B<span class="comment">(A)</span>;                          <span class="comment">// Use the copy constructor</span></span><br><span class="line">C = A;                             <span class="comment">// Assignment operator</span></span><br></pre></td></tr></table></figure></li>
<li>Mat类有一个引用计数机制，进行拷贝构造时引用加1，Mat对象析构时引用减1，当引用变为0时，释放数据部分内存。</li>
<li>当需要进行数据部分拷贝时，OpenCV提供了<code>cv::Mat::clone()</code>和<code>cv::Mat::copyTo</code>两个方法</li>
</ul>
<h4 id="Mat数据存储方式"><a href="#Mat数据存储方式" class="headerlink" title="Mat数据存储方式"></a>Mat数据存储方式</h4><ul>
<li>根据颜色空间和数据类型来选择图像数据存储方式</li>
</ul>
<h4 id="Mat对象操作"><a href="#Mat对象操作" class="headerlink" title="Mat对象操作"></a>Mat对象操作</h4><ul>
<li>使用<code>cv::Mat::Mat</code>构造函数进行创建<code>Mat img(2, 2, CV_8UC3, Scalar(0, 0, 255))</code>，指定图像的行和列大小、像素数据类型、像素颜色通道，如<code>CV_8UC3</code>表示8位无符号数据，颜色通道为3，由以下方式进行定义<br><code>CV_[The number of bits per item][Signed or Unsigned][Type Prefix]C[The channel number]</code></li>
<li>类似MATLAB方式创建单位矩阵<code>cv::Mat::eyes</code>、零矩阵<code>cv::Mat::zeros</code>、元素全为1的矩阵<code>cv::Mat::ones</code>  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Mat E = Mat::<span class="built_in">eye</span>(<span class="number">4</span>, <span class="number">4</span>, CV_64F);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;E = &quot;</span> &lt;&lt; endl &lt;+ Mat对象的打印</span><br><span class="line"><span class="number">1.</span> 默认输出&lt; <span class="string">&quot; &quot;</span> &lt;&lt; E &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line">Mat O = Mat::<span class="built_in">ones</span>(<span class="number">2</span>, <span class="number">2</span>, CV_32F);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;O = &quot;</span> &lt;&lt; endl &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; O &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line">Mat Z = Mat::<span class="built_in">zeros</span>(<span class="number">3</span>,<span class="number">3</span>, CV_8UC1);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Z = &quot;</span> &lt;&lt; endl &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; Z &lt;&lt; endl &lt;&lt; endl;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>OpenCV</category>
      </categories>
      <tags>
        <tag>OpenCV Mat</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCV图像操作</title>
    <url>/archives/117a3b0c.html</url>
    <content><![CDATA[<h4 id="图像读取和保存"><a href="#图像读取和保存" class="headerlink" title="图像读取和保存"></a>图像读取和保存</h4><ul>
<li>图像读取<code>Mat img = imread(filename)</code></li>
<li>图像保存<code>imwrite(filename, img)</code><span id="more"></span></li>
</ul>
<h4 id="像素级操作"><a href="#像素级操作" class="headerlink" title="像素级操作"></a>像素级操作</h4><ul>
<li>获取单通道灰度图像(x, y)位置像素值<code>Scalar intensity = img.at&lt;uchar&gt;(Point(x, y));</code></li>
<li>修改像素值<code>img.at&lt;uchar&gt;(Point(x, y)) = 128</code></li>
<li>获取3通道BGR颜色空间图像(x, y)位置像素值  <figure class="highlight sml"><table><tr><td class="code"><pre><span class="line"><span class="type">Vec3b</span> <span class="built_in">vector</span> = img.at&lt;<span class="type">Vec3b</span>&gt;(<span class="type">Point</span>(x, y));</span><br><span class="line">uchar blue = <span class="built_in">vector</span>.<span class="keyword">val</span>[<span class="number">0</span>];</span><br><span class="line">uchar green = <span class="built_in">vector</span>.<span class="keyword">val</span>[<span class="number">1</span>];</span><br><span class="line">uchar red = <span class="built_in">vector</span>.<span class="keyword">val</span>[<span class="number">2</span>];</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="图像基本操作"><a href="#图像基本操作" class="headerlink" title="图像基本操作"></a>图像基本操作</h4><ul>
<li>选取图像某个区域  <figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Rect</span> r(<span class="number">10</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line"><span class="attribute">Mat</span> smallImg = img(r);</span><br></pre></td></tr></table></figure></li>
<li>颜色空间转换  <figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">Mat img = imread(<span class="string">&quot;image.jpg&quot;</span>);</span><br><span class="line">Mat gray;</span><br><span class="line">cvt<span class="constructor">Color(<span class="params">img</span>, <span class="params">gray</span>, COLOR_BGR2GRAY)</span>;</span><br></pre></td></tr></table></figure></li>
<li>数据类型转换<code>src.convertTo(dst, CV_32F)</code></li>
<li>图像显示  <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">Mat img = imread(<span class="string">&quot;image.jpg&quot;</span>)<span class="comment">;</span></span><br><span class="line">namedWindow(<span class="string">&quot;image&quot;</span>, WINDOW_AUTOSIZE)<span class="comment">;</span></span><br><span class="line">imshow(<span class="string">&quot;image&quot;</span>, img)<span class="comment">;</span></span><br><span class="line">waitKey()<span class="comment">;</span></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>OpenCV</category>
      </categories>
      <tags>
        <tag>OpenCV Image</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCV 图像处理基本操作</title>
    <url>/archives/6465c2cc.html</url>
    <content><![CDATA[<h4 id="基于Mat类的图像操作"><a href="#基于Mat类的图像操作" class="headerlink" title="基于Mat类的图像操作"></a>基于Mat类的图像操作</h4><p><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220608085010.png"></p>
<ul>
<li>Mat类分为两个数据部分：数据头部分（保存矩阵大小、矩阵存储方式等信息）、矩阵数据部分， 一般的Mat对象复制构造仅拷贝数据头部分，矩阵数据部分共享。也可以通过<code>cv::Mat::copyTo</code>和<code>cv::Mat::clone</code>进行深度拷贝。<span id="more"></span></li>
<li>Mat构造函数<code>Mat img(2, 2, CV_8UC3, Scalar(0, 0, 255))</code>， 需要明确矩阵大小、矩阵存储数据类型、像素颜色通道数、像素值。</li>
<li>CV_8UC3含义表示8位无符号数据，颜色通道为3，含义参考：<code>CV_[The number of bits per item][Signed or Unsigned][Type Prefix]C[The channel number]</code></li>
<li>几种特殊矩阵的构造，<code>cv::Mat::eyes</code>单位矩阵、<code>cv::Mat::zeros</code>零矩阵、<code>cv::Mat::ones</code>全1矩阵</li>
</ul>
<h4 id="图像卷积操作"><a href="#图像卷积操作" class="headerlink" title="图像卷积操作"></a>图像卷积操作</h4><ul>
<li><p>根据kernel矩阵重新计算图像中每个像素的值，<em>h(k, j)</em> 为kernel，使用<code>filter2D</code>进行卷积操作<br>  <img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220609163143.png"></p>
  <figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">CV_EXPORTS_W <span class="type">void</span> filter2D( InputArray src, </span><br><span class="line">                            OutputArray dst, </span><br><span class="line">                            <span class="type">int</span> ddepth, </span><br><span class="line">                            InputArray kernel, </span><br><span class="line">                            <span class="type">Point</span> anchor = <span class="type">Point</span>(<span class="number">-1</span>,<span class="number">-1</span>), </span><br><span class="line">                            <span class="type">double</span> delta = <span class="number">0</span>, </span><br><span class="line">                            <span class="type">int</span> borderType = BORDER_DEFAULT );</span><br></pre></td></tr></table></figure></li>
<li><p>使用图像卷积进行图像模糊（平滑）</p>
<ol>
<li>简单的图像平滑，Kernel模型如下<br>  <img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220609163417.png"></li>
<li>高斯模糊，根据距当前像素点的距离决定平滑的权重，一维高斯核的图像如下<br>  <img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220609163925.png"><br>  二维高斯公式，其中μ为平均值，σ为方差<br>  <img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220609164447.png"></li>
<li>中值滤波，将像素点周围区域内的像素进行排序，采用中间位置的像素值作为当前像素点的值</li>
<li>双边滤波，权重由两部分来决定，第一部分是类似于二维高斯，另一部分由颜色差异来决定，这样可以比较好的保留边缘信息。</li>
</ol>
</li>
<li><p>图像边界处理，使用<code>copyMakeBorder</code>给图像创建一个边框</p>
<ol>
<li><code>BORDER_CONTANT</code>，使用固定像素值填充创建的边框</li>
<li><code>BORDER_REPLICATE</code>，复制原图像中的边界值</li>
</ol>
</li>
<li><p>使用图像卷积进行形态学操作，主要针对阈值化后的图像</p>
<ol>
<li>膨胀 Dilate，使用Kernel范围内的最大值取代当前像素值<br>  膨胀二值化图像<br>  <img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220610150255.png"><br>  膨胀灰度图像<br>  <img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220610150405.png"></li>
<li>腐蚀 Erode，使用Kernel范围内的最小值取代当前像素值<br>  腐蚀二值化图像<br>  <img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220610150527.png"><br>  腐蚀灰度图像<br>  <img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220610150618.png"></li>
<li>开操作 Opening，先腐蚀后膨胀，去除暗黑背景中细小的噪点，原理 *dst &#x3D; open(src, element) &#x3D; dilate(erode(src, element))*， <em>element</em>为kernel</li>
<li>闭操作 Closing，先膨胀后腐蚀，去除明亮背景中的细小噪点，原理 <em>dst &#x3D; close(src, element) &#x3D; erode(dilate(src, element))</em></li>
<li>形态梯度 Morphological Gradient，膨胀图像与腐蚀图像的差，用来找出物体轮廓，原理 <em>dst &#x3D; morphy(src, element) &#x3D; dilate(src, element) - erode(src, element)</em></li>
<li>高帽 Top Hat</li>
</ol>
</li>
<li><p>也可以使用 <em>getStructuringElement</em> 创造指定形状和大小的Kernel，进行图像的特征提取，如官方教程<a href="https://docs.opencv.org/4.x/dd/dd7/tutorial_morph_lines_detection.html">提取乐谱中的直线和音符</a>，就是借助形态学开操作进行直线和音符的提取。</p>
</li>
</ul>
<h4 id="图像融合"><a href="#图像融合" class="headerlink" title="图像融合"></a>图像融合</h4><ul>
<li>图像融合公式<code>dst = src1*alpha + src2*beta + gamma</code>，使用<code>addWeighted()</code>进行融合。  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cv::addWeighted</span><span class="params">( InputArray src1,</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="keyword">double</span> alpha,</span></span></span><br><span class="line"><span class="params"><span class="function">                      InputArray src2,</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="keyword">double</span> beta,</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="keyword">double</span> gamma,</span></span></span><br><span class="line"><span class="params"><span class="function">                      OutputArray dst,</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="keyword">int</span> dtype = <span class="number">-1</span> )</span></span>;	</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="改变图像对比度和亮度"><a href="#改变图像对比度和亮度" class="headerlink" title="改变图像对比度和亮度"></a>改变图像对比度和亮度</h4><ul>
<li>公式<code>g(x)=αf(x)+β</code>改变α的值可以改变图像的对比度，改变β的值可以改变图像的亮度</li>
<li>Gamma校准，使用查找表，按照如下公式对像素值进行一个非线性的转换 <em>O &#x3D; (I &#x2F; 255)^γ × 255</em>，γ越大整体亮度降低。<br><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220609161302.png"></li>
</ul>
<h4 id="图像的缩放"><a href="#图像的缩放" class="headerlink" title="图像的缩放"></a>图像的缩放</h4><ul>
<li>高斯金字塔(Gaussian Pyramid)，从底部开始计数，第 <em>i+1</em> 层表示为 <em>G(i + 1)</em><br><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220613132715.png"></li>
<li>*G(i + 1)<em>层的变换过程，由</em>G(i)*层先进行高斯模糊，然后丢掉偶数行和偶数列的像素，即图像缩小的操作</li>
<li>图像放大的操作，图像放大两倍，在奇数行和奇数列填充0像素，再进行高斯模糊<br><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220613141653.png"></li>
</ul>
<h4 id="图像阈值操作threshold的几种方法"><a href="#图像阈值操作threshold的几种方法" class="headerlink" title="图像阈值操作threshold的几种方法"></a>图像阈值操作<em>threshold</em>的几种方法</h4><ol>
<li>二值化（Threshold Binary），<code>src(x, y)</code>大于阈值<code>threshold</code>则置为最大值，否则置为0</li>
<li>反向二值化（Threshold Binary, Inverted），<code>src(x, y)</code>小于阈值<code>threshold</code>则置为最大值，否则置为0</li>
<li>截取像素值（Truncate），<code>src(x, y)</code>大于阈值<code>threshold</code>则令<code>src(x, y)</code>等于<code>threshold</code>，否则不变</li>
<li>只保留超过阈值部分，<code>src(x, y)</code>大于阈值<code>threshold</code>则置为原值，否则置为0</li>
<li>只保留小于阈值部分，<code>src(x, y)</code>小于阈值<code>threshold</code>则置为0，否则不变</li>
</ol>
<h4 id="图像像素梯度计算"><a href="#图像像素梯度计算" class="headerlink" title="图像像素梯度计算"></a>图像像素梯度计算</h4><ul>
<li><p><code>Sobel</code>边缘检测算子，利用图像边缘像素强度值变化非常显著的特点，使用特殊的卷积核计算水平方向的梯度变化和竖直方向的梯度变化。如下图是图像边缘像素强度的变化曲线的一维图像和该图像像素强度变化梯度图像（即导数图像），像素强度变化最剧烈的地方就可能是物体边缘。<br><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220614155216.png"> <img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220614160139.png">  </p>
</li>
<li><p>利用特殊的卷积核计算水平梯度变化和垂直梯度变化，然后再融合两个梯度图像<br><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220614160526.png"> <img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220614160536.png"><br><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220614160543.png"> <img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220614160552.png"></p>
</li>
<li><p>利用二级导数，像素强度变化剧烈的点即一阶导数极值点，其二级导数值接近0，拉普拉斯算子<code>Laplacian</code>计算水平方向和竖直方向上二级导数的和，OpenCV提供的<code>Laplacian()</code>函数，内部也是通过调用<code>Sobel()</code>来计算的，如下图二级导数图像和拉普拉斯公式。<br><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220624144442.png"><br><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220624144513.png"></p>
</li>
<li><p><code>Canny</code>边缘检测，1986年由John F. Canny提出，被认为是最优的边缘检测算法，其具有三个主要的特点：较低的错误率、较好的边缘定位、较快的检测速度，其检测步骤如下：</p>
<ol>
<li>使用高斯平滑模糊图像</li>
<li>计算图像亮度梯度图像，其过程与Sobel算子类似，分别计算x y方向上的梯度，再进行融合</li>
<li>去掉不是很连续的像素点，认为其不属于边缘</li>
<li>使用两个阈值，一大一小，其比例一般为2:1或者3:1，高于upper阈值认为其为边缘，低于lower阈值丢弃该像素点，介于upper与lower之间的像素点则看邻接像素点是否高于upper，是的话接受其为边缘</li>
</ol>
</li>
</ul>
<h4 id="霍夫变换直线检测"><a href="#霍夫变换直线检测" class="headerlink" title="霍夫变换直线检测"></a>霍夫变换直线检测</h4><ul>
<li>图像转化为灰度颜色，首先进行高斯模糊</li>
<li>再进行边缘检测，使其变成了一个二值化包含边缘的图像</li>
<li>经过该图像上像素点（x0, y0）的所有直线的方程可以表述为如下，霍夫变换检测每一个像素点的经过直线的条数，经过的直线条数到达一定阈值后可认为该</li>
</ul>
]]></content>
      <categories>
        <category>OpenCV</category>
      </categories>
      <tags>
        <tag>OpenCV Core</tag>
      </tags>
  </entry>
  <entry>
    <title>HI3559AV100调试记录</title>
    <url>/archives/7803046f.html</url>
    <content><![CDATA[<h4 id="内核编译与烧写"><a href="#内核编译与烧写" class="headerlink" title="内核编译与烧写"></a>内核编译与烧写</h4><ul>
<li>内核版本4.9.37，Linux内核源码如下<br><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220609101727.png"><span id="more"></span></li>
<li>编译<code>make ARCH=arm64 CROSS_COMPILE=aarch64-himix100-linux- uImage -j12</code>，编译完成结果如下，编译完成后会在arch&#x2F;arm64&#x2F;boot&#x2F;生成UImage<br><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220609101926.png"></li>
<li>arm-trusted-firmware目录中运行mk.sh生成fip.bin<br><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220609110821.png"></li>
<li>主机搭建tftp服务器，将fip.bin拷贝到共享目录</li>
<li>进入uboot，配置ethact ipaddr serverip环境变量<br><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220609111122.png"></li>
<li>从tftp加载内核，测试内核是否能启动、  <figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">tftp</span> fip.bin <span class="number">0</span>x<span class="number">42000000</span></span><br><span class="line"><span class="attribute">bootm</span> <span class="number">0</span>x<span class="number">42000000</span></span><br></pre></td></tr></table></figure></li>
<li>烧写内核到emmc  <figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">tftp</span> fip.bin <span class="number">0</span>x<span class="number">42000000</span></span><br><span class="line"><span class="attribute">mmc</span> dev <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="attribute">mmc</span> write <span class="number">0</span> <span class="number">0</span>x<span class="number">42000000</span> <span class="number">800</span> <span class="number">4800</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="驱动调试"><a href="#驱动调试" class="headerlink" title="驱动调试"></a>驱动调试</h4><ul>
<li>参照正点原子教程搭建驱动调试环境，配置的<em>Makefile</em>内容如下  <figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">KERNEL_DIR = /home/jack/hisi/minimum_system/linux-4.9.y_multi-core</span><br><span class="line">CURRENT_PATH = <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line">obj-m := gpio-pca953x.o</span><br><span class="line"></span><br><span class="line"><span class="section">build: kernel_modules</span></span><br><span class="line"></span><br><span class="line"><span class="section">kernel_modules: </span></span><br><span class="line"><span class="variable">$(MAKE)</span> ARCH=arm64 CROSS_COMPILE=aarch64-himix100-linux- -C <span class="variable">$(KERNEL_DIR)</span> M=<span class="variable">$(CURRENT_PATH)</span> modules</span><br><span class="line"></span><br><span class="line"><span class="section">clean: </span></span><br><span class="line"><span class="variable">$(MAKE)</span> ARCH=arm64 CROSS_COMPILE=aarch64-himix100-linux- -C <span class="variable">$(KERNEL_DIR)</span> M=<span class="variable">$(CURRENT_PATH)</span> clean</span><br></pre></td></tr></table></figure></li>
<li><em>KERNEL_DIR</em>表示Linux内核源码目录，使用绝对路径</li>
<li><em>CURRENT_PATH</em>表示当前路径，直接使用<em>pwd</em>来获取当前路径</li>
<li><em>obj-m</em>表示将这个c文件编译为ko模块</li>
<li><em>modules</em>表示编译模块，*-C*表示将当前的工作目录切换到指定目录中， <em>M</em>表示模块源码目录</li>
<li><em>make modules</em>命令中加入 M&#x3D;dir 以后程序会自动到指定的 dir 目录中读取模块的源码并将其编译为.ko 文件</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Hi3559AV100 Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux Input子系统按键连按驱动调试记录</title>
    <url>/archives/e19e1ecc.html</url>
    <content><![CDATA[<h4 id="Linux-Input子系统介绍"><a href="#Linux-Input子系统介绍" class="headerlink" title="Linux Input子系统介绍"></a>Linux Input子系统介绍</h4><blockquote>
<p>按键、鼠标、键盘、触摸屏等都属于输入(input)设备, Linux 内核为此专门做了一个叫做 input子系统的框架来处理输入事件。输入设备本质上还是字符设备,只是在此基础上套上了 input 框架,用户只需要负责上报输入事件,比如按键值、坐标等信息, input 核心层负责处理这些事件。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220609141734.png"></p>
<span id="more"></span>

<h4 id="input驱动编写流程"><a href="#input驱动编写流程" class="headerlink" title="input驱动编写流程"></a>input驱动编写流程</h4><ul>
<li><p>注册input_dev</p>
<ol>
<li>使用<em>input_allocate_device</em>申请一个<em>input_dev</em>结构体</li>
<li>初始化<em>input_dev</em>的事件类型以及事件值</li>
<li>使用<em>input_register_device</em>函数向系统注册<em>input_dev</em></li>
<li><strong>按键需要实现连按时<em>evbit</em>需要设置<em>EV_REP</em>标志，调按键驱动时在调连按功能时在这里卡了很久</strong>  <figure class="highlight xl"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">chip</span>-&gt;</span>input = input_allocate_device();</span><br><span class="line"><span class="function"><span class="title">if</span> (!chip-&gt;</span>input) </span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_ERR <span class="string">&quot;Unable to allocate the input device !!\n&quot;</span>);</span><br><span class="line">    return -ENOMEM;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">chip</span>-&gt;</span><span class="function"><span class="title">input</span>-&gt;</span><span class="keyword">name</span> = <span class="string">&quot;pca953x_button&quot;</span>;</span><br><span class="line"><span class="function"><span class="title">set_bit</span>(EV_KEY, chip-&gt;</span><span class="function"><span class="title">input</span>-&gt;</span>evbit);     <span class="comment">/* 设置产生按键事件 */</span> </span><br><span class="line"><span class="function"><span class="title">set_bit</span>(EV_REP, chip-&gt;</span><span class="function"><span class="title">input</span>-&gt;</span>evbit);     <span class="comment">/* 设置重复事件  */</span> </span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; ZKEY_NUM + <span class="number">5</span>; i++)	</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="title">set_bit</span>(button_info[i].code, chip-&gt;</span><span class="function"><span class="title">input</span>-&gt;</span>keybit);	<span class="comment">//支持具体按键键码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">status</span> = input_register_device(chip-&gt;</span>input);   <span class="comment">//注册input设备</span></span><br><span class="line"><span class="keyword">if</span>(status)</span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_ERR <span class="string">&quot;input_register_device\n&quot;</span>);</span><br><span class="line">    return -ENOMEM;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="上报输入事件"><a href="#上报输入事件" class="headerlink" title="上报输入事件"></a>上报输入事件</h4></li>
</ol>
</li>
<li><p>使用<em>input_event</em>函数上报指定的事件及对应的值，函数原型如下</p>
  <figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> input_event(<span class="keyword">struct</span> input_dev *dev,</span><br><span class="line">                 <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="keyword">type</span>,</span><br><span class="line">                 <span class="keyword">unsigned</span> <span class="keyword">int</span> code,</span><br><span class="line">                 <span class="keyword">int</span> value)</span><br></pre></td></tr></table></figure>
<p>  dev:需要上报的 input_dev。<br>  type: 上报的事件类型,比如 EV_KEY。<br>  code:事件码,也就是我们注册的按键值,比如 KEY_0、KEY_1 等等。<br>  value:事件值,比如 1 表示按键按下,0 表示按键松开。</p>
</li>
<li><p>上报按键事件，Linux内核也提供了具体的上报函数<em>input_report_key</em></p>
  <figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">static inline void input<span class="constructor">_report_key(<span class="params">struct</span> <span class="params">input_dev</span> <span class="operator">*</span><span class="params">dev</span>, <span class="params">unsigned</span> <span class="params">int</span> <span class="params">code</span>, <span class="params">int</span> <span class="params">value</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    input<span class="constructor">_event(<span class="params">dev</span>, EV_KEY, <span class="params">code</span>, !!<span class="params">value</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  type:事件类型,比如 EV_KEY,表示此次事件为按键事件,此成员变量为 16 位。<br>  code:事件码,比如在 EV_KEY 事件中 code 就表示具体的按键码,如:KEY_0、KEY_1等等这些按键。此成员变量为 16 位。<br>  value:值,比如 EV_KEY 事件中 value 就是按键值,表示按键有没有被按下,如果为1的话说明按键按下,如果为0的话说明按键没有被按下或者按键松开了。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux Driver 按键驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt中串口数据处理机制</title>
    <url>/archives/6e893f38.html</url>
    <content><![CDATA[<p>在嵌入式项目或者工控项目中经常会用到串口通讯，用到串口通讯可能就涉及到串口私有协议（类似 包头 + 帧类型 + 帧长度 + 帧数据 + 校验和 的形式）的解析。在Qt中经常用到<code>QSerialPort</code>类来进行串口数据收发，<code>QSerialPort</code>在串口数据可读时会释放<code>readyRead()</code>信号，接到这个信号再调用<code>readAll()</code>将缓冲区的数据全部读出来（串口数据量比较大，这个过程一般都是在一个独立的接收线程中进行处理）。<span id="more"></span>但是这个<code>readyRead()</code>信号释放时，缓冲区的数据长度是不固定的（一般是几十个字节会释放一次读信号），不过串口私有协议各个帧的长度基本都是固定的，这就导致处理串口数据时需要对<code>readAll()</code>中读出来的数据进行链接，然后进行数据解析。<br>记录一下最近调试Qt串口通讯时用到的方法，这个方法也适用于任何系统的串口数据接收，可以达到不错的处理速度，保证不丢帧的接收。该方法的处理机制比较简单，在槽函数中接收到串口数据后，释放信号将读到的数据传递出去，接收信号方逐字节的按照协议对这些数据进行处理，这样只要<code>QSerialPort</code>将串口上的数据都完整的读出来了，应该是不会出现丢帧的情况。</p>
<h4 id="串口初始化及数据接收"><a href="#串口初始化及数据接收" class="headerlink" title="串口初始化及数据接收"></a>串口初始化及数据接收</h4><ul>
<li>串口类进行初始化后，转移到<code>thread</code>线程中进行处理，在<code>readSerialData()</code>中将数据读取后将数据传递出去。<br>  serialport.h  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SerialPort</span> :</span> <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">SerialPort</span><span class="params">(QObject *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">    ~<span class="built_in">SerialPort</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">startThread</span><span class="params">(<span class="keyword">const</span> QString &amp;port)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">closeSerialPort</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">writeSerialData</span><span class="params">(<span class="keyword">const</span> QByteArray &amp;data)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">openSerialPort</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">readSerialData</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">serialStateChanged</span><span class="params">(<span class="keyword">bool</span> state)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dataReaded</span><span class="params">(<span class="keyword">const</span> QByteArray &amp;data)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QString port;</span><br><span class="line">    qint32 baudrate;</span><br><span class="line">    QSerialPort *serial;</span><br><span class="line">    QThread *thread;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
  serialport.cpp  <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &quot;serialport.h&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@brief</span> SerialPort::SerialPort</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> parent</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">SerialPort::SerialPort(QObject *<span class="built_in">parent</span>) : QObject(<span class="built_in">parent</span>)</span><br><span class="line">&#123;</span><br><span class="line">    serial = <span class="keyword">new</span> QSerialPort;</span><br><span class="line">    thread = <span class="keyword">new</span> QThread;</span><br><span class="line">    this-&gt;moveToThread(thread);</span><br><span class="line">    serial-&gt;moveToThread(thread);</span><br><span class="line">    connect(thread, &amp;QThread::started, this, &amp;SerialPort::openSerialPort);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@brief</span> SerialPort::~SerialPort</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">SerialPort::~SerialPort()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (serial-&gt;isOpen())</span><br><span class="line">    &#123;</span><br><span class="line">        serial-&gt;close();</span><br><span class="line">    &#125;</span><br><span class="line">    serial-&gt;deleteLater();</span><br><span class="line">    thread-&gt;quit();</span><br><span class="line">    thread-&gt;wait();</span><br><span class="line">    thread-&gt;deleteLater();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@brief</span> SerialPort::startThread</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> port serial port name(QSerialPortInfo::name)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">void</span> SerialPort::startThread(<span class="keyword">const</span> QString &amp;port)</span><br><span class="line">&#123;</span><br><span class="line">    this-&gt;port = port;</span><br><span class="line">    qDebug() &lt;&lt; <span class="string">&quot;current port is &quot;</span> &lt;&lt; port;</span><br><span class="line">    <span class="keyword">if</span> (!thread-&gt;isRunning())</span><br><span class="line">    &#123;</span><br><span class="line">        thread-&gt;start();</span><br><span class="line">        qDebug() &lt;&lt; <span class="string">&quot;serialport thread start: &quot;</span> &lt;&lt; QThread::currentThread();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@brief</span> SerialPort::openSerialPort</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">void</span> SerialPort::openSerialPort()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (serial-&gt;isOpen())</span><br><span class="line">    &#123;</span><br><span class="line">        qDebug() &lt;&lt; <span class="string">&quot;serial is opened, return.&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    serial-&gt;setPortName(port);</span><br><span class="line">    serial-&gt;setBaudRate(<span class="number">115200</span>);</span><br><span class="line">    serial-&gt;setDataBits(QSerialPort::Data8);</span><br><span class="line">    serial-&gt;setStopBits(QSerialPort::OneStop);</span><br><span class="line">    serial-&gt;setParity(QSerialPort::NoParity);</span><br><span class="line">    serial-&gt;setFlowControl(QSerialPort::NoFlowControl);</span><br><span class="line">    <span class="keyword">if</span> (serial-&gt;open(QIODevice::ReadWrite))</span><br><span class="line">    &#123;</span><br><span class="line">        qDebug() &lt;&lt; <span class="string">&quot;serial open success.&quot;</span> &lt;&lt; QThread::currentThread();</span><br><span class="line">        connect(serial, &amp;QSerialPort::readyRead,</span><br><span class="line">                this, &amp;SerialPort::readSerialData, Qt::QueuedConnection);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        qDebug() &lt;&lt; <span class="string">&quot;serial open failed.&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@brief</span> SerialPort::readSerialData</span></span><br><span class="line"><span class="comment">* read 16 bytes each time</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">void</span> SerialPort::readSerialData()</span><br><span class="line">&#123;</span><br><span class="line">    QByteArray buf = serial-&gt;readAll();</span><br><span class="line">    emit dataReaded(buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@brief</span> SerialPort::writeSerialData</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> data  buff to write</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">void</span> SerialPort::writeSerialData(<span class="keyword">const</span> QByteArray &amp;data)</span><br><span class="line">&#123;</span><br><span class="line">    serial-&gt;write(data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@brief</span> SerialPort::closeSerialPort</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">void</span> SerialPort::closeSerialPort()</span><br><span class="line">&#123;</span><br><span class="line">    qDebug() &lt;&lt; <span class="string">&quot;close serialport.&quot;</span>;</span><br><span class="line">    serial-&gt;clear();</span><br><span class="line">    serial-&gt;close();</span><br><span class="line">    <span class="keyword">if</span> (thread-&gt;isRunning())</span><br><span class="line">    &#123;</span><br><span class="line">        thread-&gt;quit();</span><br><span class="line">        thread-&gt;wait();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="串口数据处理"><a href="#串口数据处理" class="headerlink" title="串口数据处理"></a>串口数据处理</h4><ul>
<li>数据处理类接收到串口类传递的数据后，按照协议逐字节的进行处理，帧头的处理比较麻烦，因为帧头一般是两个字节，可能被缓冲到前后两个数据缓冲区，所以需要对前后两个帧头的位置关系进行判断。<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uartRecvProcess</span><span class="params">(<span class="keyword">const</span> QByteArray&amp; data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> firstHeadPos = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> frameLen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> frameDataIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> lastLen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">uint8_t</span> frameData[MAX_FRAME_LEN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> PRINT_UART_DEBUG</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; data.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;0x%02x &quot;</span>, (<span class="keyword">uint8_t</span>)data.<span class="built_in">at</span>(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (index &lt; data.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">uint8_t</span> temp = data.<span class="built_in">at</span>(index);</span><br><span class="line"></span><br><span class="line">        <span class="built_in"><span class="keyword">switch</span></span> (step)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="comment">// 查找第一个帧头</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="number">0x55</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                step = <span class="number">1</span>;</span><br><span class="line">                firstHeadPos = index;</span><br><span class="line">                frameData[frameDataIndex++] = temp;</span><br><span class="line">                lastLen = data.<span class="built_in">size</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查找第二个帧头</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> ((temp == <span class="number">0xAA</span>) &amp;&amp;</span><br><span class="line">                ((index == firstHeadPos + <span class="number">1</span>) ||</span><br><span class="line">                ((firstHeadPos == lastLen <span class="number">-1</span>) &amp;&amp; index == <span class="number">0</span>)))</span><br><span class="line">            &#123;</span><br><span class="line">                step = <span class="number">2</span>;</span><br><span class="line">                frameData[frameDataIndex++] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                step = <span class="number">0</span>;</span><br><span class="line">                firstHeadPos = <span class="number">-1</span>;</span><br><span class="line">                frameDataIndex = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 帧类型判断</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">if</span>(temp == CMD_AD)</span><br><span class="line">            &#123;</span><br><span class="line">                frameLen = FRAME_SIZE_AD;</span><br><span class="line">                frameData[frameDataIndex++] = temp;</span><br><span class="line">                step = <span class="number">3</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(temp == CMD_IO)</span><br><span class="line">            &#123;</span><br><span class="line">                frameLen = FRAME_SIZE_IO;</span><br><span class="line">                step = <span class="number">3</span>;</span><br><span class="line">                frameData[frameDataIndex++] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//去掉帧头，重新查找</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;unknow uart frame type\n&quot;</span>);</span><br><span class="line">                step = <span class="number">0</span>;</span><br><span class="line">                frameLen = <span class="number">0</span>;</span><br><span class="line">                firstHeadPos = <span class="number">-1</span>;</span><br><span class="line">                frameDataIndex = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 帧数据接收及解析</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">if</span> (frameDataIndex &lt; frameLen)</span><br><span class="line">                frameData[frameDataIndex++] = temp;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (frameDataIndex == frameLen)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(frameData[frameLen - <span class="number">1</span>] != <span class="built_in">checkSum</span>(frameData, frameLen - <span class="number">1</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;type: %d, checksum error! received is 0x%02x, calculated is 0x%02x\n&quot;</span>,</span><br><span class="line">                           frameLen, frameData[frameLen - <span class="number">1</span>], <span class="built_in">checkSum</span>(frameData, frameLen - <span class="number">1</span>));</span><br><span class="line">                    step = <span class="number">0</span>;</span><br><span class="line">                    frameLen = <span class="number">0</span>;</span><br><span class="line">                    firstHeadPos = <span class="number">-1</span>;</span><br><span class="line">                    frameDataIndex = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;type: %d, uart data handler\n&quot;</span>, frameLen);</span><br><span class="line">                    <span class="built_in">uartDataHandler</span>(frameData, frameLen);</span><br><span class="line">                    step = <span class="number">0</span>;</span><br><span class="line">                    frameLen = <span class="number">0</span>;</span><br><span class="line">                    firstHeadPos = <span class="number">-1</span>;</span><br><span class="line">                    frameDataIndex = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        index ++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>Qt QSerialPort 串口</tag>
      </tags>
  </entry>
  <entry>
    <title>龙芯2K1000内核源码编译</title>
    <url>/archives/67263a86.html</url>
    <content><![CDATA[<h4 id="解压PMON源码pmon-loongson3-tar-gz"><a href="#解压PMON源码pmon-loongson3-tar-gz" class="headerlink" title="解压PMON源码pmon-loongson3.tar.gz"></a>解压PMON源码<em>pmon-loongson3.tar.gz</em></h4><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">tar</span> -xvf pmon-loongson<span class="number">3</span>-nd-<span class="number">33</span>j.tar.gz</span><br></pre></td></tr></table></figure>
<h4 id="配置交叉编译环境"><a href="#配置交叉编译环境" class="headerlink" title="配置交叉编译环境"></a>配置交叉编译环境</h4><ul>
<li>解压交叉编译工具<em>gcc-4.4.0-pmon.tgz</em>，配置环境<span id="more"></span>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">tar</span> -xvf gcc-<span class="number">4</span>.<span class="number">4</span>.<span class="number">0</span>-pmon.tgz</span><br></pre></td></tr></table></figure>
编辑&#x2F;etc&#x2F;profile，配置交叉编译工具路径<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">export PATH=<span class="variable">$PATH</span><span class="symbol">:/home/jack/loongson/tools/gcc-</span><span class="number">4.4</span>.0-pmon/bin</span><br><span class="line">export LD_LIBRARY_PATH=<span class="regexp">/home/jack</span><span class="regexp">/loongson/tools</span><span class="regexp">/gcc-4.4.0-pmon/lib</span><span class="symbol">:</span><span class="variable">$LD_LIBRARY_PATH</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>安装makedepend，<code>sudo apt-get install xutils-dev </code></li>
<li>进入源码目录编译安装pmoncfg<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> install bison flex build-essential patch</span><br><span class="line"><span class="keyword">cd</span> tools/pmoncfg </span><br><span class="line"><span class="keyword">make</span> </span><br><span class="line">sudo <span class="keyword">cp</span> pmoncfg /usr/bin</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="编译PMON源码"><a href="#编译PMON源码" class="headerlink" title="编译PMON源码"></a>编译PMON源码</h4><p>进入PMON源码目录，若只需要修改PMON，可在原来的项目目录基础上进行编译，源码内有脚本文件<em>build.sh</em>，输入格式: <code>./build.sh [cputype] [proID]</code>，比如龙芯2K1000，项目ID hm19047，输入<code>./build.sh ls2k hm19047</code>即可开始编译，编译结果在<em>zloader.ls2k-hm19047</em>目录中，会生成<em>gzrom-dtb.bin</em>，将该文件烧录进flash即可。</p>
<h4 id="PMON网络烧录"><a href="#PMON网络烧录" class="headerlink" title="PMON网络烧录"></a>PMON网络烧录</h4><ul>
<li>主机IP地址为192.168.0.100，搭建tftp服务器</li>
<li>开机按C键进入PMON下，设置IP地址<code>ifconfig syn0 192.168.0.10</code></li>
<li>烧写PMON<code>load -rf 0xbfc00000 tftp://192.168.0.100/gzrom-dtb.bin</code></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>PMON</tag>
        <tag>Loongson</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu编译QFtp并使用</title>
    <url>/archives/1b5a9595.html</url>
    <content><![CDATA[<h4 id="下载QFtp源码"><a href="#下载QFtp源码" class="headerlink" title="下载QFtp源码"></a>下载QFtp源码</h4><p><a href="https://github.com/qt/qtftp.git">QFtp源码</a><br><code>gti clone https://github.com/qt/qtftp.git</code></p>
<h4 id="编译QFtp模块"><a href="#编译QFtp模块" class="headerlink" title="编译QFtp模块"></a>编译QFtp模块</h4><p>在QtCreator上编译出了点问题，只能在终端进行编译</p>
<ul>
<li>进入源码目录<code>cd src/qftp</code>，修改pro文件<code>qftp.pro</code>,修改如下<span id="more"></span>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">load(qt_build_config)</span><br><span class="line"></span><br><span class="line">TARGET = QtFtp</span><br><span class="line">CONFIG += static</span><br><span class="line">CONFIG -= shared</span><br><span class="line">QT = core network</span><br><span class="line"></span><br><span class="line">MODULE_PRI = ../../modules/qt_ftp.pri</span><br><span class="line">MODULE = ftp</span><br><span class="line"></span><br><span class="line">load(qt_module)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Input</span></span><br><span class="line">HEADERS += qftp.h qurlinfo.h</span><br><span class="line">SOURCES += qftp.cpp qurlinfo.cpp</span><br><span class="line"></span><br></pre></td></tr></table></figure>
修改<code>qurlinfo.cpp</code>中的<code>qurlinfo.h</code>路径，修改如下<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &quot;qurlinfo.h&quot;</span><br><span class="line"></span><br><span class="line">#include &quot;qurl.h&quot;</span><br><span class="line">#include &quot;qdir.h&quot;</span><br><span class="line">#include &lt;limits.h&gt;</span><br><span class="line"></span><br><span class="line">QT_BEGIN_NAMESPACE</span><br></pre></td></tr></table></figure></li>
<li>在终端中进入源码目录<code>cd src/qftp</code>，运行<code>qmake</code>，之后会生成Makefile</li>
<li><code>make</code>生成<code>libQt5Ftp.a</code>静态库，pri模块文件</li>
<li><code>make install</code>将生成的库文件及QFtp头文件复制到Qt安装目录</li>
<li>对于交叉编译环境下其他平台的编译也可按照上面的步骤，qmake需要替换交叉编译环境下对应的qmake</li>
</ul>
<h4 id="QFtp使用"><a href="#QFtp使用" class="headerlink" title="QFtp使用"></a>QFtp使用</h4><ul>
<li>官方源码目录example文件夹下有一个例程，网上有大佬稍加修改上传到了GitHub，<a href="https://github.com/chuanstudyup/QFtpExample.git">QFtp例程</a>  </li>
<li>下载这个例程，上述编译步骤没问题的话，直接编译运行即可<br><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220627150335.png"></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>QFtp</tag>
      </tags>
  </entry>
  <entry>
    <title>C/C++ 中宏定义中#和##的作用</title>
    <url>/archives/57aaac13.html</url>
    <content><![CDATA[<h4 id="宏定义中-的功能"><a href="#宏定义中-的功能" class="headerlink" title="宏定义中#的功能"></a>宏定义中#的功能</h4><p>C&#x2F;C++宏定义#中的功能是将其后面的宏参数进行字符串化操作，简单说就是在对它所引用的宏变量通过替换后在其左右各添加一个双引号。</p>
<span id="more"></span>

<h4 id="宏定义中-的功能-1"><a href="#宏定义中-的功能-1" class="headerlink" title="宏定义中##的功能"></a>宏定义中##的功能</h4><p>宏定义中##中的功能是在带参数的宏定义中将##前后的子串进行拼接。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STR(s) #s</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONS(a, b) int(a##e##b)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">STR</span>(hello) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">CONS</span>(<span class="number">2</span>, <span class="number">3</span>) &lt;&lt; endl;     <span class="comment">// CONS(2, 3) -&gt; 2e3 </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line">hello</span><br><span class="line"><span class="number">2000</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核链表结构</title>
    <url>/archives/4896cd7d.html</url>
    <content><![CDATA[<p>Linux内核中，对于数据管理，提供了2种类型的双向链表，一种是使用list_head结构体构成的双向环形链表。<br><img src="https://raw.githubusercontent.com/JackHuang021/images/master/20221103103152.png"></p>
<span id="more"></span>
<h4 id="list-head链表"><a href="#list-head链表" class="headerlink" title="list_head链表"></a>list_head链表</h4><p><code>list_head</code>结构体定义在<code>include/linux/types.h</code>中，定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">next</span>, *<span class="title">prev</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>list_head</code>组成的双向链表，仅包含两个成员，<code>next</code>和<code>prev</code>指针，分别指向下一个和前一个<code>list_head</code></p>
<p><code>list_head</code>一般不是单独使用的，一般用来嵌入到其他结构体中，知道<code>list_head</code>指针时就可以通过<code>include/linux/list.h</code>中提供的<code>list_entry</code>宏来获取它父结构的地址，其中调用了<code>container_of</code>宏，该宏定义在<code>include/linux/kernel</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* list_head 使用示例 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_list</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *item;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* list_entry */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* list_entry - get the struct for this entry</span></span><br><span class="line"><span class="comment">* @ptr:	the &amp;struct list_head pointer.</span></span><br><span class="line"><span class="comment">* @type:	the type of the struct this is embedded in.</span></span><br><span class="line"><span class="comment">* @member:	the name of the list_head within the struct.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_entry(ptr, type, member) \</span></span><br><span class="line"><span class="meta">    container_of(ptr, type, member)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* container_of - cast a member of a structure out to the containing structure</span></span><br><span class="line"><span class="comment">* @ptr:	the pointer to the member.</span></span><br><span class="line"><span class="comment">* @type:	the type of the container struct this is embedded in.</span></span><br><span class="line"><span class="comment">* @member:	the name of the member within the struct.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> container_of(ptr, type, member) (&#123; \</span></span><br><span class="line"><span class="meta">    void *__mptr = (void *)(ptr); \</span></span><br><span class="line"><span class="meta">    ((type *)(__mptr - offsetof(type, member))); &#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* offsetof */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> offsetof(TYPE, MEMBER) ((size_t) &amp;((TYPE *)0)-&gt;MEMBER)</span></span><br></pre></td></tr></table></figure>
<p><code>offsetof</code>获取结构体成员在结构体中地址的偏移量<br><code>container_of</code>的作用是通过结构体的成员地址获取结构体变量的地址，container_of一共<br>需要传入三个参数，<code>ptr</code>指针地址，<code>type</code>结构体类型，<code>member</code>结构体成员名称，具体<br>的做法就是通过成员的指针地址，减去成员在结构体中偏移的地址</p>
<h4 id="list-head链表操作"><a href="#list-head链表操作" class="headerlink" title="list_head链表操作"></a><code>list_head</code>链表操作</h4><ul>
<li><p><code>list_head</code>初始化，<code>list_head</code>初始化分为静态初始化和动态初始化</p>
<ul>
<li><p>静态初始化</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIST_HEAD_INIT(name) &#123; &amp;(name), &amp;(name) &#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIST_HEAD(name) struct list_head name = LIST_HEAD_INIT(name)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 例如 */</span></span><br><span class="line">LIST_HEAD(my_list);</span><br><span class="line"><span class="comment">/* 展开即为 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">mylist</span> =</span> &#123; &amp;(mylist), &amp;(mylist) &#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>动态初始化</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIST_HEAD_INIT(name) &#123; &amp;(name), &amp;(name) &#125;</span></span><br><span class="line"><span class="comment">/* 或者 */</span></span><br><span class="line"><span class="function">struct <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">INIT_LIST_HEAD</span><span class="params">(struct list_head *<span class="built_in">list</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    WRITE_ONCE(<span class="built_in">list</span>-&gt;next, <span class="built_in">list</span>);</span><br><span class="line">    <span class="built_in">list</span>-&gt;prev = <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 例如 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">mylist</span> =</span> LIST_HEAD_INIT(mylist);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">mylist2</span>;</span></span><br><span class="line">INIT_LIST_HEAD(&amp;mylist2);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>从<code>list_head</code>中获取对象结构体</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @ptr:	the list head to take the element from.</span></span><br><span class="line"><span class="comment"> * @type:	the type of the struct this is embedded in.</span></span><br><span class="line"><span class="comment"> * @member:	the name of the list_head within the struct.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实际就是使用container_of通过list_head地址来获取原结构体的地址</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_entry(ptr, type, member) \</span></span><br><span class="line"><span class="meta">    container_of(ptr, type, member)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取链表上的第一个节点，这里ptr传入的默认应该是链表头节点，且传入的这个ptr不能为空指针</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_first_enrty(ptr, type, member) \</span></span><br><span class="line"><span class="meta">    container_of((ptr)-&gt;next, type, member)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取链表上的最后一个节点，通过双向链表的prev指针来获取</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_last_entry(ptr, type, member) \</span></span><br><span class="line"><span class="meta">    container_of((ptr)-&gt;prev, type, member)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断当前给入的链表是否为空链表，不为空表返回下一个节点对应的结构体地址</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_first_enrty_or_null(ptr, type, member) (&#123; \</span></span><br><span class="line"><span class="meta">    struct list_head *head__ = (ptr); \</span></span><br><span class="line"><span class="meta">    struct list_head *pos__ = READ_ONCE(head__-&gt;next); \</span></span><br><span class="line"><span class="meta">    pos__ != head__ ? list_entry(pos__, type, member) : NULL; \</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* @pos:     含list_head结构体对象的指针</span></span><br><span class="line"><span class="comment">* @member:  list_head在这个结构体中的成员名</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 通过结构体对象的指针来获取链表中下一个节点的结构体对象地址</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_next_entry(pos, member) \</span></span><br><span class="line"><span class="meta">    list_entry((pos)-&gt;member.next, typeof(*(pos)), member)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过结构体对象的指针来获取链表中上一个节点的结构体对象地址</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_prev_entry(pos, member) \</span></span><br><span class="line"><span class="meta">    list_entry((pos)-&gt;member.prev, typeof(*(pos)), member)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>list_head</code>增加节点</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> __list_add(struct list_head *<span class="keyword">new</span>,</span><br><span class="line">                struct list_head *prev,</span><br><span class="line">                struct list_head *next)</span><br><span class="line">&#123;</span><br><span class="line">    next-&gt;prev = <span class="keyword">new</span>;</span><br><span class="line">    <span class="keyword">new</span>-&gt;next = next;</span><br><span class="line">    <span class="keyword">new</span>-&gt;prev = prev;</span><br><span class="line">    prev-&gt;next = <span class="keyword">new</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* new插入到head后 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">list_add</span><span class="params">(struct list_head *<span class="keyword">new</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                struct list_head *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __list_add(<span class="keyword">new</span>, head, head-&gt;next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* new插入到head之前 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">list_add_tail</span><span class="params">(struct list_head *<span class="keyword">new</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                struct list_node *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __list_add(<span class="keyword">new</span>, head-&gt;prev, head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>遍历<code>list_head</code></p>
<ul>
<li><p>通过<code>list_head</code>的头节点向后遍历整个链表</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @pos:    the &amp;struct list_head to use as a loop cursor</span></span><br><span class="line"><span class="comment"> * @head:   the head for your list</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_for_each(pos, head) \</span></span><br><span class="line"><span class="meta">    for (pos = (head)-&gt;next; pos != (head); pos = pos-&gt;next)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>通过<code>list_head</code>的头节点向前遍历整个链表</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_for_each_prev(pos, head) \</span></span><br><span class="line"><span class="meta">    for (pos = (head)-&gt;prev; pos != (head); pos = pos-&gt;prev)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>通过<code>list_head</code>的头节点向后遍历链表，这里使用<code>n</code>来存储<code>pos</code>指向的下一个节点的原因主要就是若：当前循环对<code>pos</code>进行了删除操作，因为<code>n</code>存储了下一个节点，那么可以保证遍历安全的进行下去</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @pos:    the &amp;struct list_head to use as a loop cursor</span></span><br><span class="line"><span class="comment"> * @n:      another &amp;struct list_head to use a temporary storage</span></span><br><span class="line"><span class="comment"> * @head:   the head for your list</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_for_each_safe(pos, n, head) \</span></span><br><span class="line"><span class="meta">    for (pos = (head)-&gt;next, n = pos-&gt;next; pos != head; \</span></span><br><span class="line"><span class="meta">        pos = n, n = pos-&gt;next)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>通过<code>list_head</code>的头节点向前遍历链表</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_for_each_prev_safe(pos, n, head) \</span></span><br><span class="line"><span class="meta">    for (pos = (head)-&gt;prev, n = pos-&gt;prev; pos != head; \</span></span><br><span class="line"><span class="meta">        pos = n, n = pos-&gt;prev)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>通过<code>list_head</code>指针来向后遍历链表上的所有结构体对象</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_for_each_entry(pos, head, member) \</span></span><br><span class="line"><span class="meta">    for (pos = list_first_entry((head), typeof(*pos), member); \</span></span><br><span class="line"><span class="meta">        &amp;pos-&gt;member != (head); \</span></span><br><span class="line"><span class="meta">        pos = list_next_entry(pos, member))</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>通过<code>list_head</code>指针来向前遍历链表上的所有的结构体对象</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_for_each_entry_reverse(pos, head, member) \</span></span><br><span class="line"><span class="meta">    for (pos = list_last_entry((head), typeof(*pos), member); \</span></span><br><span class="line"><span class="meta">        &amp;pos-&gt;member != (head); \</span></span><br><span class="line"><span class="meta">        pos = list_prev_entry(pos, member))</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>通过给定的结构体指针<code>pos</code>和链表头，<code>pos</code>不能为空，从下一个节点开始继续向后遍历链表</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_for_each_entry_continue(pos, head, member) \</span></span><br><span class="line"><span class="meta">    for (pos = list_next_entry(pos, member); \</span></span><br><span class="line"><span class="meta">        &amp;pos-&gt;member != (head); \</span></span><br><span class="line"><span class="meta">        pos = list_next_entry(pos, member))</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>通过给定的结构体指针<code>pos</code>和链表头，<code>pos</code>不能为空，从上一个节点开始继续向前遍历链表</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_for_each_entry_continue_reverse(pos, head, member) \</span></span><br><span class="line"><span class="meta">    for (pos = list_prev_entry(pos, member); \</span></span><br><span class="line"><span class="meta">        &amp;pos-&gt;member != (head); \</span></span><br><span class="line"><span class="meta">        pos = list_prev_entry(pos, member))</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>通过给定的结构体指针<code>pos</code>和链表头，<code>pos</code>不能为空，从当前节点开始继续向后遍历链表</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_for_each_entry_from(pos, head, member) \</span></span><br><span class="line"><span class="meta">    for (; &amp;pos-&gt;member != (head); \</span></span><br><span class="line"><span class="meta">        pos = list_next_entry(pos, member))</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>通过给定的结构体指针<code>pos</code>和链表头，来安全的遍历链表，可以在循环中对当前遍历的结构体进行删除操作</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* list_for_each_entry_safe - iterate over list of given type safe against removal of list entry</span></span><br><span class="line"><span class="comment">* @pos:	    the type * to use as a loop cursor.</span></span><br><span class="line"><span class="comment">* @n:		another type * to use as temporary storage</span></span><br><span class="line"><span class="comment">* @head:	the head for your list.</span></span><br><span class="line"><span class="comment">* @member:	the name of the list_head within the struct.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_for_each_entry_safe(pos, n, head, member)			\</span></span><br><span class="line"><span class="meta">    for (pos = list_first_entry(head, typeof(*pos), member),	\</span></span><br><span class="line"><span class="meta">        n = list_next_entry(pos, member);			\</span></span><br><span class="line"><span class="meta">        !list_entry_is_head(pos, head, member); 			\</span></span><br><span class="line"><span class="meta">        pos = n, n = list_next_entry(n, member))</span></span><br></pre></td></tr></table></figure>
<p>  <code>platform</code>总线初始化的时候<code>platform_bus_init()</code>会调用<code>early_platform_clean()</code>来清除<code>early_platform_device_list</code>链表，代码如下：</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> __initdata <span class="title">LIST_HEAD</span><span class="params">(early_platform_device_list)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * early_platform_cleanup - clean up early platform code</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> __init <span class="title">early_platform_cleanup</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> *<span class="title">pd</span>, *<span class="title">pd2</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* clean up the devres list used to chain devices */</span></span><br><span class="line">    list_for_each_entry_safe(pd, pd2, &amp;early_platform_device_list,</span><br><span class="line">                 dev.devres_head) &#123;</span><br><span class="line">        list_del(&amp;pd-&gt;dev.devres_head);</span><br><span class="line">        <span class="built_in">memset</span>(&amp;pd-&gt;dev.devres_head, <span class="number">0</span>, <span class="keyword">sizeof</span>(pd-&gt;dev.devres_head));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  采用这种遍历的方式可以安全的删除当前遍历的节点</p>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>List</tag>
      </tags>
  </entry>
  <entry>
    <title>Platform设备驱动</title>
    <url>/archives/f8def83d.html</url>
    <content><![CDATA[<h4 id="Platform平台驱动模型"><a href="#Platform平台驱动模型" class="headerlink" title="Platform平台驱动模型"></a>Platform平台驱动模型</h4><p>由于某些外设是没有总线这个概念的，但是又要使用总线、驱动和设备模型的话，就需要使用<code>platform</code>这个虚拟总线，相应的就有<code>platform_device</code>和<code>platform_driver</code></p>
<span id="more"></span>

<h4 id="Platform总线"><a href="#Platform总线" class="headerlink" title="Platform总线"></a>Platform总线</h4><p>Linux内核使用<code>bus_type</code>结构体表示总线，该结构体定义在<code>include/linux/device.h</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>		*name;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>		*dev_name;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span>		*<span class="title">dev_root</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> **<span class="title">bus_groups</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> **<span class="title">dev_groups</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> **<span class="title">drv_groups</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> (*match)(struct device *dev, struct device_driver *drv);</span><br><span class="line">    <span class="keyword">int</span> (*uevent)(struct device *dev, struct kobj_uevent_env *env);</span><br><span class="line">    <span class="keyword">int</span> (*probe)(struct device *dev);</span><br><span class="line">    <span class="keyword">int</span> (*remove)(struct device *dev);</span><br><span class="line">    <span class="keyword">void</span> (*shutdown)(struct device *dev);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> (*online)(struct device *dev);</span><br><span class="line">    <span class="keyword">int</span> (*offline)(struct device *dev);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> (*suspend)(struct device *dev, <span class="keyword">pm_message_t</span> state);</span><br><span class="line">    <span class="keyword">int</span> (*resume)(struct device *dev);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> (*num_vf)(struct device *dev);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> (*dma_configure)(struct device *dev);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dev_pm_ops</span> *<span class="title">pm</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">iommu_ops</span> *<span class="title">iommu_ops</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">subsys_private</span> *<span class="title">p</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">lock_key</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> need_parent_lock;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>设备和驱动的匹配函数：<br><code>int (*match)(struct device *dev, struct device_driver*drv)</code><br>match函数有两个参数dev和driver，这两个参数分别为<code>device</code>和<code>device_driver</code>类型，也就是设备和驱动</p>
<p>platform总线是<code>bus_type</code>的一个具体实例，定义在<code>driver/base/platform.c</code>中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> <span class="title">platform_bus_type</span> =</span> &#123;</span><br><span class="line">    .name		= <span class="string">&quot;platform&quot;</span>,</span><br><span class="line">    .dev_groups	= platform_dev_groups,</span><br><span class="line">    .match		= platform_match,</span><br><span class="line">    .uevent		= platform_uevent,</span><br><span class="line">    .dma_configure	= platform_dma_configure,</span><br><span class="line">    .pm		= &amp;platform_dev_pm_ops,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中<code>platform_match</code>为驱动和设备的匹配函数，<code>platform_match</code>函数如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">platform_match</span><span class="params">(struct device *dev, struct device_driver *drv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> *<span class="title">pdev</span> =</span> to_platform_device(dev);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> *<span class="title">pdrv</span> =</span> to_platform_driver(drv);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* When driver_override is set, only bind to the matching driver */</span></span><br><span class="line">    <span class="keyword">if</span> (pdev-&gt;driver_override)</span><br><span class="line">        <span class="keyword">return</span> !<span class="built_in">strcmp</span>(pdev-&gt;driver_override, drv-&gt;name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Attempt an OF style match first */</span></span><br><span class="line">    <span class="keyword">if</span> (of_driver_match_device(dev, drv))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Then try ACPI style match */</span></span><br><span class="line">    <span class="keyword">if</span> (acpi_driver_match_device(dev, drv))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Then try to match against the id table */</span></span><br><span class="line">    <span class="keyword">if</span> (pdrv-&gt;id_table)</span><br><span class="line">        <span class="keyword">return</span> platform_match_id(pdrv-&gt;id_table, pdev) != <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* fall-back to driver name match */</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">strcmp</span>(pdev-&gt;name, drv-&gt;name) == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>platform驱动和设备匹配一共有四种方法:<ul>
<li>OF类型的匹配，也就是采用设备树的方式，<code>of_driver_match_device()</code>定义在文件 <code>/include/linux/of_device</code>中，<code>device_drive</code>结构体中有一个名为<code>of_match_table</code>的成员变量，该成员保存着驱动的compatible匹配表，设备树中的每个设备节点的compatible属性会和of_match_table中的所有成员比较，查看是否有相同的条目，如果有的话表示设备和驱动相匹配，设备和驱动匹配成功后，probe函数就会执行</li>
<li>ACPI匹配方式</li>
<li><code>id_table</code>匹配，每个<code>platform_driver</code>结构体有一个<code>id_table</code>成员变量，保留了很多id信息，这些id信息存放着这个驱动所支持的设备信息，该<code>id_table</code>会与<code>platform_device</code>中的<code>name</code>成员相比较</li>
<li>如果<code>id_table</code>不存在的话就直接比较驱动和设备的<code>name</code>字段，看看是否相等</li>
</ul>
</li>
</ul>
<h5 id="Platform总线初始化过程"><a href="#Platform总线初始化过程" class="headerlink" title="Platform总线初始化过程"></a>Platform总线初始化过程</h5><p>内核在初始化过程中调用<code>platform_bus_init()</code>来初始化Platform总线，调用流程如下<br><code>kernel_init_freeable() -&gt; do_basic_setup() -&gt; driver_init() -&gt; platform_bus_init()</code><br>其中<code>platform_bus_init()</code>函数定义在<code>driver/base/platform.c</code>中，内容如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __init <span class="title">platform_bus_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line"></span><br><span class="line">    early_platform_cleanup();</span><br><span class="line"></span><br><span class="line">    error = device_register(&amp;platform_bus);</span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        put_device(&amp;platform_bus);</span><br><span class="line">        <span class="keyword">return</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">    error =  bus_register(&amp;platform_bus_type);</span><br><span class="line">    <span class="keyword">if</span> (error)</span><br><span class="line">        device_unregister(&amp;platform_bus);</span><br><span class="line">    of_platform_register_reconfig_notifier();</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先来看<code>earlt_platform_cleanup()</code>这个函数，位于<code>arch/sh/drivers/platform_early.c</code>中，这个函数主要的功能就是清空<code>sh_early_platform_device_list)</code>这个链表，然后向内核注册<code>platform_bus</code>这个设备和<code>platform_bus_type</code>总线</p>
<h4 id="Platform驱动"><a href="#Platform驱动" class="headerlink" title="Platform驱动"></a>Platform驱动</h4><ul>
<li><p><code>platform_driver</code>结构体表示<code>platform</code>驱动，定义在<code>include/linux/platform.h</code>里面</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> (*probe)(struct platform_device *);</span><br><span class="line">    <span class="keyword">int</span> (*remove)(struct platform_device *);</span><br><span class="line">    <span class="keyword">void</span> (*shutdown)(struct platform_device *);</span><br><span class="line">    <span class="keyword">int</span> (*suspend)(struct platform_device *, <span class="keyword">pm_message_t</span> state);</span><br><span class="line">    <span class="keyword">int</span> (*resume)(struct platform_device *);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_driver</span> <span class="title">driver</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_device_id</span> *<span class="title">id_table</span>;</span></span><br><span class="line">    <span class="keyword">bool</span> prevent_deferred_probe;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>  当驱动和设备匹配成功后<code>platform_driver</code>的<code>probe</code>函数就会执行，<code>driver</code>成员为<code>device_driver</code>结构体变量，<code>device_driver</code>相当于基类，提供了最基础的驱动框架，<code>platform_driver</code>相当于继承了这个基类，在这个基类基础上添加了一些特有的成员变量</p>
</li>
<li><p><code>device_driver</code>结构体定义在*<code>include/linux/device.h</code>，内容如下</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_driver</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>		*name;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span>		*<span class="title">bus</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span>		*<span class="title">owner</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>		*mod_name;	<span class="comment">/* used for built-in modules */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> suppress_bind_attrs;	<span class="comment">/* disables bind/unbind via sysfs */</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">probe_type</span> <span class="title">probe_type</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span>	*<span class="title">of_match_table</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">acpi_device_id</span>	*<span class="title">acpi_match_table</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> (*probe) (struct device *dev);</span><br><span class="line">    <span class="keyword">int</span> (*remove) (struct device *dev);</span><br><span class="line">    <span class="keyword">void</span> (*shutdown) (struct device *dev);</span><br><span class="line">    <span class="keyword">int</span> (*suspend) (struct device *dev, <span class="keyword">pm_message_t</span> state);</span><br><span class="line">    <span class="keyword">int</span> (*resume) (struct device *dev);</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> **<span class="title">groups</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dev_pm_ops</span> *<span class="title">pm</span>;</span></span><br><span class="line">    <span class="keyword">void</span> (*coredump) (struct device *dev);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">driver_private</span> *<span class="title">p</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在编写<code>platform</code>驱动的时候，首先需要定义一个<code>platform_driver</code>结构体变量，实现结构体中的成员变量，重点是实现匹配方法和<code>probe</code>函数，具体的驱动程序在<code>probe</code>里面编写</p>
</li>
<li><p>定义好<code>platform_driver</code>结构体变量以后，需要在驱动入口函数里面调用<code>platform_driver_register()</code>函数向内核注册一个platform驱动，         <code>platform_driver_register()</code>函数的原型如下：<br><code>int platform_driver_register(struct platform_driver *driver)</code><br>还需要在驱动卸载函数中通过<code>platform_driver_unregister()</code>来卸载platform驱动，函数原型如下：<br><code>int platform_driver_unregister(struct platform_driver *driver)</code></p>
</li>
</ul>
<h4 id="Platform设备"><a href="#Platform设备" class="headerlink" title="Platform设备"></a>Platform设备</h4><ul>
<li><p><code>platform_device</code>结构体表示<code>platfrom</code>设备，如果内核支持设备树的话，就不需要使用<code>platform_device</code>来描述设备，改用设备树来描述，<code>platform_device</code>结构体定义在<em>include&#x2F;linux&#x2F;platform_device.h</em>中，结构体的内容如下：</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>	*name;</span><br><span class="line">    <span class="keyword">int</span>		id;</span><br><span class="line">    <span class="keyword">bool</span>		id_auto;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span>	<span class="title">dev</span>;</span></span><br><span class="line">    u32		num_resources;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">resource</span>	*<span class="title">resource</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_device_id</span>	*<span class="title">id_entry</span>;</span></span><br><span class="line">    <span class="keyword">char</span> *driver_override; <span class="comment">/* Driver name to force a match */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* MFD cell pointer */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mfd_cell</span> *<span class="title">mfd_cell</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* arch specific additions */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pdev_archdata</span>	<span class="title">archdata</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>name</code>表示设备的名字，要和所使用的<code>platform_driver</code>的<code>name</code>字段相同，否则设备无法匹配到对应的驱动</li>
<li><code>resource</code>表示资源，一般用来表示设备的寄存器信息，结构体内容如下  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">resource</span> &#123;</span></span><br><span class="line">    <span class="keyword">resource_size_t</span> start;</span><br><span class="line">    <span class="keyword">resource_size_t</span> end;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> desc;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">parent</span>, *<span class="title">sibling</span>, *<span class="title">child</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
  <code>start</code>和<code>end</code>分别表示资源的起始和终止信息，对于内存类资源就表示内存起始和终止地址，<code>name</code>表示资源名称，<code>flag</code>表示资源类型</li>
</ul>
</li>
<li><p>Linux支持设备树之后就不需要用户去手动注册<code>platform</code>设备了，因为设备信息都放到设备树中去描述，Linux内核启动的时候会从设备树中读取设备信息，然后将其组织成<code>platform_device</code>形式</p>
</li>
</ul>
<h4 id="Platform驱动匹配过程"><a href="#Platform驱动匹配过程" class="headerlink" title="Platform驱动匹配过程"></a>Platform驱动匹配过程</h4><ul>
<li><p>这里使用phytium i2c适配器驱动分析，驱动文件位于<code>drivers/i2c/busses/i2c-phytium-platform.c</code>，在<code>module_platform_driver(phytium_i2c_driver)</code>进行<code>platform_drvier</code>的注册，<code>module_platform_driver</code>是一个宏定义，该宏定义定义在<code>include/linux/platform_device.h</code>其内容如下：</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> module_platform_driver(__platform_drvier) module_driver(__platform_drvier, platform_drvier_register, platform_drvier_unregister)</span></span><br></pre></td></tr></table></figure>
<p>  继续对<em>module_driver</em>宏进行展开，其内容如下：  </p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> module_driver(__driver, __register, __unregister, ...) \</span></span><br><span class="line"><span class="meta">static int __init __driver##_init(void) \</span></span><br><span class="line"><span class="meta">&#123; \</span></span><br><span class="line"><span class="meta">    return __register(&amp;(__driver) , ##__VA_ARGS__); \</span></span><br><span class="line"><span class="meta">&#125; \</span></span><br><span class="line"><span class="meta">module_init(__driver##_init); \</span></span><br><span class="line"><span class="meta">static void __exit __driver##_exit(void) \</span></span><br><span class="line"><span class="meta">&#123; \</span></span><br><span class="line"><span class="meta">    __unregister(&amp;(__driver) , ##__VA_ARGS__); \</span></span><br><span class="line"><span class="meta">&#125; \</span></span><br><span class="line"><span class="meta">module_exit(__driver##_exit);</span></span><br></pre></td></tr></table></figure>
<p>  最终展开后的内容相当于：</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">phytium_i2c_driver_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> platform_driver_register(&amp;(phytium_i2c_driver));</span><br><span class="line">&#125;</span><br><span class="line">module_init(phytium_i2c_driver_init);</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __exit <span class="title">phytium_i2c_driver_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> platform_driver_unregister(&amp;(phytium_i2c_driver));</span><br><span class="line">&#125;</span><br><span class="line">moudle_exit(phytium_i2c_driver_exit);</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>moudle_init</code>中调用了<code>platform_drvier_register(&amp;phytium_i2c_driver)</code>，<code>platform_driver_regsiter</code>又是一个宏定义，定义在<code>include/linux/platform_device.h</code>中，其内容如下：<br><code>#define platform_driver_regsiter(drv) __platform_drvier_register(drv, THIS_MODULE)</code><br>其中<code>__platform_drvier_register()</code>函数的定义如下：  </p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> __platform_drvier_register(struct platform_deriver *drv, struct <span class="keyword">module</span> *owner)`</span><br><span class="line">&#123;</span><br><span class="line">    drv-&gt;driver.owner = owner;</span><br><span class="line">    drv-&gt;driver.bus = &amp;platform_bus_type;</span><br><span class="line">    drv-&gt;driver.probe = platform_drv_porbe;</span><br><span class="line">    drv-&gt;driver.remove = platform_drv_remove;</span><br><span class="line">    drv-&gt;driver.shutdown = platform_drv_shutdown;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> driver_register(&amp;drv-&gt;driver);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  其中<code>driver</code>成员的类型为之前提到的<code>device_driver</code>结构体，<code>driver-&gt;bus</code>指向了<code>platform_bus_type</code></p>
</li>
<li><p>继续来看<code>driver_register(&amp;drv-&gt;driver)</code>，该函数位于<code>driver/base/driver.c</code>中，其内容如下</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">driver_register</span><span class="params">(struct device_driver *drv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_driver</span> *<span class="title">other</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!drv-&gt;bus-&gt;p) &#123;</span><br><span class="line">        pr_err(<span class="string">&quot;Driver &#x27;%s&#x27; was unable to register with bus_type &#x27;%s&#x27; because the bus was not initialized.\n&quot;</span>,</span><br><span class="line">            drv-&gt;name, drv-&gt;bus-&gt;name);</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 检测总线的操作函数和驱动的操作函数是否都已经定义好 */</span></span><br><span class="line">    <span class="keyword">if</span> ((drv-&gt;bus-&gt;probe &amp;&amp; drv-&gt;probe) ||</span><br><span class="line">        (drv-&gt;bus-&gt;remove &amp;&amp; drv-&gt;remove) ||</span><br><span class="line">        (drv-&gt;bus-&gt;shutdown &amp;&amp; drv-&gt;shutdown))</span><br><span class="line">        printk(KERN_WARNING <span class="string">&quot;Driver &#x27;%s&#x27; needs updating - please use &quot;</span></span><br><span class="line">            <span class="string">&quot;bus_type methods\n&quot;</span>, drv-&gt;name);</span><br><span class="line"></span><br><span class="line">    other = driver_find(drv-&gt;name, drv-&gt;bus);</span><br><span class="line">    <span class="keyword">if</span> (other) &#123;</span><br><span class="line">        printk(KERN_ERR <span class="string">&quot;Error: Driver &#x27;%s&#x27; is already registered, &quot;</span></span><br><span class="line">            <span class="string">&quot;aborting...\n&quot;</span>, drv-&gt;name);</span><br><span class="line">        <span class="keyword">return</span> -EBUSY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = bus_add_driver(drv);</span><br><span class="line">    <span class="keyword">if</span> (ret)</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    ret = driver_add_groups(drv, drv-&gt;groups);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        bus_remove_driver(drv);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    kobject_uevent(&amp;drv-&gt;p-&gt;kobj, KOBJ_ADD);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  <code>driver_register()</code>中调用了<code>bus_add_driver(drv)</code>，该函数位于<code>driver/base/bus.c</code>中，<code>bus_add_driver()</code>源码如下：</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * bus_add_driver - Add a driver to the bus.</span></span><br><span class="line"><span class="comment"> * @drv: driver.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bus_add_driver</span><span class="params">(struct device_driver *drv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> *<span class="title">bus</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">driver_private</span> *<span class="title">priv</span>;</span></span><br><span class="line">	<span class="keyword">int</span> error = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	bus = bus_get(drv-&gt;bus);</span><br><span class="line">	<span class="keyword">if</span> (!bus)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	pr_debug(<span class="string">&quot;bus: &#x27;%s&#x27;: add driver %s\n&quot;</span>, bus-&gt;name, drv-&gt;name);</span><br><span class="line"></span><br><span class="line">	priv = kzalloc(<span class="keyword">sizeof</span>(*priv), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!priv) &#123;</span><br><span class="line">		error = -ENOMEM;</span><br><span class="line">		<span class="keyword">goto</span> out_put_bus;</span><br><span class="line">	&#125;</span><br><span class="line">	klist_init(&amp;priv-&gt;klist_devices, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">	priv-&gt;driver = drv;</span><br><span class="line">	drv-&gt;p = priv;</span><br><span class="line">	priv-&gt;kobj.kset = bus-&gt;p-&gt;drivers_kset;</span><br><span class="line">	error = kobject_init_and_add(&amp;priv-&gt;kobj, &amp;driver_ktype, <span class="literal">NULL</span>,</span><br><span class="line">				     <span class="string">&quot;%s&quot;</span>, drv-&gt;name);</span><br><span class="line">	<span class="keyword">if</span> (error)</span><br><span class="line">		<span class="keyword">goto</span> out_unregister;</span><br><span class="line"></span><br><span class="line">	klist_add_tail(&amp;priv-&gt;knode_bus, &amp;bus-&gt;p-&gt;klist_drivers);</span><br><span class="line">	<span class="keyword">if</span> (drv-&gt;bus-&gt;p-&gt;drivers_autoprobe) &#123;</span><br><span class="line">		error = driver_attach(drv);</span><br><span class="line">		<span class="keyword">if</span> (error)</span><br><span class="line">			<span class="keyword">goto</span> out_unregister;</span><br><span class="line">	&#125;</span><br><span class="line">	module_add_driver(drv-&gt;owner, drv);</span><br><span class="line"></span><br><span class="line">	error = driver_create_file(drv, &amp;driver_attr_uevent);</span><br><span class="line">	<span class="keyword">if</span> (error) &#123;</span><br><span class="line">		printk(KERN_ERR <span class="string">&quot;%s: uevent attr (%s) failed\n&quot;</span>,</span><br><span class="line">			__func__, drv-&gt;name);</span><br><span class="line">	&#125;</span><br><span class="line">	error = driver_add_groups(drv, bus-&gt;drv_groups);</span><br><span class="line">	<span class="keyword">if</span> (error) &#123;</span><br><span class="line">		<span class="comment">/* How the hell do we get out of this pickle? Give up */</span></span><br><span class="line">		printk(KERN_ERR <span class="string">&quot;%s: driver_create_groups(%s) failed\n&quot;</span>,</span><br><span class="line">			__func__, drv-&gt;name);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!drv-&gt;suppress_bind_attrs) &#123;</span><br><span class="line">		error = add_bind_files(drv);</span><br><span class="line">		<span class="keyword">if</span> (error) &#123;</span><br><span class="line">			<span class="comment">/* Ditto */</span></span><br><span class="line">			printk(KERN_ERR <span class="string">&quot;%s: add_bind_files(%s) failed\n&quot;</span>,</span><br><span class="line">				__func__, drv-&gt;name);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">out_unregister:</span><br><span class="line">	kobject_put(&amp;priv-&gt;kobj);</span><br><span class="line">	<span class="comment">/* drv-&gt;p is freed in driver_release()  */</span></span><br><span class="line">	drv-&gt;p = <span class="literal">NULL</span>;</span><br><span class="line">out_put_bus:</span><br><span class="line">	bus_put(bus);</span><br><span class="line">	<span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Platform</tag>
      </tags>
  </entry>
  <entry>
    <title>phytium i2c适配器驱动</title>
    <url>/archives/1dd4e6b7.html</url>
    <content><![CDATA[<h4 id="I2C总线驱动"><a href="#I2C总线驱动" class="headerlink" title="I2C总线驱动"></a>I2C总线驱动</h4><ul>
<li><p>I2C总线驱动重点是I2C适配器（也就是SOC的I2C接口）控制器驱动，这里涉及到两个重要的数据结构：i2c_adapter和i2c_algorithm，Linux内核将SOC的I2C控制器抽象成i2c_adapter，i2c_adapter定义在include&#x2F;linux&#x2F;i2c.h中，结构体的内容如下：</p>
<span id="more"></span>
  <figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="type">i2c_adapter</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="type">module</span> *owner;</span><br><span class="line">    unsigned int class;		  <span class="comment">/* classes to allow probing for */</span></span><br><span class="line">    const <span class="keyword">struct</span> <span class="type">i2c_algorithm</span> *algo; <span class="comment">/* the algorithm to access the bus */</span></span><br><span class="line">    void *algo_data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* data fields that are valid for all devices	*/</span></span><br><span class="line">    const <span class="keyword">struct</span> <span class="type">i2c_lock_operations</span> *lock_ops;</span><br><span class="line">    <span class="keyword">struct</span> <span class="type">rt_mutex</span> bus_lock;</span><br><span class="line">    <span class="keyword">struct</span> <span class="type">rt_mutex</span> mux_lock;</span><br><span class="line"></span><br><span class="line">    int timeout;			<span class="comment">/* in jiffies */</span></span><br><span class="line">    int retries;</span><br><span class="line">    <span class="keyword">struct</span> <span class="type">device</span> dev;		<span class="comment">/* the adapter device */</span></span><br><span class="line"></span><br><span class="line">    int nr;</span><br><span class="line">    char name[<span class="number">48</span>];</span><br><span class="line">    <span class="keyword">struct</span> <span class="type">completion</span> dev_released;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="type">mutex</span> userspace_clients_lock;</span><br><span class="line">    <span class="keyword">struct</span> <span class="type">list_head</span> userspace_clients;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="type">i2c_bus_recovery_info</span> *bus_recovery_info;</span><br><span class="line">    const <span class="keyword">struct</span> <span class="type">i2c_adapter_quirks</span> *quirks;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="type">irq_domain</span> *host_notify_domain;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>  其中algo成员为i2c适配器对外提供的API读写操作函数，i2c_algorithm为I2C适配器和I2C设备通信的方法，i2c_algorithm结构体的内容如下：</p>
  <figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> i2c_algorithm &#123;</span><br><span class="line">    <span class="comment">/* If an adapter algorithm can&#x27;t do I2C-level access, set master_xfer</span></span><br><span class="line"><span class="comment">       to NULL. If an adapter algorithm can do SMBus access, set</span></span><br><span class="line"><span class="comment">       smbus_xfer. If set to NULL, the SMBus protocol is simulated</span></span><br><span class="line"><span class="comment">       using common I2C messages */</span></span><br><span class="line">    <span class="comment">/* master_xfer should return the number of messages successfully</span></span><br><span class="line"><span class="comment">       processed, or a negative value on error */</span></span><br><span class="line">    <span class="keyword">int</span> (*master_xfer)(<span class="keyword">struct</span> i2c_adapter *adap, <span class="keyword">struct</span> i2c_msg *msgs,</span><br><span class="line">               <span class="keyword">int</span> num);</span><br><span class="line">    <span class="keyword">int</span> (*smbus_xfer) (<span class="keyword">struct</span> i2c_adapter *adap, u16 addr,</span><br><span class="line">               <span class="keyword">unsigned</span> <span class="keyword">short</span> flags, <span class="keyword">char</span> read_write,</span><br><span class="line">               u8 command, <span class="keyword">int</span> size, <span class="keyword">union</span> i2c_smbus_data *data);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* To determine what the adapter supports */</span></span><br><span class="line">    u32 (*functionality) (<span class="keyword">struct</span> i2c_adapter *);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> IS_ENABLED(CONFIG_I2C_SLAVE)</span></span><br><span class="line">    <span class="keyword">int</span> (*reg_slave)(<span class="keyword">struct</span> i2c_client *client);</span><br><span class="line">    <span class="keyword">int</span> (*unreg_slave)(<span class="keyword">struct</span> i2c_client *client);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>master_xfer是I2C适配器的的传输函数</li>
<li>smbus_xfer是SMBUS总线的传输函数</li>
</ul>
</li>
<li><p>I2C适配器驱动的主要工作就是初始化i2c_adapter的结构体变量，然后实现i2c_algorithm中的传输函数，完成后通过<em>i2c_add_numbered_adapter</em>或者<em>i2c_add_adapter</em>这两个函数向系统注册设置好的i2c_adapter，函数原型如下：<br><code>int i2c_add_adapter(struct i2c_adapter *adapter)</code><br><code>int i2c_add_numbered_adapter(struct i2c_adapter *adap)</code><br>i2c_add_adapter()使用动态的总线号，i2c_add_numbered_adapter()使用静态的总线号</p>
</li>
</ul>
<h4 id="phytium-i2c适配器驱动分析"><a href="#phytium-i2c适配器驱动分析" class="headerlink" title="phytium i2c适配器驱动分析"></a>phytium i2c适配器驱动分析</h4><ul>
<li><p>phytium i2c设备树节点内容</p>
  <figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="symbol">mio14:</span> <span class="class">i2c@28030000 </span>&#123;</span><br><span class="line">    compatible = <span class="string">&quot;phytium,i2c&quot;</span>;</span><br><span class="line">    reg = <span class="params">&lt;<span class="number">0x0</span> <span class="number">0x28030000</span> <span class="number">0x0</span> <span class="number">0x1000</span>&gt;</span>;</span><br><span class="line">    interrupts = <span class="params">&lt;GIC_SPI <span class="number">106</span> IRQ_TYPE_LEVEL_HIGH&gt;</span>;</span><br><span class="line">    clocks = <span class="params">&lt;<span class="variable">&amp;sysclk_50mhz</span>&gt;</span>;</span><br><span class="line">    <span class="meta">#address-cells = &lt;1&gt;;</span></span><br><span class="line">    <span class="meta">#size-cells = &lt;0&gt;;</span></span><br><span class="line">    status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>  对应的驱动文件为<em>drivers&#x2F;i2c&#x2F;busses&#x2F;i2c-phytium-platform.c</em></p>
</li>
<li><p>phytium i2c适配器驱动为一个标准的platform驱动</p>
  <figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">static struct platform_driver <span class="attr">phytium_i2c_driver</span> = &#123;</span><br><span class="line">    .<span class="attr">probe</span> = phytium_i2c_plat_probe,</span><br><span class="line">    .<span class="attr">remove</span> = phytium_i2c_plat_remove,</span><br><span class="line">    .<span class="attr">driver</span> = &#123;</span><br><span class="line">        .<span class="attr">name</span> = DRV_NAME,</span><br><span class="line">        .<span class="attr">of_match_table</span> = of_match_ptr(phytium_i2c_of_match),</span><br><span class="line">        .<span class="attr">acpi_match_table</span> = ACPI_PTR(phytium_i2c_acpi_match),</span><br><span class="line">        .<span class="attr">pm</span> = &amp;phytium_i2c_dev_pm_ops,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<em>of_device_id</em>与设备树mio14节点相匹配，在platform_match函数中进行匹配</p>
  <figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">static const <span class="keyword">struct</span> of_device_id phytium_i2c_of_match<span class="literal">[]</span> = &#123;</span><br><span class="line">    &#123; .compatible = <span class="string">&quot;phytium,i2c&quot;</span>, &#125;,</span><br><span class="line">    &#123;   &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="constructor">MODULE_DEVICE_TABLE(<span class="params">of</span>, <span class="params">phytium_i2c_of_match</span>)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>当设备和驱动匹配完成后，<em>phytium_i2c_plat_probe</em>函数就会执行，完成i2c适配器的初始化工作，probe中的工作如下：</p>
<ul>
<li>调用platform_get_irq()函数获取中断号</li>
<li>调用platform_get_resource()函数获取I2C控制器的寄存器物理基地址，获取到物理基地址后再使用devm_ioremap_resource()函数对其进行内存映射，得到可以在Linux内核中使用的虚拟内存地址</li>
<li>设置I2C设备总线速度</li>
<li>根据I2C地址第30位数据来判断当前I2C适配器配置成slave模式还是master模式，填充phytium_i2c_dev数据成员，主要设计适配器工作能力等一些参数标志</li>
<li>使能I2C总线时钟</li>
<li>调用i2c_phytium_probe()函数，该函数位于drivers&#x2F;i2c&#x2F;busses&#x2F;i2c-phytium-master.c，在i2c_phytium_probe()里面继续完善adapter数据成员</li>
</ul>
</li>
<li><p>phytium_i2c_dev结构体</p>
  <figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">struct phytium_i2c_dev &#123;</span><br><span class="line">    struct device		*dev<span class="comment">;</span></span><br><span class="line">    void __iomem		*base<span class="comment">;</span></span><br><span class="line">    int			irq<span class="comment">;</span></span><br><span class="line">    u32			flags<span class="comment">;</span></span><br><span class="line">    struct completion	cmd_complete<span class="comment">;</span></span><br><span class="line">    struct clk		*clk<span class="comment">;</span></span><br><span class="line">    struct reset_control	*rst<span class="comment">;</span></span><br><span class="line">    int			mode<span class="comment">;</span></span><br><span class="line">    struct i2c_client	*slave<span class="comment">;</span></span><br><span class="line">    u32			(*get_clk_rate_khz)(struct phytium_i2c_dev *dev)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    struct i2c_adapter	adapter<span class="comment">;</span></span><br><span class="line">    struct i2c_client	*ara<span class="comment">;</span></span><br><span class="line">    struct i2c_smbus_alert_setup alert_data<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    struct phytium_pci_i2c *controller<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    unsigned int		status<span class="comment">;</span></span><br><span class="line">    int			cmd_err<span class="comment">;</span></span><br><span class="line">    u32			abort_source<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    struct i2c_msg		*msgs<span class="comment">;</span></span><br><span class="line">    int			msgs_num<span class="comment">;</span></span><br><span class="line">    int			msg_write_idx<span class="comment">;</span></span><br><span class="line">    int			msg_read_idx<span class="comment">;</span></span><br><span class="line">    int			msg_err<span class="comment">;</span></span><br><span class="line">    u32			tx_buf_len<span class="comment">;</span></span><br><span class="line">    u8			*tx_buf<span class="comment">;</span></span><br><span class="line">    u32			rx_buf_len<span class="comment">;</span></span><br><span class="line">    u8			*rx_buf<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    u32			master_cfg<span class="comment">;</span></span><br><span class="line">    u32			slave_cfg<span class="comment">;</span></span><br><span class="line">    u32			functionality<span class="comment">;</span></span><br><span class="line">    unsigned int		tx_fifo_depth<span class="comment">;</span></span><br><span class="line">    unsigned int		rx_fifo_depth<span class="comment">;</span></span><br><span class="line">    int			rx_outstanding<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    struct i2c_timings	timings<span class="comment">;</span></span><br><span class="line">    u32			sda_hold_time<span class="comment">;</span></span><br><span class="line">    u16			ss_hcnt<span class="comment">;</span></span><br><span class="line">    u16			ss_lcnt<span class="comment">;</span></span><br><span class="line">    u16			fs_hcnt<span class="comment">;</span></span><br><span class="line">    u16			fs_lcnt<span class="comment">;</span></span><br><span class="line">    u16			fp_hcnt<span class="comment">;</span></span><br><span class="line">    u16			fp_lcnt<span class="comment">;</span></span><br><span class="line">    u16			hs_hcnt<span class="comment">;</span></span><br><span class="line">    u16			hs_lcnt<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    bool			pm_disabled<span class="comment">;</span></span><br><span class="line">    void			(*disable)(struct phytium_i2c_dev *dev)<span class="comment">;</span></span><br><span class="line">    void			(*disable_int)(struct phytium_i2c_dev *dev)<span class="comment">;</span></span><br><span class="line">    int			(*init)(struct phytium_i2c_dev *dev)<span class="comment">;</span></span><br><span class="line">&#125;<span class="comment">;</span></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>I2C</tag>
      </tags>
  </entry>
  <entry>
    <title>ASoC Platform Driver</title>
    <url>/archives/131a876a.html</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>ALSA是Advanced Linux Sound Architecture的缩写，<a href="https://www.alsa-project.org/">ALSA官网地址</a>  </p>
<span id="more"></span>

<p>ALSA作为Linux现在主流的音频体系架构，提供了内核的驱动框架，也提供了应用层的<br><code>alsa-lib</code>库，ALSA还提供了<code>alsa-utils</code>应用程序，方便进行音频控制</p>
<ul>
<li>音频设备文件结构如下<br><img src="https://raw.githubusercontent.com/JackHuang021/images/master/20221108112754.png"><ul>
<li>controlC0: 用于card0声卡的控制</li>
<li>pcmC0D0c: 用于card0 device0录音的pcm设备</li>
<li>pcmC0D0p: 用于card0 device0播放的pcm设备</li>
<li>timer: 定时器</li>
</ul>
</li>
<li>一个声卡可以有多个设备，一个设备可以有多个播放\录音通道，每个设备节点都对应一个fops，</li>
</ul>
<h3 id="ASoC驱动框架"><a href="#ASoC驱动框架" class="headerlink" title="ASoC驱动框架"></a>ASoC驱动框架</h3><ul>
<li><p>ASoC是建立在标准ALSA驱动层上，对底层的ALSA框架封装了一层，为了更好的支持嵌入式CPU和音频编解码设备的一套软件体系，ASoC驱动主要由Platform驱动、Codec驱动、Machine驱动组成。</p>
</li>
<li><p>CPU DAI：在嵌入式系统中通常指CPU的I2S或PCM总线控制器</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Digital Audio Interface Driver.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* Describes the Digital Audio Interface in terms of its ALSA, DAI and AC97</span></span><br><span class="line"><span class="comment">* operations and capabilities. Codec and platform drivers will register this</span></span><br><span class="line"><span class="comment">* structure for every DAI they have.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* This structure covers the clocking, formating and ALSA operations for each</span></span><br><span class="line"><span class="comment">* interface.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dai_driver</span> &#123;</span></span><br><span class="line">    <span class="comment">/* DAI description */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> id;                </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> base;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dobj</span> <span class="title">dobj</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* DAI driver callbacks */</span></span><br><span class="line">    <span class="keyword">int</span> (*probe)(struct snd_soc_dai *dai);</span><br><span class="line">    <span class="keyword">int</span> (*remove)(struct snd_soc_dai *dai);</span><br><span class="line">    <span class="keyword">int</span> (*suspend)(struct snd_soc_dai *dai);</span><br><span class="line">    <span class="keyword">int</span> (*resume)(struct snd_soc_dai *dai);</span><br><span class="line">    <span class="comment">/* compress dai */</span></span><br><span class="line">    <span class="keyword">int</span> (*compress_new)(struct snd_soc_pcm_runtime *rtd, <span class="keyword">int</span> num);</span><br><span class="line">    <span class="comment">/* Optional Callback used at pcm creation*/</span></span><br><span class="line">    <span class="keyword">int</span> (*pcm_new)(struct snd_soc_pcm_runtime *rtd,</span><br><span class="line">            struct snd_soc_dai *dai);</span><br><span class="line">    <span class="comment">/* DAI is also used for the control bus */</span></span><br><span class="line">    <span class="keyword">bool</span> bus_control;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ops */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dai_ops</span> *<span class="title">ops</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_cdai_ops</span> *<span class="title">cops</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* DAI capabilities */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_pcm_stream</span> <span class="title">capture</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_pcm_stream</span> <span class="title">playback</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> symmetric_rates:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> symmetric_channels:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> symmetric_samplebits:<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* probe ordering - for components with runtime dependencies */</span></span><br><span class="line">    <span class="keyword">int</span> probe_order;</span><br><span class="line">    <span class="keyword">int</span> remove_order;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>ASoC</tag>
      </tags>
  </entry>
  <entry>
    <title>phytium E2000搭建aarch64虚拟机</title>
    <url>/archives/4ed0329a.html</url>
    <content><![CDATA[<blockquote>
<p>最近需要在E2000平台上测试虚拟化功能，需要搭建一个arm64虚拟机用于测试，记录一下搭建过程</p>
</blockquote>
<h3 id="系统环境"><a href="#系统环境" class="headerlink" title="系统环境"></a>系统环境</h3><ul>
<li>E2000Q CPU，Linux内核版本4.19.246，Ubuntu 20.04</li>
<li>清华软件源</li>
<li>交叉编译工具，<code>gcc-linaro-7.5.0-2019.12-x86_64_aarch64-linux-gnu</code><span id="more"></span></li>
</ul>
<h3 id="qemu安装"><a href="#qemu安装" class="headerlink" title="qemu安装"></a>qemu安装</h3><ul>
<li>安装qemu，<code>apt-get install qemu-system-arm</code></li>
<li>安装aarch64 uefi固件，<code>apt-get install qemu-efi-aarch64</code></li>
</ul>
<h3 id="根文件系统制作"><a href="#根文件系统制作" class="headerlink" title="根文件系统制作"></a>根文件系统制作</h3><ul>
<li><p>下载BusyBox源码，<a href="https://busybox.net/downloads/">官网下载地址</a>，这里下载<code>1.33.1</code>版本</p>
</li>
<li><p>解压源码，进入源码目录，进行编译</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -xvf busybox-1.33.1.tar.bz2</span><br><span class="line"><span class="built_in">cd</span> busybox-1.33.1</span><br><span class="line"><span class="built_in">export</span> ARCH=arm64</span><br><span class="line"><span class="built_in">export</span> CROSS_COMPILE=aarch64-linux-gnu-</span><br><span class="line">make menuconfig</span><br></pre></td></tr></table></figure>
<p>  选择静态编译<br>  <img src="https://raw.githubusercontent.com/JackHuang021/images/master/20221107093137.png"></p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make -j12</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<p>  编译完成后，源码目录<code>_install</code>下会生成根文件系统</p>
</li>
<li><p>完善根文件系统</p>
<ul>
<li>创建其他目录<code>mkdir dev etc lib</code></li>
<li>创建<code>/etc/profile</code>文件  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">export</span> HOSTNAME=linux</span><br><span class="line"><span class="built_in">export</span> USER=root</span><br><span class="line"><span class="built_in">export</span> HOME=/home</span><br><span class="line"><span class="built_in">export</span> PS1=<span class="string">&quot;[<span class="variable">$USER</span>@<span class="variable">$HOSTNAME</span> \W]\# &quot;</span></span><br><span class="line">PATH=/bin:/sbin:/usr/bin:/usr/sbin</span><br><span class="line">LD_LIBRARY_PATH=/lib:/usr/lib:<span class="variable">$LD_LIBRARY_PATH</span></span><br><span class="line"><span class="built_in">export</span> PATH LD_LIBRARY_PATH</span><br></pre></td></tr></table></figure></li>
<li>创建<code>/etc/inittab</code>文件  <figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="meta">::sysinit:/etc/init.d/rcS</span></span><br><span class="line"><span class="meta">::respawn:-/bin/sh</span></span><br><span class="line"><span class="meta">::askfirst:-/bin/sh</span></span><br><span class="line"><span class="meta">::ctrlaltdel:/bin/umount</span> -a -r</span><br></pre></td></tr></table></figure></li>
<li>创建<code>/etc/init.d/rcS</code>文件  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir -p /sys</span><br><span class="line">mkdir -p /tmp</span><br><span class="line">mkdir -p /proc</span><br><span class="line">mkdir -p /mnt</span><br><span class="line">/bin/mount -a</span><br><span class="line">mkdir -p /dev/pts</span><br><span class="line">mount -t devpts devpts /dev/pts</span><br><span class="line"><span class="built_in">echo</span> /sbin/mdev &gt; /proc/sys/kernel/hotplug</span><br><span class="line">mdev -s</span><br></pre></td></tr></table></figure></li>
<li>制作<code>/dev</code>目录下必要的文件，<code>sudo mknod console c 5 1</code></li>
</ul>
</li>
<li><p>编译内核</p>
<ul>
<li>Linux源码下载地址，<a href="https://mirrors.edge.kernel.org/pub/linux/kernel/">官网下载地址</a></li>
<li>这里下载<code>4.19.262</code>版本，解压内核源码，将之前生成的根文件目录到内核源码目录  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -xvf linux-4.19.262.tar.xz</span><br><span class="line"><span class="built_in">cd</span> linux-4.19.246</span><br><span class="line">cp -a ../busybox-1.33.1/_install  rootfs -a</span><br><span class="line"><span class="built_in">export</span> ARCH=arm64</span><br><span class="line"><span class="built_in">export</span> CROSS_COMPILE=aarch64-linux-gnu-</span><br><span class="line">make defconfig</span><br><span class="line">make menucofig</span><br></pre></td></tr></table></figure>
  设置Initramfs支持<br>  <img src="https://raw.githubusercontent.com/JackHuang021/images/master/20221107112153.png">  <figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">make</span> <span class="literal">all</span> -j<span class="number">12</span></span><br></pre></td></tr></table></figure></li>
<li>将<code>arch/arm64/boot/Image</code>拷贝到E2000开发板上</li>
</ul>
</li>
</ul>
<h3 id="Qemu启动虚拟机"><a href="#Qemu启动虚拟机" class="headerlink" title="Qemu启动虚拟机"></a>Qemu启动虚拟机</h3><pre><code><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">   qemu-system-aarch64 \</span><br><span class="line">-enable-kvm \</span><br><span class="line">-m 2048 \</span><br><span class="line">-smp 4 \</span><br><span class="line">-cpu host \</span><br><span class="line">-M virt,gic-version=3 \</span><br><span class="line">-kernel Image \</span><br><span class="line">-append <span class="string">&quot;rdinit=/linuxrc console=ttyAMA0 loglevel=8&quot;</span> \</span><br><span class="line">-net none \</span><br><span class="line">-nographic </span><br></pre></td></tr></table></figure>
</code></pre>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>qemu</tag>
        <tag>虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title>rootfs</title>
    <url>/archives/265c268b.html</url>
    <content><![CDATA[<h3 id="根文件系统简介"><a href="#根文件系统简介" class="headerlink" title="根文件系统简介"></a>根文件系统简介</h3><ul>
<li>根文件系统一般也叫做rootfs，Linux中的根文件系统就像是一个文件夹，这个文件夹内包含很多子目录，这些目录中会有很多文件，这些文件是Linux运行所必须的，比如库、常用的软件和命令、设备文件、配置文件等，根文件系统是Linux内核启动以后挂载的第一个文件系统，然后从根文件系统中读取初始化脚本，比如rcS、inittab等，根文件系统和Linux内核是分开的，单独的Linux内核无法正常工作，必须搭配根文件系统。<span id="more"></span></li>
</ul>
<h4 id="根文件系统子目录"><a href="#根文件系统子目录" class="headerlink" title="根文件系统子目录"></a>根文件系统子目录</h4><ul>
<li><p>&#x2F;bin目录：该目录下存放着系统需要的可执行文件，一般都是一些命令，比如ls、mv等，此目录下的所有命令所有用户都能使用</p>
</li>
<li><p>&#x2F;dev目录：dev是device的缩写，此目录下的文件都是和设备相关的，都是设备文件，在Linux下一切皆文件，即使是硬件设备，也是以文件的形式存在，比如说&#x2F;dev&#x2F;ttymxc0就表示串口0，可以通过对文件&#x2F;dev&#x2F;ttymxc0的读写操作来实现串口0的数据收发</p>
</li>
<li><p>&#x2F;etc目录：该目录下存放着各种配置文件，在嵌入式Linux下该目录下文件内容比较少</p>
</li>
<li><p>&#x2F;lib目录：lib是library的简称，也就是库的意思，因此该目录下存放着Linux所必须的库文件，这些库文件是共享库，命令和用户编写的应用程序都需要使用这些库文件</p>
</li>
<li><p>&#x2F;mnt目录：临时挂载目录，一般是空目录，可以在此目录下创建空的子目录，比如&#x2F;mnt&#x2F;sd，&#x2F;mnt&#x2F;usb这样就可以将SD卡或者U盘挂载</p>
</li>
<li><p>&#x2F;porc目录：当Linux系统启动后会将此目录作为proc文件系统的挂载点，proc是个虚拟文件系统，没有实际的存储设备，proc里面的文件都是临时存在的，一般用来存储系统运行信息文件</p>
</li>
<li><p>&#x2F;usr目录：usr的全称是Unix Software Resource，也就是Unix操作系统的软件资源目录，Linux一般被称为类Unix操作系统，&#x2F;usr目录下也存放着很多软件，一般系统安装后此目录占用的空间最多</p>
</li>
<li><p>&#x2F;var目录：此目录存放着一些可以改变的数据</p>
</li>
<li><p>&#x2F;sbin目录：此目录存放着一些可执行文件，但是此目录下的文件或者命令只有管理员才能使用</p>
</li>
<li><p>&#x2F;sys目录：系统启动后此目录作为sysfs文件系统的挂载点，sysfs是一个类似proc文件系统的特殊文件系统，sysfs也是基于ram的文件系统，没有实际的存储设备，此目录是系统设备管理的重要目录，此目录通过一定的组织结构向用户提供详细的内核数据结构信息</p>
</li>
<li><p>&#x2F;opt目录：可选的文件、软件存放区，由用户选择将哪些文件或者软件放到此目录</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>rootfs</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 字符设备驱动开发</title>
    <url>/archives/d281c370.html</url>
    <content><![CDATA[<p>字符设备是Linux驱动中最基本的一类设备驱动，字符设备就是一个一个字节，按照字节流进行读写操作的设备，读写数据是分先后顺序的，这些设备的驱动就叫做字符设备驱动</p>
<span id="more"></span>

<p>应用程序运行在用户空间，Linux驱动属于内核的一部分，因此驱动运行于内核空间，当在用户空间想要实现对内核的操作，比如使用<code>open</code>函数打开<code>/dev/led</code>这个设备，因为用户空间不能直接对内核进行操作，因此必须使用一个叫做“系统调用”的方法来实现从用户空间陷入到内核空间，这样才能实现对底层驱动的操作。</p>
<p>应用程序调用<code>open()</code>函数的流程:<br>应用调用open函数（应用程序） -&gt; C库中的open（）函数 -&gt; open（）系统调用</p>
<p>每一个系统调用在驱动中都有与之对应的一个驱动函数，在Linux内核文件<code>include/linux/fs.h</code>中有一个叫做<code>file_operations</code>的结构体，此结构体就是Linux内核驱动操作函数集合，<br>该结构体内容如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">    <span class="keyword">loff_t</span> (*llseek) (struct file *, <span class="keyword">loff_t</span>, <span class="keyword">int</span>);</span><br><span class="line">    <span class="keyword">ssize_t</span> (*read) (struct file *, <span class="keyword">char</span> __user *, <span class="keyword">size_t</span>, <span class="keyword">loff_t</span> *);</span><br><span class="line">    <span class="keyword">ssize_t</span> (*write) (struct file *, <span class="keyword">const</span> <span class="keyword">char</span> __user *, <span class="keyword">size_t</span>, <span class="keyword">loff_t</span> *);</span><br><span class="line">    <span class="keyword">ssize_t</span> (*read_iter) (struct kiocb *, struct iov_iter *);</span><br><span class="line">    <span class="keyword">ssize_t</span> (*write_iter) (struct kiocb *, struct iov_iter *);</span><br><span class="line">    <span class="keyword">int</span> (*iterate) (struct file *, struct dir_context *);</span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span> <span class="params">(*poll)</span> <span class="params">(struct file *, struct poll_table_struct *)</span></span>;</span><br><span class="line">    <span class="keyword">long</span> (*unlocked_ioctl) (struct file *, <span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>);</span><br><span class="line">    <span class="keyword">long</span> (*compat_ioctl) (struct file *, <span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>);</span><br><span class="line">    <span class="keyword">int</span> (*mmap) (struct file *, struct vm_area_struct *);</span><br><span class="line">    <span class="keyword">int</span> (*mremap)(struct file *, struct vm_area_struct *);</span><br><span class="line">    <span class="keyword">int</span> (*open) (struct inode *, struct file *);</span><br><span class="line">    <span class="keyword">int</span> (*flush) (struct file *, <span class="keyword">fl_owner_t</span> id);</span><br><span class="line">    <span class="keyword">int</span> (*release) (struct inode *, struct file *);</span><br><span class="line">    <span class="keyword">int</span> (*fsync) (struct file *, <span class="keyword">loff_t</span>, <span class="keyword">loff_t</span>, <span class="keyword">int</span> datasync);</span><br><span class="line">    <span class="keyword">int</span> (*aio_fsync) (struct kiocb *, <span class="keyword">int</span> datasync);</span><br><span class="line">    <span class="keyword">int</span> (*fasync) (<span class="keyword">int</span>, struct file *, <span class="keyword">int</span>);</span><br><span class="line">    <span class="keyword">int</span> (*lock) (struct file *, <span class="keyword">int</span>, struct file_lock *);</span><br><span class="line">    <span class="keyword">ssize_t</span> (*sendpage) (struct file *, struct page *, <span class="keyword">int</span>, <span class="keyword">size_t</span>, <span class="keyword">loff_t</span> *, <span class="keyword">int</span>);</span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">long</span> <span class="params">(*get_unmapped_area)</span><span class="params">(struct file *, <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> (*check_flags)(<span class="keyword">int</span>);</span><br><span class="line">    <span class="keyword">int</span> (*flock) (struct file *, <span class="keyword">int</span>, struct file_lock *);</span><br><span class="line">    <span class="keyword">ssize_t</span> (*splice_write)(struct pipe_inode_info *, struct file *, <span class="keyword">loff_t</span> *, <span class="keyword">size_t</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span>);</span><br><span class="line">    <span class="keyword">ssize_t</span> (*splice_read)(struct file *, <span class="keyword">loff_t</span> *, struct pipe_inode_info *, <span class="keyword">size_t</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span>);</span><br><span class="line">    <span class="keyword">int</span> (*setlease)(struct file *, <span class="keyword">long</span>, struct file_lock **, <span class="keyword">void</span> **);</span><br><span class="line">    <span class="keyword">long</span> (*fallocate)(struct file *file, <span class="keyword">int</span> mode, <span class="keyword">loff_t</span> offset,</span><br><span class="line">              <span class="keyword">loff_t</span> len);</span><br><span class="line">    <span class="keyword">void</span> (*show_fdinfo)(struct seq_file *m, struct file *f);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONFIG_MMU</span></span><br><span class="line">    <span class="keyword">unsigned</span> (*mmap_capabilities)(struct file *);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<pre><code>+ `owner`拥有该结构体的模块的指针，一般设置为`THIS_MODULE`  
+ `loff_t (*llseak) (struct file *, loff_t, int)`：该函数用于修改文件当前的读写位置  
+ `ssize_t (*read) (struct file *, char __user *, size_t, loff_t *)`：用于读取设备文件
+ `ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *)`：用于向设备文件写入数据
+ `unsigned int (*poll) (struct file *, struct poll_table_struct *)`：用于查询设备是否可以进行非阻塞的读写
+ `long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long)`：与应用程序中的`ioctl`函数对应
+ `long (*compat_ioctl) (struct file *, unsigned int, unsigned long)`：功能与`unlocked_ioctl()`函数功能一样，区别在于在64位系统上，32位的应用程序调用将会使用此函数，在32位的系统上运行32位的应用程序调用的是`unlocked_ioctl()`
+ `int (*mmap) (struct file *, struct vm_area_struct *)`：用于将设备的内存映射到进程空间（即用户空间），一般帧缓冲设备会使用此函数，比如LCD驱动的显存，将帧缓冲映射到用户空间中以后应用程序就可以直接操作显存了，这样就不用在用户空间和内核空间之间来回复制
+ `int (*open) (struct inode *, struct file *)`、：用于打开设备文件
+ `int (*release) (struct inode *, struct file *)`：用于释放设备文件，与应用程序中的`close()`函数对应
+ `int (*fsync) (int, struct file *, int)`：用于刷新待处理的数据，将缓冲区的数据刷新到磁盘中
</code></pre>
<h4 id="sysfs文件系统目录结构"><a href="#sysfs文件系统目录结构" class="headerlink" title="sysfs文件系统目录结构"></a>sysfs文件系统目录结构</h4><table>
<thead>
<tr>
<th align="center">目录</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>sysfs</code></td>
<td>文件系统提供了一种用户与内核数据结构进行交互的方式，Linux设备模型中设备、驱动、总线组织成拓扑结构，通过<code>sysfs</code>文件系统以目录结构进行展示与管理</td>
</tr>
<tr>
<td align="center"><code>devices</code></td>
<td>内核对系统中所有设备的分层次表达模型，也是<code>/sys</code>文件系统管理设备的最重要的目录结构</td>
</tr>
<tr>
<td align="center"><code>dev</code></td>
<td>这个目录下维护一个按字符设备和块设备的设备号文件(major:minor)链接到真实的设备</td>
</tr>
<tr>
<td align="center"><code>bus</code></td>
<td>内核按照总线类型分层放置的目录结构，<code>devices</code>中的所有设备都是连接于某种总线之下，每一种具体总线之下可以找到每一个具体设备的符号链接，是构成Linux统一设备模型的一部分</td>
</tr>
<tr>
<td align="center"><code>class</code></td>
<td>这是按照设备功能分类的设备模型，如系统所有输入设备都会出现在<code>/sys/class/input</code>之下，不论它们是以何种总线连接到系统，它也是构成Linux统一设备模型的一部分</td>
</tr>
<tr>
<td align="center"><code>block</code></td>
<td>这是系统中当前所有块设备所在的目录，按照功能来说放置在<code>/sys/class</code>下更恰当，由于历史遗留因素而一直存在于<code>/sys/block</code>，在2.6.26内核中已经正式移到<code>/sys/class/block</code>，<code>/sys/block</code>中的内容已经变为指向它们在<code>/sys/devices</code>中真实设备的符号链接文件</td>
</tr>
<tr>
<td align="center"><code>firmware</code></td>
<td>系统加载固件机制的对用户空间的接口</td>
</tr>
<tr>
<td align="center"><code>fs</code></td>
<td>用于描述系统中所有文件系统，包括文件系统本身和按文件系统分类存放的已挂载点</td>
</tr>
<tr>
<td align="center"><code>kernel</code></td>
<td>内核所有可调整参数的位置，目前只有<code>uevent_helper</code>,<code>kexec_loaded</code>,<code>mm</code>和新式的<code>slab</code>分配器等几项较新的设计在使用，其它内核可调整参数仍然位于<code>/proc/sys/kernel</code>接口中</td>
</tr>
<tr>
<td align="center"><code>module</code></td>
<td>系统中所有模块的信息，不论这些模块是以内联方式编译到内核镜像<code>vmlinux</code>中还是编译为外部</td>
</tr>
</tbody></table>
<h4 id="对字符设备的封装：cdev结构体"><a href="#对字符设备的封装：cdev结构体" class="headerlink" title="对字符设备的封装：cdev结构体"></a>对字符设备的封装：<code>cdev</code>结构体</h4><ul>
<li><code>cdev</code>结构体定义在<code>include/linux/cdev.h</code>中  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">    <span class="keyword">dev_t</span> dev;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count;</span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure></li>
<li>其中<a href="https://lwn.net/Articles/722293/"><code>__randomsize_layout</code></a>表示随机化一个结构体，在编译时随机排布结构体中元素的顺序，从而使攻击者无法通过地址偏移的方式获取一些敏感数据成员的信息</li>
<li><code>struct kobject kobj;</code>：抽象出来的用来表示设备模型的数据结构</li>
<li><code>const struct file_operations *ops;</code>：定义了字符设备驱动提供给虚拟文件系统的接口函数集合</li>
<li><code>struct list_head list;</code>：将所有字符设备通过链表进行管理</li>
<li><code>dev_t dev</code>：设备号，<code>dev_t</code>数据结构定义在<code>include/linux/types.h</code>中，包含主设备号和次设备号，实际是一个32位整形数据，其中高12位为主设备号，低20位为次设备号  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// dev_t的定义</span></span><br><span class="line"><span class="keyword">typedef</span> u32 <span class="keyword">__kernel_dev_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">__kernel_dev_t</span>		<span class="keyword">dev_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设备号的一些操作宏</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MINORBITS	20</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MINORMASK	((1U &lt;&lt; MINORBITS) - 1)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAJOR(dev)	((unsigned int) ((dev) &gt;&gt; MINORBITS))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MINOR(dev)	((unsigned int) ((dev) &amp; MINORMASK))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MKDEV(ma,mi)	(((ma) &lt;&lt; MINORBITS) | (mi))</span></span><br></pre></td></tr></table></figure></li>
<li><code>unsigned int count;</code>：属于同主设备号的次设备号的个数</li>
</ul>
<h4 id="设备管理机制：kobject"><a href="#设备管理机制：kobject" class="headerlink" title="设备管理机制：kobject"></a>设备管理机制：<code>kobject</code></h4><ul>
<li><code>kobject</code>是Linux设备驱动模型的基础，也是设备模型中抽象的一部分，它与sysfs文件系统紧密相连，在内核中注册的每个<code>kobject</code>对象对应sysfs文件系统中的一个目录</li>
<li><code>kobject</code>是组成设备模型的基本结构，是所有用来描述设备模型的数据结构的基类，它嵌入在所有的描述设备模型的容器对象中，例如bus,devices,drivers，这些容器通过<code>kobject</code>链接起来，形成一个树形结构</li>
<li>该结构体定义在<code>include/linux/kobject.h</code>中，通过这个数据结构可以使所有设备在底层都具有统一的接口，<code>kobject</code>提供基本的对象管理，结构体内容如下：  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>		*name;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">entry</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span>		*<span class="title">parent</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kset</span>		*<span class="title">kset</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobj_type</span>	*<span class="title">ktype</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kernfs_node</span>	*<span class="title">sd</span>;</span> <span class="comment">/* sysfs directory entry */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kref</span>		<span class="title">kref</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_KOBJECT_RELEASE</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">delayed_work</span>	<span class="title">release</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> state_initialized:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> state_in_sysfs:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> state_add_uevent_sent:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> state_remove_uevent_sent:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> uevent_suppress:<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><code>const char *name;</code>：<code>kobject</code>名字，对应<code>sysfs</code>下的一个目录</li>
<li><code>struct list_head entry;</code>：<code>kobject</code>中插入的的<code>list_head</code>链表结构，用于构造双向链表</li>
<li><code>struct kobject *parent;</code>：指向当前<code>kobject</code>父对象的指针，体现在<code>sysfs</code>中就是包含当前<code>kobject</code>对象的目录对象</li>
<li><code>struct kset *kset;</code>：当前<code>kobject</code>对象所属的集合</li>
<li><code>struct kobj_type *ktype;</code>：当前<code>kobject</code>对象的类型</li>
<li><code>struct kernfs_node *sd;</code>：VFS文件系统的目录项，是设备和文件之间的桥梁，<code>sysfs</code>中的符号链接是通过<code>kernel_node</code>内的联合体实现的</li>
<li><code>struct kref kref;</code>：<code>kobject</code>的引用计数，当计数为0时，回调之前注册的<code>release</code>方法释放对象</li>
<li><code>unsigned int state_initialized:1;</code>：初始化标志位，初始化时被置位</li>
<li><code>unsigned int state_in_sysfs:1;</code>：<code>kobject</code>在<code>sysfs</code>中的状态，在目录中创建则为1，否则为0</li>
<li><code>unsigned int state_add_uevent_sent:1</code>：添加设备的<code>uevent</code>事件是否发送标志，添加设备时向用户控件发送<code>uevent</code>事件，请求新增设备</li>
<li><code>unsigned int state_remove_uevent_sent:1</code>：删除设备的<code>uevent</code>事件是否发送标志，删除设备时向用户控件发送<code>uevent</code>事件，请求卸载设备</li>
<li><code>unsigned int uevent_suppress:1</code>：是否忽略上报<code>uevent</code></li>
</ul>
<h4 id="kobject集合-kset"><a href="#kobject集合-kset" class="headerlink" title="kobject集合 kset"></a><code>kobject</code>集合 <code>kset</code></h4><ul>
<li><code>kset</code>是包含多个<code>kobject</code>的集合，如果在<code>sysfs</code>的目录中包含多个子目录，那需要将它定义成一个<code>kset</code>  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct kset - a set of kobjects of a specific type, belonging to a specific subsystem.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * A kset defines a group of kobjects.  They can be individually</span></span><br><span class="line"><span class="comment"> * different &quot;types&quot; but overall these kobjects all want to be grouped</span></span><br><span class="line"><span class="comment"> * together and operated on in the same manner.  ksets are used to</span></span><br><span class="line"><span class="comment"> * define the attribute callbacks and other common events that happen to</span></span><br><span class="line"><span class="comment"> * a kobject.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @list: the list of all kobjects for this kset</span></span><br><span class="line"><span class="comment"> * @list_lock: a lock for iterating over the kobjects</span></span><br><span class="line"><span class="comment"> * @kobj: the embedded kobject for this kset (recursion, isn&#x27;t it fun...)</span></span><br><span class="line"><span class="comment"> * @uevent_ops: the set of uevent operations for this kset.  These are</span></span><br><span class="line"><span class="comment"> * called whenever a kobject has something happen to it so that the kset</span></span><br><span class="line"><span class="comment"> * can add new environment variables, or filter out the uevents if so</span></span><br><span class="line"><span class="comment"> * desired.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kset</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">    <span class="keyword">spinlock_t</span> list_lock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">kset_uevent_ops</span> *<span class="title">uevent_ops</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><code>struct list_head list;</code>：包含在<code>kset</code>在内的所有<code>kobject</code>构成的一个双向链表</li>
<li><code>spinlock_t list_lock;</code>：遍历<code>kobject</code>时的锁</li>
<li><code>struct kobject kobj;</code>：归属于该<code>kset</code>的所有的<code>kobject</code>的parent</li>
<li><code>const struct kset_uevent_ops *uevent_ops;</code>：<code>kset</code>的<code>uevent</code>操作函数集，当<code>kset</code>中的<code>kobject</code>有状态变化时，会回调这个函数集</li>
</ul>
<h4 id="kobject类型-ktype"><a href="#kobject类型-ktype" class="headerlink" title="kobject类型 ktype"></a><code>kobject</code>类型 <code>ktype</code></h4><ul>
<li><code>kobj_type</code>用于表征<code>kobject</code>的类型，指定了删除<code>kobject</code>时要调用的函数，<code>kobject</code>结构体中有<code>struct kref</code>字段对<code>kobject</code>进行引用计数，当计数值为0时，就会调用<code>kobj_type</code>中的<code>release</code>函数对<code>kobject</code>进行释放</li>
<li><code>kobj_type</code>指定了通过<code>sysfs</code>显示或修改有关<code>kobject</code>的信息时要处理的操作，实际是调用<code>show/store</code>函数  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kobj_type</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> (*release)(struct kobject *kobj);</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sysfs_ops</span> *<span class="title">sysfs_ops</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">attribute</span> **<span class="title">default_attrs</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">kobj_ns_type_operations</span> *(*<span class="title">child_ns_type</span>)(<span class="keyword">struct</span> <span class="title">kobject</span> *<span class="title">kobj</span>);</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">void</span> *(*<span class="keyword">namespace</span>)(struct kobject *kobj);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sysfs_ops</span> &#123;</span></span><br><span class="line">    <span class="keyword">ssize_t</span>	(*show)(struct kobject *, struct attribute *, <span class="keyword">char</span> *);</span><br><span class="line">    <span class="keyword">ssize_t</span>	(*store)(struct kobject *, struct attribute *, <span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">size_t</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">attribute</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>		*name;</span><br><span class="line">    <span class="keyword">umode_t</span>			mode;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_LOCK_ALLOC</span></span><br><span class="line">    <span class="keyword">bool</span>			ignore_lockdep:<span class="number">1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span>	*<span class="title">key</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span>	<span class="title">skey</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><code>void (*release)(struct koject *kobj);</code> 释放<code>kobject</code>对象的接口，有点类似面向对象中的析构</li>
<li><code>const struct sysfs_ops *sysfs_ops;</code> 操作<code>kobject</code>的方法集</li>
<li><code>struct attribute **default_attrs;</code> 所谓的<code>attribute</code>就是内核控件和用户空间进行信息交互的一种方法，例如某个driver定义了一个变量，却希望用户空间程序可以修改该变量，那么可以将该变量以<code>sysfs attribute</code>的形式开放出来</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Driver</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux Cpufreq 框架</title>
    <url>/archives/fbf46cf3.html</url>
    <content><![CDATA[<p>Linux Kernel主要通过三类机制来实现SMP（Symmetric Multiprocessing，对称多核）系统CPU core的电源管理：</p>
<ul>
<li>cpu hotplug: 根据应用场景来up&#x2F;down CPU</li>
<li>cpuidle framework: 当cpu上没有可执行任务时，就会进入空闲状态</li>
<li>cpufreq framework: 根据使用场景和系统负荷来调整CPU的电压和频率</li>
</ul>
<span id="more"></span>
<p>cpufreq framework的核心功能，是通过调整CPU core的电压或频率，兼顾系统的性能和功耗。在不需要高性能时，降低电压或频率，以降低功耗；在需要高性能时，提高电压或频率，以提高性能。</p>
<p>cpufreq framework中的几个重要概念：</p>
<ol>
<li>policy（策略）：同一个簇的CPU动态调频的一个集合结构体，包含了当前使用的governor和cpufreq driver</li>
<li>governor（调节器）：决定如何计算合适的频率或电压</li>
<li>cpufreq driver：来实现真正的调频执行工作（与平台相关）</li>
</ol>
<p>常用的governor类型</p>
<ol>
<li>Performance：总是将CPU置于最高性能的状态，即硬件所支持的最高频率、电压</li>
<li>Powersaving：总是将CPU置于最节能的状态，即硬件所支持的最低频率、电压</li>
<li>Ondemand：设置CPU负载的阈值T，当负载低于T时，调节至一个刚好能够满足当前负载需求的最低频&#x2F;最低压；当负载高于T时，立即提升到最高性能状态</li>
<li>Conservative：跟Ondemand策略类似，设置CPU负载的阈值T，当负载低于T时，调节至一个刚好能够满足当前负载需求的最低频&#x2F;最低压；但当负载高于T时，不是立即设置为最高性能状态，而是逐级升高主频&#x2F;电压</li>
<li>Userspace：将控制接口通过sysfs开放给用户，由用户进行自定义策略</li>
<li>Schedutil：这是从Linux-4.7版本开始才引入的策略，其原理是根据调度器所提供的CPU利用率信息进行电压&#x2F;频率调节，EAS使用schedutil进行调频</li>
</ol>
<p>sysfs用户层接口，目录位于<code>/sys/devices/system/cpu/cpufreq/policy</code><br><img src="https://raw.githubusercontent.com/JackHuang021/images/master/20221124110212.png"></p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">cpuinfo_max_freq</td>
<td align="left">硬件所支持的最高频率</td>
</tr>
<tr>
<td align="left">cpuinfo_min_freq</td>
<td align="left">硬件所支持的最低频率</td>
</tr>
<tr>
<td align="left">affected_cpus</td>
<td align="left">该policy影响到哪些cpu（没显示offline状态的cpu）</td>
</tr>
<tr>
<td align="left">related_cpus</td>
<td align="left">该policy影响到的所有cpu，包括offline状态的cpu</td>
</tr>
<tr>
<td align="left">scaling_max_freq</td>
<td align="left">该policy支持调整的最高频率</td>
</tr>
<tr>
<td align="left">scaling_min_freq</td>
<td align="left">该policy支持调整的最低频率</td>
</tr>
<tr>
<td align="left">scaling_cur_freq</td>
<td align="left">policy当前设置的频率</td>
</tr>
<tr>
<td align="left">scaling_available_governors</td>
<td align="left">当前系统支持的governor</td>
</tr>
<tr>
<td align="left">scaling_available_frequencies</td>
<td align="left">支持的调频频率</td>
</tr>
<tr>
<td align="left">scaling_driver</td>
<td align="left">当前使用的调频驱动</td>
</tr>
<tr>
<td align="left">scaling_governor</td>
<td align="left">当前使用的governor</td>
</tr>
<tr>
<td align="left">scaling_setspeed</td>
<td align="left">在userspace模式下才能使用，手动设置频率</td>
</tr>
</tbody></table>
<h4 id="cpufreq软件架构"><a href="#cpufreq软件架构" class="headerlink" title="cpufreq软件架构"></a>cpufreq软件架构</h4><p><img src="https://raw.githubusercontent.com/JackHuang021/images/master/20230103092146.png"><br>cpufreq core（可以理解为对policy的操作）：把一些公共的逻辑和接口代码抽象出来</p>
<ul>
<li><code>cpufreq</code>作为所有cpu设备的一个功能，注册到了<code>cpu_subsys</code>总线上</li>
<li>对上以sysfs的形式向用户空间提供统一的接口，以notifier的形式向其他driver提供频率变化的通知</li>
<li>对下提供CPU频率和电压控制的驱动框架，方便底层driver的开发，同时提供governor框架，用于实现不同的频率调整机制</li>
<li>内部封装各种逻辑，主要围绕<code>struct cpufreq_policy</code> <code>struct cpufreq_driver</code> <code>struct cpufreq_governor</code>三个数据结构进行</li>
</ul>
<p>kernel使用<code>struct cpufreq_policy</code>用来抽象cpufreq，它从一定程度上代表了一个CPU簇的cpufreq的属性<br><img src="https://raw.githubusercontent.com/JackHuang021/images/master/20230103093856.png"></p>
<p><code>cpufreq_policy</code>结构体</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cpufreq_cpuinfo</span> &#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		max_freq;			<span class="comment">// cpu最大频率</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		min_freq;			<span class="comment">// cpu最小频率</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* in 10^(-9) s = nanoseconds */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		transition_latency;	<span class="comment">// cpu频率转换时间 单位：ns</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cpufreq_policy</span> &#123;</span></span><br><span class="line">	<span class="comment">/* CPUs sharing clock, require sw coordination */</span></span><br><span class="line">	<span class="keyword">cpumask_var_t</span>		cpus;	<span class="comment">/* Online CPUs only */</span></span><br><span class="line">	<span class="keyword">cpumask_var_t</span>		related_cpus; <span class="comment">/* Online + Offline CPUs */</span></span><br><span class="line">	<span class="keyword">cpumask_var_t</span>		real_cpus; <span class="comment">/* Related and present */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		shared_type; <span class="comment">/* ACPI: ANY or ALL affected CPUs</span></span><br><span class="line"><span class="comment">						should set cpufreq */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		cpu;    <span class="comment">/* cpu managing this policy, must be online */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">clk</span>		*<span class="title">clk</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cpufreq_cpuinfo</span>	<span class="title">cpuinfo</span>;</span><span class="comment">/* see above */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		min;    <span class="comment">/* in kHz */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		max;    <span class="comment">/* in kHz */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		cur;    <span class="comment">/* in kHz, only needed if cpufreq</span></span><br><span class="line"><span class="comment">					 * governors are used */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cpufreq_governor</span>	*<span class="title">governor</span>;</span> <span class="comment">/* see below */</span></span><br><span class="line">	<span class="keyword">void</span>			*governor_data;</span><br><span class="line">	<span class="keyword">char</span>			last_governor[CPUFREQ_NAME_LEN]; <span class="comment">/* last governor used */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span>	<span class="title">update</span>;</span> <span class="comment">/* if update_policy() needs to be</span></span><br><span class="line"><span class="comment">					 * called, but you&#x27;re in IRQ context */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cpufreq_user_policy</span> <span class="title">user_policy</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cpufreq_frequency_table</span>	*<span class="title">freq_table</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">cpufreq_table_sorting</span> <span class="title">freq_table_sorted</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>        <span class="title">policy_list</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kobject</span>		<span class="title">kobj</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">completion</span>	<span class="title">kobj_unregister</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Preferred average time interval between consecutive invocations of</span></span><br><span class="line"><span class="comment">	 * the driver to set the frequency for this policy.  To be set by the</span></span><br><span class="line"><span class="comment">	 * scaling driver (0, which is the default, means no preference).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		transition_delay_us;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Remote DVFS flag (Not added to the driver structure as we don&#x27;t want</span></span><br><span class="line"><span class="comment">	 * to access another structure from scheduler hotpath).</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Should be set if CPUs can do DVFS on behalf of other CPUs from</span></span><br><span class="line"><span class="comment">	 * different cpufreq policies.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">bool</span>			dvfs_possible_from_any_cpu;</span><br><span class="line"></span><br><span class="line">	 <span class="comment">/* Cached frequency lookup from cpufreq_driver_resolve_freq. */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> cached_target_freq;</span><br><span class="line">	<span class="keyword">int</span> cached_resolved_idx;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* cpufreq-stats */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cpufreq_stats</span>	*<span class="title">stats</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* For cpufreq driver&#x27;s internal use */</span></span><br><span class="line">	<span class="keyword">void</span>			*driver_data;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>driver/cpufreq/cpufreq.c</code>中定义了一个全局的percpu变量</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">DEFINE_PER_CPU</span><span class="params">(struct cpufreq_policy *, cpufreq_cpu_data)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这里对应E2000 sysfs中3个policy文件夹，两个小核在一个簇中，使用1个policy，另外两个大核分别对应1个policy<br><img src="https://raw.githubusercontent.com/JackHuang021/images/master/20230103094857.png"></p>
<blockquote>
<p>per-CPU变量是linux系统一个非常重要的特性，它为系统中的每个处理器都分配了该变量的副本。这样做的好处是，在多处理器系统中，当处理器操作属于它的变量副本时，不需要考虑与其他处理器的竞争的问题，同时该副本还可以充分利用处理器本地的硬件缓冲cache来提供访问速度</p>
</blockquote>
<h4 id="cpufreq初始化过程"><a href="#cpufreq初始化过程" class="headerlink" title="cpufreq初始化过程"></a>cpufreq初始化过程</h4><p><code>cpufreq_driver</code>结构体如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cpufreq_driver</span> &#123;</span></span><br><span class="line">	<span class="keyword">char</span>		name[CPUFREQ_NAME_LEN];</span><br><span class="line">	u16		    flags;</span><br><span class="line">	<span class="keyword">void</span>		*driver_data;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* needed by all drivers */</span></span><br><span class="line">	<span class="keyword">int</span>		(*init)(struct cpufreq_policy *policy);</span><br><span class="line">	<span class="keyword">int</span>		(*verify)(struct cpufreq_policy_data *policy);</span><br><span class="line">	<span class="keyword">int</span>		(*target_index)(struct cpufreq_policy *policy,</span><br><span class="line">					<span class="keyword">unsigned</span> <span class="keyword">int</span> index);</span><br><span class="line">	<span class="function"><span class="keyword">unsigned</span> <span class="title">int</span>	<span class="params">(*fast_switch)</span><span class="params">(struct cpufreq_policy *policy,</span></span></span><br><span class="line"><span class="params"><span class="function">				       <span class="keyword">unsigned</span> <span class="keyword">int</span> target_freq)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* should be defined, if possible */</span></span><br><span class="line">	<span class="function"><span class="keyword">unsigned</span> <span class="title">int</span>	<span class="params">(*get)</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> cpu)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Called to update policy limits on firmware notifications. */</span></span><br><span class="line">	<span class="keyword">void</span>		(*update_limits)(<span class="keyword">unsigned</span> <span class="keyword">int</span> cpu);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span>		(*online)(struct cpufreq_policy *policy);</span><br><span class="line">	<span class="keyword">int</span>		(*offline)(struct cpufreq_policy *policy);</span><br><span class="line">	<span class="keyword">int</span>		(*<span class="built_in">exit</span>)(struct cpufreq_policy *policy);</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">freq_attr</span> **<span class="title">attr</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="cpufreq初始化概述"><a href="#cpufreq初始化概述" class="headerlink" title="cpufreq初始化概述"></a>cpufreq初始化概述</h5><p>在kconfig中(CPU Power Management -&gt; CPU Frequency scaling)可以对cpufreq进行配置，可以配置支持的governor及系统默认的governor，以及cpufreq调频driver，例如Phytium E2000 5.10内核的配置如下，默认使用schedutil governor，根据调度器所提供的CPU利用率信息进行电压&#x2F;频率调节，EAS能源感知依赖该governor工作：<br><img src="https://raw.githubusercontent.com/JackHuang021/images/master/20230105110139.png"></p>
<p>cpufreq的初始化从cpufreq_drvier注册开始，<code>cpufreq_register_driver()</code>函数为cpufreq驱动注册的入口，驱动程序通过调用该函数进行初始化，传入相关的<code>struct cpufreq_driver</code>，<code>cpufreq_register_driver()</code>会调用<code>subsys_interface_register()</code>最终执行回调函数<code>cpufreq_add_dev</code>，然后调用<code>cpufreq_online()</code>走初始化流程</p>
<h5 id="Performance-Domain-opp（Operating-Performance-Points）表初始化"><a href="#Performance-Domain-opp（Operating-Performance-Points）表初始化" class="headerlink" title="Performance Domain opp（Operating Performance Points）表初始化"></a>Performance Domain opp（Operating Performance Points）表初始化</h5><p>OPP表的定义：域中每个设备支持的电压和频率的离散元组的集合称为Operating Performance Points（OPP）,内核设备树opp文档<code>Documentation/devicetree/bindings/opp/opp.txt</code>  </p>
<p>假设一个CPU设备支持如下的电压和频率关系：<br>{300MHz at minimum voltage of 1V}<br>{800MHz at minimum voltage of 1.2V}<br>{1GHz at minimum voltage of 1.3V}<br>用OPP表示就可以用{Hz,  uV}方式表示如下:<br>{300000000, 1000000}<br>{800000000, 1200000}<br>{1000000000, 1300000}</p>
<p>这里初始化的就是各个性能域（即不同CPU簇）的OPP表，在E2000平台中是通过SCMI的Performace domain management protocol协议获取PERFORMANCE_DESCRIBE_LEVELS这个参数表，具体的协议实现源码在<code>drivers/firmware/arm_scmi/perf.c</code>里面，<code>perf.c</code>实现了SCMI的Performance domain managment protocol，scmi cpufreq_drvier也是通过<code>perf_ops</code>函数集进行调频</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/linux/scmi_protocol.h</span></span><br><span class="line"><span class="comment">// 抽象描述scmi协议的结构体，相应的ops操作集对应scmi的一个协议</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">scmi_handle</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">scmi_revision_info</span> *<span class="title">version</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">scmi_perf_ops</span> *<span class="title">perf_ops</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">scmi_clk_ops</span> *<span class="title">clk_ops</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">scmi_power_ops</span> *<span class="title">power_ops</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">scmi_sensor_ops</span> *<span class="title">sensor_ops</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">scmi_reset_ops</span> *<span class="title">reset_ops</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">scmi_notify_ops</span> *<span class="title">notify_ops</span>;</span></span><br><span class="line">	<span class="comment">/* for protocol internal use */</span></span><br><span class="line">	<span class="keyword">void</span> *perf_priv;</span><br><span class="line">	<span class="keyword">void</span> *clk_priv;</span><br><span class="line">	<span class="keyword">void</span> *power_priv;</span><br><span class="line">	<span class="keyword">void</span> *sensor_priv;</span><br><span class="line">	<span class="keyword">void</span> *reset_priv;</span><br><span class="line">	<span class="keyword">void</span> *notify_priv;</span><br><span class="line">	<span class="keyword">void</span> *system_priv;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// scmi_handle这个结构体实现的就是scmi整个协议的处理</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">scmi_handle</span> *<span class="title">handle</span>;</span>	</span><br><span class="line"></span><br><span class="line"><span class="comment">// include/linux/scmi_protocol.h</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct scmi_perf_ops - represents the various operations provided</span></span><br><span class="line"><span class="comment"> *	by SCMI Performance Protocol</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @limits_set: sets limits on the performance level of a domain</span></span><br><span class="line"><span class="comment"> * @limits_get: gets limits on the performance level of a domain</span></span><br><span class="line"><span class="comment"> * @level_set: sets the performance level of a domain</span></span><br><span class="line"><span class="comment"> * @level_get: gets the performance level of a domain</span></span><br><span class="line"><span class="comment"> * @device_domain_id: gets the scmi domain id for a given device</span></span><br><span class="line"><span class="comment"> * @transition_latency_get: gets the DVFS transition latency for a given device</span></span><br><span class="line"><span class="comment"> * @device_opps_add: adds all the OPPs for a given device</span></span><br><span class="line"><span class="comment"> * @freq_set: sets the frequency for a given device using sustained frequency</span></span><br><span class="line"><span class="comment"> *	to sustained performance level mapping</span></span><br><span class="line"><span class="comment"> * @freq_get: gets the frequency for a given device using sustained frequency</span></span><br><span class="line"><span class="comment"> *	to sustained performance level mapping</span></span><br><span class="line"><span class="comment"> * @est_power_get: gets the estimated power cost for a given performance domain</span></span><br><span class="line"><span class="comment"> *	at a given frequency</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">scmi_perf_ops</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> (*limits_set)(<span class="keyword">const</span> struct scmi_handle *handle, u32 domain,</span><br><span class="line">			  u32 max_perf, u32 min_perf);</span><br><span class="line">	<span class="keyword">int</span> (*limits_get)(<span class="keyword">const</span> struct scmi_handle *handle, u32 domain,</span><br><span class="line">			  u32 *max_perf, u32 *min_perf);</span><br><span class="line">	<span class="keyword">int</span> (*level_set)(<span class="keyword">const</span> struct scmi_handle *handle, u32 domain,</span><br><span class="line">			 u32 level, <span class="keyword">bool</span> poll);</span><br><span class="line">	<span class="keyword">int</span> (*level_get)(<span class="keyword">const</span> struct scmi_handle *handle, u32 domain,</span><br><span class="line">			 u32 *level, <span class="keyword">bool</span> poll);</span><br><span class="line">	<span class="keyword">int</span> (*device_domain_id)(struct device *dev);</span><br><span class="line">	<span class="keyword">int</span> (*transition_latency_get)(<span class="keyword">const</span> struct scmi_handle *handle,</span><br><span class="line">				      struct device *dev);</span><br><span class="line">	<span class="keyword">int</span> (*device_opps_add)(<span class="keyword">const</span> struct scmi_handle *handle,</span><br><span class="line">			       struct device *dev);</span><br><span class="line">	<span class="keyword">int</span> (*freq_set)(<span class="keyword">const</span> struct scmi_handle *handle, u32 domain,</span><br><span class="line">			<span class="keyword">unsigned</span> <span class="keyword">long</span> rate, <span class="keyword">bool</span> poll);</span><br><span class="line">	<span class="keyword">int</span> (*freq_get)(<span class="keyword">const</span> struct scmi_handle *handle, u32 domain,</span><br><span class="line">			<span class="keyword">unsigned</span> <span class="keyword">long</span> *rate, <span class="keyword">bool</span> poll);</span><br><span class="line">	<span class="keyword">int</span> (*est_power_get)(<span class="keyword">const</span> struct scmi_handle *handle, u32 domain,</span><br><span class="line">			     <span class="keyword">unsigned</span> <span class="keyword">long</span> *rate, <span class="keyword">unsigned</span> <span class="keyword">long</span> *power);</span><br><span class="line">	<span class="keyword">bool</span> (*fast_switch_possible)(<span class="keyword">const</span> struct scmi_handle *handle,</span><br><span class="line">				     struct device *dev);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// scmi performance domain management protocol(性能域管理相关协议 0x13), messageid: 0x03</span></span><br><span class="line"><span class="comment">// scmi opp结构体定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">scmi_opp</span> &#123;</span></span><br><span class="line">	u32 perf;		<span class="comment">// 性能级别，单位KHz</span></span><br><span class="line">	u32 power;		<span class="comment">// 当前性能级别的功耗</span></span><br><span class="line">	u32 trans_latency_us;	<span class="comment">// 切换延时</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// scmi performance domain management protocol(性能域管理相关协议 0x13)对应操作函数集</span></span><br><span class="line"><span class="comment">// scmi cpufreq_driver 主要利用这个函数集进行调频相关操作</span></span><br><span class="line"><span class="comment">// 对应Performace domain management protocol各个message_id</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">scmi_perf_ops</span> <span class="title">perf_ops</span> =</span> &#123;</span><br><span class="line">	.limits_set = scmi_perf_limits_set,</span><br><span class="line">	.limits_get = scmi_perf_limits_get,</span><br><span class="line">	.level_set = scmi_perf_level_set,</span><br><span class="line">	.level_get = scmi_perf_level_get,</span><br><span class="line">	.device_domain_id = scmi_dev_domain_id,</span><br><span class="line">	.transition_latency_get = scmi_dvfs_transition_latency_get,</span><br><span class="line">	.device_opps_add = scmi_dvfs_device_opps_add,</span><br><span class="line">	.freq_set = scmi_dvfs_freq_set,</span><br><span class="line">	.freq_get = scmi_dvfs_freq_get,</span><br><span class="line">	.est_power_get = scmi_dvfs_est_power_get,</span><br><span class="line">	.fast_switch_possible = scmi_fast_switch_possible,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在这个宏进行SCMI performance domain management protocol协议的初始化</span></span><br><span class="line">DEFINE_SCMI_PROTOCOL_REGISTER_UNREGISTER(SCMI_PROTOCOL_PERF, perf)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFINE_SCMI_PROTOCOL_REGISTER_UNREGISTER(id, name) \</span></span><br><span class="line"><span class="meta">int __init scmi_##name##_register(void) \</span></span><br><span class="line"><span class="meta">&#123; \</span></span><br><span class="line"><span class="meta">	return scmi_protocol_register((id), &amp;scmi_##name##_protocol_init); \</span></span><br><span class="line"><span class="meta">&#125; \</span></span><br><span class="line"><span class="meta">\</span></span><br><span class="line"><span class="meta">void __exit scmi_##name##_unregister(void) \</span></span><br><span class="line"><span class="meta">&#123; \</span></span><br><span class="line"><span class="meta">	scmi_protocol_unregister((id)); \</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="comment">// 展开该宏</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> __init <span class="title">scmi_perf_register</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> scmi_protocol_register(SCMI_PROTOCOL_PER, &amp;scmi_perf_protocol_init);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化过程中调用了scmi_perf_protocol_init();</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">scmi_perf_protocol_init</span><span class="params">(struct scmi_handle *handle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> domain;</span><br><span class="line">	u32 version;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">scmi_perf_info</span> *<span class="title">pinfo</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取当前perf domain management协议版本</span></span><br><span class="line">	scmi_version_get(handle, SCMI_PROTOCOL_PERF, &amp;version);</span><br><span class="line"></span><br><span class="line">	dev_dbg(handle-&gt;dev, <span class="string">&quot;Performance Version %d.%d\n&quot;</span>,</span><br><span class="line">		PROTOCOL_REV_MAJOR(version), PROTOCOL_REV_MINOR(version));</span><br><span class="line"></span><br><span class="line">	pinfo = devm_kzalloc(handle-&gt;dev, <span class="keyword">sizeof</span>(*pinfo), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!pinfo)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	scmi_perf_attributes_get(handle, pinfo);</span><br><span class="line"></span><br><span class="line">	pinfo-&gt;dom_info = devm_kcalloc(handle-&gt;dev, pinfo-&gt;num_domains,</span><br><span class="line">				       <span class="keyword">sizeof</span>(*pinfo-&gt;dom_info), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!pinfo-&gt;dom_info)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 遍历每个performance_domain，获取performance domain的属性和performance level参数</span></span><br><span class="line">	<span class="keyword">for</span> (domain = <span class="number">0</span>; domain &lt; pinfo-&gt;num_domains; domain++) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">perf_dom_info</span> *<span class="title">dom</span> =</span> pinfo-&gt;dom_info + domain;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 获取performance domain属性</span></span><br><span class="line">		scmi_perf_domain_attributes_get(handle, domain, dom);</span><br><span class="line">		<span class="comment">// 获取performance level参数即opp表</span></span><br><span class="line">		scmi_perf_describe_levels_get(handle, domain, dom);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (dom-&gt;perf_fastchannels)</span><br><span class="line">			scmi_perf_domain_init_fc(handle, domain, &amp;dom-&gt;fc_info);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	scmi_register_protocol_events(handle,</span><br><span class="line">				      SCMI_PROTOCOL_PERF, SCMI_PROTO_QUEUE_SZ,</span><br><span class="line">				      &amp;perf_event_ops, perf_events,</span><br><span class="line">				      ARRAY_SIZE(perf_events),</span><br><span class="line">				      pinfo-&gt;num_domains);</span><br><span class="line"></span><br><span class="line">	pinfo-&gt;version = version;</span><br><span class="line">	handle-&gt;perf_ops = &amp;perf_ops;</span><br><span class="line">	handle-&gt;perf_priv = pinfo;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终获取得到的OPP表如下<br><img src="https://raw.githubusercontent.com/JackHuang021/images/master/20230103140116.png"></p>
<h5 id="cpufreq初始化过程-1"><a href="#cpufreq初始化过程-1" class="headerlink" title="cpufreq初始化过程"></a>cpufreq初始化过程</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// driver/base/cpu.c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> <span class="title">cpu_subsys</span> =</span> &#123;</span><br><span class="line">	.name = <span class="string">&quot;cpu&quot;</span>,</span><br><span class="line">	.dev_name = <span class="string">&quot;cpu&quot;</span>,</span><br><span class="line">	.match = cpu_subsys_match,</span><br><span class="line">	.online = cpu_subsys_online,</span><br><span class="line">	.offline = cpu_subsys_offline,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// driver/cpufreq/cpufreq.c</span></span><br><span class="line"><span class="comment">// 指向当前使用的cpufreq_driver</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">cpufreq_driver</span> *<span class="title">cpufreq_driver</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// cpufreq subsys接口，用来挂到CPU subsys总线上</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">subsys_interface</span> <span class="title">cpufreq_interface</span> =</span> &#123;</span><br><span class="line">	.name		= <span class="string">&quot;cpufreq&quot;</span>,</span><br><span class="line">	.subsys		= &amp;cpu_subsys,</span><br><span class="line">	.add_dev	= cpufreq_add_dev,</span><br><span class="line">	.remove_dev	= cpufreq_remove_dev,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// scmi cpufreq_driver结构体定义</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">cpufreq_driver</span> <span class="title">scmi_cpufreq_driver</span> =</span> &#123;</span><br><span class="line">	.name	= <span class="string">&quot;scmi&quot;</span>,</span><br><span class="line">	.flags	= CPUFREQ_STICKY | CPUFREQ_HAVE_GOVERNOR_PER_POLICY |</span><br><span class="line">		  CPUFREQ_NEED_INITIAL_FREQ_CHECK,</span><br><span class="line">	.verify	= cpufreq_generic_frequency_table_verify,</span><br><span class="line">	.attr	= cpufreq_generic_attr,</span><br><span class="line">	.target_index	= scmi_cpufreq_set_target,</span><br><span class="line">	.fast_switch	= scmi_cpufreq_fast_switch,</span><br><span class="line">	.get	= scmi_cpufreq_get_rate,</span><br><span class="line">	.init	= scmi_cpufreq_init,</span><br><span class="line">	.<span class="built_in">exit</span>	= scmi_cpufreq_exit,</span><br><span class="line">	.ready	= scmi_cpufreq_ready,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为每个cluster定义一个cpufreq_policy结构体，对每个cluster上的CPU进行调频管理</span></span><br><span class="line"><span class="comment">// 其中又分别进行cpufreq_driver的初始化和governor的初始化</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">DEFINE_PER_CPU</span><span class="params">(struct cpufreq_policy *, cpufreq_cpu_data)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// cpufreq驱动框架初始化过程，整个过程都围绕着policy这个结构体进行，逐步进行初始化</span></span><br><span class="line">cpufreq_register_driver(&amp;scmi_cpufreq_driver);</span><br><span class="line">	subsys_interface_register(&amp;cpufreq_interface);</span><br><span class="line">		cpufreq_add_dev(dev, sif);</span><br><span class="line">			cpufreq_online(cpu);</span><br><span class="line">				<span class="comment">// 初步初始化policy</span></span><br><span class="line">				policy = cpufreq_policy_alloc(cpu);</span><br><span class="line">				<span class="comment">// 调用cpufreq_drvier init接口，完善policy结构体</span></span><br><span class="line">				<span class="comment">// 将opp表添加到对应的device，通过dev_pm_opp_add接口</span></span><br><span class="line">				<span class="comment">// 生成频率表 freq_table</span></span><br><span class="line">				cpufreq_driver-&gt;init(policy) -&gt; scmi_cpufreq_init(policy)</span><br><span class="line">				cpufreq_table_validate_and_sort(policy);</span><br><span class="line">				<span class="comment">// 创建/sys/device/system/cpu/cpux目录下的cpufreq符号链接</span></span><br><span class="line">				add_cpu_dev_symlink();</span><br><span class="line">				freq_qos_and_request();</span><br><span class="line">				blocking_notifier_call_chain();</span><br><span class="line">				<span class="comment">// CPU进行频率调整，使当前运行频率在频率表中</span></span><br><span class="line">				__cpufreq_driver_target();</span><br><span class="line">				<span class="comment">// 创建sys节点，/sys/device/system/cpu/cpufreq/policyx目录下的一些可选属性</span></span><br><span class="line">				cpufreq_add_dev_interface(policy);</span><br><span class="line">				cpufreq_stats_create_table(policy);</span><br><span class="line">				list_add(&amp;policy-&gt;polic_list, &amp;cpufreq_policy_list);</span><br><span class="line">				<span class="comment">// 使用默认governor初始化policy</span></span><br><span class="line">				cpufreq_init_policy();</span><br></pre></td></tr></table></figure>

<h4 id="cpufreq-governor的初始化过程"><a href="#cpufreq-governor的初始化过程" class="headerlink" title="cpufreq_governor的初始化过程"></a>cpufreq_governor的初始化过程</h4><p>cpufreq governor的初始化过程，在cpufreq_init_policy(policy)中进行，这里以ondemand为例进行分析</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/linux/cpufreq.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cpufreq_governor</span> &#123;</span></span><br><span class="line">	<span class="keyword">char</span>	name[CPUFREQ_NAME_LEN];</span><br><span class="line">	<span class="keyword">int</span>	(*init)(struct cpufreq_policy *policy);</span><br><span class="line">	<span class="keyword">void</span>	(*<span class="built_in">exit</span>)(struct cpufreq_policy *policy);</span><br><span class="line">	<span class="keyword">int</span>	(*start)(struct cpufreq_policy *policy);</span><br><span class="line">	<span class="keyword">void</span>	(*stop)(struct cpufreq_policy *policy);</span><br><span class="line">	<span class="keyword">void</span>	(*limits)(struct cpufreq_policy *policy);</span><br><span class="line">	<span class="keyword">ssize_t</span>	(*show_setspeed)	(struct cpufreq_policy *policy,</span><br><span class="line">					 <span class="keyword">char</span> *buf);</span><br><span class="line">	<span class="keyword">int</span>	(*store_setspeed)	(struct cpufreq_policy *policy,</span><br><span class="line">					 <span class="keyword">unsigned</span> <span class="keyword">int</span> freq);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">governor_list</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">module</span>		*<span class="title">owner</span>;</span></span><br><span class="line">	u8			flags;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Common Governor data across policies */</span></span><br><span class="line"><span class="comment">// 抽象出的governor调度器结构体</span></span><br><span class="line"><span class="comment">// drivers/cpufreq/cpufreq_governor.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dbs_governor</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cpufreq_governor</span> <span class="title">gov</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kobj_type</span> <span class="title">kobj_type</span>;</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Common data for platforms that don&#x27;t set</span></span><br><span class="line"><span class="comment">	 * CPUFREQ_HAVE_GOVERNOR_PER_POLICY</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dbs_data</span> *<span class="title">gdbs_data</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">unsigned</span> <span class="title">int</span> <span class="params">(*gov_dbs_update)</span><span class="params">(struct cpufreq_policy *policy)</span></span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">policy_dbs_info</span> *(*<span class="title">alloc</span>)(<span class="title">void</span>);</span></span><br><span class="line">	<span class="keyword">void</span> (*<span class="built_in">free</span>)(struct policy_dbs_info *policy_dbs);</span><br><span class="line">	<span class="keyword">int</span> (*init)(struct dbs_data *dbs_data);</span><br><span class="line">	<span class="keyword">void</span> (*<span class="built_in">exit</span>)(struct dbs_data *dbs_data);</span><br><span class="line">	<span class="keyword">void</span> (*start)(struct cpufreq_policy *policy);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// drivers/cpufreq/cpufreq_governor.h</span></span><br><span class="line"><span class="comment">// governor初始化宏</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CPUFREQ_DBS_GOVERNOR_INITIALIZER(_name_)			\</span></span><br><span class="line"><span class="meta">	&#123;								\</span></span><br><span class="line"><span class="meta">		.name = _name_,						\</span></span><br><span class="line"><span class="meta">		.flags = CPUFREQ_GOV_DYNAMIC_SWITCHING,			\</span></span><br><span class="line"><span class="meta">		.owner = THIS_MODULE,					\</span></span><br><span class="line"><span class="meta">		.init = cpufreq_dbs_governor_init,			\</span></span><br><span class="line"><span class="meta">		.exit = cpufreq_dbs_governor_exit,			\</span></span><br><span class="line"><span class="meta">		.start = cpufreq_dbs_governor_start,			\</span></span><br><span class="line"><span class="meta">		.stop = cpufreq_dbs_governor_stop,			\</span></span><br><span class="line"><span class="meta">		.limits = cpufreq_dbs_governor_limits,			\</span></span><br><span class="line"><span class="meta">	&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ondemand governor定义</span></span><br><span class="line"><span class="comment">// driver/cpufreq/cpufreq_ondemand.c</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">dbs_governor</span> <span class="title">od_dbs_gov</span> =</span> &#123;</span><br><span class="line">	.gov = CPUFREQ_DBS_GOVERNOR_INITIALIZER(<span class="string">&quot;ondemand&quot;</span>),</span><br><span class="line">	.kobj_type = &#123; .default_attrs = od_attributes &#125;,</span><br><span class="line">	.gov_dbs_update = od_dbs_update,</span><br><span class="line">	.alloc = od_alloc,</span><br><span class="line">	.<span class="built_in">free</span> = od_free,</span><br><span class="line">	.init = od_init,</span><br><span class="line">	.<span class="built_in">exit</span> = od_exit,</span><br><span class="line">	.start = od_start,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化governor</span></span><br><span class="line"><span class="comment">// 该函数会在governor模块驱动的入口函数调用</span></span><br><span class="line"><span class="comment">// 只要编译该模块，就会注册到cpufreq framework中</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CPU_FREQ_GOV_ONDEMAND	(od_dbs_gov.gov)</span></span><br><span class="line">cpufreq_governor_init(CPU_FREQ_GOV_ONDEMAND);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> cpufreq_governor_init(__governor)			\</span></span><br><span class="line"><span class="meta">static int __init __governor##_init(void)			\</span></span><br><span class="line"><span class="meta">&#123;								\</span></span><br><span class="line"><span class="meta">	return cpufreq_register_governor(&amp;__governor);	\</span></span><br><span class="line"><span class="meta">&#125;								\</span></span><br><span class="line"><span class="meta">core_initcall(__governor##_init)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在cpufreq_online()中调用默认governor对policy进行完善，启动当前governor</span></span><br><span class="line">cpufreq_init_policy(policy);</span><br><span class="line">	gov = get_governor(default_governor);</span><br><span class="line">	<span class="comment">// 设置新的governor</span></span><br><span class="line">	cpufreq_set_policy(policy, gov, pol);</span><br><span class="line">		cpufreq_init_governor(policy);</span><br><span class="line">			policy-&gt;governor-&gt;init();  -&gt; cpufreq_dbs_governor_init(policy);</span><br><span class="line">				gov-&gt;init(dbs_data); -&gt; odinit(dbs_data);</span><br><span class="line">		cpufreq_start_governor(policy);</span><br><span class="line">			policy-&gt;governor-&gt;start(); -&gt; cpufreq_dbs_governor_start(policy);</span><br><span class="line">				<span class="comment">// 设置governor回调函数， 以ondemand为例</span></span><br><span class="line">				gov_set_update_util(policy_dbs, sampling_rate);</span><br><span class="line">					cpufreq_add_update_util_hook(cpu, &amp;cdbs-&gt;updata_util,</span><br><span class="line">									dbs_update_util_handler);</span><br></pre></td></tr></table></figure>
<p>启动governor中比较重要的是设置调频回调函数,该函数是真正调频时计算合适频率的函数</p>
<h4 id="schedutil调节器"><a href="#schedutil调节器" class="headerlink" title="schedutil调节器"></a>schedutil调节器</h4><p><img src="https://raw.githubusercontent.com/JackHuang021/images/master/20230103174117.png"><br>sugov作为一种内核调频策略模块，它主要是根据当前CPU的利用率进行调频。因此，sugov会注册一个callback函数（sugov_update_shared&#x2F;sugov_update_single）到调度器负载跟踪模块，当CPU util发生变化的时候就会调用该callback函数，检查一下当前CPU频率是否和当前的CPU util匹配，如果不匹配，那么就进行升频或者降频。</p>
<p><code>sugov_tunables</code>结构体，用来描述sugov的可调参数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sugov_tunables结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sugov_tunables</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gov_attr_set</span> <span class="title">attr_set</span>;</span></span><br><span class="line">	<span class="comment">// 目前sugov只有这一个可调参数，该参数用来限制连续调频的间隔时间</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> rate_limit_us;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>sugov_policy</code>结构体，sugov为每个cluster构建了该数据结构，记录每个cluster的调频数据信息</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sugov_policy结构体，为每个簇构建了该数据结构，记录每个簇的调频数据信息</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sugov_policy</span> &#123;</span></span><br><span class="line">	<span class="comment">// 指向cpufreq framework层的policy对象</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cpufreq_policy</span>	*<span class="title">policy</span>;</span></span><br><span class="line">	<span class="comment">// sugov的可调参数</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sugov_tunables</span>	*<span class="title">tunables</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">tunables_hook</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">raw_spinlock_t</span>		update_lock;	<span class="comment">/* For shared policies */</span></span><br><span class="line">	<span class="comment">// 记录上次进行频率调整的时间点</span></span><br><span class="line">	u64			last_freq_update_time;</span><br><span class="line">	<span class="comment">// 最小调频时间间隔</span></span><br><span class="line">	s64			freq_update_delay_ns;</span><br><span class="line">	<span class="comment">// 下一个需要调整到的频率值，回调函数主要是计算这个参数</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		next_freq;</span><br><span class="line">	<span class="comment">// 根据CPU util计算出来的原始频率，在频率表中向上找最接近的频率进行调整</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		cached_raw_freq;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* The next fields are only needed if fast switch cannot be used: */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span>			<span class="title">irq_work</span> <span class="title">irq_work</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span>			<span class="title">kthread_work</span> <span class="title">work</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span>			<span class="title">mutex</span> <span class="title">work_lock</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span>			<span class="title">kthread_worker</span> <span class="title">worker</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>	*<span class="title">thread</span>;</span></span><br><span class="line">	<span class="keyword">bool</span>			work_in_progress;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">bool</span>			limits_changed;</span><br><span class="line">	<span class="keyword">bool</span>			need_freq_update;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>sugov_cpu</code>结构体，sugov为每个cpu构建了该数据结构，记录per-cpu的调频数据信息</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sugov_cpu</span> &#123;</span></span><br><span class="line">	<span class="comment">// 保存了cpu util变化后的回调函数</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">update_util_data</span>	<span class="title">update_util</span>;</span></span><br><span class="line">	<span class="comment">// 该sugov_cpu对应的sugov_policy对象</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sugov_policy</span>	*<span class="title">sg_policy</span>;</span></span><br><span class="line">	<span class="comment">// 对应的CPU id</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		cpu;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">bool</span>			iowait_boost_pending;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		iowait_boost;</span><br><span class="line">	<span class="comment">// 上一次cpu负载变化驱动调频的时间点，util更新的时间点</span></span><br><span class="line">	u64			last_update;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		bw_dl;</span><br><span class="line">	<span class="comment">// 该CPU的最大算力，即最大utilities，归一化到1024</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		max;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* The field below is for single-CPU policies only: */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NO_HZ_COMMON</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		saved_idle_calls;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>sugov初始化过程和ondemand初始化过程相似，当内核设定默认governor为sugov时，在<code>cpufreq_init_governor(policy);</code>中会调用<code>sugov_init()</code>初始化sugov，然后调用<code>sugov_start()</code>设置调频回调函数，每当CPU利用率发生变化的时候，调度器都会调用<code>cpufreq_update_util()</code>通知sugov，在<code>cpufreq_update_util()</code>被调用时，即任务调度后CPU当前的util发生变化，会调用sugov的回调函数进行调频，<code>sugov_update_shared()</code>当一个簇中有多个CPU调用该回调，遍历簇上的CPU找到当前最大util的CPU，然后根据该util映射到频率；<code>sugov_update_single()</code>即一个簇上单个CPU的情况直接根据该CPUte_shared()&#96; util计算频率</p>
<p>调度事件的发生还是非常密集的，特别是在重载的情况下，很多任务可能执行若干个us就切换出去了。如果每次都计算CPU util看看是否需要调整频率，那么本身sugov就给系统带来较重的负荷，因此并非每次调频时机都会真正执行调频检查，sugov设置了一个最小调频间隔，小于这个间隔的调频请求会被过滤掉。</p>
<h5 id="schedutil频率计算过程"><a href="#schedutil频率计算过程" class="headerlink" title="schedutil频率计算过程"></a>schedutil频率计算过程</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sugov_start会遍历该sugov policy（cluster）中的所有cpu</span></span><br><span class="line"><span class="comment">// 调用cpufreq_add_update_util_hook为sugov cpu注册调频回调函数，代码逻辑如下：</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sugov_start</span><span class="params">(struct cpufreq_policy *policy)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	...</span><br><span class="line">	for_each_cpu(cpu, policy-&gt;cpus) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">sugov_cpu</span> *<span class="title">sg_cpu</span> =</span> &amp;per_cpu(sugov_cpu, cpu);</span><br><span class="line">		<span class="comment">// 设置governor 计算回调函数，cpufreq_update_util()被调用时</span></span><br><span class="line">		<span class="comment">// 即任务调度后CPU当前的util发生变化，会调用sugov的回调函数进行调频计算</span></span><br><span class="line">		cpufreq_add_update_util_hook(cpu, &amp;sg_cpu-&gt;update_util,</span><br><span class="line">					     policy_is_shared(policy) ?</span><br><span class="line">							sugov_update_shared :</span><br><span class="line">							sugov_update_single);</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// schedutil频率计算过程</span></span><br><span class="line">sugov_update_single();</span><br><span class="line">	<span class="comment">// 调频最小间隔时间检查，小于设定时间，直接返回</span></span><br><span class="line">	sugov_should_update_freq();</span><br><span class="line">	util = sugov_get_util(sg_cpuu);</span><br><span class="line">		schedutil_cpu_util(sg_cpu-&gt;cpu, util, max, FREQUENCY_UTIL, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="comment">// 根据当前CPU的util映射到具体的频率上</span></span><br><span class="line">	next_f = get_next_freq(sg_policy, util, max);</span><br><span class="line">	<span class="comment">// 调用cpufreq_driver进行调频</span></span><br><span class="line">	sugov_deferred_update(sg_policy, time, next_f);</span><br><span class="line">		__cpufreq_driver_target()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算cpu当前的utility</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">schedutil_cpu_util</span><span class="params">(<span class="keyword">int</span> cpu, <span class="keyword">unsigned</span> <span class="keyword">long</span> util_cfs,</span></span></span><br><span class="line"><span class="params"><span class="function">					<span class="keyword">unsigned</span> <span class="keyword">long</span> max, <span class="keyword">enum</span> schedutil_type type,</span></span></span><br><span class="line"><span class="params"><span class="function">					struct task_struct *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> dl_util, util, irq;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span> =</span> cpu_rq(cpu);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!uclamp_is_used() &amp;&amp;</span><br><span class="line">	    type == FREQUENCY_UTIL &amp;&amp; rt_rq_is_runnable(&amp;rq-&gt;rt)) &#123;</span><br><span class="line">		<span class="keyword">return</span> max;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果CPU处理了过多的中断服务函数，irq负载已经高过CPU最大算力，直接返回最大算力</span></span><br><span class="line">	irq = cpu_util_irq(rq);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(irq &gt;= max))</span><br><span class="line">		<span class="keyword">return</span> max;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 累加了cfs和rt任务的utility</span></span><br><span class="line">	util = util_cfs + cpu_util_rt(rq);</span><br><span class="line">	<span class="keyword">if</span> (type == FREQUENCY_UTIL)</span><br><span class="line">		util = uclamp_rq_util_with(rq, util, p);</span><br><span class="line"></span><br><span class="line">	dl_util = cpu_util_dl(rq);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (util + dl_util &gt;= max)</span><br><span class="line">		<span class="keyword">return</span> max;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * OTOH, for energy computation we need the estimated running time, so</span></span><br><span class="line"><span class="comment">	 * include util_dl and ignore dl_bw.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (type == ENERGY_UTIL)</span><br><span class="line">		util += dl_util;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * There is still idle time; further improve the number by using the</span></span><br><span class="line"><span class="comment">	 * irq metric. Because IRQ/steal time is hidden from the task clock we</span></span><br><span class="line"><span class="comment">	 * need to scale the task numbers:</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 *              max - irq</span></span><br><span class="line"><span class="comment">	 *   U&#x27; = irq + --------- * U</span></span><br><span class="line"><span class="comment">	 *                 max</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">// irq会偷走一部分的cpu算力，从而让其capacity没有那么大。</span></span><br><span class="line">	<span class="comment">// 这里通过scale_irq_capacity对任务的utility进行调整</span></span><br><span class="line">	util = scale_irq_capacity(util, irq, max);</span><br><span class="line">	util += irq;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Bandwidth required by DEADLINE must always be granted while, for</span></span><br><span class="line"><span class="comment">	 * FAIR and RT, we use blocked utilization of IDLE CPUs as a mechanism</span></span><br><span class="line"><span class="comment">	 * to gracefully reduce the frequency when no tasks show up for longer</span></span><br><span class="line"><span class="comment">	 * periods of time.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Ideally we would like to set bw_dl as min/guaranteed freq and util +</span></span><br><span class="line"><span class="comment">	 * bw_dl as requested freq. However, cpufreq is not yet ready for such</span></span><br><span class="line"><span class="comment">	 * an interface. So, we only do the latter for now.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (type == FREQUENCY_UTIL)</span><br><span class="line">		util += cpu_bw_dl(rq);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> min(max, util);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据当前CPU计算的util映射对应频率</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">get_next_freq</span><span class="params">(struct sugov_policy *sg_policy,</span></span></span><br><span class="line"><span class="params"><span class="function">				  <span class="keyword">unsigned</span> <span class="keyword">long</span> util, <span class="keyword">unsigned</span> <span class="keyword">long</span> max)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cpufreq_policy</span> *<span class="title">policy</span> =</span> sg_policy-&gt;policy;</span><br><span class="line">	<span class="comment">// 先取得当前CPU的最大频率</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> freq = arch_scale_freq_invariant() ?</span><br><span class="line">				policy-&gt;cpuinfo.max_freq : policy-&gt;cur;</span><br><span class="line">	<span class="comment">// 计算当前util对应频率，计算公式: freq = (1.25) * freq * util / max</span></span><br><span class="line">	<span class="comment">// 这里冗余了25%的算力余量</span></span><br><span class="line">	freq = map_util_freq(util, freq, max);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 若计算出的freq和上次缓存的一样，则实际调整的next_freq计算后肯定也是一样的，直接返回</span></span><br><span class="line">	<span class="comment">// 上次记录的频率值</span></span><br><span class="line">	<span class="keyword">if</span> (freq == sg_policy-&gt;cached_raw_freq &amp;&amp; !sg_policy-&gt;need_freq_update)</span><br><span class="line">		<span class="keyword">return</span> sg_policy-&gt;next_freq;</span><br><span class="line"></span><br><span class="line">	sg_policy-&gt;cached_raw_freq = freq;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 根据当前算的freq，在CPU频率表上查找对应的频率</span></span><br><span class="line">	freq = cpufreq_driver_resolve_freq(policy, freq);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> freq;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="EAS能源感知调度"><a href="#EAS能源感知调度" class="headerlink" title="EAS能源感知调度"></a>EAS能源感知调度</h4><p>EAS整体框架<br><img src="https://raw.githubusercontent.com/JackHuang021/images/master/20221216104706.png"></p>
<p>完全公平调度（Completely Fair Scheduler CFS）实现了面向吞吐量的的任务调度策略，EAS为这个调度器添加了一个基于能耗的调度策略，在优化CPU算力冗余的同时实现了节能，EAS在系统中、低度负载情况下工作，CFS在系统满负载情况下工作。</p>
<p>EAS在CPU调度领域，在为任务选核是起作用，目的是保证性能的情况下尽可能节省功耗，EAS涉及内核的几个子系统（任务调度、能源管理、CPU动态调频），EAS代码主要位于<code>kernel/sched/fair.c</code>，能源感知的任务调度需要调度器评估各个任务在CPU上运行带来的能耗影响</p>
<p>EAS负载跟踪有两种模式，一种是“每实体负载跟踪（Per_Entity Load Track）”，通常用于负载跟踪，然后该信息用于确定频率以及如何在CPU上委派任务，另一种是“窗口辅助的负载跟踪（Window-Assisted Load Tracking）”，WALT更具有突发性，而PELT试图让频率保持连贯性，负载跟踪器实际上并不影响CPU频率，它只是告诉系统CPU使用率是多少</p>
<p>EAS全局控制开关<code>/proc/sys/kernel/sched_energy_aware</code></p>
<h5 id="CPU算力归一化过程"><a href="#CPU算力归一化过程" class="headerlink" title="CPU算力归一化过程"></a>CPU算力归一化过程</h5><p>当前，Linux无法凭自身算出CPU算力，因此必须要有把这个信息传递给Linux的方式，它是从<code>capacity-dmips-mhz</code> CPU 设备树binding中衍生计算出来的</p>
<p>归一化CPU capacity，<code>topology_normalize_cpu_scale()</code>定义在<code>drivers/base/arch_topology()</code>，这个capacity在schedutil调度中被<code>sugov_get_util()</code>函数读取</p>
<p><code>topology_normalize_cpu_scale()</code>在CPU初始化<code>parse_dt_topology()</code>中被调用，capacity归一化的前提条件是需要在设备树中CPU节点设置<code>capacity-dmips-mhz</code>属性，该属性表示不同CPU的计算能力，内核读取该属性设置CPU的<code>raw_capacity</code>为<code>capacity-dmips-mhz</code>，参考内核文档<code>Documentation/devicetree/bindings/arm/cpu-capacity.txt</code></p>
<blockquote>
<p>ARM推荐的测试CPU的性能工具：Dhrystone 2.1以上版本，可以通过单核跑分成绩作为<code>capacity-dmips-mhz</code>属性的参考，DMIPS： Dhrystone Million Instructions executed Per Second，表示了在Dhrystone这样一种测试方法下的MIPS，Dhrystone是一种整数运算测试程序。MIPS&#x2F;MHz，就是说每MHz频率能产生多大的MIPS，CPU性能通常由每秒百万指令（Millions of Instructions Per Second，MIPS）表示，设备树里表示为dmips&#x2F;mhz</p>
</blockquote>
<p>CPU算力归一化公式，并不是简单的将capacity-dmips-mhz归一化到capacity，CPU的频率也参与到了计算中<br><code> capacity = (own(capacity-dmips-mhz) * own(max_freq)) / (max(capacity-dmips-mhz) * max(max_freq)) * 1024</code></p>
<p>根据测试部测试的E2000QCPU单核性能数据，E2000Q的<code>capacity-dmips-mhz</code>属性值可以设置为如下，放大1000倍：<br><img src="https://raw.githubusercontent.com/JackHuang021/images/master/20230105152415.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 小核</span></span><br><span class="line">cpu_l0: cpu@<span class="number">0</span> &#123;</span><br><span class="line">	...</span><br><span class="line">	capacity-dmips-mhz = &lt;<span class="number">2850</span>&gt;;</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 大核</span></span><br><span class="line">cpu_b0: cpu@<span class="number">0</span> &#123;</span><br><span class="line">	...</span><br><span class="line">	capacity-dmips-mhz = &lt;<span class="number">5660</span>&gt;;</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>实际经过CPU算力归一化到1024之后，对应的小核CPU算力为386，大核为1024</p>
<h5 id="EAS代码相关结构体"><a href="#EAS代码相关结构体" class="headerlink" title="EAS代码相关结构体"></a>EAS代码相关结构体</h5><p>perf_domain结构表示一个CPU性能域，perf_domain和cpufreq_policy是一一对应的，性能域之间形成链，链表头存放在root_domian中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/sched/sched.h</span></span><br><span class="line"><span class="comment">// perf_comain 结构表示一个CPU性能域，perf_domain和cpufreq_policy是一一对应的</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">perf_domain</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">em_perf_domain</span> *<span class="title">em_pd</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">perf_domain</span> *<span class="title">next</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">root_domain</span> &#123;</span></span><br><span class="line">	<span class="keyword">atomic_t</span>		refcount;</span><br><span class="line">	<span class="keyword">atomic_t</span>		rto_count;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span>		<span class="title">rcu</span>;</span></span><br><span class="line">	<span class="keyword">cpumask_var_t</span>		span;</span><br><span class="line">	<span class="keyword">cpumask_var_t</span>		online;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 该root_domain是否处于overload状态</span></span><br><span class="line">	<span class="keyword">int</span>			overload;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 该root_domain是否处于overutilized状态</span></span><br><span class="line">	<span class="keyword">int</span>			overutilized;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The bit corresponding to a CPU gets set here if such CPU has more</span></span><br><span class="line"><span class="comment">	 * than one runnable -deadline task (as it is below for RT tasks).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">cpumask_var_t</span>		dlo_mask;</span><br><span class="line">	<span class="keyword">atomic_t</span>		dlo_count;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dl_bw</span>		<span class="title">dl_bw</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cpudl</span>		<span class="title">cpudl</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_RT_PUSH_IPI</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * For IPI pull requests, loop across the rto_mask.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_work</span>		<span class="title">rto_push_work</span>;</span></span><br><span class="line">	<span class="keyword">raw_spinlock_t</span>		rto_lock;</span><br><span class="line">	<span class="comment">/* These are only updated and read within rto_lock */</span></span><br><span class="line">	<span class="keyword">int</span>			rto_loop;</span><br><span class="line">	<span class="keyword">int</span>			rto_cpu;</span><br><span class="line">	<span class="comment">/* These atomics are updated outside of a lock */</span></span><br><span class="line">	<span class="keyword">atomic_t</span>		rto_loop_next;</span><br><span class="line">	<span class="keyword">atomic_t</span>		rto_loop_start;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The &quot;RT overload&quot; flag: it gets set if a CPU has more than</span></span><br><span class="line"><span class="comment">	 * one runnable RT task.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">cpumask_var_t</span>		rto_mask;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cpupri</span>		<span class="title">cpupri</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 系统中算力最大的CPU的算力</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		max_cpu_capacity;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * NULL-terminated list of performance domains intersecting with the</span></span><br><span class="line"><span class="comment">	 * CPUs of the rd. Protected by RCU.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">// perf_domain单链表的表头</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">perf_domain</span> __<span class="title">rcu</span> *<span class="title">pd</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// include/linux/energy_model.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">em_perf_state</span> &#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> frequency;	<span class="comment">// CPU频点，单位KHz</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> power;		<span class="comment">// 此频点下的功耗</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> cost;			<span class="comment">// 此频点下的成本系数，等于 power * max_freq / freq</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">em_perf_domain</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">em_perf_state</span> *<span class="title">table</span>;</span>	<span class="comment">// CPU频点表</span></span><br><span class="line">	<span class="keyword">int</span> nr_perf_states;				<span class="comment">// 频点表中元素的个数</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> cpus[];			<span class="comment">// 此性能域中包括哪些CPU</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>E2000Q 5.10内核，perf_domain_debug 打印信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[    2.574534] root_domain 0-3: pd3:&#123; cpus=3 nr_pstate=4 &#125;</span><br><span class="line">[    2.574540] freq: 250000, power: 79, cost: 632</span><br><span class="line">[    2.579072] freq: 500000, power: 197, cost: 788</span><br><span class="line">[    2.583690] freq: 1000000, power: 409, cost: 818</span><br><span class="line">[    2.588390] freq: 2000000, power: 839, cost: 839</span><br><span class="line">[    2.593094]  pd2:&#123; cpus=2 nr_pstate=4 &#125;</span><br><span class="line">[    2.593096] freq: 250000, power: 79, cost: 632</span><br><span class="line">[    2.601445] freq: 500000, power: 197, cost: 788</span><br><span class="line">[    2.606054] freq: 1000000, power: 409, cost: 818</span><br><span class="line">[    2.610749] freq: 2000000, power: 839, cost: 839</span><br><span class="line">[    2.615445]  pd0:&#123; cpus=0-1 nr_pstate=4 &#125;</span><br><span class="line">[    2.615447] freq: 187500, power: 1, cost: 8</span><br><span class="line">[    2.623709] freq: 375000, power: 9, cost: 36</span><br><span class="line">[    2.628058] freq: 750000, power: 55, cost: 110</span><br><span class="line">[    2.632579] freq: 1500000, power: 125, cost: 125</span><br></pre></td></tr></table></figure>

<p>root_domain的overload和overutilized说明：</p>
<ul>
<li>对于一个 CPU 而言，其处于 overload 状态则说明其 rq 上有大于等于2个任务，或者虽然只有一个任务，但是是 misfit task</li>
<li>对于一个 CPU 而言，其处于 overutilized 状态说明该 cpu 的 utility 超过其 capacity（缺省预留20%的算力，另外，这里的 capacity 是用于cfs任务的算力）</li>
<li>对于 root domain，overload 表示至少有一个 cpu 处于 overload 状态。overutilized 表示至少有一个 cpu 处于 overutilized 状态</li>
<li>overutilized 状态非常重要，它决定了调度器是否启用EAS，只有在系统没有 overutilized 的情况下EAS才会生效。overload和newidle balance的频次控制相关，当系统在overload的情况下，newidle balance才会启动进行均衡。</li>
</ul>
<h5 id="EAS能量计算方法"><a href="#EAS能量计算方法" class="headerlink" title="EAS能量计算方法"></a>EAS能量计算方法</h5><p>CPU在某个performance state(ps)下的计算能力：<br>ps-&gt;cap &#x3D; ps-&gt;freq * scale_cpu &#x2F; cpu_max_freq	（1）</p>
<p>CPU在该频点performace state(ps)下的能量消耗：<br>cpu_nrg &#x3D; ps-&gt;power * cpu_util &#x2F; ps-&gt;cap  （2）</p>
<p>结合(1) (2)可以得出CPU在该ps下的能量消耗<br>    cpu_nrg &#x3D; ps-&gt;power * cpu_max_freq * cpu_util &#x2F; ps-&gt;freq * scale_cpu (3)</p>
<p>其中 ps-&gt;power * cpu_max_freq &#x2F; ps-&gt;freq 是一个固定数据存放在频点表的cost成员中</p>
<p>一个pd内的CPU，拥有相同的cost，所以一个pd内所有CPU的能量消耗可以表示为<br>pd_nrg &#x3D; ps-&gt;cost * sum(cpu_util) &#x2F; scale_cpu</p>
<h5 id="EAS的调度过程"><a href="#EAS的调度过程" class="headerlink" title="EAS的调度过程"></a>EAS的调度过程</h5><p>在任务被重新唤醒或者fork新建时，会通过<code>select_task_rq_fair()</code>将任务进行balance，达到充分利用CPU的目的。在<code>select_task_rq_fair()</code>，若任务是被重新唤醒就会调用<code>find_energy_efficient_cpu()</code>进行选核执行</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * compute_energy(): Estimates the energy that @pd would consume if @p was</span></span><br><span class="line"><span class="comment"> * migrated to @dst_cpu. compute_energy() predicts what will be the utilization</span></span><br><span class="line"><span class="comment"> * landscape of @pd&#x27;s CPUs after the task migration, and uses the Energy Model</span></span><br><span class="line"><span class="comment"> * to compute what would be the energy if we decided to actually migrate that</span></span><br><span class="line"><span class="comment"> * task.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 计算任务迁移到dst_cpu后，整个pd，即此cluster的energy</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span></span></span><br><span class="line"><span class="function"><span class="title">compute_energy</span><span class="params">(struct task_struct *p, <span class="keyword">int</span> dst_cpu, struct perf_domain *pd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cpumask</span> *<span class="title">pd_mask</span> =</span> perf_domain_span(pd);</span><br><span class="line">	<span class="comment">// 获取该CPU的算力</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> cpu_cap = arch_scale_cpu_capacity(cpumask_first(pd_mask));</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> max_util = <span class="number">0</span>, sum_util = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> cpu;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 对此pd中每个online cpu都执行计算</span></span><br><span class="line">	for_each_cpu_and(cpu, pd_mask, cpu_online_mask) &#123;</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> cpu_util, util_cfs = cpu_util_next(cpu, p, dst_cpu);</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">tsk</span> =</span> cpu == dst_cpu ? p : <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 返回该CPU下cfs+irq+rt+dl使用掉的CPU算力总和</span></span><br><span class="line">		sum_util += schedutil_cpu_util(cpu, util_cfs, cpu_cap,</span><br><span class="line">					       ENERGY_UTIL, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">		cpu_util = schedutil_cpu_util(cpu, util_cfs, cpu_cap,</span><br><span class="line">					      FREQUENCY_UTIL, tsk);</span><br><span class="line">		max_util = max(max_util, cpu_util);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 计算该pd下所有CPU的功耗和</span></span><br><span class="line">	<span class="keyword">return</span> em_cpu_energy(pd-&gt;em_pd, max_util, sum_util);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算该pd下所有CPU的功耗和</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">em_cpu_energy</span><span class="params">(struct em_perf_domain *pd,</span></span></span><br><span class="line"><span class="params"><span class="function">				<span class="keyword">unsigned</span> <span class="keyword">long</span> max_util, <span class="keyword">unsigned</span> <span class="keyword">long</span> sum_util)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> freq, scale_cpu;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">em_perf_state</span> *<span class="title">ps</span>;</span></span><br><span class="line">	<span class="keyword">int</span> i, cpu;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * In order to predict the performance state, map the utilization of</span></span><br><span class="line"><span class="comment">	 * the most utilized CPU of the performance domain to a requested</span></span><br><span class="line"><span class="comment">	 * frequency, like schedutil.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	cpu = cpumask_first(to_cpumask(pd-&gt;cpus));</span><br><span class="line">	scale_cpu = arch_scale_cpu_capacity(cpu);</span><br><span class="line">	ps = &amp;pd-&gt;table[pd-&gt;nr_perf_states - <span class="number">1</span>];</span><br><span class="line">	freq = map_util_freq(max_util, ps-&gt;frequency, scale_cpu);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Find the lowest performance state of the Energy Model above the</span></span><br><span class="line"><span class="comment">	 * requested frequency.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; pd-&gt;nr_perf_states; i++) &#123;</span><br><span class="line">		ps = &amp;pd-&gt;table[i];</span><br><span class="line">		<span class="keyword">if</span> (ps-&gt;frequency &gt;= freq)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The capacity of a CPU in the domain at the performance state (ps)</span></span><br><span class="line"><span class="comment">	 * can be computed as:</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 *             ps-&gt;freq * scale_cpu</span></span><br><span class="line"><span class="comment">	 *   ps-&gt;cap = --------------------                          (1)</span></span><br><span class="line"><span class="comment">	 *                 cpu_max_freq</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * So, ignoring the costs of idle states (which are not available in</span></span><br><span class="line"><span class="comment">	 * the EM), the energy consumed by this CPU at that performance state</span></span><br><span class="line"><span class="comment">	 * is estimated as:</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 *             ps-&gt;power * cpu_util</span></span><br><span class="line"><span class="comment">	 *   cpu_nrg = --------------------                          (2)</span></span><br><span class="line"><span class="comment">	 *                   ps-&gt;cap</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * since &#x27;cpu_util / ps-&gt;cap&#x27; represents its percentage of busy time.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 *   <span class="doctag">NOTE:</span> Although the result of this computation actually is in</span></span><br><span class="line"><span class="comment">	 *         units of power, it can be manipulated as an energy value</span></span><br><span class="line"><span class="comment">	 *         over a scheduling period, since it is assumed to be</span></span><br><span class="line"><span class="comment">	 *         constant during that interval.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * By injecting (1) in (2), &#x27;cpu_nrg&#x27; can be re-expressed as a product</span></span><br><span class="line"><span class="comment">	 * of two terms:</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 *             ps-&gt;power * cpu_max_freq   cpu_util</span></span><br><span class="line"><span class="comment">	 *   cpu_nrg = ------------------------ * ---------          (3)</span></span><br><span class="line"><span class="comment">	 *                    ps-&gt;freq            scale_cpu</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * The first term is static, and is stored in the em_perf_state struct</span></span><br><span class="line"><span class="comment">	 * as &#x27;ps-&gt;cost&#x27;.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Since all CPUs of the domain have the same micro-architecture, they</span></span><br><span class="line"><span class="comment">	 * share the same &#x27;ps-&gt;cost&#x27;, and the same CPU capacity. Hence, the</span></span><br><span class="line"><span class="comment">	 * total energy of the domain (which is the simple sum of the energy of</span></span><br><span class="line"><span class="comment">	 * all of its CPUs) can be factorized as:</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 *            ps-&gt;cost * \Sum cpu_util</span></span><br><span class="line"><span class="comment">	 *   pd_nrg = ------------------------                       (4)</span></span><br><span class="line"><span class="comment">	 *                  scale_cpu</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">return</span> ps-&gt;cost * sum_util / scale_cpu;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 寻找工作能耗最低的CPU</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">find_energy_efficient_cpu</span><span class="params">(struct task_struct *p, <span class="keyword">int</span> prev_cpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> prev_delta = ULONG_MAX, best_delta = ULONG_MAX;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">root_domain</span> *<span class="title">rd</span> =</span> cpu_rq(smp_processor_id())-&gt;rd;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> cpu_cap, util, base_energy = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> cpu, best_energy_cpu = prev_cpu;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sched_domain</span> *<span class="title">sd</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">perf_domain</span> *<span class="title">pd</span>;</span></span><br><span class="line"></span><br><span class="line">	rcu_read_lock();</span><br><span class="line">	<span class="comment">// 从rd取pd的指针</span></span><br><span class="line">	pd = rcu_dereference(rd-&gt;pd);</span><br><span class="line">	<span class="keyword">if</span> (!pd || READ_ONCE(rd-&gt;overutilized))</span><br><span class="line">		<span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Energy-aware wake-up happens on the lowest sched_domain starting</span></span><br><span class="line"><span class="comment">	 * from sd_asym_cpucapacity spanning over this_cpu and prev_cpu.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	sd = rcu_dereference(*this_cpu_ptr(&amp;sd_asym_cpucapacity));</span><br><span class="line">	<span class="keyword">while</span> (sd &amp;&amp; !cpumask_test_cpu(prev_cpu, sched_domain_span(sd)))</span><br><span class="line">		sd = sd-&gt;parent;</span><br><span class="line">	<span class="keyword">if</span> (!sd)</span><br><span class="line">		<span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">	sync_entity_load_avg(&amp;p-&gt;se);</span><br><span class="line">	<span class="keyword">if</span> (!task_util_est(p))</span><br><span class="line">		<span class="keyword">goto</span> unlock;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 遍历整个pd链表，计算p在不同pd下的能耗</span></span><br><span class="line">	<span class="keyword">for</span> (; pd; pd = pd-&gt;next) &#123;</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> cur_delta, spare_cap, max_spare_cap = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> base_energy_pd;</span><br><span class="line">		<span class="keyword">int</span> max_spare_cap_cpu = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Compute the &#x27;base&#x27; energy of the pd, without @p */</span></span><br><span class="line">		<span class="comment">// 计算不包括p的情况下此pd当前的energy</span></span><br><span class="line">		base_energy_pd = compute_energy(p, <span class="number">-1</span>, pd);</span><br><span class="line">		<span class="comment">// 不包括p的情况下系统的总energy</span></span><br><span class="line">		base_energy += base_energy_pd;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 遍历整个pd中的CPU，计算p放在该CPU上的功耗</span></span><br><span class="line">		for_each_cpu_and(cpu, perf_domain_span(pd), sched_domain_span(sd)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!cpumask_test_cpu(cpu, p-&gt;cpus_ptr))</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="comment">// 计算p放到此CPU后该CPU总共消耗的算力</span></span><br><span class="line">			util = cpu_util_next(cpu, p, cpu);</span><br><span class="line">			cpu_cap = capacity_of(cpu);</span><br><span class="line">			spare_cap = cpu_cap;</span><br><span class="line">			<span class="comment">// 计算p放到此CPU后剩余的算力</span></span><br><span class="line">			lsub_positive(&amp;spare_cap, util);</span><br><span class="line"></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * Skip CPUs that cannot satisfy the capacity request.</span></span><br><span class="line"><span class="comment">			 * IOW, placing the task there would make the CPU</span></span><br><span class="line"><span class="comment">			 * overutilized. Take uclamp into account to see how</span></span><br><span class="line"><span class="comment">			 * much capacity we can get out of the CPU; this is</span></span><br><span class="line"><span class="comment">			 * aligned with schedutil_cpu_util().</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			util = uclamp_rq_util_with(cpu_rq(cpu), util, p);</span><br><span class="line">			<span class="comment">// CPU需要保留20%左右的算力，不满足需求后进行下一个CPU的探测</span></span><br><span class="line">			<span class="keyword">if</span> (!fits_capacity(util, cpu_cap))</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* Always use prev_cpu as a candidate. */</span></span><br><span class="line">			<span class="comment">// 若对比的这个CPU就是任务之前运行的CPU</span></span><br><span class="line">			<span class="keyword">if</span> (cpu == prev_cpu) &#123;</span><br><span class="line">				<span class="comment">// 计算p放在该cpu后整个pd的能量消耗</span></span><br><span class="line">				prev_delta = compute_energy(p, prev_cpu, pd);</span><br><span class="line">				<span class="comment">// 计算p放在该CPU后整个pd增加的能量消耗</span></span><br><span class="line">				prev_delta -= base_energy_pd;</span><br><span class="line">				<span class="comment">// 更新best_delta，取最优能耗</span></span><br><span class="line">				best_delta = min(best_delta, prev_delta);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * Find the CPU with the maximum spare capacity in</span></span><br><span class="line"><span class="comment">			 * the performance domain</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="comment">// 记录p放上去后剩余算力最大的CPU和最大的剩余算力</span></span><br><span class="line">			<span class="keyword">if</span> (spare_cap &gt; max_spare_cap) &#123;</span><br><span class="line">				max_spare_cap = spare_cap;</span><br><span class="line">				max_spare_cap_cpu = cpu;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Evaluate the energy impact of using this CPU. */</span></span><br><span class="line">		<span class="comment">// 同一个簇上的CPU取最大余量算力的那个CPU与其他簇的CPU做能量消耗对比</span></span><br><span class="line">		<span class="keyword">if</span> (max_spare_cap_cpu &gt;= <span class="number">0</span> &amp;&amp; max_spare_cap_cpu != prev_cpu) &#123;</span><br><span class="line">			<span class="comment">// 计算p放在算力剩余最大的CPU后整个pd的能量消耗</span></span><br><span class="line">			cur_delta = compute_energy(p, max_spare_cap_cpu, pd);</span><br><span class="line">			<span class="comment">// 计算能量消耗增量</span></span><br><span class="line">			cur_delta -= base_energy_pd;</span><br><span class="line">			<span class="comment">// 如果当前能量增量优于p放在prev_cpu运行的能量消耗，则取该cpu运行p</span></span><br><span class="line">			<span class="keyword">if</span> (cur_delta &lt; best_delta) &#123;</span><br><span class="line">				best_delta = cur_delta;</span><br><span class="line">				best_energy_cpu = max_spare_cap_cpu;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">unlock:</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Pick the best CPU if prev_cpu cannot be used, or if it saves at</span></span><br><span class="line"><span class="comment">	 * least 6% of the energy used by prev_cpu.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">// 若prev_cpu找不到，就直接返回最优能耗cpu</span></span><br><span class="line">	<span class="keyword">if</span> (prev_delta == ULONG_MAX)</span><br><span class="line">		<span class="keyword">return</span> best_energy_cpu;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 若最优能耗比放在prev_cpu上运行的能耗还要低6.25%以上，则取最优能耗cpu</span></span><br><span class="line">	<span class="keyword">if</span> ((prev_delta - best_delta) &gt; ((prev_delta + base_energy) &gt;&gt; <span class="number">4</span>))</span><br><span class="line">		<span class="keyword">return</span> best_energy_cpu;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 否则不做改变，直接使用prev_cpu运行p</span></span><br><span class="line">	<span class="keyword">return</span> prev_cpu;</span><br><span class="line"></span><br><span class="line">fail:</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Cpufreq</tag>
      </tags>
  </entry>
  <entry>
    <title>030_linux_task_schedule.md</title>
    <url>/archives/c7062853.html</url>
    <content><![CDATA[<h4 id="环境："><a href="#环境：" class="headerlink" title="环境："></a>环境：</h4><ol>
<li>Kernel版本： 5.10</li>
<li>Phytium E2000Q armv8 aarch64</li>
</ol>
<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><p>在Linux中，每个CPU都会有一个队列来存储处于TASK_RUNNING状态的任务，任务调度就是从这些队列中取出优先级最高的任务作为下一个放入CPU执行的任务</p>
<p>任务的调度需要经过两个过程：上下文切换和选择算法</p>
<span id="more"></span>

<p>在Linux内核中，进程和线程都使用<code>struct task_struct</code>结构（定义在<code>/include/linux/sched.h</code>）来进行抽象描述，进程的虚拟地址空间分为用户虚拟地址空间和内核虚拟地址空间，所有进程共享内核虚拟地址空间，没有用户虚拟地址空间的进程称为内核线程</p>
<p>Linux内核使用<code>task_struct</code>结构体来抽象进程，该结构包含了进程的各类信息及所拥有的资源，比如进程的状态，打开的文件，地址空间信息，信号资源等</p>
<p><code>task_struct结构体非常复杂，定义如下</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// /include/linux/sched.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_THREAD_INFO_IN_TASK</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * For reasons of header soup (see current_thread_info()), this</span></span><br><span class="line"><span class="comment">	 * must be the first element of task_struct.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">thread_info</span>		<span class="title">thread_info</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="comment">/* -1 unrunnable, 0 runnable, &gt;0 stopped: */</span></span><br><span class="line">    <span class="comment">// 进程状态</span></span><br><span class="line">	<span class="keyword">volatile</span> <span class="keyword">long</span>			state;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * This begins the randomizable portion of task_struct. Only</span></span><br><span class="line"><span class="comment">	 * scheduling-critical items should be added above here.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	randomized_struct_fields_start</span><br><span class="line"></span><br><span class="line">	<span class="keyword">void</span>				*<span class="built_in">stack</span>;</span><br><span class="line">	<span class="keyword">refcount_t</span>			usage;</span><br><span class="line">	<span class="comment">/* Per task flags (PF_*), defined further below: */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>			flags;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>			ptrace;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 多核系统相关属性</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">	<span class="keyword">int</span>				on_cpu;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> __<span class="title">call_single_node</span>	<span class="title">wake_entry</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_THREAD_INFO_IN_TASK</span></span><br><span class="line">	<span class="comment">/* Current CPU: */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>			cpu;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>			wakee_flips;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>			wakee_flip_decay_ts;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>		*<span class="title">last_wakee</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * recent_used_cpu is initially set as the last CPU used by a task</span></span><br><span class="line"><span class="comment">	 * that wakes affine another task. Waker/wakee relationships can</span></span><br><span class="line"><span class="comment">	 * push tasks around a CPU where each wakeup moves to the next one.</span></span><br><span class="line"><span class="comment">	 * Tracking a recently used CPU allows a quick search for a recently</span></span><br><span class="line"><span class="comment">	 * used CPU that may be idle.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">int</span>				recent_used_cpu;</span><br><span class="line">	<span class="keyword">int</span>				wake_cpu;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">int</span>				on_rq;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调度优先级相关</span></span><br><span class="line">	<span class="keyword">int</span>				prio;</span><br><span class="line">	<span class="keyword">int</span>				static_prio;</span><br><span class="line">	<span class="keyword">int</span>				normal_prio;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>			rt_priority;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调度类，调度实体相关，任务组相关</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span>	*<span class="title">sched_class</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span>		<span class="title">se</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sched_rt_entity</span>		<span class="title">rt</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_CGROUP_SCHED</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_group</span>		*<span class="title">sched_task_group</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sched_dl_entity</span>		<span class="title">dl</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_UCLAMP_TASK</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Clamp values requested for a scheduling entity.</span></span><br><span class="line"><span class="comment">	 * Must be updated with task_rq_lock() held.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">uclamp_se</span>		<span class="title">uclamp_req</span>[<span class="title">UCLAMP_CNT</span>];</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Effective clamp values used for a scheduling entity.</span></span><br><span class="line"><span class="comment">	 * Must be updated with task_rq_lock() held.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">uclamp_se</span>		<span class="title">uclamp</span>[<span class="title">UCLAMP_CNT</span>];</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PREEMPT_NOTIFIERS</span></span><br><span class="line">	<span class="comment">/* List of struct preempt_notifier: */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span>		<span class="title">preempt_notifiers</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_BLK_DEV_IO_TRACE</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>			btrace_seq;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>			policy;</span><br><span class="line">	<span class="keyword">int</span>				nr_cpus_allowed;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">cpumask_t</span>			*cpus_ptr;</span><br><span class="line">	<span class="keyword">cpumask_t</span>			cpus_mask;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PREEMPT_RCU</span></span><br><span class="line">	<span class="keyword">int</span>				rcu_read_lock_nesting;</span><br><span class="line">	<span class="class"><span class="keyword">union</span> <span class="title">rcu_special</span>		<span class="title">rcu_read_unlock_special</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>		<span class="title">rcu_node_entry</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rcu_node</span>			*<span class="title">rcu_blocked_node</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* #ifdef CONFIG_PREEMPT_RCU */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_TASKS_RCU</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>			rcu_tasks_nvcsw;</span><br><span class="line">	u8				rcu_tasks_holdout;</span><br><span class="line">	u8				rcu_tasks_idx;</span><br><span class="line">	<span class="keyword">int</span>				rcu_tasks_idle_cpu;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>		<span class="title">rcu_tasks_holdout_list</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* #ifdef CONFIG_TASKS_RCU */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_TASKS_TRACE_RCU</span></span><br><span class="line">	<span class="keyword">int</span>				trc_reader_nesting;</span><br><span class="line">	<span class="keyword">int</span>				trc_ipi_to_cpu;</span><br><span class="line">	<span class="class"><span class="keyword">union</span> <span class="title">rcu_special</span>		<span class="title">trc_reader_special</span>;</span></span><br><span class="line">	<span class="keyword">bool</span>				trc_reader_checked;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>		<span class="title">trc_holdout_list</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* #ifdef CONFIG_TASKS_TRACE_RCU */</span></span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sched_info</span>		<span class="title">sched_info</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>		<span class="title">tasks</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">plist_node</span>		<span class="title">pushable_tasks</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span>			<span class="title">pushable_dl_tasks</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span>		*<span class="title">mm</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span>		*<span class="title">active_mm</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Per-thread vma caching: */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vmacache</span>			<span class="title">vmacache</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> SPLIT_RSS_COUNTING</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_rss_stat</span>		<span class="title">rss_stat</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">int</span>				exit_state;</span><br><span class="line">	<span class="keyword">int</span>				exit_code;</span><br><span class="line">	<span class="keyword">int</span>				exit_signal;</span><br><span class="line">	<span class="comment">/* The signal sent when the parent dies: */</span></span><br><span class="line">	<span class="keyword">int</span>				pdeath_signal;</span><br><span class="line">	<span class="comment">/* JOBCTL_*, siglock protected: */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>			jobctl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Used for emulating ABI behavior of previous Linux versions: */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>			personality;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Scheduler bits, serialized by scheduler locks: */</span></span><br><span class="line">	<span class="keyword">unsigned</span>			sched_reset_on_fork:<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">unsigned</span>			sched_contributes_to_load:<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">unsigned</span>			sched_migrated:<span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PSI</span></span><br><span class="line">	<span class="keyword">unsigned</span>			sched_psi_wake_requeue:<span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Force alignment to the next boundary: */</span></span><br><span class="line">	<span class="keyword">unsigned</span>			:<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Unserialized, strictly &#x27;current&#x27; */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * This field must not be in the scheduler word above due to wakelist</span></span><br><span class="line"><span class="comment">	 * queueing no longer being serialized by p-&gt;on_cpu. However:</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * p-&gt;XXX = X;			ttwu()</span></span><br><span class="line"><span class="comment">	 * schedule()			  if (p-&gt;on_rq &amp;&amp; ..) // false</span></span><br><span class="line"><span class="comment">	 *   smp_mb__after_spinlock();	  if (smp_load_acquire(&amp;p-&gt;on_cpu) &amp;&amp; //true</span></span><br><span class="line"><span class="comment">	 *   deactivate_task()		      ttwu_queue_wakelist())</span></span><br><span class="line"><span class="comment">	 *     p-&gt;on_rq = 0;			p-&gt;sched_remote_wakeup = Y;</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * guarantees all stores of &#x27;current&#x27; are visible before</span></span><br><span class="line"><span class="comment">	 * -&gt;sched_remote_wakeup gets used, so it can be in this word.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">unsigned</span>			sched_remote_wakeup:<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Bit to tell LSMs we&#x27;re in execve(): */</span></span><br><span class="line">	<span class="keyword">unsigned</span>			in_execve:<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">unsigned</span>			in_iowait:<span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> TIF_RESTORE_SIGMASK</span></span><br><span class="line">	<span class="keyword">unsigned</span>			restore_sigmask:<span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MEMCG</span></span><br><span class="line">	<span class="keyword">unsigned</span>			in_user_fault:<span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_COMPAT_BRK</span></span><br><span class="line">	<span class="keyword">unsigned</span>			brk_randomized:<span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_CGROUPS</span></span><br><span class="line">	<span class="comment">/* disallow userland-initiated cgroup migration */</span></span><br><span class="line">	<span class="keyword">unsigned</span>			no_cgroup_migration:<span class="number">1</span>;</span><br><span class="line">	<span class="comment">/* task is frozen/stopped (used by the cgroup freezer) */</span></span><br><span class="line">	<span class="keyword">unsigned</span>			frozen:<span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_BLK_CGROUP</span></span><br><span class="line">	<span class="keyword">unsigned</span>			use_memdelay:<span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PSI</span></span><br><span class="line">	<span class="comment">/* Stalled due to lack of memory */</span></span><br><span class="line">	<span class="keyword">unsigned</span>			in_memstall:<span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>			atomic_flags; <span class="comment">/* Flags requiring atomic access. */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">restart_block</span>		<span class="title">restart_block</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">pid_t</span>				pid;</span><br><span class="line">	<span class="keyword">pid_t</span>				tgid;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_STACKPROTECTOR</span></span><br><span class="line">	<span class="comment">/* Canary value for the -fstack-protector GCC feature: */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>			stack_canary;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Pointers to the (original) parent process, youngest child, younger sibling,</span></span><br><span class="line"><span class="comment">	 * older sibling, respectively.  (p-&gt;father can be replaced with</span></span><br><span class="line"><span class="comment">	 * p-&gt;real_parent-&gt;pid)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Real parent process: */</span></span><br><span class="line">    <span class="comment">// 父进程</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> __<span class="title">rcu</span>	*<span class="title">real_parent</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Recipient of SIGCHLD, wait4() reports: */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> __<span class="title">rcu</span>	*<span class="title">parent</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Children/sibling form the list of natural children:</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">// 子进程 兄弟进程链表</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>		<span class="title">children</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>		<span class="title">sibling</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>		*<span class="title">group_leader</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * &#x27;ptraced&#x27; is the list of tasks this task is using ptrace() on.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * This includes both natural children and PTRACE_ATTACH targets.</span></span><br><span class="line"><span class="comment">	 * &#x27;ptrace_entry&#x27; is this task&#x27;s link on the p-&gt;parent-&gt;ptraced list.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>		<span class="title">ptraced</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>		<span class="title">ptrace_entry</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* PID/PID hash table linkage. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pid</span>			*<span class="title">thread_pid</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span>		<span class="title">pid_links</span>[<span class="title">PIDTYPE_MAX</span>];</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>		<span class="title">thread_group</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>		<span class="title">thread_node</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">completion</span>		*<span class="title">vfork_done</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* CLONE_CHILD_SETTID: */</span></span><br><span class="line">	<span class="keyword">int</span> __user			*set_child_tid;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* CLONE_CHILD_CLEARTID: */</span></span><br><span class="line">	<span class="keyword">int</span> __user			*clear_child_tid;</span><br><span class="line"></span><br><span class="line">	u64				utime;</span><br><span class="line">	u64				stime;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_ARCH_HAS_SCALED_CPUTIME</span></span><br><span class="line">	u64				utimescaled;</span><br><span class="line">	u64				stimescaled;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	u64				gtime;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">prev_cputime</span>		<span class="title">prev_cputime</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_VIRT_CPU_ACCOUNTING_GEN</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vtime</span>			<span class="title">vtime</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NO_HZ_FULL</span></span><br><span class="line">	<span class="keyword">atomic_t</span>			tick_dep_mask;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="comment">/* Context switch counts: */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>			nvcsw;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>			nivcsw;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Monotonic time in nsecs: */</span></span><br><span class="line">	u64				start_time;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Boot based time in nsecs: */</span></span><br><span class="line">	u64				start_boottime;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* MM fault and swap info: this can arguably be seen as either mm-specific or thread-specific: */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>			min_flt;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>			maj_flt;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Empty if CONFIG_POSIX_CPUTIMERS=n */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">posix_cputimers</span>		<span class="title">posix_cputimers</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_POSIX_CPU_TIMERS_TASK_WORK</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">posix_cputimers_work</span>	<span class="title">posix_cputimers_work</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Process credentials: */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Tracer&#x27;s credentials at attach: */</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span>		*<span class="title">ptracer_cred</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Objective and real subjective task credentials (COW): */</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span>		*<span class="title">real_cred</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Effective (overridable) subjective task credentials (COW): */</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span>		*<span class="title">cred</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_KEYS</span></span><br><span class="line">	<span class="comment">/* Cached requested key. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">key</span>			*<span class="title">cached_requested_key</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * executable name, excluding path.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * - normally initialized setup_new_exec()</span></span><br><span class="line"><span class="comment">	 * - access it with [gs]et_task_comm()</span></span><br><span class="line"><span class="comment">	 * - lock it with task_lock()</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">char</span>				comm[TASK_COMM_LEN];</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nameidata</span>		*<span class="title">nameidata</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SYSVIPC</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sysv_sem</span>			<span class="title">sysvsem</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sysv_shm</span>			<span class="title">sysvshm</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DETECT_HUNG_TASK</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>			last_switch_count;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>			last_switch_time;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="comment">/* Filesystem information: */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fs_struct</span>		*<span class="title">fs</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Open file information: */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span>		*<span class="title">files</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_IO_URING</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">io_uring_task</span>		*<span class="title">io_uring</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Namespaces: */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nsproxy</span>			*<span class="title">nsproxy</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Signal handlers: */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">signal_struct</span>		*<span class="title">signal</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sighand_struct</span> __<span class="title">rcu</span>		*<span class="title">sighand</span>;</span></span><br><span class="line">	<span class="keyword">sigset_t</span>			blocked;</span><br><span class="line">	<span class="keyword">sigset_t</span>			real_blocked;</span><br><span class="line">	<span class="comment">/* Restored if set_restore_sigmask() was used: */</span></span><br><span class="line">	<span class="keyword">sigset_t</span>			saved_sigmask;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sigpending</span>		<span class="title">pending</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>			sas_ss_sp;</span><br><span class="line">	<span class="keyword">size_t</span>				sas_ss_size;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>			sas_ss_flags;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">callback_head</span>		*<span class="title">task_works</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_AUDIT</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_AUDITSYSCALL</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">audit_context</span>		*<span class="title">audit_context</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">kuid_t</span>				loginuid;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>			sessionid;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">seccomp</span>			<span class="title">seccomp</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Thread group tracking: */</span></span><br><span class="line">	u64				parent_exec_id;</span><br><span class="line">	u64				self_exec_id;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Protection against (de-)allocation: mm, files, fs, tty, keyrings, mems_allowed, mempolicy: */</span></span><br><span class="line">	<span class="keyword">spinlock_t</span>			alloc_lock;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Protection of the PI data structures: */</span></span><br><span class="line">	<span class="keyword">raw_spinlock_t</span>			pi_lock;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">wake_q_node</span>		<span class="title">wake_q</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_RT_MUTEXES</span></span><br><span class="line">	<span class="comment">/* PI waiters blocked on a rt_mutex held by this task: */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_root_cached</span>		<span class="title">pi_waiters</span>;</span></span><br><span class="line">	<span class="comment">/* Updated under owner&#x27;s pi_lock and rq lock */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>		*<span class="title">pi_top_task</span>;</span></span><br><span class="line">	<span class="comment">/* Deadlock detection and priority inheritance handling: */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rt_mutex_waiter</span>		*<span class="title">pi_blocked_on</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_MUTEXES</span></span><br><span class="line">	<span class="comment">/* Mutex deadlock detection: */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex_waiter</span>		*<span class="title">blocked_on</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_ATOMIC_SLEEP</span></span><br><span class="line">	<span class="keyword">int</span>				non_block_count;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_TRACE_IRQFLAGS</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irqtrace_events</span>		<span class="title">irqtrace</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>			hardirq_threaded;</span><br><span class="line">	u64				hardirq_chain_key;</span><br><span class="line">	<span class="keyword">int</span>				softirqs_enabled;</span><br><span class="line">	<span class="keyword">int</span>				softirq_context;</span><br><span class="line">	<span class="keyword">int</span>				irq_config;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_LOCKDEP</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> MAX_LOCK_DEPTH			48UL</span></span><br><span class="line">	u64				curr_chain_key;</span><br><span class="line">	<span class="keyword">int</span>				lockdep_depth;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>			lockdep_recursion;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">held_lock</span>		<span class="title">held_locks</span>[<span class="title">MAX_LOCK_DEPTH</span>];</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_UBSAN) &amp;&amp; !defined(CONFIG_UBSAN_TRAP)</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>			in_ubsan;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Journalling filesystem info: */</span></span><br><span class="line">	<span class="keyword">void</span>				*journal_info;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Stacked block device info: */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bio_list</span>			*<span class="title">bio_list</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_BLOCK</span></span><br><span class="line">	<span class="comment">/* Stack plugging: */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">blk_plug</span>			*<span class="title">plug</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* VM state: */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">reclaim_state</span>		*<span class="title">reclaim_state</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">backing_dev_info</span>		*<span class="title">backing_dev_info</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">io_context</span>		*<span class="title">io_context</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_COMPACTION</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">capture_control</span>		*<span class="title">capture_control</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="comment">/* Ptrace state: */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>			ptrace_message;</span><br><span class="line">	<span class="keyword">kernel_siginfo_t</span>		*last_siginfo;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_io_accounting</span>	<span class="title">ioac</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PSI</span></span><br><span class="line">	<span class="comment">/* Pressure stall state */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>			psi_flags;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_TASK_XACCT</span></span><br><span class="line">	<span class="comment">/* Accumulated RSS usage: */</span></span><br><span class="line">	u64				acct_rss_mem1;</span><br><span class="line">	<span class="comment">/* Accumulated virtual memory usage: */</span></span><br><span class="line">	u64				acct_vm_mem1;</span><br><span class="line">	<span class="comment">/* stime + utime since last update: */</span></span><br><span class="line">	u64				acct_timexpd;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_CPUSETS</span></span><br><span class="line">	<span class="comment">/* Protected by -&gt;alloc_lock: */</span></span><br><span class="line">	<span class="keyword">nodemask_t</span>			mems_allowed;</span><br><span class="line">	<span class="comment">/* Seqence number to catch updates: */</span></span><br><span class="line">	<span class="keyword">seqcount_spinlock_t</span>		mems_allowed_seq;</span><br><span class="line">	<span class="keyword">int</span>				cpuset_mem_spread_rotor;</span><br><span class="line">	<span class="keyword">int</span>				cpuset_slab_spread_rotor;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_CGROUPS</span></span><br><span class="line">	<span class="comment">/* Control Group info protected by css_set_lock: */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">css_set</span> __<span class="title">rcu</span>		*<span class="title">cgroups</span>;</span></span><br><span class="line">	<span class="comment">/* cg_list protected by css_set_lock and tsk-&gt;alloc_lock: */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>		<span class="title">cg_list</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_X86_CPU_RESCTRL</span></span><br><span class="line">	u32				closid;</span><br><span class="line">	u32				rmid;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_FUTEX</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">robust_list_head</span> __<span class="title">user</span>	*<span class="title">robust_list</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_COMPAT</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">compat_robust_list_head</span> __<span class="title">user</span> *<span class="title">compat_robust_list</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>		<span class="title">pi_state_list</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">futex_pi_state</span>		*<span class="title">pi_state_cache</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>			<span class="title">futex_exit_mutex</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>			futex_state;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PERF_EVENTS</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">perf_event_context</span>	*<span class="title">perf_event_ctxp</span>[<span class="title">perf_nr_task_contexts</span>];</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>			<span class="title">perf_event_mutex</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>		<span class="title">perf_event_list</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_PREEMPT</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>			preempt_disable_ip;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line">	<span class="comment">/* Protected by alloc_lock: */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mempolicy</span>		*<span class="title">mempolicy</span>;</span></span><br><span class="line">	<span class="keyword">short</span>				il_prev;</span><br><span class="line">	<span class="keyword">short</span>				pref_node_fork;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NUMA_BALANCING</span></span><br><span class="line">	<span class="keyword">int</span>				numa_scan_seq;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>			numa_scan_period;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>			numa_scan_period_max;</span><br><span class="line">	<span class="keyword">int</span>				numa_preferred_nid;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>			numa_migrate_retry;</span><br><span class="line">	<span class="comment">/* Migration stamp: */</span></span><br><span class="line">	u64				node_stamp;</span><br><span class="line">	u64				last_task_numa_placement;</span><br><span class="line">	u64				last_sum_exec_runtime;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">callback_head</span>		<span class="title">numa_work</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * This pointer is only modified for current in syscall and</span></span><br><span class="line"><span class="comment">	 * pagefault context (and for tasks being destroyed), so it can be read</span></span><br><span class="line"><span class="comment">	 * from any of the following contexts:</span></span><br><span class="line"><span class="comment">	 *  - RCU read-side critical section</span></span><br><span class="line"><span class="comment">	 *  - current-&gt;numa_group from everywhere</span></span><br><span class="line"><span class="comment">	 *  - task&#x27;s runqueue locked, task not running</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">numa_group</span> __<span class="title">rcu</span>		*<span class="title">numa_group</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * numa_faults is an array split into four regions:</span></span><br><span class="line"><span class="comment">	 * faults_memory, faults_cpu, faults_memory_buffer, faults_cpu_buffer</span></span><br><span class="line"><span class="comment">	 * in this precise order.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * faults_memory: Exponential decaying average of faults on a per-node</span></span><br><span class="line"><span class="comment">	 * basis. Scheduling placement decisions are made based on these</span></span><br><span class="line"><span class="comment">	 * counts. The values remain static for the duration of a PTE scan.</span></span><br><span class="line"><span class="comment">	 * faults_cpu: Track the nodes the process was running on when a NUMA</span></span><br><span class="line"><span class="comment">	 * hinting fault was incurred.</span></span><br><span class="line"><span class="comment">	 * faults_memory_buffer and faults_cpu_buffer: Record faults per node</span></span><br><span class="line"><span class="comment">	 * during the current scan window. When the scan completes, the counts</span></span><br><span class="line"><span class="comment">	 * in faults_memory and faults_cpu decay and these values are copied.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>			*numa_faults;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>			total_numa_faults;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * numa_faults_locality tracks if faults recorded during the last</span></span><br><span class="line"><span class="comment">	 * scan window were remote/local or failed to migrate. The task scan</span></span><br><span class="line"><span class="comment">	 * period is adapted based on the locality of the faults with different</span></span><br><span class="line"><span class="comment">	 * weights depending on whether they were shared or private faults</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>			numa_faults_locality[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>			numa_pages_migrated;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_NUMA_BALANCING */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_RSEQ</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rseq</span> __<span class="title">user</span> *<span class="title">rseq</span>;</span></span><br><span class="line">	u32 rseq_sig;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * RmW on rseq_event_mask must be performed atomically</span></span><br><span class="line"><span class="comment">	 * with respect to preemption.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> rseq_event_mask;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tlbflush_unmap_batch</span>	<span class="title">tlb_ubc</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="keyword">refcount_t</span>		rcu_users;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span>		<span class="title">rcu</span>;</span></span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Cache last used pipe for splice(): */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span>		*<span class="title">splice_pipe</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page_frag</span>		<span class="title">task_frag</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_TASK_DELAY_ACCT</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_delay_info</span>		*<span class="title">delays</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_FAULT_INJECTION</span></span><br><span class="line">	<span class="keyword">int</span>				make_it_fail;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>			fail_nth;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * When (nr_dirtied &gt;= nr_dirtied_pause), it&#x27;s time to call</span></span><br><span class="line"><span class="comment">	 * balance_dirty_pages() for a dirty throttling pause:</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">int</span>				nr_dirtied;</span><br><span class="line">	<span class="keyword">int</span>				nr_dirtied_pause;</span><br><span class="line">	<span class="comment">/* Start of a write-and-pause period: */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>			dirty_paused_when;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_LATENCYTOP</span></span><br><span class="line">	<span class="keyword">int</span>				latency_record_count;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">latency_record</span>		<span class="title">latency_record</span>[<span class="title">LT_SAVECOUNT</span>];</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Time slack values; these are used to round up poll() and</span></span><br><span class="line"><span class="comment">	 * select() etc timeout values. These are in nanoseconds.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	u64				timer_slack_ns;</span><br><span class="line">	u64				default_timer_slack_ns;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_KASAN</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>			kasan_depth;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_KCSAN</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kcsan_ctx</span>		<span class="title">kcsan_ctx</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_TRACE_IRQFLAGS</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irqtrace_events</span>		<span class="title">kcsan_save_irqtrace</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> IS_ENABLED(CONFIG_KUNIT)</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kunit</span>			*<span class="title">kunit_test</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_FUNCTION_GRAPH_TRACER</span></span><br><span class="line">	<span class="comment">/* Index of current stored address in ret_stack: */</span></span><br><span class="line">	<span class="keyword">int</span>				curr_ret_stack;</span><br><span class="line">	<span class="keyword">int</span>				curr_ret_depth;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Stack of return addresses for return function tracing: */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ftrace_ret_stack</span>		*<span class="title">ret_stack</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Timestamp for last schedule: */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>		ftrace_timestamp;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Number of functions that haven&#x27;t been traced</span></span><br><span class="line"><span class="comment">	 * because of depth overrun:</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">atomic_t</span>			trace_overrun;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Pause tracing: */</span></span><br><span class="line">	<span class="keyword">atomic_t</span>			tracing_graph_pause;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_TRACING</span></span><br><span class="line">	<span class="comment">/* State flags for use by tracers: */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>			trace;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Bitmask and counter of trace recursion: */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>			trace_recursion;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_TRACING */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_KCOV</span></span><br><span class="line">	<span class="comment">/* See kernel/kcov.c for more details. */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Coverage collection mode enabled for this task (0 if disabled): */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>			kcov_mode;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Size of the kcov_area: */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>			kcov_size;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Buffer for coverage collection: */</span></span><br><span class="line">	<span class="keyword">void</span>				*kcov_area;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* KCOV descriptor wired with this task or NULL: */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kcov</span>			*<span class="title">kcov</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* KCOV common handle for remote coverage collection: */</span></span><br><span class="line">	u64				kcov_handle;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* KCOV sequence number: */</span></span><br><span class="line">	<span class="keyword">int</span>				kcov_sequence;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Collect coverage from softirq context: */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>			kcov_softirq;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MEMCG</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mem_cgroup</span>		*<span class="title">memcg_in_oom</span>;</span></span><br><span class="line">	<span class="keyword">gfp_t</span>				memcg_oom_gfp_mask;</span><br><span class="line">	<span class="keyword">int</span>				memcg_oom_order;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Number of pages to reclaim on returning to userland: */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>			memcg_nr_pages_over_high;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Used by memcontrol for targeted memcg charge: */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mem_cgroup</span>		*<span class="title">active_memcg</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_BLK_CGROUP</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">request_queue</span>		*<span class="title">throttle_queue</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_UPROBES</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">uprobe_task</span>		*<span class="title">utask</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_BCACHE) || defined(CONFIG_BCACHE_MODULE)</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>			sequential_io;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>			sequential_io_avg;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_ATOMIC_SLEEP</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>			task_state_change;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">int</span>				pagefault_disabled;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MMU</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>		*<span class="title">oom_reaper_list</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_VMAP_STACK</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vm_struct</span>		*<span class="title">stack_vm_area</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_THREAD_INFO_IN_TASK</span></span><br><span class="line">	<span class="comment">/* A live task holds one reference: */</span></span><br><span class="line">	<span class="keyword">refcount_t</span>			stack_refcount;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_LIVEPATCH</span></span><br><span class="line">	<span class="keyword">int</span> patch_state;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line">	<span class="comment">/* Used by LSM modules for access restriction: */</span></span><br><span class="line">	<span class="keyword">void</span>				*security;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_GCC_PLUGIN_STACKLEAK</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>			lowest_stack;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>			prev_lowest_stack;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_X86_MCE</span></span><br><span class="line">	<span class="keyword">void</span> __user			*mce_vaddr;</span><br><span class="line">	__u64				mce_kflags;</span><br><span class="line">	u64				mce_addr;</span><br><span class="line">	__u64				mce_ripv : <span class="number">1</span>,</span><br><span class="line">					mce_whole_page : <span class="number">1</span>,</span><br><span class="line">					__mce_reserved : <span class="number">62</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">callback_head</span>		<span class="title">mce_kill_me</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * New fields for task_struct should be added above here, so that</span></span><br><span class="line"><span class="comment">	 * they are included in the randomized portion of task_struct.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	randomized_struct_fields_end</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* CPU-specific state of this task: */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">thread_struct</span>		<span class="title">thread</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * WARNING: on x86, &#x27;thread_struct&#x27; contains a variable-sized</span></span><br><span class="line"><span class="comment">	 * structure.  It *MUST* be at the end of &#x27;task_struct&#x27;.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Do not put anything below here!</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h5><p>进程三状态模和Linux内核对应的进程状态切换，Linux中进程的就绪态和运行态对应的都是<code>TASK_RUNNING</code>标志位，就绪态表示进程正处在队列中，尚未被调度，运行态则表示进程正在CPU上运行</p>
<p><img src="https://raw.githubusercontent.com/JackHuang021/images/master/process_state.drawio2.png"></p>
<p>内核中主要的状态字段定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* used in task_struct-&gt;state */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_RUNNING            0x0000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_INTERRUPTIBLE      0x0001</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_UNINTERRUPTIBLE    0x0002</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __TASK_STOPPED          0x0004</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __TASK_TRACED           0x0008</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* used in task_struct-&gt;exit_state */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXIT_DEAD               0x0010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXIT_ZOMBIE             0x0020</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXIT_TRACE              (EXIT_ZOMBIE | EXIT_DEAD)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* used in task_struct-&gt;state */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_PARKED             0x0040</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_DEAD               0x0080</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_WAKEKILL           0x0100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_WAKING             0x0200</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_NOLOAD             0x0400</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_NEW                0x0800</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_STATE_MAX          0x1000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Convenience macros for the sake of set_current_state */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_KILLABLE           (TASK_WAKEKILL | TASK_UNINTERRUPTIBLE)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_STOPPED            (TASK_WAKEKILL | __TASK_STOPPED)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_TRACED             (TASK_WAKEKILL | __TASK_TRACED)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_IDLE               (TASK_UNINTERRUPTIBLE | TASK_NOLOAD)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Convenience macros for the sake of wake_up() */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_NORMAL             (TASK_INTERRUPTIBLE | TASK_UNINTERRUPTIBLE)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* get_task_state() */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_REPORT             (TASK_RUNNING | TASK_INTERRUPTIBLE | \</span></span><br><span class="line"><span class="meta">                                TASK_UNINTERRUPTIBLE | __TASK_STOPPED | \</span></span><br><span class="line"><span class="meta">                                __TASK_TRACED | EXIT_DEAD | EXIT_ZOMBIE | \</span></span><br><span class="line"><span class="meta">                                TASK)</span></span><br></pre></td></tr></table></figure>

<h5 id="Linux进程调度器"><a href="#Linux进程调度器" class="headerlink" title="Linux进程调度器"></a>Linux进程调度器</h5><p>所谓调度，就是按照某种调度的算法，从进程的就绪队列中选取进程分配CPU，主要是协调对CPU等的资源使用，进程调度的目标是最大限度利用CPU时间</p>
<p>Linux内核提供了5种进程调度器，使用<code>struct sched_class</code>来对调度器进行抽象</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* kernel/sched/sched.h */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_classs</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> (*enqueue_task) (struct rq *rq, struct task_struct *p, <span class="keyword">int</span> flags);</span><br><span class="line">    <span class="keyword">void</span> (*dequeue_task) (struct rq *rq, struct task_struct *p, <span class="keyword">int</span> flags);</span><br><span class="line">    <span class="keyword">void</span> (*yield_task) (struct rq *rq);</span><br><span class="line">    <span class="keyword">bool</span> (*yield_to_task) (struct rq *rq, struct task_struct *p);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> (*check_preempt_curr) (struct rq *rq, struct task_struct *p, <span class="keyword">int</span> flags);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *(*<span class="title">pick_next_task</span>) (<span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span>);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> (*put_prev_task) (struct rq *rq, struct task_struct *p);</span><br><span class="line">    <span class="keyword">void</span> (*set_next_task) (struct rq *rq, struct task_struct *p, <span class="keyword">bool</span> first);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">    <span class="keyword">int</span> (*balance) (struct rq *rq, struct task_struct *prev, struct rq_flags *rf);</span><br><span class="line">    <span class="keyword">int</span> (*select_task_rq) (struct task_struct *rq, <span class="keyword">int</span> task_cpu, <span class="keyword">int</span> sd_flag, <span class="keyword">int</span> flags);</span><br><span class="line">    <span class="keyword">void</span> (*migrate_task_rq) (struct task_struct *p, <span class="keyword">int</span> new_cpu);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> (*task_woken) (struct rq *this_rq, struct task_struct *task);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> (*set_cpus_allowed) (struct task_struct *p, <span class="keyword">const</span> struct cpumask *newmask);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> (*rq_online) (struct rq *rq);</span><br><span class="line">    <span class="keyword">void</span> (*rq_offline) (struct rq * rq);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> (*task_tick) (struct rq *rq, struct task_struct *p, <span class="keyword">int</span> queued);</span><br><span class="line">    <span class="keyword">void</span> (*task_fork) (struct task_struct *p);</span><br><span class="line">    <span class="keyword">void</span> (*task_dead) (struct task_struct *p);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> (*switched_from) (struct rq *this_rq, struct task_struct *task);</span><br><span class="line">    <span class="keyword">void</span> (*switched_to) (struct rq *this_rq, struct task_struct *task);</span><br><span class="line">	<span class="keyword">void</span> (*prio_changed) (struct rq *this_rq, struct task_struct *tassk,</span><br><span class="line">						<span class="keyword">int</span> oldprio);</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">unsigned</span> <span class="title">int</span> <span class="params">(*get_rr_interval)</span> <span class="params">(struct rq *rq, struct task_struct *task)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">void</span> (*update_curr) (struct rq *rq);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_SET_GROUP		0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_MOVE_GROUP		1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_FAIR_GROUP_SHCED</span></span><br><span class="line">	<span class="keyword">void</span> (*task_change_group) (struct task_struct *p, <span class="keyword">int</span> type);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125; __aligned(STRUCT_ALIGNMENT);</span><br></pre></td></tr></table></figure>
<p>Linux内核中调度器种类</p>
<ol>
<li>stop调度器（stop_sched_class）：优先级最高的调度类，可以抢占其他所有进程，不能被其他进程抢占</li>
<li>deadline调度器（dl_sched_class）：使用红黑树，把进程按照绝对截止期限进行排序，选择绝对截止期限最小的进程进行调度运行</li>
<li>rt调度器（rt_sched_class）：实时调度器，为每个优先级维护一个队列</li>
<li>cfs调度器（csf_sched_class）：完全公平调度器，采用完全公平调度算法，引入虚拟运行时间概念</li>
<li>idle-task调度器（idle_sched_class）：空闲调度器，每个CPU都会有一个idle线程，当没有其他进程可以调度时，调度运行idle线程</li>
</ol>
<p>Linux内核提供了一些调度策略（policy）供用户程序来选择调度器，其中stop调度器和idle-task调度器，仅由内核使用，用户无法进行选择</p>
<ol>
<li>SCHED_DEADLINE：限期进程调度策略，使task选择deadline调度器来调度运行</li>
<li>SCHED_RR：实时进程调度策略，时间片轮转，进程用完时间片后加入优先级对应运行队列的尾部，把CPU让给同优先级的其他进程</li>
<li>SCHED_FIFO：实时进程调度策略，先进先出调度，没有时间片</li>
<li>SCHED_NORMAL：普通进程调度策略，使task选择CFS调度器来调度运行</li>
<li>SCHED_BATCH：普通进程调度策略，批量处理，选择CFS调度器来调度运行</li>
<li>SCHED_IDLE：普通进程调度策略，使task以最低优先级选择CFS调度器来调度运行<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* include/uapi/linux/sched.h */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Scheduling policies</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SCHED_NORMAL		0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SCHED_FIFO		1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SCHED_RR		2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SCHED_BATCH		3</span></span><br><span class="line"><span class="comment">/* SCHED_ISO: reserved but not implemented yet */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SCHED_IDLE		5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SCHED_DEADLINE		6</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="运行队列"><a href="#运行队列" class="headerlink" title="运行队列"></a>运行队列</h5><p>每个CPU都有一个运行队列，每个调度器都最作用于运行队列，分配给CPU的task最为调度实体加入到运行队列中</p>
<p>Linux内核使用<code>struct rq</code>结构体来描述运行队列</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* kernel/sched/sched.h */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This is the main, per-CPU runqueue data structure.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Locking rule: those places that want to lock multiple runqueues</span></span><br><span class="line"><span class="comment"> * (such as the load balancing or the thread migration code), lock</span></span><br><span class="line"><span class="comment"> * acquire operations must be ordered by ascending &amp;runqueue.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rq</span> &#123;</span></span><br><span class="line">	<span class="comment">/* runqueue lock: */</span></span><br><span class="line">	<span class="keyword">raw_spinlock_t</span>		lock;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * nr_running and cpu_load should be in the same cacheline because</span></span><br><span class="line"><span class="comment">	 * remote CPUs use both these fields when doing load calculation.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		nr_running;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NUMA_BALANCING</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		nr_numa_running;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		nr_preferred_running;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		numa_migrate_on;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NO_HZ_COMMON</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		last_blocked_load_update_tick;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		has_blocked_load;</span><br><span class="line">	<span class="keyword">call_single_data_t</span>	nohz_csd;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_SMP */</span></span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		nohz_tick_stopped;</span><br><span class="line">	<span class="keyword">atomic_t</span>		nohz_flags;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_NO_HZ_COMMON */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		ttwu_pending;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	u64			nr_switches;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_UCLAMP_TASK</span></span><br><span class="line">	<span class="comment">/* Utilization clamp values based on CPU&#x27;s RUNNABLE tasks */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">uclamp_rq</span>	<span class="title">uclamp</span>[<span class="title">UCLAMP_CNT</span>] ____<span class="title">cacheline_aligned</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		uclamp_flags;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UCLAMP_FLAG_IDLE 0x01</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 三个调度队列，CFS调度 RT调度 DL调度</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cfs_rq</span>		<span class="title">cfs</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rt_rq</span>		<span class="title">rt</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dl_rq</span>		<span class="title">dl</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_FAIR_GROUP_SCHED</span></span><br><span class="line">	<span class="comment">/* list of leaf cfs_rq on this CPU: */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">leaf_cfs_rq_list</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	*<span class="title">tmp_alone_branch</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_FAIR_GROUP_SCHED */</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * This is part of a global counter where only the total sum</span></span><br><span class="line"><span class="comment">	 * over all CPUs matters. A task can increase this counter on</span></span><br><span class="line"><span class="comment">	 * one CPU and if it got migrated afterwards it may decrease</span></span><br><span class="line"><span class="comment">	 * it on another CPU. Always updated under the runqueue lock:</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		nr_uninterruptible;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> __<span class="title">rcu</span>	*<span class="title">curr</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>	*<span class="title">idle</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>	*<span class="title">stop</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		next_balance;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span>	*<span class="title">prev_mm</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		clock_update_flags;</span><br><span class="line">	u64			clock;</span><br><span class="line">	<span class="comment">/* Ensure that all clocks are in the same cache line */</span></span><br><span class="line">	u64			clock_task ____cacheline_aligned;</span><br><span class="line">	u64			clock_pelt;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		lost_idle_time;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">atomic_t</span>		nr_iowait;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MEMBARRIER</span></span><br><span class="line">	<span class="keyword">int</span> membarrier_state;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">root_domain</span>		*<span class="title">rd</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sched_domain</span> __<span class="title">rcu</span>	*<span class="title">sd</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		cpu_capacity;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		cpu_capacity_orig;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">callback_head</span>	*<span class="title">balance_callback</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span>		nohz_idle_balance;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span>		idle_balance;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		misfit_task_load;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* For active balancing */</span></span><br><span class="line">	<span class="keyword">int</span>			active_balance;</span><br><span class="line">	<span class="keyword">int</span>			push_cpu;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cpu_stop_work</span>	<span class="title">active_balance_work</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* CPU of this runqueue: */</span></span><br><span class="line">	<span class="keyword">int</span>			cpu;</span><br><span class="line">	<span class="keyword">int</span>			online;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">cfs_tasks</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sched_avg</span>	<span class="title">avg_rt</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sched_avg</span>	<span class="title">avg_dl</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_HAVE_SCHED_AVG_IRQ</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sched_avg</span>	<span class="title">avg_irq</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SCHED_THERMAL_PRESSURE</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sched_avg</span>	<span class="title">avg_thermal</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	u64			idle_stamp;</span><br><span class="line">	u64			avg_idle;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* This is used to determine avg_idle&#x27;s max value */</span></span><br><span class="line">	u64			max_idle_balance_cost;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_SMP */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_IRQ_TIME_ACCOUNTING</span></span><br><span class="line">	u64			prev_irq_time;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PARAVIRT</span></span><br><span class="line">	u64			prev_steal_time;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PARAVIRT_TIME_ACCOUNTING</span></span><br><span class="line">	u64			prev_steal_time_rq;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* calc_load related fields */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		calc_load_update;</span><br><span class="line">	<span class="keyword">long</span>			calc_load_active;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SCHED_HRTICK</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">	<span class="keyword">call_single_data_t</span>	hrtick_csd;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hrtimer</span>		<span class="title">hrtick_timer</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SCHEDSTATS</span></span><br><span class="line">	<span class="comment">/* latency stats */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sched_info</span>	<span class="title">rq_sched_info</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>	rq_cpu_time;</span><br><span class="line">	<span class="comment">/* could above be rq-&gt;cfs_rq.exec_clock + rq-&gt;rt_rq.rt_runtime ? */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* sys_sched_yield() stats */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		yld_count;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* schedule() stats */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		sched_count;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		sched_goidle;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* try_to_wake_up() stats */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		ttwu_count;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		ttwu_local;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_CPU_IDLE</span></span><br><span class="line">	<span class="comment">/* Must be inspected within a rcu lock section */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cpuidle_state</span>	*<span class="title">idle_state</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="任务分组task-group"><a href="#任务分组task-group" class="headerlink" title="任务分组task_group"></a>任务分组task_group</h5><p>引入任务分组机制，可以设置或限制任务组对CPU的利用率，比如将某些任务限制在某个区间内，从而不去影响其他任务的执行效率，引入task_group后，调度器的调度对象不仅仅是进程了，Linux内核抽象出了sched_entity、sched_rt_entity、sched_dl_entity描述调度实体，调度实体可以是进程或task_group</p>
<p>Linux内核使用<code>struct task_group</code>来描述任务组，任务组在每个CPU上都会维护一个CFS调度实体、CFS运行队列、RT调度实体、RT运行队列</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Task group related information */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_group</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cgroup_subsys_state</span> <span class="title">css</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 为每个CPU都分配一个CFS调度实体和CFS运行队列</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_FAIR_GROUP_SCHED</span></span><br><span class="line">	<span class="comment">/* schedulable entities of this group on each CPU */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span>	**<span class="title">se</span>;</span></span><br><span class="line">	<span class="comment">/* runqueue &quot;owned&quot; by this group on each CPU */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cfs_rq</span>		**<span class="title">cfs_rq</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		shares;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span>	CONFIG_SMP</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * load_avg can be heavily contended at clock tick time, so put</span></span><br><span class="line"><span class="comment">	 * it in its own cacheline separated from the fields above which</span></span><br><span class="line"><span class="comment">	 * will also be accessed at each tick.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">atomic_long_t</span>		load_avg ____cacheline_aligned;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="comment">// 为每个CPU都分配一个RT调度实体和RT运行队列</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_RT_GROUP_SCHED</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sched_rt_entity</span>	**<span class="title">rt_se</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rt_rq</span>		**<span class="title">rt_rq</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rt_bandwidth</span>	<span class="title">rt_bandwidth</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span>		<span class="title">rcu</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">list</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_group</span>	*<span class="title">parent</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">siblings</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">children</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SCHED_AUTOGROUP</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">autogroup</span>	*<span class="title">autogroup</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cfs_bandwidth</span>	<span class="title">cfs_bandwidth</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_UCLAMP_TASK_GROUP</span></span><br><span class="line">	<span class="comment">/* The two decimal precision [%] value requested from user-space */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		uclamp_pct[UCLAMP_CNT];</span><br><span class="line">	<span class="comment">/* Clamp values requested for a task group */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">uclamp_se</span>	<span class="title">uclamp_req</span>[<span class="title">UCLAMP_CNT</span>];</span></span><br><span class="line">	<span class="comment">/* Effective clamp values used for a task group */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">uclamp_se</span>	<span class="title">uclamp</span>[<span class="title">UCLAMP_CNT</span>];</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Schedule</tag>
      </tags>
  </entry>
</search>
