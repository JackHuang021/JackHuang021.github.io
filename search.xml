<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>从零开始搭建Hexo博客</title>
    <url>/archives/39fb7b7f.html</url>
    <content><![CDATA[<h2 id="Hexo简介"><a href="#Hexo简介" class="headerlink" title="Hexo简介"></a>Hexo简介</h2><p>引用官网的介绍：A fast, simple &amp; powerful blog framework<br>Hexo是一款基于Node.js的静态博客框架，依赖少易于安装使用，可以方便的生成静态网页托管在GitHub上，是搭建博客的首选框架。</p>
<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>基于Ubuntu20.04安装Hexo配置Next主题</p>
<span id="more"></span>

<h3 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h3><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">sudo apt-<span class="builtin-name">get</span> install git</span><br></pre></td></tr></table></figure>
<p>安装完成后进行配置</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">config</span> --<span class="keyword">global</span> user<span class="variable">.email</span> <span class="string">&quot;you@example.com&quot;</span></span><br><span class="line">git <span class="keyword">config</span> --<span class="keyword">global</span> user<span class="variable">.name</span> <span class="string">&quot;Your Name&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h3><p>使用NVM（Node Version Manager）方式进行安装</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">curl -o- https:<span class="regexp">//</span>raw.githubusercontent.com<span class="regexp">/nvm-sh/</span>nvm<span class="regexp">/v0.35.2/i</span>nstall.sh | bash</span><br></pre></td></tr></table></figure>
<p>安装完成后关闭终端重新打开</p>
<h3 id="安装最新版本node"><a href="#安装最新版本node" class="headerlink" title="安装最新版本node"></a>安装最新版本node</h3><p>安装过程中可能会因为网络问题失败，可以尝试挂梯子,安装完成后更新自带npm</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">nvm install <span class="keyword">node</span></span><br><span class="line"><span class="title">npm</span> install npm -g</span><br></pre></td></tr></table></figure>

<h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><p>安装过程中可能会因为网络问题失败，可以多重试几次或挂梯子</p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-<span class="keyword">cli</span></span><br></pre></td></tr></table></figure>

<h3 id="安装Next主题"><a href="#安装Next主题" class="headerlink" title="安装Next主题"></a>安装Next主题</h3><p>Next主题是Hexo比较知名的第三方主题，极简风格，有相当多的使用者，维护也做得比较好<br>不过Next新旧版本的仓库地址不一样，目前最新的GitHub地址<a href="https://github.com/next-theme/hexo-theme-next.git">hexo-theme-next</a><br>Next主题安装比较简单，直接从仓库clone然后修改Hexo配置文件</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">cd blog</span><br><span class="line">git clone https:<span class="regexp">//gi</span>thub.com<span class="regexp">/next-theme/</span>hexo-theme-<span class="keyword">next</span> themes/<span class="keyword">next</span></span><br></pre></td></tr></table></figure>
<p>修改Hexo配置文件<code>_config.yml</code>，将站点主题改为Next，修改如下</p>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line"># Extensions</span><br><span class="line">## Plugins: https:<span class="comment">//hexo.io/plugins/</span></span><br><span class="line">## Themes: https:<span class="comment">//hexo.io/themes/</span></span><br><span class="line">theme: next</span><br></pre></td></tr></table></figure>

<p>全部安装完成后的版本信息如下</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">jack@linux:~/blog/source/_posts$ hexo -v</span></span><br><span class="line">INFO  Validating config</span><br><span class="line">INFO  ==================================</span><br><span class="line">  ███╗   ██╗███████╗██╗  ██╗████████╗</span><br><span class="line">  ████╗  ██║██╔════╝╚██╗██╔╝╚══██╔══╝</span><br><span class="line">  ██╔██╗ ██║█████╗   ╚███╔╝    ██║</span><br><span class="line">  ██║╚██╗██║██╔══╝   ██╔██╗    ██║</span><br><span class="line">  ██║ ╚████║███████╗██╔╝ ██╗   ██║</span><br><span class="line">  ╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝   ╚═╝</span><br><span class="line">========================================</span><br><span class="line">NexT version 8.11.1</span><br><span class="line"><span class="section">Documentation: https://theme-next.js.org</span></span><br><span class="line">========================================</span><br><span class="line"><span class="section">hexo: 5.4.2</span></span><br><span class="line"><span class="section">hexo-cli: 4.3.0</span></span><br><span class="line"><span class="section">os: linux 5.13.0-40-generic Ubuntu 20.04.4 LTS (Focal Fossa)</span></span><br><span class="line"><span class="section">node: 18.2.0</span></span><br><span class="line"><span class="section">v8: 10.1.124.8-node.13</span></span><br><span class="line"><span class="section">uv: 1.43.0</span></span><br><span class="line"><span class="section">zlib: 1.2.11</span></span><br><span class="line"><span class="section">brotli: 1.0.9</span></span><br><span class="line"><span class="section">ares: 1.18.1</span></span><br><span class="line"><span class="section">modules: 108</span></span><br><span class="line"><span class="section">nghttp2: 1.47.0</span></span><br><span class="line"><span class="section">napi: 8</span></span><br><span class="line"><span class="section">llhttp: 6.0.6</span></span><br><span class="line"><span class="section">openssl: 3.0.3+quic</span></span><br><span class="line"><span class="section">cldr: 41.0</span></span><br><span class="line"><span class="section">icu: 71.1</span></span><br><span class="line"><span class="section">tz: 2022a</span></span><br><span class="line"><span class="section">unicode: 14.0</span></span><br><span class="line"><span class="section">ngtcp2: 0.1.0-DEV</span></span><br><span class="line"><span class="section">nghttp3: 0.1.0-DEV</span></span><br></pre></td></tr></table></figure>

<h3 id="初步运行Hexo进行验证"><a href="#初步运行Hexo进行验证" class="headerlink" title="初步运行Hexo进行验证"></a>初步运行Hexo进行验证</h3><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">hexo init <span class="keyword">blog</span></span><br><span class="line"><span class="keyword"></span>cd <span class="keyword">blog</span></span><br><span class="line"><span class="keyword"></span>npm <span class="keyword">install</span></span><br><span class="line"><span class="keyword"></span>hexo server</span><br></pre></td></tr></table></figure>
<p>运行之后可以通过 <a href="http://localhost:4000/">http://localhost:4000</a> 进行访问</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">INFO  Validating config</span><br><span class="line">INFO  ==================================</span><br><span class="line"><span class="code">  ███╗   ██╗███████╗██╗  ██╗████████╗</span></span><br><span class="line"><span class="code">  ████╗  ██║██╔════╝╚██╗██╔╝╚══██╔══╝</span></span><br><span class="line"><span class="code">  ██╔██╗ ██║█████╗   ╚███╔╝    ██║</span></span><br><span class="line"><span class="code">  ██║╚██╗██║██╔══╝   ██╔██╗    ██║</span></span><br><span class="line"><span class="code">  ██║ ╚████║███████╗██╔╝ ██╗   ██║</span></span><br><span class="line"><span class="section">  ╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝   ╚═╝</span></span><br><span class="line"><span class="section">========================================</span></span><br><span class="line">NexT version 8.11.1</span><br><span class="line"><span class="section">Documentation: https://theme-next.js.org</span></span><br><span class="line"><span class="section">========================================</span></span><br><span class="line">INFO  Start processing</span><br><span class="line">INFO  Hexo is running at http://localhost:4000 . Press Ctrl+C to stop.</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/imageshexo_next_theme.png"></p>
<h3 id="部署GitHub远程服务器"><a href="#部署GitHub远程服务器" class="headerlink" title="部署GitHub远程服务器"></a>部署GitHub远程服务器</h3><h4 id="创建GitHub项目"><a href="#创建GitHub项目" class="headerlink" title="创建GitHub项目"></a>创建GitHub项目</h4><p>在GitHub上注册账号，注册后上传ssh公钥，便于后续的部署操作<br>创建一个与你用户名对应的项目<code>username.github.io</code>，例如我创建的项目地址为<code>https://github.com/JackHuang021/JackHuang021.github.io.git</code>  </p>
<h4 id="进行部署"><a href="#进行部署" class="headerlink" title="进行部署"></a>进行部署</h4><p>部署需要用到<code>hexo deploy</code>上传到GitHub仓库，这里需要下载部署插件，并修改hexo配置文件<code>_config.yml</code>，<br>我们很多的博客设置都可以在这个配置文件里面进行修改<br>首先安装Git部署插件</p>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cd</span> ~<span class="string">/blog</span></span><br><span class="line">npm install hex-deployer-git <span class="params">--save</span></span><br></pre></td></tr></table></figure>
<p>修改博客配置文件<code>_config.yml</code>，增加如下内容</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="meta"># Deployment</span></span><br><span class="line"><span class="meta">## Docs: https:<span class="comment">//hexo.io/docs/one-command-deployment</span></span></span><br><span class="line"><span class="symbol">deploy:</span></span><br><span class="line"><span class="symbol">  type:</span> git</span><br><span class="line"><span class="symbol">  repo:</span> git@github.com:JackHuang021/JackHuang021.github.io.git</span><br><span class="line"><span class="symbol">  branch:</span> master</span><br></pre></td></tr></table></figure>
<p>最后使用<code>hexo d</code>进行上传部署，现在访问<code>username.github.io</code>便可以看到博客页面了<br>后续更新博客设置或者文章的话需要再次进行上传部署<code>hexo g -d</code></p>
<h3 id="Hexo博客备份"><a href="#Hexo博客备份" class="headerlink" title="Hexo博客备份"></a>Hexo博客备份</h3><p>Hexo在进行部署时，是将页面内容解析后放在<code>.depoly_git</code>中进行上传GitHub仓库，博客内文章源文件并未进行上传，所以还需要手动将这些文件进行手动上传。目前比较常用的方法是在原GitHub仓库建立一条分支，将这些文件上传到该分支。</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cd</span> blog </span><br><span class="line">git init </span><br><span class="line">git submodule <span class="built_in">add</span> http<span class="variable">s:</span>//github.<span class="keyword">com</span>/<span class="keyword">next</span>-theme/hexo-theme-<span class="keyword">next</span>.git themes/<span class="keyword">next</span></span><br><span class="line">git <span class="built_in">add</span> .</span><br><span class="line">git commit -<span class="keyword">m</span> <span class="string">&quot;init blog backup&quot;</span></span><br><span class="line">git branch -<span class="keyword">m</span> master hexo</span><br><span class="line">git remote <span class="built_in">add</span> origin git@github.<span class="keyword">com</span>:JackHuang021/JackHuang021.github.io.git</span><br><span class="line">git push -<span class="keyword">u</span> origin hexo</span><br></pre></td></tr></table></figure>

<h3 id="恢复Hexo博客"><a href="#恢复Hexo博客" class="headerlink" title="恢复Hexo博客"></a>恢复Hexo博客</h3><ol>
<li>按照之前的步骤搭建Hexo环境</li>
<li>clone之前备份的hexo分支内容<code>git clone --recursive -b hexo git@github.com:JackHuang021/JackHuang021.github.io.git blog</code></li>
<li>下载npm依赖模块<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> blog</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure></li>
<li>clone master分支内容<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">cd blog</span><br><span class="line">git clone git@github<span class="selector-class">.com</span>:JackHuang021/JackHuang021<span class="selector-class">.github</span><span class="selector-class">.io</span><span class="selector-class">.git</span> <span class="selector-class">.deploy_git</span> </span><br></pre></td></tr></table></figure></li>
<li>正常更新、部署博客<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">hexo g</span></span><br><span class="line"><span class="attribute">hexo s</span></span><br><span class="line"><span class="attribute">hexo d</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="关于Hexo使用的思考"><a href="#关于Hexo使用的思考" class="headerlink" title="关于Hexo使用的思考"></a>关于Hexo使用的思考</h3><p>我觉得Hexo最大的特点就是便捷，借助GitHub可以在多台设备中无缝切换进行博客写作，服务器的维护工作基本不需要作者进行，换设备后直接搭建hexo环境，从GitHub拉取博客内容即可。</p>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
        <tag>博客搭建</tag>
        <tag>博客备份恢复</tag>
      </tags>
  </entry>
  <entry>
    <title>ssh使用密钥实现免密登录</title>
    <url>/archives/37d9659b.html</url>
    <content><![CDATA[<h3 id="本地ssh客户端准备ssh密钥"><a href="#本地ssh客户端准备ssh密钥" class="headerlink" title="本地ssh客户端准备ssh密钥"></a>本地ssh客户端准备ssh密钥</h3><p>ssh密钥默认保存路径<code>~/.ssh</code>，进入该目录查看是否已存在生成的密钥</p>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ls</span> -al ~<span class="string">/.ssh</span></span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220601093641.png"></p>
<span id="more"></span>
<p>如上图，<code>id_rsa.pub</code>和<code>qtc_id.pub</code>都是公钥<br>如果没有公钥，可以使用<code>ssh-keygen</code>生成</p>
<h3 id="上传ssh公钥到ssh服务器"><a href="#上传ssh公钥到ssh服务器" class="headerlink" title="上传ssh公钥到ssh服务器"></a>上传ssh公钥到ssh服务器</h3><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">ssh-<span class="keyword">copy</span>-id -i ~<span class="regexp">/.ssh/i</span>d_rsa.pub username@ip_address</span><br></pre></td></tr></table></figure>
<p>执行后会提示输入服务器用户密码</p>
<h3 id="测试ssh免密登录"><a href="#测试ssh免密登录" class="headerlink" title="测试ssh免密登录"></a>测试ssh免密登录</h3><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">ssh <span class="symbol">username@</span>ip_address</span><br></pre></td></tr></table></figure>
<p>如果可以直接登录，说明已经配置成功<br>都2022年了，不要在输入密码上再浪费更多时间了</p>
<h3 id="删除免密登录"><a href="#删除免密登录" class="headerlink" title="删除免密登录"></a>删除免密登录</h3><p>上传公钥后，服务端<code>.ssh/authorized_keys</code>文件中会添加一行内容，就是本地客户端的公钥，编辑该文件删除改行，即可禁用客户端免密登录<br><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220601094901.png"></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title>imx6ull OpenCV4.5 交叉编译</title>
    <url>/archives/e4359116.html</url>
    <content><![CDATA[<h4 id="交叉编译环境"><a href="#交叉编译环境" class="headerlink" title="交叉编译环境"></a>交叉编译环境</h4><ul>
<li>Ubuntu版本：Ubuntu20.04 64bits</li>
<li>交叉编译工具：arm-linux-gnueabihf-</li>
<li>硬件平台正点原子IMX6ULL (ALPHA)</li>
</ul>
<span id="more"></span>

<h4 id="准备源码和交叉编译工具链"><a href="#准备源码和交叉编译工具链" class="headerlink" title="准备源码和交叉编译工具链"></a>准备源码和交叉编译工具链</h4><p>Linux环境下的编译方法可以参考<a href="https://docs.opencv.org/4.x/d7/d9f/tutorial_linux_install.html">Opencv安装官网教程</a></p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">wget -O opencv.zip https:<span class="regexp">//gi</span>thub.com<span class="regexp">/opencv/</span>opencv<span class="regexp">/archive/</span><span class="number">4</span>.x.zip</span><br><span class="line">unzip opencv.zip</span><br></pre></td></tr></table></figure>
<p>交叉编译工具链版本<br><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220602095241.png"></p>
<h4 id="安装cmake和cmake-gui工具"><a href="#安装cmake和cmake-gui工具" class="headerlink" title="安装cmake和cmake-gui工具"></a>安装cmake和cmake-gui工具</h4><p>在命令行使用cmake工具确实很不方便，cmake-gui配置起来比较省时间<br><code>sudo apt-get install cmake cmake-qt-gui  cmake-curses-gui</code>  </p>
<h4 id="配置交叉编译环境"><a href="#配置交叉编译环境" class="headerlink" title="配置交叉编译环境"></a>配置交叉编译环境</h4><ol>
<li>运行cmake-gui<br><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220602100408.png">  </li>
<li>在第一个框输入OpenCV源码路径，在第二个框输入OpenCV编译目录  </li>
<li>点击<code>Configure</code>配置交叉编译环境<br><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220602100750.png"></li>
<li>选择<code>Spcify options for cross-compile</code>  </li>
<li>按照下图设置交叉编译工具链<br><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220602101028.png"></li>
<li>点击<code>Finish</code>回到cmake-gui主页面，勾选Advanced<br><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220602101237.png"></li>
</ol>
<h4 id="配置cmake选项"><a href="#配置cmake选项" class="headerlink" title="配置cmake选项"></a>配置cmake选项</h4><ol>
<li>在CMAKE_EXE_LINKER_FLAGS处添加上<code>-lpthread -lrt -ldl</code><br><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220602101546.png"></li>
<li>在CMAKE_INSTALL_PREFIX处指定安装目录，如果不指定，它会默认安装到Ubuntu系统目录<code>/usr/local</code>下。  </li>
<li>取消<code>BUILD_opencv_gapi</code>选项，不取消这个选项后续编译的时候会报错</li>
<li>再依次点击<code>Configure</code>， <code>Generate</code>，击了Generate后看到信息像如下图一样，表明生成成功，一般按照上面配置后基本都不会报错。<br><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220602102258.png"></li>
</ol>
<h4 id="编译OpenCV"><a href="#编译OpenCV" class="headerlink" title="编译OpenCV"></a>编译OpenCV</h4><ol>
<li>打开之前设置的imx6编译目录，该目录下有刚才生成的Makefile  </li>
<li>输入<code>make -j12</code>开始编译</li>
<li>编译完成后输入<code>make install</code>，OpenCV的库和头文件会安装到之前设置的<code>CMAKE_INSTALL_PREFIX</code>目录</li>
</ol>
<h4 id="编译过程中遇到的错误"><a href="#编译过程中遇到的错误" class="headerlink" title="编译过程中遇到的错误"></a>编译过程中遇到的错误</h4><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">/home/</span>tanyd<span class="regexp">/zdyz/</span>linaro494<span class="regexp">/arm-linux-gnueabihf/</span>libc<span class="regexp">/usr/i</span>nclude/features.h:<span class="number">311</span>:<span class="number">52</span>: error: operator <span class="string">&#x27;&amp;&amp;&#x27;</span> has no right operand <span class="comment">#if defined _FILE_OFFSET_BITS &amp;&amp; _FILE_OFFSET_BITS == 64</span></span><br></pre></td></tr></table></figure>
<p>解决方法： 在<code>#if defined</code>前面加上 <code>#define _FILE_OFFSET_BITS 64</code>  </p>
<h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><ol>
<li><a href="https://blog.csdn.net/qq_26943851/article/details/104434130">正点原子IMX6ULL移植OpenCV3.4.1</a></li>
<li><a href="https://blog.csdn.net/u011827554/article/details/123657141">imx6ull编译opencv4.4问题整理</a></li>
</ol>
]]></content>
      <categories>
        <category>OpenCV</category>
      </categories>
      <tags>
        <tag>imx6ull OpenCV 交叉编译</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu安装搜狗输入法的问题记录</title>
    <url>/archives/245a6c83.html</url>
    <content><![CDATA[<ul>
<li>最近在帮一个客户安装搜狗输入法时遇到了安装后无候选框的问题，记录一下该问题的解决办法，今天进入官网查看，官网已经修改安装指南，建议按照官网指南安装，本文截图来自搜狗官网</li>
</ul>
<h4 id="Ubuntu搜狗输入法下载"><a href="#Ubuntu搜狗输入法下载" class="headerlink" title="Ubuntu搜狗输入法下载"></a>Ubuntu搜狗输入法下载</h4><ul>
<li><a href="https://pinyin.sogou.com/linux?r=pinyin">搜狗输入法Linux版官网</a>，目前最新版本为V4.0.1</li>
<li><a href="https://pinyin.sogou.com/linux/guide">搜狗输入法Linux版安装指南</a></li>
</ul>
<span id="more"></span>

<h4 id="Ubuntu20-04安装步骤"><a href="#Ubuntu20-04安装步骤" class="headerlink" title="Ubuntu20.04安装步骤"></a>Ubuntu20.04安装步骤</h4><ol>
<li>添加中文语言支持，打开 系统设置——区域和语言——管理已安装的语言——在“语言”tab下——点击“添加或删除语言”<br><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220606092214.png"></li>
<li>弹出“已安装语言”窗口，勾选中文（简体），点击应用<br><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220606092221.png"></li>
<li>安装fcitx输入法框架<code>sudo apt-get install fcitx</code></li>
<li>卸载系统ibus输入法框架<code>sudo apt purge ibus</code></li>
<li>回到“语言支持”窗口，在键盘输入法系统中，选择<code>fcitx</code><br><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220606092226.png"></li>
<li>通过命令行安装搜狗输入法<code>sudo dpkg -i sogoupinyin_版本号_amd64.deb</code>，如果安装过程中提示缺少相关依赖，则执行如下命令解决：<code>sudo apt -f install</code></li>
<li>安装输入法依赖<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">sudo</span> apt install libqt<span class="number">5</span>qml<span class="number">5</span> libqt<span class="number">5</span>quick<span class="number">5</span> libqt<span class="number">5</span>quickwidgets<span class="number">5</span> qml-module-qtquick<span class="number">2</span></span><br><span class="line"><span class="attribute">sudo</span> apt install libgsettings-qt<span class="number">1</span></span><br></pre></td></tr></table></figure></li>
<li>点击“应用到整个系统”，关闭窗口，重启电脑</li>
<li>查看状态栏右上角，可以看到“搜狗”字样，在输入窗口即可使用搜狗输入法。没有“搜狗”字样，选择配置，将搜狗加入输入法列表即可。<br><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220606094224.png"><br><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220606094237.png"><br><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220606094048.png"></li>
</ol>
<h4 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h4><ul>
<li>安装完成后输入候选框不出现，只能输入英文</li>
<li>解决办法，安装qt依赖库可以解决<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">sudo</span> apt install libqt<span class="number">5</span>qml<span class="number">5</span> libqt<span class="number">5</span>quick<span class="number">5</span> libqt<span class="number">5</span>quickwidgets<span class="number">5</span> qml-module-qtquick<span class="number">2</span></span><br><span class="line"><span class="attribute">sudo</span> apt install libgsettings-qt<span class="number">1</span></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>搜狗输入法</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCV图像容器Mat</title>
    <url>/archives/d2c86892.html</url>
    <content><![CDATA[<h4 id="图像的存储"><a href="#图像的存储" class="headerlink" title="图像的存储"></a>图像的存储</h4><p><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220608085010.png"><br>借助官方这张很有代表性的图片，在计算机中以像素值的方式存储图像中的每个像素点，所有像素值以类似矩阵的二维数组形式进行存储。官网给OpenCV的定义：OpenCV是一个计算机视觉库，主要的目的就是在这些像素值上进行处理、计算，所以首先就需要学习OpenCV是怎么存储、处理这些图像的。</p>
<span id="more"></span>

<h4 id="Mat介绍"><a href="#Mat介绍" class="headerlink" title="Mat介绍"></a>Mat介绍</h4><ul>
<li>OpenCV起始于2001年，最开始是基于C语言编写，图像存储在C结构体<code>IplImage</code>。</li>
<li>OpenCV2.0基于C++进行重写，图像以Mat类进行存储。</li>
<li>Mat类包含两部分数据：  <ol>
<li>图像数据头部分，包含图像尺寸、存储方式、图像数据指针等信息</li>
<li>图像数据部分</li>
</ol>
</li>
<li>每个Mat对象都独立的保存数据头部分，但是可能共享图像数据部分。</li>
<li>Mat的拷贝构造只会拷贝数据头部分，数据部分不会进行拷贝。  <figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">Mat A, C;                          <span class="comment">// creates just the header parts</span></span><br><span class="line">A = imread<span class="comment">(argv[1], IMREAD_COLOR)</span>; <span class="comment">// here we&#x27;ll know the method used (allocate matrix)</span></span><br><span class="line">Mat B<span class="comment">(A)</span>;                          <span class="comment">// Use the copy constructor</span></span><br><span class="line">C = A;                             <span class="comment">// Assignment operator</span></span><br></pre></td></tr></table></figure></li>
<li>Mat类有一个引用计数机制，进行拷贝构造时引用加1，Mat对象析构时引用减1，当引用变为0时，释放数据部分内存。</li>
<li>当需要进行数据部分拷贝时，OpenCV提供了<code>cv::Mat::clone()</code>和<code>cv::Mat::copyTo</code>两个方法</li>
</ul>
<h4 id="Mat数据存储方式"><a href="#Mat数据存储方式" class="headerlink" title="Mat数据存储方式"></a>Mat数据存储方式</h4><ul>
<li>根据颜色空间和数据类型来选择图像数据存储方式</li>
</ul>
<h4 id="Mat对象操作"><a href="#Mat对象操作" class="headerlink" title="Mat对象操作"></a>Mat对象操作</h4><ul>
<li>使用<code>cv::Mat::Mat</code>构造函数进行创建<code>Mat img(2, 2, CV_8UC3, Scalar(0, 0, 255))</code>，指定图像的行和列大小、像素数据类型、像素颜色通道，如<code>CV_8UC3</code>表示8位无符号数据，颜色通道为3，由以下方式进行定义<br><code>CV_[The number of bits per item][Signed or Unsigned][Type Prefix]C[The channel number]</code></li>
<li>类似MATLAB方式创建单位矩阵<code>cv::Mat::eyes</code>、零矩阵<code>cv::Mat::zeros</code>、元素全为1的矩阵<code>cv::Mat::ones</code>  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Mat E = Mat::<span class="built_in">eye</span>(<span class="number">4</span>, <span class="number">4</span>, CV_64F);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;E = &quot;</span> &lt;&lt; endl &lt;+ Mat对象的打印</span><br><span class="line"><span class="number">1.</span> 默认输出&lt; <span class="string">&quot; &quot;</span> &lt;&lt; E &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line">Mat O = Mat::<span class="built_in">ones</span>(<span class="number">2</span>, <span class="number">2</span>, CV_32F);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;O = &quot;</span> &lt;&lt; endl &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; O &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line">Mat Z = Mat::<span class="built_in">zeros</span>(<span class="number">3</span>,<span class="number">3</span>, CV_8UC1);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Z = &quot;</span> &lt;&lt; endl &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; Z &lt;&lt; endl &lt;&lt; endl;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>OpenCV</category>
      </categories>
      <tags>
        <tag>OpenCV Mat</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCV图像操作</title>
    <url>/archives/117a3b0c.html</url>
    <content><![CDATA[<h4 id="图像读取和保存"><a href="#图像读取和保存" class="headerlink" title="图像读取和保存"></a>图像读取和保存</h4><ul>
<li>图像读取<code>Mat img = imread(filename)</code></li>
<li>图像保存<code>imwrite(filename, img)</code><span id="more"></span></li>
</ul>
<h4 id="像素级操作"><a href="#像素级操作" class="headerlink" title="像素级操作"></a>像素级操作</h4><ul>
<li>获取单通道灰度图像(x, y)位置像素值<code>Scalar intensity = img.at&lt;uchar&gt;(Point(x, y));</code></li>
<li>修改像素值<code>img.at&lt;uchar&gt;(Point(x, y)) = 128</code></li>
<li>获取3通道BGR颜色空间图像(x, y)位置像素值  <figure class="highlight sml"><table><tr><td class="code"><pre><span class="line"><span class="type">Vec3b</span> <span class="built_in">vector</span> = img.at&lt;<span class="type">Vec3b</span>&gt;(<span class="type">Point</span>(x, y));</span><br><span class="line">uchar blue = <span class="built_in">vector</span>.<span class="keyword">val</span>[<span class="number">0</span>];</span><br><span class="line">uchar green = <span class="built_in">vector</span>.<span class="keyword">val</span>[<span class="number">1</span>];</span><br><span class="line">uchar red = <span class="built_in">vector</span>.<span class="keyword">val</span>[<span class="number">2</span>];</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="图像基本操作"><a href="#图像基本操作" class="headerlink" title="图像基本操作"></a>图像基本操作</h4><ul>
<li>选取图像某个区域  <figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Rect</span> r(<span class="number">10</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line"><span class="attribute">Mat</span> smallImg = img(r);</span><br></pre></td></tr></table></figure></li>
<li>颜色空间转换  <figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">Mat img = imread(<span class="string">&quot;image.jpg&quot;</span>);</span><br><span class="line">Mat gray;</span><br><span class="line">cvt<span class="constructor">Color(<span class="params">img</span>, <span class="params">gray</span>, COLOR_BGR2GRAY)</span>;</span><br></pre></td></tr></table></figure></li>
<li>数据类型转换<code>src.convertTo(dst, CV_32F)</code></li>
<li>图像显示  <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">Mat img = imread(<span class="string">&quot;image.jpg&quot;</span>)<span class="comment">;</span></span><br><span class="line">namedWindow(<span class="string">&quot;image&quot;</span>, WINDOW_AUTOSIZE)<span class="comment">;</span></span><br><span class="line">imshow(<span class="string">&quot;image&quot;</span>, img)<span class="comment">;</span></span><br><span class="line">waitKey()<span class="comment">;</span></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>OpenCV</category>
      </categories>
      <tags>
        <tag>OpenCV Image</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCV 图像处理基本操作</title>
    <url>/archives/6465c2cc.html</url>
    <content><![CDATA[<h4 id="基于Mat类的图像操作"><a href="#基于Mat类的图像操作" class="headerlink" title="基于Mat类的图像操作"></a>基于Mat类的图像操作</h4><p><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220608085010.png"></p>
<ul>
<li>Mat类分为两个数据部分：数据头部分（保存矩阵大小、矩阵存储方式等信息）、矩阵数据部分， 一般的Mat对象复制构造仅拷贝数据头部分，矩阵数据部分共享。也可以通过<code>cv::Mat::copyTo</code>和<code>cv::Mat::clone</code>进行深度拷贝。<span id="more"></span></li>
<li>Mat构造函数<code>Mat img(2, 2, CV_8UC3, Scalar(0, 0, 255))</code>， 需要明确矩阵大小、矩阵存储数据类型、像素颜色通道数、像素值。</li>
<li>CV_8UC3含义表示8位无符号数据，颜色通道为3，含义参考：<code>CV_[The number of bits per item][Signed or Unsigned][Type Prefix]C[The channel number]</code></li>
<li>几种特殊矩阵的构造，<code>cv::Mat::eyes</code>单位矩阵、<code>cv::Mat::zeros</code>零矩阵、<code>cv::Mat::ones</code>全1矩阵</li>
</ul>
<h4 id="图像卷积操作"><a href="#图像卷积操作" class="headerlink" title="图像卷积操作"></a>图像卷积操作</h4><ul>
<li><p>根据kernel矩阵重新计算图像中每个像素的值，<em>h(k, j)</em> 为kernel，使用<code>filter2D</code>进行卷积操作<br>  <img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220609163143.png"></p>
  <figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">CV_EXPORTS_W <span class="type">void</span> filter2D( InputArray src, </span><br><span class="line">                            OutputArray dst, </span><br><span class="line">                            <span class="type">int</span> ddepth, </span><br><span class="line">                            InputArray kernel, </span><br><span class="line">                            <span class="type">Point</span> anchor = <span class="type">Point</span>(<span class="number">-1</span>,<span class="number">-1</span>), </span><br><span class="line">                            <span class="type">double</span> delta = <span class="number">0</span>, </span><br><span class="line">                            <span class="type">int</span> borderType = BORDER_DEFAULT );</span><br></pre></td></tr></table></figure></li>
<li><p>使用图像卷积进行图像模糊（平滑）</p>
<ol>
<li>简单的图像平滑，Kernel模型如下<br>  <img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220609163417.png"></li>
<li>高斯模糊，根据距当前像素点的距离决定平滑的权重，一维高斯核的图像如下<br>  <img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220609163925.png"><br>  二维高斯公式，其中μ为平均值，σ为方差<br>  <img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220609164447.png"></li>
<li>中值滤波，将像素点周围区域内的像素进行排序，采用中间位置的像素值作为当前像素点的值</li>
<li>双边滤波，权重由两部分来决定，第一部分是类似于二维高斯，另一部分由颜色差异来决定，这样可以比较好的保留边缘信息。</li>
</ol>
</li>
<li><p>图像边界处理，使用<code>copyMakeBorder</code>给图像创建一个边框</p>
<ol>
<li><code>BORDER_CONTANT</code>，使用固定像素值填充创建的边框</li>
<li><code>BORDER_REPLICATE</code>，复制原图像中的边界值</li>
</ol>
</li>
<li><p>使用图像卷积进行形态学操作，主要针对阈值化后的图像</p>
<ol>
<li>膨胀 Dilate，使用Kernel范围内的最大值取代当前像素值<br>  膨胀二值化图像<br>  <img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220610150255.png"><br>  膨胀灰度图像<br>  <img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220610150405.png"></li>
<li>腐蚀 Erode，使用Kernel范围内的最小值取代当前像素值<br>  腐蚀二值化图像<br>  <img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220610150527.png"><br>  腐蚀灰度图像<br>  <img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220610150618.png"></li>
<li>开操作 Opening，先腐蚀后膨胀，去除暗黑背景中细小的噪点，原理 *dst &#x3D; open(src, element) &#x3D; dilate(erode(src, element))*， <em>element</em>为kernel</li>
<li>闭操作 Closing，先膨胀后腐蚀，去除明亮背景中的细小噪点，原理 <em>dst &#x3D; close(src, element) &#x3D; erode(dilate(src, element))</em></li>
<li>形态梯度 Morphological Gradient，膨胀图像与腐蚀图像的差，用来找出物体轮廓，原理 <em>dst &#x3D; morphy(src, element) &#x3D; dilate(src, element) - erode(src, element)</em></li>
<li>高帽 Top Hat</li>
</ol>
</li>
<li><p>也可以使用 <em>getStructuringElement</em> 创造指定形状和大小的Kernel，进行图像的特征提取，如官方教程<a href="https://docs.opencv.org/4.x/dd/dd7/tutorial_morph_lines_detection.html">提取乐谱中的直线和音符</a>，就是借助形态学开操作进行直线和音符的提取。</p>
</li>
</ul>
<h4 id="图像融合"><a href="#图像融合" class="headerlink" title="图像融合"></a>图像融合</h4><ul>
<li>图像融合公式<code>dst = src1*alpha + src2*beta + gamma</code>，使用<code>addWeighted()</code>进行融合。  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cv::addWeighted</span><span class="params">( InputArray src1,</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="keyword">double</span> alpha,</span></span></span><br><span class="line"><span class="params"><span class="function">                      InputArray src2,</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="keyword">double</span> beta,</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="keyword">double</span> gamma,</span></span></span><br><span class="line"><span class="params"><span class="function">                      OutputArray dst,</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="keyword">int</span> dtype = <span class="number">-1</span> )</span></span>;	</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="改变图像对比度和亮度"><a href="#改变图像对比度和亮度" class="headerlink" title="改变图像对比度和亮度"></a>改变图像对比度和亮度</h4><ul>
<li>公式<code>g(x)=αf(x)+β</code>改变α的值可以改变图像的对比度，改变β的值可以改变图像的亮度</li>
<li>Gamma校准，使用查找表，按照如下公式对像素值进行一个非线性的转换 <em>O &#x3D; (I &#x2F; 255)^γ × 255</em>，γ越大整体亮度降低。<br><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220609161302.png"></li>
</ul>
<h4 id="图像的缩放"><a href="#图像的缩放" class="headerlink" title="图像的缩放"></a>图像的缩放</h4><ul>
<li>高斯金字塔(Gaussian Pyramid)，从底部开始计数，第 <em>i+1</em> 层表示为 <em>G(i + 1)</em><br><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220613132715.png"></li>
<li>*G(i + 1)<em>层的变换过程，由</em>G(i)*层先进行高斯模糊，然后丢掉偶数行和偶数列的像素，即图像缩小的操作</li>
<li>图像放大的操作，图像放大两倍，在奇数行和奇数列填充0像素，再进行高斯模糊<br><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220613141653.png"></li>
</ul>
<h4 id="图像阈值操作threshold的几种方法"><a href="#图像阈值操作threshold的几种方法" class="headerlink" title="图像阈值操作threshold的几种方法"></a>图像阈值操作<em>threshold</em>的几种方法</h4><ol>
<li>二值化（Threshold Binary），<code>src(x, y)</code>大于阈值<code>threshold</code>则置为最大值，否则置为0</li>
<li>反向二值化（Threshold Binary, Inverted），<code>src(x, y)</code>小于阈值<code>threshold</code>则置为最大值，否则置为0</li>
<li>截取像素值（Truncate），<code>src(x, y)</code>大于阈值<code>threshold</code>则令<code>src(x, y)</code>等于<code>threshold</code>，否则不变</li>
<li>只保留超过阈值部分，<code>src(x, y)</code>大于阈值<code>threshold</code>则置为原值，否则置为0</li>
<li>只保留小于阈值部分，<code>src(x, y)</code>小于阈值<code>threshold</code>则置为0，否则不变</li>
</ol>
<h4 id="图像像素梯度计算"><a href="#图像像素梯度计算" class="headerlink" title="图像像素梯度计算"></a>图像像素梯度计算</h4><ul>
<li><p><code>Sobel</code>边缘检测算子，利用图像边缘像素强度值变化非常显著的特点，使用特殊的卷积核计算水平方向的梯度变化和竖直方向的梯度变化。如下图是图像边缘像素强度的变化曲线的一维图像和该图像像素强度变化梯度图像（即导数图像），像素强度变化最剧烈的地方就可能是物体边缘。<br><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220614155216.png"> <img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220614160139.png">  </p>
</li>
<li><p>利用特殊的卷积核计算水平梯度变化和垂直梯度变化，然后再融合两个梯度图像<br><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220614160526.png"> <img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220614160536.png"><br><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220614160543.png"> <img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220614160552.png"></p>
</li>
<li><p>利用二级导数，像素强度变化剧烈的点即一阶导数极值点，其二级导数值接近0，拉普拉斯算子<code>Laplacian</code>计算水平方向和竖直方向上二级导数的和，OpenCV提供的<code>Laplacian()</code>函数，内部也是通过调用<code>Sobel()</code>来计算的，如下图二级导数图像和拉普拉斯公式。<br><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220624144442.png"><br><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220624144513.png"></p>
</li>
<li><p><code>Canny</code>边缘检测，1986年由John F. Canny提出，被认为是最优的边缘检测算法，其具有三个主要的特点：较低的错误率、较好的边缘定位、较快的检测速度，其检测步骤如下：</p>
<ol>
<li>使用高斯平滑模糊图像</li>
<li>计算图像亮度梯度图像，其过程与Sobel算子类似，分别计算x y方向上的梯度，再进行融合</li>
<li>去掉不是很连续的像素点，认为其不属于边缘</li>
<li>使用两个阈值，一大一小，其比例一般为2:1或者3:1，高于upper阈值认为其为边缘，低于lower阈值丢弃该像素点，介于upper与lower之间的像素点则看邻接像素点是否高于upper，是的话接受其为边缘</li>
</ol>
</li>
</ul>
<h4 id="霍夫变换直线检测"><a href="#霍夫变换直线检测" class="headerlink" title="霍夫变换直线检测"></a>霍夫变换直线检测</h4><ul>
<li>图像转化为灰度颜色，首先进行高斯模糊</li>
<li>再进行边缘检测，使其变成了一个二值化包含边缘的图像</li>
<li>经过该图像上像素点（x0, y0）的所有直线的方程可以表述为如下，霍夫变换检测每一个像素点的经过直线的条数，经过的直线条数到达一定阈值后可认为该</li>
</ul>
]]></content>
      <categories>
        <category>OpenCV</category>
      </categories>
      <tags>
        <tag>OpenCV Core</tag>
      </tags>
  </entry>
  <entry>
    <title>HI3559AV100调试记录</title>
    <url>/archives/7803046f.html</url>
    <content><![CDATA[<h4 id="内核编译与烧写"><a href="#内核编译与烧写" class="headerlink" title="内核编译与烧写"></a>内核编译与烧写</h4><ul>
<li>内核版本4.9.37，Linux内核源码如下<br><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220609101727.png"><span id="more"></span></li>
<li>编译<code>make ARCH=arm64 CROSS_COMPILE=aarch64-himix100-linux- uImage -j12</code>，编译完成结果如下，编译完成后会在arch&#x2F;arm64&#x2F;boot&#x2F;生成UImage<br><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220609101926.png"></li>
<li>arm-trusted-firmware目录中运行mk.sh生成fip.bin<br><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220609110821.png"></li>
<li>主机搭建tftp服务器，将fip.bin拷贝到共享目录</li>
<li>进入uboot，配置ethact ipaddr serverip环境变量<br><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220609111122.png"></li>
<li>从tftp加载内核，测试内核是否能启动、  <figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">tftp</span> fip.bin <span class="number">0</span>x<span class="number">42000000</span></span><br><span class="line"><span class="attribute">bootm</span> <span class="number">0</span>x<span class="number">42000000</span></span><br></pre></td></tr></table></figure></li>
<li>烧写内核到emmc  <figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">tftp</span> fip.bin <span class="number">0</span>x<span class="number">42000000</span></span><br><span class="line"><span class="attribute">mmc</span> dev <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="attribute">mmc</span> write <span class="number">0</span> <span class="number">0</span>x<span class="number">42000000</span> <span class="number">800</span> <span class="number">4800</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="驱动调试"><a href="#驱动调试" class="headerlink" title="驱动调试"></a>驱动调试</h4><ul>
<li>参照正点原子教程搭建驱动调试环境，配置的<em>Makefile</em>内容如下  <figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">KERNEL_DIR = /home/jack/hisi/minimum_system/linux-4.9.y_multi-core</span><br><span class="line">CURRENT_PATH = <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line">obj-m := gpio-pca953x.o</span><br><span class="line"></span><br><span class="line"><span class="section">build: kernel_modules</span></span><br><span class="line"></span><br><span class="line"><span class="section">kernel_modules: </span></span><br><span class="line"><span class="variable">$(MAKE)</span> ARCH=arm64 CROSS_COMPILE=aarch64-himix100-linux- -C <span class="variable">$(KERNEL_DIR)</span> M=<span class="variable">$(CURRENT_PATH)</span> modules</span><br><span class="line"></span><br><span class="line"><span class="section">clean: </span></span><br><span class="line"><span class="variable">$(MAKE)</span> ARCH=arm64 CROSS_COMPILE=aarch64-himix100-linux- -C <span class="variable">$(KERNEL_DIR)</span> M=<span class="variable">$(CURRENT_PATH)</span> clean</span><br></pre></td></tr></table></figure></li>
<li><em>KERNEL_DIR</em>表示Linux内核源码目录，使用绝对路径</li>
<li><em>CURRENT_PATH</em>表示当前路径，直接使用<em>pwd</em>来获取当前路径</li>
<li><em>obj-m</em>表示将这个c文件编译为ko模块</li>
<li><em>modules</em>表示编译模块，*-C*表示将当前的工作目录切换到指定目录中， <em>M</em>表示模块源码目录</li>
<li><em>make modules</em>命令中加入 M&#x3D;dir 以后程序会自动到指定的 dir 目录中读取模块的源码并将其编译为.ko 文件</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Hi3559AV100 Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux Input子系统按键连按驱动调试记录</title>
    <url>/archives/e19e1ecc.html</url>
    <content><![CDATA[<h4 id="Linux-Input子系统介绍"><a href="#Linux-Input子系统介绍" class="headerlink" title="Linux Input子系统介绍"></a>Linux Input子系统介绍</h4><blockquote>
<p>按键、鼠标、键盘、触摸屏等都属于输入(input)设备, Linux 内核为此专门做了一个叫做 input子系统的框架来处理输入事件。输入设备本质上还是字符设备,只是在此基础上套上了 input 框架,用户只需要负责上报输入事件,比如按键值、坐标等信息, input 核心层负责处理这些事件。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220609141734.png"></p>
<span id="more"></span>

<h4 id="input驱动编写流程"><a href="#input驱动编写流程" class="headerlink" title="input驱动编写流程"></a>input驱动编写流程</h4><ul>
<li><p>注册input_dev</p>
<ol>
<li>使用<em>input_allocate_device</em>申请一个<em>input_dev</em>结构体</li>
<li>初始化<em>input_dev</em>的事件类型以及事件值</li>
<li>使用<em>input_register_device</em>函数向系统注册<em>input_dev</em></li>
<li><strong>按键需要实现连按时<em>evbit</em>需要设置<em>EV_REP</em>标志，调按键驱动时在调连按功能时在这里卡了很久</strong>  <figure class="highlight xl"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">chip</span>-&gt;</span>input = input_allocate_device();</span><br><span class="line"><span class="function"><span class="title">if</span> (!chip-&gt;</span>input) </span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_ERR <span class="string">&quot;Unable to allocate the input device !!\n&quot;</span>);</span><br><span class="line">    return -ENOMEM;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">chip</span>-&gt;</span><span class="function"><span class="title">input</span>-&gt;</span><span class="keyword">name</span> = <span class="string">&quot;pca953x_button&quot;</span>;</span><br><span class="line"><span class="function"><span class="title">set_bit</span>(EV_KEY, chip-&gt;</span><span class="function"><span class="title">input</span>-&gt;</span>evbit);     <span class="comment">/* 设置产生按键事件 */</span> </span><br><span class="line"><span class="function"><span class="title">set_bit</span>(EV_REP, chip-&gt;</span><span class="function"><span class="title">input</span>-&gt;</span>evbit);     <span class="comment">/* 设置重复事件  */</span> </span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; ZKEY_NUM + <span class="number">5</span>; i++)	</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="title">set_bit</span>(button_info[i].code, chip-&gt;</span><span class="function"><span class="title">input</span>-&gt;</span>keybit);	<span class="comment">//支持具体按键键码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">status</span> = input_register_device(chip-&gt;</span>input);   <span class="comment">//注册input设备</span></span><br><span class="line"><span class="keyword">if</span>(status)</span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_ERR <span class="string">&quot;input_register_device\n&quot;</span>);</span><br><span class="line">    return -ENOMEM;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="上报输入事件"><a href="#上报输入事件" class="headerlink" title="上报输入事件"></a>上报输入事件</h4></li>
</ol>
</li>
<li><p>使用<em>input_event</em>函数上报指定的事件及对应的值，函数原型如下</p>
  <figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> input_event(<span class="keyword">struct</span> input_dev *dev,</span><br><span class="line">                 <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="keyword">type</span>,</span><br><span class="line">                 <span class="keyword">unsigned</span> <span class="keyword">int</span> code,</span><br><span class="line">                 <span class="keyword">int</span> value)</span><br></pre></td></tr></table></figure>
<p>  dev:需要上报的 input_dev。<br>  type: 上报的事件类型,比如 EV_KEY。<br>  code:事件码,也就是我们注册的按键值,比如 KEY_0、KEY_1 等等。<br>  value:事件值,比如 1 表示按键按下,0 表示按键松开。</p>
</li>
<li><p>上报按键事件，Linux内核也提供了具体的上报函数<em>input_report_key</em></p>
  <figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">static inline void input<span class="constructor">_report_key(<span class="params">struct</span> <span class="params">input_dev</span> <span class="operator">*</span><span class="params">dev</span>, <span class="params">unsigned</span> <span class="params">int</span> <span class="params">code</span>, <span class="params">int</span> <span class="params">value</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    input<span class="constructor">_event(<span class="params">dev</span>, EV_KEY, <span class="params">code</span>, !!<span class="params">value</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  type:事件类型,比如 EV_KEY,表示此次事件为按键事件,此成员变量为 16 位。<br>  code:事件码,比如在 EV_KEY 事件中 code 就表示具体的按键码,如:KEY_0、KEY_1等等这些按键。此成员变量为 16 位。<br>  value:值,比如 EV_KEY 事件中 value 就是按键值,表示按键有没有被按下,如果为1的话说明按键按下,如果为0的话说明按键没有被按下或者按键松开了。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux Driver 按键驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt中串口数据处理机制</title>
    <url>/archives/6e893f38.html</url>
    <content><![CDATA[<p>在嵌入式项目或者工控项目中经常会用到串口通讯，用到串口通讯可能就涉及到串口私有协议（类似 包头 + 帧类型 + 帧长度 + 帧数据 + 校验和 的形式）的解析。在Qt中经常用到<code>QSerialPort</code>类来进行串口数据收发，<code>QSerialPort</code>在串口数据可读时会释放<code>readyRead()</code>信号，接到这个信号再调用<code>readAll()</code>将缓冲区的数据全部读出来（串口数据量比较大，这个过程一般都是在一个独立的接收线程中进行处理）。<span id="more"></span>但是这个<code>readyRead()</code>信号释放时，缓冲区的数据长度是不固定的（一般是几十个字节会释放一次读信号），不过串口私有协议各个帧的长度基本都是固定的，这就导致处理串口数据时需要对<code>readAll()</code>中读出来的数据进行链接，然后进行数据解析。<br>记录一下最近调试Qt串口通讯时用到的方法，这个方法也适用于任何系统的串口数据接收，可以达到不错的处理速度，保证不丢帧的接收。该方法的处理机制比较简单，在槽函数中接收到串口数据后，释放信号将读到的数据传递出去，接收信号方逐字节的按照协议对这些数据进行处理，这样只要<code>QSerialPort</code>将串口上的数据都完整的读出来了，应该是不会出现丢帧的情况。</p>
<h4 id="串口初始化及数据接收"><a href="#串口初始化及数据接收" class="headerlink" title="串口初始化及数据接收"></a>串口初始化及数据接收</h4><ul>
<li>串口类进行初始化后，转移到<code>thread</code>线程中进行处理，在<code>readSerialData()</code>中将数据读取后将数据传递出去。<br>  serialport.h  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SerialPort</span> :</span> <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">SerialPort</span><span class="params">(QObject *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">    ~<span class="built_in">SerialPort</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">startThread</span><span class="params">(<span class="keyword">const</span> QString &amp;port)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">closeSerialPort</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">writeSerialData</span><span class="params">(<span class="keyword">const</span> QByteArray &amp;data)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">openSerialPort</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">readSerialData</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">serialStateChanged</span><span class="params">(<span class="keyword">bool</span> state)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dataReaded</span><span class="params">(<span class="keyword">const</span> QByteArray &amp;data)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QString port;</span><br><span class="line">    qint32 baudrate;</span><br><span class="line">    QSerialPort *serial;</span><br><span class="line">    QThread *thread;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
  serialport.cpp  <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &quot;serialport.h&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@brief</span> SerialPort::SerialPort</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> parent</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">SerialPort::SerialPort(QObject *<span class="built_in">parent</span>) : QObject(<span class="built_in">parent</span>)</span><br><span class="line">&#123;</span><br><span class="line">    serial = <span class="keyword">new</span> QSerialPort;</span><br><span class="line">    thread = <span class="keyword">new</span> QThread;</span><br><span class="line">    this-&gt;moveToThread(thread);</span><br><span class="line">    serial-&gt;moveToThread(thread);</span><br><span class="line">    connect(thread, &amp;QThread::started, this, &amp;SerialPort::openSerialPort);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@brief</span> SerialPort::~SerialPort</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">SerialPort::~SerialPort()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (serial-&gt;isOpen())</span><br><span class="line">    &#123;</span><br><span class="line">        serial-&gt;close();</span><br><span class="line">    &#125;</span><br><span class="line">    serial-&gt;deleteLater();</span><br><span class="line">    thread-&gt;quit();</span><br><span class="line">    thread-&gt;wait();</span><br><span class="line">    thread-&gt;deleteLater();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@brief</span> SerialPort::startThread</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> port serial port name(QSerialPortInfo::name)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">void</span> SerialPort::startThread(<span class="keyword">const</span> QString &amp;port)</span><br><span class="line">&#123;</span><br><span class="line">    this-&gt;port = port;</span><br><span class="line">    qDebug() &lt;&lt; <span class="string">&quot;current port is &quot;</span> &lt;&lt; port;</span><br><span class="line">    <span class="keyword">if</span> (!thread-&gt;isRunning())</span><br><span class="line">    &#123;</span><br><span class="line">        thread-&gt;start();</span><br><span class="line">        qDebug() &lt;&lt; <span class="string">&quot;serialport thread start: &quot;</span> &lt;&lt; QThread::currentThread();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@brief</span> SerialPort::openSerialPort</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">void</span> SerialPort::openSerialPort()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (serial-&gt;isOpen())</span><br><span class="line">    &#123;</span><br><span class="line">        qDebug() &lt;&lt; <span class="string">&quot;serial is opened, return.&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    serial-&gt;setPortName(port);</span><br><span class="line">    serial-&gt;setBaudRate(<span class="number">115200</span>);</span><br><span class="line">    serial-&gt;setDataBits(QSerialPort::Data8);</span><br><span class="line">    serial-&gt;setStopBits(QSerialPort::OneStop);</span><br><span class="line">    serial-&gt;setParity(QSerialPort::NoParity);</span><br><span class="line">    serial-&gt;setFlowControl(QSerialPort::NoFlowControl);</span><br><span class="line">    <span class="keyword">if</span> (serial-&gt;open(QIODevice::ReadWrite))</span><br><span class="line">    &#123;</span><br><span class="line">        qDebug() &lt;&lt; <span class="string">&quot;serial open success.&quot;</span> &lt;&lt; QThread::currentThread();</span><br><span class="line">        connect(serial, &amp;QSerialPort::readyRead,</span><br><span class="line">                this, &amp;SerialPort::readSerialData, Qt::QueuedConnection);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        qDebug() &lt;&lt; <span class="string">&quot;serial open failed.&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@brief</span> SerialPort::readSerialData</span></span><br><span class="line"><span class="comment">* read 16 bytes each time</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">void</span> SerialPort::readSerialData()</span><br><span class="line">&#123;</span><br><span class="line">    QByteArray buf = serial-&gt;readAll();</span><br><span class="line">    emit dataReaded(buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@brief</span> SerialPort::writeSerialData</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> data  buff to write</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">void</span> SerialPort::writeSerialData(<span class="keyword">const</span> QByteArray &amp;data)</span><br><span class="line">&#123;</span><br><span class="line">    serial-&gt;write(data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@brief</span> SerialPort::closeSerialPort</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">void</span> SerialPort::closeSerialPort()</span><br><span class="line">&#123;</span><br><span class="line">    qDebug() &lt;&lt; <span class="string">&quot;close serialport.&quot;</span>;</span><br><span class="line">    serial-&gt;clear();</span><br><span class="line">    serial-&gt;close();</span><br><span class="line">    <span class="keyword">if</span> (thread-&gt;isRunning())</span><br><span class="line">    &#123;</span><br><span class="line">        thread-&gt;quit();</span><br><span class="line">        thread-&gt;wait();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="串口数据处理"><a href="#串口数据处理" class="headerlink" title="串口数据处理"></a>串口数据处理</h4><ul>
<li>数据处理类接收到串口类传递的数据后，按照协议逐字节的进行处理，帧头的处理比较麻烦，因为帧头一般是两个字节，可能被缓冲到前后两个数据缓冲区，所以需要对前后两个帧头的位置关系进行判断。<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uartRecvProcess</span><span class="params">(<span class="keyword">const</span> QByteArray&amp; data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> firstHeadPos = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> frameLen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> frameDataIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> lastLen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">uint8_t</span> frameData[MAX_FRAME_LEN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> PRINT_UART_DEBUG</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; data.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;0x%02x &quot;</span>, (<span class="keyword">uint8_t</span>)data.<span class="built_in">at</span>(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (index &lt; data.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">uint8_t</span> temp = data.<span class="built_in">at</span>(index);</span><br><span class="line"></span><br><span class="line">        <span class="built_in"><span class="keyword">switch</span></span> (step)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="comment">// 查找第一个帧头</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="number">0x55</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                step = <span class="number">1</span>;</span><br><span class="line">                firstHeadPos = index;</span><br><span class="line">                frameData[frameDataIndex++] = temp;</span><br><span class="line">                lastLen = data.<span class="built_in">size</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查找第二个帧头</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> ((temp == <span class="number">0xAA</span>) &amp;&amp;</span><br><span class="line">                ((index == firstHeadPos + <span class="number">1</span>) ||</span><br><span class="line">                ((firstHeadPos == lastLen <span class="number">-1</span>) &amp;&amp; index == <span class="number">0</span>)))</span><br><span class="line">            &#123;</span><br><span class="line">                step = <span class="number">2</span>;</span><br><span class="line">                frameData[frameDataIndex++] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                step = <span class="number">0</span>;</span><br><span class="line">                firstHeadPos = <span class="number">-1</span>;</span><br><span class="line">                frameDataIndex = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 帧类型判断</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">if</span>(temp == CMD_AD)</span><br><span class="line">            &#123;</span><br><span class="line">                frameLen = FRAME_SIZE_AD;</span><br><span class="line">                frameData[frameDataIndex++] = temp;</span><br><span class="line">                step = <span class="number">3</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(temp == CMD_IO)</span><br><span class="line">            &#123;</span><br><span class="line">                frameLen = FRAME_SIZE_IO;</span><br><span class="line">                step = <span class="number">3</span>;</span><br><span class="line">                frameData[frameDataIndex++] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//去掉帧头，重新查找</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;unknow uart frame type\n&quot;</span>);</span><br><span class="line">                step = <span class="number">0</span>;</span><br><span class="line">                frameLen = <span class="number">0</span>;</span><br><span class="line">                firstHeadPos = <span class="number">-1</span>;</span><br><span class="line">                frameDataIndex = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 帧数据接收及解析</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">if</span> (frameDataIndex &lt; frameLen)</span><br><span class="line">                frameData[frameDataIndex++] = temp;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (frameDataIndex == frameLen)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(frameData[frameLen - <span class="number">1</span>] != <span class="built_in">checkSum</span>(frameData, frameLen - <span class="number">1</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;type: %d, checksum error! received is 0x%02x, calculated is 0x%02x\n&quot;</span>,</span><br><span class="line">                           frameLen, frameData[frameLen - <span class="number">1</span>], <span class="built_in">checkSum</span>(frameData, frameLen - <span class="number">1</span>));</span><br><span class="line">                    step = <span class="number">0</span>;</span><br><span class="line">                    frameLen = <span class="number">0</span>;</span><br><span class="line">                    firstHeadPos = <span class="number">-1</span>;</span><br><span class="line">                    frameDataIndex = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;type: %d, uart data handler\n&quot;</span>, frameLen);</span><br><span class="line">                    <span class="built_in">uartDataHandler</span>(frameData, frameLen);</span><br><span class="line">                    step = <span class="number">0</span>;</span><br><span class="line">                    frameLen = <span class="number">0</span>;</span><br><span class="line">                    firstHeadPos = <span class="number">-1</span>;</span><br><span class="line">                    frameDataIndex = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        index ++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>Qt QSerialPort 串口</tag>
      </tags>
  </entry>
  <entry>
    <title>龙芯2K1000内核源码编译</title>
    <url>/archives/67263a86.html</url>
    <content><![CDATA[<h4 id="解压PMON源码pmon-loongson3-tar-gz"><a href="#解压PMON源码pmon-loongson3-tar-gz" class="headerlink" title="解压PMON源码pmon-loongson3.tar.gz"></a>解压PMON源码<em>pmon-loongson3.tar.gz</em></h4><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">tar</span> -xvf pmon-loongson<span class="number">3</span>-nd-<span class="number">33</span>j.tar.gz</span><br></pre></td></tr></table></figure>
<h4 id="配置交叉编译环境"><a href="#配置交叉编译环境" class="headerlink" title="配置交叉编译环境"></a>配置交叉编译环境</h4><ul>
<li>解压交叉编译工具<em>gcc-4.4.0-pmon.tgz</em>，配置环境<span id="more"></span>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">tar</span> -xvf gcc-<span class="number">4</span>.<span class="number">4</span>.<span class="number">0</span>-pmon.tgz</span><br></pre></td></tr></table></figure>
编辑&#x2F;etc&#x2F;profile，配置交叉编译工具路径<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">export PATH=<span class="variable">$PATH</span><span class="symbol">:/home/jack/loongson/tools/gcc-</span><span class="number">4.4</span>.0-pmon/bin</span><br><span class="line">export LD_LIBRARY_PATH=<span class="regexp">/home/jack</span><span class="regexp">/loongson/tools</span><span class="regexp">/gcc-4.4.0-pmon/lib</span><span class="symbol">:</span><span class="variable">$LD_LIBRARY_PATH</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>安装makedepend，<code>sudo apt-get install xutils-dev </code></li>
<li>进入源码目录编译安装pmoncfg<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> install bison flex build-essential patch</span><br><span class="line"><span class="keyword">cd</span> tools/pmoncfg </span><br><span class="line"><span class="keyword">make</span> </span><br><span class="line">sudo <span class="keyword">cp</span> pmoncfg /usr/bin</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="编译PMON源码"><a href="#编译PMON源码" class="headerlink" title="编译PMON源码"></a>编译PMON源码</h4><p>进入PMON源码目录，若只需要修改PMON，可在原来的项目目录基础上进行编译，源码内有脚本文件<em>build.sh</em>，输入格式: <code>./build.sh [cputype] [proID]</code>，比如龙芯2K1000，项目ID hm19047，输入<code>./build.sh ls2k hm19047</code>即可开始编译，编译结果在<em>zloader.ls2k-hm19047</em>目录中，会生成<em>gzrom-dtb.bin</em>，将该文件烧录进flash即可。</p>
<h4 id="PMON网络烧录"><a href="#PMON网络烧录" class="headerlink" title="PMON网络烧录"></a>PMON网络烧录</h4><ul>
<li>主机IP地址为192.168.0.100，搭建tftp服务器</li>
<li>开机按C键进入PMON下，设置IP地址<code>ifconfig syn0 192.168.0.10</code></li>
<li>烧写PMON<code>load -rf 0xbfc00000 tftp://192.168.0.100/gzrom-dtb.bin</code></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>PMON</tag>
        <tag>Loongson</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu编译QFtp并使用</title>
    <url>/archives/1b5a9595.html</url>
    <content><![CDATA[<h4 id="下载QFtp源码"><a href="#下载QFtp源码" class="headerlink" title="下载QFtp源码"></a>下载QFtp源码</h4><p><a href="https://github.com/qt/qtftp.git">QFtp源码</a><br><code>gti clone https://github.com/qt/qtftp.git</code></p>
<h4 id="编译QFtp模块"><a href="#编译QFtp模块" class="headerlink" title="编译QFtp模块"></a>编译QFtp模块</h4><p>在QtCreator上编译出了点问题，只能在终端进行编译</p>
<ul>
<li>进入源码目录<code>cd src/qftp</code>，修改pro文件<code>qftp.pro</code>,修改如下<span id="more"></span>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">load(qt_build_config)</span><br><span class="line"></span><br><span class="line">TARGET = QtFtp</span><br><span class="line">CONFIG += static</span><br><span class="line">CONFIG -= shared</span><br><span class="line">QT = core network</span><br><span class="line"></span><br><span class="line">MODULE_PRI = ../../modules/qt_ftp.pri</span><br><span class="line">MODULE = ftp</span><br><span class="line"></span><br><span class="line">load(qt_module)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Input</span></span><br><span class="line">HEADERS += qftp.h qurlinfo.h</span><br><span class="line">SOURCES += qftp.cpp qurlinfo.cpp</span><br><span class="line"></span><br></pre></td></tr></table></figure>
修改<code>qurlinfo.cpp</code>中的<code>qurlinfo.h</code>路径，修改如下<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &quot;qurlinfo.h&quot;</span><br><span class="line"></span><br><span class="line">#include &quot;qurl.h&quot;</span><br><span class="line">#include &quot;qdir.h&quot;</span><br><span class="line">#include &lt;limits.h&gt;</span><br><span class="line"></span><br><span class="line">QT_BEGIN_NAMESPACE</span><br></pre></td></tr></table></figure></li>
<li>在终端中进入源码目录<code>cd src/qftp</code>，运行<code>qmake</code>，之后会生成Makefile</li>
<li><code>make</code>生成<code>libQt5Ftp.a</code>静态库，pri模块文件</li>
<li><code>make install</code>将生成的库文件及QFtp头文件复制到Qt安装目录</li>
<li>对于交叉编译环境下其他平台的编译也可按照上面的步骤，qmake需要替换交叉编译环境下对应的qmake</li>
</ul>
<h4 id="QFtp使用"><a href="#QFtp使用" class="headerlink" title="QFtp使用"></a>QFtp使用</h4><ul>
<li>官方源码目录example文件夹下有一个例程，网上有大佬稍加修改上传到了GitHub，<a href="https://github.com/chuanstudyup/QFtpExample.git">QFtp例程</a>  </li>
<li>下载这个例程，上述编译步骤没问题的话，直接编译运行即可<br><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220627150335.png"></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>QFtp</tag>
      </tags>
  </entry>
  <entry>
    <title>C/C++ 中宏定义中#和##的作用</title>
    <url>/archives/57aaac13.html</url>
    <content><![CDATA[<h4 id="宏定义中-的功能"><a href="#宏定义中-的功能" class="headerlink" title="宏定义中#的功能"></a>宏定义中#的功能</h4><p>C&#x2F;C++宏定义#中的功能是将其后面的宏参数进行字符串化操作，简单说就是在对它所引用的宏变量通过替换后在其左右各添加一个双引号。</p>
<span id="more"></span>

<h4 id="宏定义中-的功能-1"><a href="#宏定义中-的功能-1" class="headerlink" title="宏定义中##的功能"></a>宏定义中##的功能</h4><p>宏定义中##中的功能是在带参数的宏定义中将##前后的子串进行拼接。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STR(s) #s</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONS(a, b) int(a##e##b)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">STR</span>(hello) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">CONS</span>(<span class="number">2</span>, <span class="number">3</span>) &lt;&lt; endl;     <span class="comment">// CONS(2, 3) -&gt; 2e3 </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line">hello</span><br><span class="line"><span class="number">2000</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核链表结构</title>
    <url>/archives/4896cd7d.html</url>
    <content><![CDATA[<p>Linux内核中，对于数据管理，提供了2种类型的双向链表，一种是使用list_head结构体构成的双向环形链表。<br><img src="https://raw.githubusercontent.com/JackHuang021/images/master/20221103103152.png"></p>
<span id="more"></span>
<h4 id="list-head链表"><a href="#list-head链表" class="headerlink" title="list_head链表"></a>list_head链表</h4><p><code>list_head</code>结构体定义在<code>include/linux/types.h</code>中，定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">next</span>, *<span class="title">prev</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>list_head</code>组成的双向链表，仅包含两个成员，<code>next</code>和<code>prev</code>指针，分别指向下一个和前一个<code>list_head</code></p>
<p><code>list_head</code>一般不是单独使用的，一般用来嵌入到其他结构体中，知道<code>list_head</code>指针时就可以通过<code>include/linux/list.h</code>中提供的<code>list_entry</code>宏来获取它父结构的地址，其中调用了<code>container_of</code>宏，该宏定义在<code>include/linux/kernel</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* list_head 使用示例 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_list</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *item;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* list_entry */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* list_entry - get the struct for this entry</span></span><br><span class="line"><span class="comment">* @ptr:	the &amp;struct list_head pointer.</span></span><br><span class="line"><span class="comment">* @type:	the type of the struct this is embedded in.</span></span><br><span class="line"><span class="comment">* @member:	the name of the list_head within the struct.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_entry(ptr, type, member) \</span></span><br><span class="line"><span class="meta">    container_of(ptr, type, member)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* container_of - cast a member of a structure out to the containing structure</span></span><br><span class="line"><span class="comment">* @ptr:	the pointer to the member.</span></span><br><span class="line"><span class="comment">* @type:	the type of the container struct this is embedded in.</span></span><br><span class="line"><span class="comment">* @member:	the name of the member within the struct.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> container_of(ptr, type, member) (&#123; \</span></span><br><span class="line"><span class="meta">    void *__mptr = (void *)(ptr); \</span></span><br><span class="line"><span class="meta">    ((type *)(__mptr - offsetof(type, member))); &#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* offsetof */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> offsetof(TYPE, MEMBER) ((size_t) &amp;((TYPE *)0)-&gt;MEMBER)</span></span><br></pre></td></tr></table></figure>
<p><code>offsetof</code>获取结构体成员在结构体中地址的偏移量<br><code>container_of</code>的作用是通过结构体的成员地址获取结构体变量的地址，container_of一共<br>需要传入三个参数，<code>ptr</code>指针地址，<code>type</code>结构体类型，<code>member</code>结构体成员名称，具体<br>的做法就是通过成员的指针地址，减去成员在结构体中偏移的地址</p>
<h4 id="list-head链表操作"><a href="#list-head链表操作" class="headerlink" title="list_head链表操作"></a><code>list_head</code>链表操作</h4><ul>
<li><p><code>list_head</code>初始化，<code>list_head</code>初始化分为静态初始化和动态初始化</p>
<ul>
<li><p>静态初始化</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIST_HEAD_INIT(name) &#123; &amp;(name), &amp;(name) &#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIST_HEAD(name) struct list_head name = LIST_HEAD_INIT(name)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 例如 */</span></span><br><span class="line">LIST_HEAD(my_list);</span><br><span class="line"><span class="comment">/* 展开即为 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">mylist</span> =</span> &#123; &amp;(mylist), &amp;(mylist) &#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>动态初始化</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIST_HEAD_INIT(name) &#123; &amp;(name), &amp;(name) &#125;</span></span><br><span class="line"><span class="comment">/* 或者 */</span></span><br><span class="line"><span class="function">struct <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">INIT_LIST_HEAD</span><span class="params">(struct list_head *<span class="built_in">list</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    WRITE_ONCE(<span class="built_in">list</span>-&gt;next, <span class="built_in">list</span>);</span><br><span class="line">    <span class="built_in">list</span>-&gt;prev = <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 例如 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">mylist</span> =</span> LIST_HEAD_INIT(mylist);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">mylist2</span>;</span></span><br><span class="line">INIT_LIST_HEAD(&amp;mylist2);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>从<code>list_head</code>中获取对象结构体</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @ptr:	the list head to take the element from.</span></span><br><span class="line"><span class="comment"> * @type:	the type of the struct this is embedded in.</span></span><br><span class="line"><span class="comment"> * @member:	the name of the list_head within the struct.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实际就是使用container_of通过list_head地址来获取原结构体的地址</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_entry(ptr, type, member) \</span></span><br><span class="line"><span class="meta">    container_of(ptr, type, member)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取链表上的第一个节点，这里ptr传入的默认应该是链表头节点，且传入的这个ptr不能为空指针</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_first_enrty(ptr, type, member) \</span></span><br><span class="line"><span class="meta">    container_of((ptr)-&gt;next, type, member)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取链表上的最后一个节点，通过双向链表的prev指针来获取</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_last_entry(ptr, type, member) \</span></span><br><span class="line"><span class="meta">    container_of((ptr)-&gt;prev, type, member)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断当前给入的链表是否为空链表，不为空表返回下一个节点对应的结构体地址</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_first_enrty_or_null(ptr, type, member) (&#123; \</span></span><br><span class="line"><span class="meta">    struct list_head *head__ = (ptr); \</span></span><br><span class="line"><span class="meta">    struct list_head *pos__ = READ_ONCE(head__-&gt;next); \</span></span><br><span class="line"><span class="meta">    pos__ != head__ ? list_entry(pos__, type, member) : NULL; \</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* @pos:     含list_head结构体对象的指针</span></span><br><span class="line"><span class="comment">* @member:  list_head在这个结构体中的成员名</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 通过结构体对象的指针来获取链表中下一个节点的结构体对象地址</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_next_entry(pos, member) \</span></span><br><span class="line"><span class="meta">    list_entry((pos)-&gt;member.next, typeof(*(pos)), member)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过结构体对象的指针来获取链表中上一个节点的结构体对象地址</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_prev_entry(pos, member) \</span></span><br><span class="line"><span class="meta">    list_entry((pos)-&gt;member.prev, typeof(*(pos)), member)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>list_head</code>增加节点</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> __list_add(struct list_head *<span class="keyword">new</span>,</span><br><span class="line">                struct list_head *prev,</span><br><span class="line">                struct list_head *next)</span><br><span class="line">&#123;</span><br><span class="line">    next-&gt;prev = <span class="keyword">new</span>;</span><br><span class="line">    <span class="keyword">new</span>-&gt;next = next;</span><br><span class="line">    <span class="keyword">new</span>-&gt;prev = prev;</span><br><span class="line">    prev-&gt;next = <span class="keyword">new</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* new插入到head后 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">list_add</span><span class="params">(struct list_head *<span class="keyword">new</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                struct list_head *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __list_add(<span class="keyword">new</span>, head, head-&gt;next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* new插入到head之前 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">list_add_tail</span><span class="params">(struct list_head *<span class="keyword">new</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                struct list_node *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __list_add(<span class="keyword">new</span>, head-&gt;prev, head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>遍历<code>list_head</code></p>
<ul>
<li><p>通过<code>list_head</code>的头节点向后遍历整个链表</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @pos:    the &amp;struct list_head to use as a loop cursor</span></span><br><span class="line"><span class="comment"> * @head:   the head for your list</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_for_each(pos, head) \</span></span><br><span class="line"><span class="meta">    for (pos = (head)-&gt;next; pos != (head); pos = pos-&gt;next)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>通过<code>list_head</code>的头节点向前遍历整个链表</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_for_each_prev(pos, head) \</span></span><br><span class="line"><span class="meta">    for (pos = (head)-&gt;prev; pos != (head); pos = pos-&gt;prev)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>通过<code>list_head</code>的头节点向后遍历链表，这里使用<code>n</code>来存储<code>pos</code>指向的下一个节点的原因主要就是若：当前循环对<code>pos</code>进行了删除操作，因为<code>n</code>存储了下一个节点，那么可以保证遍历安全的进行下去</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @pos:    the &amp;struct list_head to use as a loop cursor</span></span><br><span class="line"><span class="comment"> * @n:      another &amp;struct list_head to use a temporary storage</span></span><br><span class="line"><span class="comment"> * @head:   the head for your list</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_for_each_safe(pos, n, head) \</span></span><br><span class="line"><span class="meta">    for (pos = (head)-&gt;next, n = pos-&gt;next; pos != head; \</span></span><br><span class="line"><span class="meta">        pos = n, n = pos-&gt;next)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>通过<code>list_head</code>的头节点向前遍历链表</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_for_each_prev_safe(pos, n, head) \</span></span><br><span class="line"><span class="meta">    for (pos = (head)-&gt;prev, n = pos-&gt;prev; pos != head; \</span></span><br><span class="line"><span class="meta">        pos = n, n = pos-&gt;prev)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>通过<code>list_head</code>指针来向后遍历链表上的所有结构体对象</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_for_each_entry(pos, head, member) \</span></span><br><span class="line"><span class="meta">    for (pos = list_first_entry((head), typeof(*pos), member); \</span></span><br><span class="line"><span class="meta">        &amp;pos-&gt;member != (head); \</span></span><br><span class="line"><span class="meta">        pos = list_next_entry(pos, member))</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>通过<code>list_head</code>指针来向前遍历链表上的所有的结构体对象</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_for_each_entry_reverse(pos, head, member) \</span></span><br><span class="line"><span class="meta">    for (pos = list_last_entry((head), typeof(*pos), member); \</span></span><br><span class="line"><span class="meta">        &amp;pos-&gt;member != (head); \</span></span><br><span class="line"><span class="meta">        pos = list_prev_entry(pos, member))</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>通过给定的结构体指针<code>pos</code>和链表头，<code>pos</code>不能为空，从下一个节点开始继续向后遍历链表</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_for_each_entry_continue(pos, head, member) \</span></span><br><span class="line"><span class="meta">    for (pos = list_next_entry(pos, member); \</span></span><br><span class="line"><span class="meta">        &amp;pos-&gt;member != (head); \</span></span><br><span class="line"><span class="meta">        pos = list_next_entry(pos, member))</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>通过给定的结构体指针<code>pos</code>和链表头，<code>pos</code>不能为空，从上一个节点开始继续向前遍历链表</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_for_each_entry_continue_reverse(pos, head, member) \</span></span><br><span class="line"><span class="meta">    for (pos = list_prev_entry(pos, member); \</span></span><br><span class="line"><span class="meta">        &amp;pos-&gt;member != (head); \</span></span><br><span class="line"><span class="meta">        pos = list_prev_entry(pos, member))</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>通过给定的结构体指针<code>pos</code>和链表头，<code>pos</code>不能为空，从当前节点开始继续向后遍历链表</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_for_each_entry_from(pos, head, member) \</span></span><br><span class="line"><span class="meta">    for (; &amp;pos-&gt;member != (head); \</span></span><br><span class="line"><span class="meta">        pos = list_next_entry(pos, member))</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>通过给定的结构体指针<code>pos</code>和链表头，来安全的遍历链表，可以在循环中对当前遍历的结构体进行删除操作</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* list_for_each_entry_safe - iterate over list of given type safe against removal of list entry</span></span><br><span class="line"><span class="comment">* @pos:	    the type * to use as a loop cursor.</span></span><br><span class="line"><span class="comment">* @n:		another type * to use as temporary storage</span></span><br><span class="line"><span class="comment">* @head:	the head for your list.</span></span><br><span class="line"><span class="comment">* @member:	the name of the list_head within the struct.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_for_each_entry_safe(pos, n, head, member)			\</span></span><br><span class="line"><span class="meta">    for (pos = list_first_entry(head, typeof(*pos), member),	\</span></span><br><span class="line"><span class="meta">        n = list_next_entry(pos, member);			\</span></span><br><span class="line"><span class="meta">        !list_entry_is_head(pos, head, member); 			\</span></span><br><span class="line"><span class="meta">        pos = n, n = list_next_entry(n, member))</span></span><br></pre></td></tr></table></figure>
<p>  <code>platform</code>总线初始化的时候<code>platform_bus_init()</code>会调用<code>early_platform_clean()</code>来清除<code>early_platform_device_list</code>链表，代码如下：</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> __initdata <span class="title">LIST_HEAD</span><span class="params">(early_platform_device_list)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * early_platform_cleanup - clean up early platform code</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> __init <span class="title">early_platform_cleanup</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> *<span class="title">pd</span>, *<span class="title">pd2</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* clean up the devres list used to chain devices */</span></span><br><span class="line">    list_for_each_entry_safe(pd, pd2, &amp;early_platform_device_list,</span><br><span class="line">                 dev.devres_head) &#123;</span><br><span class="line">        list_del(&amp;pd-&gt;dev.devres_head);</span><br><span class="line">        <span class="built_in">memset</span>(&amp;pd-&gt;dev.devres_head, <span class="number">0</span>, <span class="keyword">sizeof</span>(pd-&gt;dev.devres_head));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  采用这种遍历的方式可以安全的删除当前遍历的节点</p>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>List</tag>
      </tags>
  </entry>
  <entry>
    <title>Platform设备驱动</title>
    <url>/archives/f8def83d.html</url>
    <content><![CDATA[<h4 id="Platform平台驱动模型"><a href="#Platform平台驱动模型" class="headerlink" title="Platform平台驱动模型"></a>Platform平台驱动模型</h4><p>由于某些外设是没有总线这个概念的，但是又要使用总线、驱动和设备模型的话，就需要使用<code>platform</code>这个虚拟总线，相应的就有<code>platform_device</code>和<code>platform_driver</code></p>
<span id="more"></span>

<h4 id="Platform总线"><a href="#Platform总线" class="headerlink" title="Platform总线"></a>Platform总线</h4><p>Linux内核使用<code>bus_type</code>结构体表示总线，该结构体定义在<code>include/linux/device.h</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>		*name;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>		*dev_name;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span>		*<span class="title">dev_root</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> **<span class="title">bus_groups</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> **<span class="title">dev_groups</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> **<span class="title">drv_groups</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> (*match)(struct device *dev, struct device_driver *drv);</span><br><span class="line">    <span class="keyword">int</span> (*uevent)(struct device *dev, struct kobj_uevent_env *env);</span><br><span class="line">    <span class="keyword">int</span> (*probe)(struct device *dev);</span><br><span class="line">    <span class="keyword">int</span> (*remove)(struct device *dev);</span><br><span class="line">    <span class="keyword">void</span> (*shutdown)(struct device *dev);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> (*online)(struct device *dev);</span><br><span class="line">    <span class="keyword">int</span> (*offline)(struct device *dev);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> (*suspend)(struct device *dev, <span class="keyword">pm_message_t</span> state);</span><br><span class="line">    <span class="keyword">int</span> (*resume)(struct device *dev);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> (*num_vf)(struct device *dev);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> (*dma_configure)(struct device *dev);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dev_pm_ops</span> *<span class="title">pm</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">iommu_ops</span> *<span class="title">iommu_ops</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">subsys_private</span> *<span class="title">p</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">lock_key</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> need_parent_lock;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>设备和驱动的匹配函数：<br><code>int (*match)(struct device *dev, struct device_driver*drv)</code><br>match函数有两个参数dev和driver，这两个参数分别为<code>device</code>和<code>device_driver</code>类型，也就是设备和驱动</p>
<p>platform总线是<code>bus_type</code>的一个具体实例，定义在<code>driver/base/platform.c</code>中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> <span class="title">platform_bus_type</span> =</span> &#123;</span><br><span class="line">    .name		= <span class="string">&quot;platform&quot;</span>,</span><br><span class="line">    .dev_groups	= platform_dev_groups,</span><br><span class="line">    .match		= platform_match,</span><br><span class="line">    .uevent		= platform_uevent,</span><br><span class="line">    .dma_configure	= platform_dma_configure,</span><br><span class="line">    .pm		= &amp;platform_dev_pm_ops,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中<code>platform_match</code>为驱动和设备的匹配函数，<code>platform_match</code>函数如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">platform_match</span><span class="params">(struct device *dev, struct device_driver *drv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> *<span class="title">pdev</span> =</span> to_platform_device(dev);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> *<span class="title">pdrv</span> =</span> to_platform_driver(drv);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* When driver_override is set, only bind to the matching driver */</span></span><br><span class="line">    <span class="keyword">if</span> (pdev-&gt;driver_override)</span><br><span class="line">        <span class="keyword">return</span> !<span class="built_in">strcmp</span>(pdev-&gt;driver_override, drv-&gt;name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Attempt an OF style match first */</span></span><br><span class="line">    <span class="keyword">if</span> (of_driver_match_device(dev, drv))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Then try ACPI style match */</span></span><br><span class="line">    <span class="keyword">if</span> (acpi_driver_match_device(dev, drv))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Then try to match against the id table */</span></span><br><span class="line">    <span class="keyword">if</span> (pdrv-&gt;id_table)</span><br><span class="line">        <span class="keyword">return</span> platform_match_id(pdrv-&gt;id_table, pdev) != <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* fall-back to driver name match */</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">strcmp</span>(pdev-&gt;name, drv-&gt;name) == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>platform驱动和设备匹配一共有四种方法:<ul>
<li>OF类型的匹配，也就是采用设备树的方式，<code>of_driver_match_device()</code>定义在文件 <code>/include/linux/of_device</code>中，<code>device_drive</code>结构体中有一个名为<code>of_match_table</code>的成员变量，该成员保存着驱动的compatible匹配表，设备树中的每个设备节点的compatible属性会和of_match_table中的所有成员比较，查看是否有相同的条目，如果有的话表示设备和驱动相匹配，设备和驱动匹配成功后，probe函数就会执行</li>
<li>ACPI匹配方式</li>
<li><code>id_table</code>匹配，每个<code>platform_driver</code>结构体有一个<code>id_table</code>成员变量，保留了很多id信息，这些id信息存放着这个驱动所支持的设备信息，该<code>id_table</code>会与<code>platform_device</code>中的<code>name</code>成员相比较</li>
<li>如果<code>id_table</code>不存在的话就直接比较驱动和设备的<code>name</code>字段，看看是否相等</li>
</ul>
</li>
</ul>
<h5 id="Platform总线初始化过程"><a href="#Platform总线初始化过程" class="headerlink" title="Platform总线初始化过程"></a>Platform总线初始化过程</h5><p>内核在初始化过程中调用<code>platform_bus_init()</code>来初始化Platform总线，调用流程如下<br><code>kernel_init_freeable() -&gt; do_basic_setup() -&gt; driver_init() -&gt; platform_bus_init()</code><br>其中<code>platform_bus_init()</code>函数定义在<code>driver/base/platform.c</code>中，内容如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __init <span class="title">platform_bus_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line"></span><br><span class="line">    early_platform_cleanup();</span><br><span class="line"></span><br><span class="line">    error = device_register(&amp;platform_bus);</span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        put_device(&amp;platform_bus);</span><br><span class="line">        <span class="keyword">return</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">    error =  bus_register(&amp;platform_bus_type);</span><br><span class="line">    <span class="keyword">if</span> (error)</span><br><span class="line">        device_unregister(&amp;platform_bus);</span><br><span class="line">    of_platform_register_reconfig_notifier();</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先来看<code>earlt_platform_cleanup()</code>这个函数，位于<code>arch/sh/drivers/platform_early.c</code>中，这个函数主要的功能就是清空<code>sh_early_platform_device_list)</code>这个链表，然后向内核注册<code>platform_bus</code>这个设备和<code>platform_bus_type</code>总线</p>
<h4 id="Platform驱动"><a href="#Platform驱动" class="headerlink" title="Platform驱动"></a>Platform驱动</h4><ul>
<li><p><code>platform_driver</code>结构体表示<code>platform</code>驱动，定义在<code>include/linux/platform.h</code>里面</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> (*probe)(struct platform_device *);</span><br><span class="line">    <span class="keyword">int</span> (*remove)(struct platform_device *);</span><br><span class="line">    <span class="keyword">void</span> (*shutdown)(struct platform_device *);</span><br><span class="line">    <span class="keyword">int</span> (*suspend)(struct platform_device *, <span class="keyword">pm_message_t</span> state);</span><br><span class="line">    <span class="keyword">int</span> (*resume)(struct platform_device *);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_driver</span> <span class="title">driver</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_device_id</span> *<span class="title">id_table</span>;</span></span><br><span class="line">    <span class="keyword">bool</span> prevent_deferred_probe;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>  当驱动和设备匹配成功后<code>platform_driver</code>的<code>probe</code>函数就会执行，<code>driver</code>成员为<code>device_driver</code>结构体变量，<code>device_driver</code>相当于基类，提供了最基础的驱动框架，<code>platform_driver</code>相当于继承了这个基类，在这个基类基础上添加了一些特有的成员变量</p>
</li>
<li><p><code>device_driver</code>结构体定义在*<code>include/linux/device.h</code>，内容如下</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_driver</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>		*name;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span>		*<span class="title">bus</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span>		*<span class="title">owner</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>		*mod_name;	<span class="comment">/* used for built-in modules */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> suppress_bind_attrs;	<span class="comment">/* disables bind/unbind via sysfs */</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">probe_type</span> <span class="title">probe_type</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span>	*<span class="title">of_match_table</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">acpi_device_id</span>	*<span class="title">acpi_match_table</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> (*probe) (struct device *dev);</span><br><span class="line">    <span class="keyword">int</span> (*remove) (struct device *dev);</span><br><span class="line">    <span class="keyword">void</span> (*shutdown) (struct device *dev);</span><br><span class="line">    <span class="keyword">int</span> (*suspend) (struct device *dev, <span class="keyword">pm_message_t</span> state);</span><br><span class="line">    <span class="keyword">int</span> (*resume) (struct device *dev);</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> **<span class="title">groups</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dev_pm_ops</span> *<span class="title">pm</span>;</span></span><br><span class="line">    <span class="keyword">void</span> (*coredump) (struct device *dev);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">driver_private</span> *<span class="title">p</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在编写<code>platform</code>驱动的时候，首先需要定义一个<code>platform_driver</code>结构体变量，实现结构体中的成员变量，重点是实现匹配方法和<code>probe</code>函数，具体的驱动程序在<code>probe</code>里面编写</p>
</li>
<li><p>定义好<code>platform_driver</code>结构体变量以后，需要在驱动入口函数里面调用<code>platform_driver_register()</code>函数向内核注册一个platform驱动，         <code>platform_driver_register()</code>函数的原型如下：<br><code>int platform_driver_register(struct platform_driver *driver)</code><br>还需要在驱动卸载函数中通过<code>platform_driver_unregister()</code>来卸载platform驱动，函数原型如下：<br><code>int platform_driver_unregister(struct platform_driver *driver)</code></p>
</li>
</ul>
<h4 id="Platform设备"><a href="#Platform设备" class="headerlink" title="Platform设备"></a>Platform设备</h4><ul>
<li><p><code>platform_device</code>结构体表示<code>platfrom</code>设备，如果内核支持设备树的话，就不需要使用<code>platform_device</code>来描述设备，改用设备树来描述，<code>platform_device</code>结构体定义在<em>include&#x2F;linux&#x2F;platform_device.h</em>中，结构体的内容如下：</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>	*name;</span><br><span class="line">    <span class="keyword">int</span>		id;</span><br><span class="line">    <span class="keyword">bool</span>		id_auto;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span>	<span class="title">dev</span>;</span></span><br><span class="line">    u32		num_resources;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">resource</span>	*<span class="title">resource</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_device_id</span>	*<span class="title">id_entry</span>;</span></span><br><span class="line">    <span class="keyword">char</span> *driver_override; <span class="comment">/* Driver name to force a match */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* MFD cell pointer */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mfd_cell</span> *<span class="title">mfd_cell</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* arch specific additions */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pdev_archdata</span>	<span class="title">archdata</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>name</code>表示设备的名字，要和所使用的<code>platform_driver</code>的<code>name</code>字段相同，否则设备无法匹配到对应的驱动</li>
<li><code>resource</code>表示资源，一般用来表示设备的寄存器信息，结构体内容如下  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">resource</span> &#123;</span></span><br><span class="line">    <span class="keyword">resource_size_t</span> start;</span><br><span class="line">    <span class="keyword">resource_size_t</span> end;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> desc;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">parent</span>, *<span class="title">sibling</span>, *<span class="title">child</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
  <code>start</code>和<code>end</code>分别表示资源的起始和终止信息，对于内存类资源就表示内存起始和终止地址，<code>name</code>表示资源名称，<code>flag</code>表示资源类型</li>
</ul>
</li>
<li><p>Linux支持设备树之后就不需要用户去手动注册<code>platform</code>设备了，因为设备信息都放到设备树中去描述，Linux内核启动的时候会从设备树中读取设备信息，然后将其组织成<code>platform_device</code>形式</p>
</li>
</ul>
<h4 id="Platform驱动匹配过程"><a href="#Platform驱动匹配过程" class="headerlink" title="Platform驱动匹配过程"></a>Platform驱动匹配过程</h4><ul>
<li><p>这里使用phytium i2c适配器驱动分析，驱动文件位于<code>drivers/i2c/busses/i2c-phytium-platform.c</code>，在<code>module_platform_driver(phytium_i2c_driver)</code>进行<code>platform_drvier</code>的注册，<code>module_platform_driver</code>是一个宏定义，该宏定义定义在<code>include/linux/platform_device.h</code>其内容如下：</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> module_platform_driver(__platform_drvier) module_driver(__platform_drvier, platform_drvier_register, platform_drvier_unregister)</span></span><br></pre></td></tr></table></figure>
<p>  继续对<em>module_driver</em>宏进行展开，其内容如下：  </p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> module_driver(__driver, __register, __unregister, ...) \</span></span><br><span class="line"><span class="meta">static int __init __driver##_init(void) \</span></span><br><span class="line"><span class="meta">&#123; \</span></span><br><span class="line"><span class="meta">    return __register(&amp;(__driver) , ##__VA_ARGS__); \</span></span><br><span class="line"><span class="meta">&#125; \</span></span><br><span class="line"><span class="meta">module_init(__driver##_init); \</span></span><br><span class="line"><span class="meta">static void __exit __driver##_exit(void) \</span></span><br><span class="line"><span class="meta">&#123; \</span></span><br><span class="line"><span class="meta">    __unregister(&amp;(__driver) , ##__VA_ARGS__); \</span></span><br><span class="line"><span class="meta">&#125; \</span></span><br><span class="line"><span class="meta">module_exit(__driver##_exit);</span></span><br></pre></td></tr></table></figure>
<p>  最终展开后的内容相当于：</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">phytium_i2c_driver_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> platform_driver_register(&amp;(phytium_i2c_driver));</span><br><span class="line">&#125;</span><br><span class="line">module_init(phytium_i2c_driver_init);</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __exit <span class="title">phytium_i2c_driver_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> platform_driver_unregister(&amp;(phytium_i2c_driver));</span><br><span class="line">&#125;</span><br><span class="line">moudle_exit(phytium_i2c_driver_exit);</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>moudle_init</code>中调用了<code>platform_drvier_register(&amp;phytium_i2c_driver)</code>，<code>platform_driver_regsiter</code>又是一个宏定义，定义在<code>include/linux/platform_device.h</code>中，其内容如下：<br><code>#define platform_driver_regsiter(drv) __platform_drvier_register(drv, THIS_MODULE)</code><br>其中<code>__platform_drvier_register()</code>函数的定义如下：  </p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> __platform_drvier_register(struct platform_deriver *drv, struct <span class="keyword">module</span> *owner)`</span><br><span class="line">&#123;</span><br><span class="line">    drv-&gt;driver.owner = owner;</span><br><span class="line">    drv-&gt;driver.bus = &amp;platform_bus_type;</span><br><span class="line">    drv-&gt;driver.probe = platform_drv_porbe;</span><br><span class="line">    drv-&gt;driver.remove = platform_drv_remove;</span><br><span class="line">    drv-&gt;driver.shutdown = platform_drv_shutdown;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> driver_register(&amp;drv-&gt;driver);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  其中<code>driver</code>成员的类型为之前提到的<code>device_driver</code>结构体，<code>driver-&gt;bus</code>指向了<code>platform_bus_type</code></p>
</li>
<li><p>继续来看<code>driver_register(&amp;drv-&gt;driver)</code>，该函数位于<code>driver/base/driver.c</code>中，其内容如下</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">driver_register</span><span class="params">(struct device_driver *drv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_driver</span> *<span class="title">other</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!drv-&gt;bus-&gt;p) &#123;</span><br><span class="line">        pr_err(<span class="string">&quot;Driver &#x27;%s&#x27; was unable to register with bus_type &#x27;%s&#x27; because the bus was not initialized.\n&quot;</span>,</span><br><span class="line">            drv-&gt;name, drv-&gt;bus-&gt;name);</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 检测总线的操作函数和驱动的操作函数是否都已经定义好 */</span></span><br><span class="line">    <span class="keyword">if</span> ((drv-&gt;bus-&gt;probe &amp;&amp; drv-&gt;probe) ||</span><br><span class="line">        (drv-&gt;bus-&gt;remove &amp;&amp; drv-&gt;remove) ||</span><br><span class="line">        (drv-&gt;bus-&gt;shutdown &amp;&amp; drv-&gt;shutdown))</span><br><span class="line">        printk(KERN_WARNING <span class="string">&quot;Driver &#x27;%s&#x27; needs updating - please use &quot;</span></span><br><span class="line">            <span class="string">&quot;bus_type methods\n&quot;</span>, drv-&gt;name);</span><br><span class="line"></span><br><span class="line">    other = driver_find(drv-&gt;name, drv-&gt;bus);</span><br><span class="line">    <span class="keyword">if</span> (other) &#123;</span><br><span class="line">        printk(KERN_ERR <span class="string">&quot;Error: Driver &#x27;%s&#x27; is already registered, &quot;</span></span><br><span class="line">            <span class="string">&quot;aborting...\n&quot;</span>, drv-&gt;name);</span><br><span class="line">        <span class="keyword">return</span> -EBUSY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = bus_add_driver(drv);</span><br><span class="line">    <span class="keyword">if</span> (ret)</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    ret = driver_add_groups(drv, drv-&gt;groups);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        bus_remove_driver(drv);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    kobject_uevent(&amp;drv-&gt;p-&gt;kobj, KOBJ_ADD);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  <code>driver_register()</code>中调用了<code>bus_add_driver(drv)</code>，该函数位于<code>driver/base/bus.c</code>中，<code>bus_add_driver()</code>源码如下：</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * bus_add_driver - Add a driver to the bus.</span></span><br><span class="line"><span class="comment"> * @drv: driver.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bus_add_driver</span><span class="params">(struct device_driver *drv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> *<span class="title">bus</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">driver_private</span> *<span class="title">priv</span>;</span></span><br><span class="line">	<span class="keyword">int</span> error = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	bus = bus_get(drv-&gt;bus);</span><br><span class="line">	<span class="keyword">if</span> (!bus)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	pr_debug(<span class="string">&quot;bus: &#x27;%s&#x27;: add driver %s\n&quot;</span>, bus-&gt;name, drv-&gt;name);</span><br><span class="line"></span><br><span class="line">	priv = kzalloc(<span class="keyword">sizeof</span>(*priv), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!priv) &#123;</span><br><span class="line">		error = -ENOMEM;</span><br><span class="line">		<span class="keyword">goto</span> out_put_bus;</span><br><span class="line">	&#125;</span><br><span class="line">	klist_init(&amp;priv-&gt;klist_devices, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">	priv-&gt;driver = drv;</span><br><span class="line">	drv-&gt;p = priv;</span><br><span class="line">	priv-&gt;kobj.kset = bus-&gt;p-&gt;drivers_kset;</span><br><span class="line">	error = kobject_init_and_add(&amp;priv-&gt;kobj, &amp;driver_ktype, <span class="literal">NULL</span>,</span><br><span class="line">				     <span class="string">&quot;%s&quot;</span>, drv-&gt;name);</span><br><span class="line">	<span class="keyword">if</span> (error)</span><br><span class="line">		<span class="keyword">goto</span> out_unregister;</span><br><span class="line"></span><br><span class="line">	klist_add_tail(&amp;priv-&gt;knode_bus, &amp;bus-&gt;p-&gt;klist_drivers);</span><br><span class="line">	<span class="keyword">if</span> (drv-&gt;bus-&gt;p-&gt;drivers_autoprobe) &#123;</span><br><span class="line">		error = driver_attach(drv);</span><br><span class="line">		<span class="keyword">if</span> (error)</span><br><span class="line">			<span class="keyword">goto</span> out_unregister;</span><br><span class="line">	&#125;</span><br><span class="line">	module_add_driver(drv-&gt;owner, drv);</span><br><span class="line"></span><br><span class="line">	error = driver_create_file(drv, &amp;driver_attr_uevent);</span><br><span class="line">	<span class="keyword">if</span> (error) &#123;</span><br><span class="line">		printk(KERN_ERR <span class="string">&quot;%s: uevent attr (%s) failed\n&quot;</span>,</span><br><span class="line">			__func__, drv-&gt;name);</span><br><span class="line">	&#125;</span><br><span class="line">	error = driver_add_groups(drv, bus-&gt;drv_groups);</span><br><span class="line">	<span class="keyword">if</span> (error) &#123;</span><br><span class="line">		<span class="comment">/* How the hell do we get out of this pickle? Give up */</span></span><br><span class="line">		printk(KERN_ERR <span class="string">&quot;%s: driver_create_groups(%s) failed\n&quot;</span>,</span><br><span class="line">			__func__, drv-&gt;name);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!drv-&gt;suppress_bind_attrs) &#123;</span><br><span class="line">		error = add_bind_files(drv);</span><br><span class="line">		<span class="keyword">if</span> (error) &#123;</span><br><span class="line">			<span class="comment">/* Ditto */</span></span><br><span class="line">			printk(KERN_ERR <span class="string">&quot;%s: add_bind_files(%s) failed\n&quot;</span>,</span><br><span class="line">				__func__, drv-&gt;name);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">out_unregister:</span><br><span class="line">	kobject_put(&amp;priv-&gt;kobj);</span><br><span class="line">	<span class="comment">/* drv-&gt;p is freed in driver_release()  */</span></span><br><span class="line">	drv-&gt;p = <span class="literal">NULL</span>;</span><br><span class="line">out_put_bus:</span><br><span class="line">	bus_put(bus);</span><br><span class="line">	<span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Platform</tag>
      </tags>
  </entry>
  <entry>
    <title>phytium i2c适配器驱动</title>
    <url>/archives/1dd4e6b7.html</url>
    <content><![CDATA[<h4 id="I2C总线驱动"><a href="#I2C总线驱动" class="headerlink" title="I2C总线驱动"></a>I2C总线驱动</h4><ul>
<li><p>I2C总线驱动重点是I2C适配器（也就是SOC的I2C接口）控制器驱动，这里涉及到两个重要的数据结构：i2c_adapter和i2c_algorithm，Linux内核将SOC的I2C控制器抽象成i2c_adapter，i2c_adapter定义在include&#x2F;linux&#x2F;i2c.h中，结构体的内容如下：</p>
<span id="more"></span>
  <figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="type">i2c_adapter</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="type">module</span> *owner;</span><br><span class="line">    unsigned int class;		  <span class="comment">/* classes to allow probing for */</span></span><br><span class="line">    const <span class="keyword">struct</span> <span class="type">i2c_algorithm</span> *algo; <span class="comment">/* the algorithm to access the bus */</span></span><br><span class="line">    void *algo_data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* data fields that are valid for all devices	*/</span></span><br><span class="line">    const <span class="keyword">struct</span> <span class="type">i2c_lock_operations</span> *lock_ops;</span><br><span class="line">    <span class="keyword">struct</span> <span class="type">rt_mutex</span> bus_lock;</span><br><span class="line">    <span class="keyword">struct</span> <span class="type">rt_mutex</span> mux_lock;</span><br><span class="line"></span><br><span class="line">    int timeout;			<span class="comment">/* in jiffies */</span></span><br><span class="line">    int retries;</span><br><span class="line">    <span class="keyword">struct</span> <span class="type">device</span> dev;		<span class="comment">/* the adapter device */</span></span><br><span class="line"></span><br><span class="line">    int nr;</span><br><span class="line">    char name[<span class="number">48</span>];</span><br><span class="line">    <span class="keyword">struct</span> <span class="type">completion</span> dev_released;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="type">mutex</span> userspace_clients_lock;</span><br><span class="line">    <span class="keyword">struct</span> <span class="type">list_head</span> userspace_clients;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="type">i2c_bus_recovery_info</span> *bus_recovery_info;</span><br><span class="line">    const <span class="keyword">struct</span> <span class="type">i2c_adapter_quirks</span> *quirks;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="type">irq_domain</span> *host_notify_domain;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>  其中algo成员为i2c适配器对外提供的API读写操作函数，i2c_algorithm为I2C适配器和I2C设备通信的方法，i2c_algorithm结构体的内容如下：</p>
  <figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> i2c_algorithm &#123;</span><br><span class="line">    <span class="comment">/* If an adapter algorithm can&#x27;t do I2C-level access, set master_xfer</span></span><br><span class="line"><span class="comment">       to NULL. If an adapter algorithm can do SMBus access, set</span></span><br><span class="line"><span class="comment">       smbus_xfer. If set to NULL, the SMBus protocol is simulated</span></span><br><span class="line"><span class="comment">       using common I2C messages */</span></span><br><span class="line">    <span class="comment">/* master_xfer should return the number of messages successfully</span></span><br><span class="line"><span class="comment">       processed, or a negative value on error */</span></span><br><span class="line">    <span class="keyword">int</span> (*master_xfer)(<span class="keyword">struct</span> i2c_adapter *adap, <span class="keyword">struct</span> i2c_msg *msgs,</span><br><span class="line">               <span class="keyword">int</span> num);</span><br><span class="line">    <span class="keyword">int</span> (*smbus_xfer) (<span class="keyword">struct</span> i2c_adapter *adap, u16 addr,</span><br><span class="line">               <span class="keyword">unsigned</span> <span class="keyword">short</span> flags, <span class="keyword">char</span> read_write,</span><br><span class="line">               u8 command, <span class="keyword">int</span> size, <span class="keyword">union</span> i2c_smbus_data *data);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* To determine what the adapter supports */</span></span><br><span class="line">    u32 (*functionality) (<span class="keyword">struct</span> i2c_adapter *);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> IS_ENABLED(CONFIG_I2C_SLAVE)</span></span><br><span class="line">    <span class="keyword">int</span> (*reg_slave)(<span class="keyword">struct</span> i2c_client *client);</span><br><span class="line">    <span class="keyword">int</span> (*unreg_slave)(<span class="keyword">struct</span> i2c_client *client);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>master_xfer是I2C适配器的的传输函数</li>
<li>smbus_xfer是SMBUS总线的传输函数</li>
</ul>
</li>
<li><p>I2C适配器驱动的主要工作就是初始化i2c_adapter的结构体变量，然后实现i2c_algorithm中的传输函数，完成后通过<em>i2c_add_numbered_adapter</em>或者<em>i2c_add_adapter</em>这两个函数向系统注册设置好的i2c_adapter，函数原型如下：<br><code>int i2c_add_adapter(struct i2c_adapter *adapter)</code><br><code>int i2c_add_numbered_adapter(struct i2c_adapter *adap)</code><br>i2c_add_adapter()使用动态的总线号，i2c_add_numbered_adapter()使用静态的总线号</p>
</li>
</ul>
<h4 id="phytium-i2c适配器驱动分析"><a href="#phytium-i2c适配器驱动分析" class="headerlink" title="phytium i2c适配器驱动分析"></a>phytium i2c适配器驱动分析</h4><ul>
<li><p>phytium i2c设备树节点内容</p>
  <figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="symbol">mio14:</span> <span class="class">i2c@28030000 </span>&#123;</span><br><span class="line">    compatible = <span class="string">&quot;phytium,i2c&quot;</span>;</span><br><span class="line">    reg = <span class="params">&lt;<span class="number">0x0</span> <span class="number">0x28030000</span> <span class="number">0x0</span> <span class="number">0x1000</span>&gt;</span>;</span><br><span class="line">    interrupts = <span class="params">&lt;GIC_SPI <span class="number">106</span> IRQ_TYPE_LEVEL_HIGH&gt;</span>;</span><br><span class="line">    clocks = <span class="params">&lt;<span class="variable">&amp;sysclk_50mhz</span>&gt;</span>;</span><br><span class="line">    <span class="meta">#address-cells = &lt;1&gt;;</span></span><br><span class="line">    <span class="meta">#size-cells = &lt;0&gt;;</span></span><br><span class="line">    status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>  对应的驱动文件为<em>drivers&#x2F;i2c&#x2F;busses&#x2F;i2c-phytium-platform.c</em></p>
</li>
<li><p>phytium i2c适配器驱动为一个标准的platform驱动</p>
  <figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">static struct platform_driver <span class="attr">phytium_i2c_driver</span> = &#123;</span><br><span class="line">    .<span class="attr">probe</span> = phytium_i2c_plat_probe,</span><br><span class="line">    .<span class="attr">remove</span> = phytium_i2c_plat_remove,</span><br><span class="line">    .<span class="attr">driver</span> = &#123;</span><br><span class="line">        .<span class="attr">name</span> = DRV_NAME,</span><br><span class="line">        .<span class="attr">of_match_table</span> = of_match_ptr(phytium_i2c_of_match),</span><br><span class="line">        .<span class="attr">acpi_match_table</span> = ACPI_PTR(phytium_i2c_acpi_match),</span><br><span class="line">        .<span class="attr">pm</span> = &amp;phytium_i2c_dev_pm_ops,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<em>of_device_id</em>与设备树mio14节点相匹配，在platform_match函数中进行匹配</p>
  <figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">static const <span class="keyword">struct</span> of_device_id phytium_i2c_of_match<span class="literal">[]</span> = &#123;</span><br><span class="line">    &#123; .compatible = <span class="string">&quot;phytium,i2c&quot;</span>, &#125;,</span><br><span class="line">    &#123;   &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="constructor">MODULE_DEVICE_TABLE(<span class="params">of</span>, <span class="params">phytium_i2c_of_match</span>)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>当设备和驱动匹配完成后，<em>phytium_i2c_plat_probe</em>函数就会执行，完成i2c适配器的初始化工作，probe中的工作如下：</p>
<ul>
<li>调用platform_get_irq()函数获取中断号</li>
<li>调用platform_get_resource()函数获取I2C控制器的寄存器物理基地址，获取到物理基地址后再使用devm_ioremap_resource()函数对其进行内存映射，得到可以在Linux内核中使用的虚拟内存地址</li>
<li>设置I2C设备总线速度</li>
<li>根据I2C地址第30位数据来判断当前I2C适配器配置成slave模式还是master模式，填充phytium_i2c_dev数据成员，主要设计适配器工作能力等一些参数标志</li>
<li>使能I2C总线时钟</li>
<li>调用i2c_phytium_probe()函数，该函数位于drivers&#x2F;i2c&#x2F;busses&#x2F;i2c-phytium-master.c，在i2c_phytium_probe()里面继续完善adapter数据成员</li>
</ul>
</li>
<li><p>phytium_i2c_dev结构体</p>
  <figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">struct phytium_i2c_dev &#123;</span><br><span class="line">    struct device		*dev<span class="comment">;</span></span><br><span class="line">    void __iomem		*base<span class="comment">;</span></span><br><span class="line">    int			irq<span class="comment">;</span></span><br><span class="line">    u32			flags<span class="comment">;</span></span><br><span class="line">    struct completion	cmd_complete<span class="comment">;</span></span><br><span class="line">    struct clk		*clk<span class="comment">;</span></span><br><span class="line">    struct reset_control	*rst<span class="comment">;</span></span><br><span class="line">    int			mode<span class="comment">;</span></span><br><span class="line">    struct i2c_client	*slave<span class="comment">;</span></span><br><span class="line">    u32			(*get_clk_rate_khz)(struct phytium_i2c_dev *dev)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    struct i2c_adapter	adapter<span class="comment">;</span></span><br><span class="line">    struct i2c_client	*ara<span class="comment">;</span></span><br><span class="line">    struct i2c_smbus_alert_setup alert_data<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    struct phytium_pci_i2c *controller<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    unsigned int		status<span class="comment">;</span></span><br><span class="line">    int			cmd_err<span class="comment">;</span></span><br><span class="line">    u32			abort_source<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    struct i2c_msg		*msgs<span class="comment">;</span></span><br><span class="line">    int			msgs_num<span class="comment">;</span></span><br><span class="line">    int			msg_write_idx<span class="comment">;</span></span><br><span class="line">    int			msg_read_idx<span class="comment">;</span></span><br><span class="line">    int			msg_err<span class="comment">;</span></span><br><span class="line">    u32			tx_buf_len<span class="comment">;</span></span><br><span class="line">    u8			*tx_buf<span class="comment">;</span></span><br><span class="line">    u32			rx_buf_len<span class="comment">;</span></span><br><span class="line">    u8			*rx_buf<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    u32			master_cfg<span class="comment">;</span></span><br><span class="line">    u32			slave_cfg<span class="comment">;</span></span><br><span class="line">    u32			functionality<span class="comment">;</span></span><br><span class="line">    unsigned int		tx_fifo_depth<span class="comment">;</span></span><br><span class="line">    unsigned int		rx_fifo_depth<span class="comment">;</span></span><br><span class="line">    int			rx_outstanding<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    struct i2c_timings	timings<span class="comment">;</span></span><br><span class="line">    u32			sda_hold_time<span class="comment">;</span></span><br><span class="line">    u16			ss_hcnt<span class="comment">;</span></span><br><span class="line">    u16			ss_lcnt<span class="comment">;</span></span><br><span class="line">    u16			fs_hcnt<span class="comment">;</span></span><br><span class="line">    u16			fs_lcnt<span class="comment">;</span></span><br><span class="line">    u16			fp_hcnt<span class="comment">;</span></span><br><span class="line">    u16			fp_lcnt<span class="comment">;</span></span><br><span class="line">    u16			hs_hcnt<span class="comment">;</span></span><br><span class="line">    u16			hs_lcnt<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    bool			pm_disabled<span class="comment">;</span></span><br><span class="line">    void			(*disable)(struct phytium_i2c_dev *dev)<span class="comment">;</span></span><br><span class="line">    void			(*disable_int)(struct phytium_i2c_dev *dev)<span class="comment">;</span></span><br><span class="line">    int			(*init)(struct phytium_i2c_dev *dev)<span class="comment">;</span></span><br><span class="line">&#125;<span class="comment">;</span></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>I2C</tag>
      </tags>
  </entry>
  <entry>
    <title>ASoC Platform Driver</title>
    <url>/archives/131a876a.html</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>ALSA是Advanced Linux Sound Architecture的缩写，<a href="https://www.alsa-project.org/">ALSA官网地址</a>  </p>
<span id="more"></span>

<p>ALSA作为Linux现在主流的音频体系架构，提供了内核的驱动框架，也提供了应用层的<br><code>alsa-lib</code>库，ALSA还提供了<code>alsa-utils</code>应用程序，方便进行音频控制</p>
<ul>
<li>音频设备文件结构如下<br><img src="https://raw.githubusercontent.com/JackHuang021/images/master/20221108112754.png"><ul>
<li>controlC0: 用于card0声卡的控制</li>
<li>pcmC0D0c: 用于card0 device0录音的pcm设备</li>
<li>pcmC0D0p: 用于card0 device0播放的pcm设备</li>
<li>timer: 定时器</li>
</ul>
</li>
<li>一个声卡可以有多个设备，一个设备可以有多个播放\录音通道，每个设备节点都对应一个fops，</li>
</ul>
<h3 id="ASoC驱动框架"><a href="#ASoC驱动框架" class="headerlink" title="ASoC驱动框架"></a>ASoC驱动框架</h3><ul>
<li><p>ASoC是建立在标准ALSA驱动层上，对底层的ALSA框架封装了一层，为了更好的支持嵌入式CPU和音频编解码设备的一套软件体系，ASoC驱动主要由Platform驱动、Codec驱动、Machine驱动组成。</p>
</li>
<li><p>CPU DAI：在嵌入式系统中通常指CPU的I2S或PCM总线控制器</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Digital Audio Interface Driver.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* Describes the Digital Audio Interface in terms of its ALSA, DAI and AC97</span></span><br><span class="line"><span class="comment">* operations and capabilities. Codec and platform drivers will register this</span></span><br><span class="line"><span class="comment">* structure for every DAI they have.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* This structure covers the clocking, formating and ALSA operations for each</span></span><br><span class="line"><span class="comment">* interface.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dai_driver</span> &#123;</span></span><br><span class="line">    <span class="comment">/* DAI description */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> id;                </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> base;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dobj</span> <span class="title">dobj</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* DAI driver callbacks */</span></span><br><span class="line">    <span class="keyword">int</span> (*probe)(struct snd_soc_dai *dai);</span><br><span class="line">    <span class="keyword">int</span> (*remove)(struct snd_soc_dai *dai);</span><br><span class="line">    <span class="keyword">int</span> (*suspend)(struct snd_soc_dai *dai);</span><br><span class="line">    <span class="keyword">int</span> (*resume)(struct snd_soc_dai *dai);</span><br><span class="line">    <span class="comment">/* compress dai */</span></span><br><span class="line">    <span class="keyword">int</span> (*compress_new)(struct snd_soc_pcm_runtime *rtd, <span class="keyword">int</span> num);</span><br><span class="line">    <span class="comment">/* Optional Callback used at pcm creation*/</span></span><br><span class="line">    <span class="keyword">int</span> (*pcm_new)(struct snd_soc_pcm_runtime *rtd,</span><br><span class="line">            struct snd_soc_dai *dai);</span><br><span class="line">    <span class="comment">/* DAI is also used for the control bus */</span></span><br><span class="line">    <span class="keyword">bool</span> bus_control;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ops */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dai_ops</span> *<span class="title">ops</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_cdai_ops</span> *<span class="title">cops</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* DAI capabilities */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_pcm_stream</span> <span class="title">capture</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_pcm_stream</span> <span class="title">playback</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> symmetric_rates:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> symmetric_channels:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> symmetric_samplebits:<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* probe ordering - for components with runtime dependencies */</span></span><br><span class="line">    <span class="keyword">int</span> probe_order;</span><br><span class="line">    <span class="keyword">int</span> remove_order;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>ASoC</tag>
      </tags>
  </entry>
  <entry>
    <title>phytium E2000搭建aarch64虚拟机</title>
    <url>/archives/4ed0329a.html</url>
    <content><![CDATA[<blockquote>
<p>最近需要在E2000平台上测试虚拟化功能，需要搭建一个arm64虚拟机用于测试，记录一下搭建过程</p>
</blockquote>
<h3 id="系统环境"><a href="#系统环境" class="headerlink" title="系统环境"></a>系统环境</h3><ul>
<li>E2000Q CPU，Linux内核版本4.19.246，Ubuntu 20.04</li>
<li>清华软件源</li>
<li>交叉编译工具，<code>gcc-linaro-7.5.0-2019.12-x86_64_aarch64-linux-gnu</code><span id="more"></span></li>
</ul>
<h3 id="qemu安装"><a href="#qemu安装" class="headerlink" title="qemu安装"></a>qemu安装</h3><ul>
<li>安装qemu，<code>apt-get install qemu-system-arm</code></li>
<li>安装aarch64 uefi固件，<code>apt-get install qemu-efi-aarch64</code></li>
</ul>
<h3 id="根文件系统制作"><a href="#根文件系统制作" class="headerlink" title="根文件系统制作"></a>根文件系统制作</h3><ul>
<li><p>下载BusyBox源码，<a href="https://busybox.net/downloads/">官网下载地址</a>，这里下载<code>1.33.1</code>版本</p>
</li>
<li><p>解压源码，进入源码目录，进行编译</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -xvf busybox-1.33.1.tar.bz2</span><br><span class="line"><span class="built_in">cd</span> busybox-1.33.1</span><br><span class="line"><span class="built_in">export</span> ARCH=arm64</span><br><span class="line"><span class="built_in">export</span> CROSS_COMPILE=aarch64-linux-gnu-</span><br><span class="line">make menuconfig</span><br></pre></td></tr></table></figure>
<p>  选择静态编译<br>  <img src="https://raw.githubusercontent.com/JackHuang021/images/master/20221107093137.png"></p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make -j12</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<p>  编译完成后，源码目录<code>_install</code>下会生成根文件系统</p>
</li>
<li><p>完善根文件系统</p>
<ul>
<li>创建其他目录<code>mkdir dev etc lib</code></li>
<li>创建<code>/etc/profile</code>文件  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">export</span> HOSTNAME=linux</span><br><span class="line"><span class="built_in">export</span> USER=root</span><br><span class="line"><span class="built_in">export</span> HOME=/home</span><br><span class="line"><span class="built_in">export</span> PS1=<span class="string">&quot;[<span class="variable">$USER</span>@<span class="variable">$HOSTNAME</span> \W]\# &quot;</span></span><br><span class="line">PATH=/bin:/sbin:/usr/bin:/usr/sbin</span><br><span class="line">LD_LIBRARY_PATH=/lib:/usr/lib:<span class="variable">$LD_LIBRARY_PATH</span></span><br><span class="line"><span class="built_in">export</span> PATH LD_LIBRARY_PATH</span><br></pre></td></tr></table></figure></li>
<li>创建<code>/etc/inittab</code>文件  <figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="meta">::sysinit:/etc/init.d/rcS</span></span><br><span class="line"><span class="meta">::respawn:-/bin/sh</span></span><br><span class="line"><span class="meta">::askfirst:-/bin/sh</span></span><br><span class="line"><span class="meta">::ctrlaltdel:/bin/umount</span> -a -r</span><br></pre></td></tr></table></figure></li>
<li>创建<code>/etc/init.d/rcS</code>文件  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir -p /sys</span><br><span class="line">mkdir -p /tmp</span><br><span class="line">mkdir -p /proc</span><br><span class="line">mkdir -p /mnt</span><br><span class="line">/bin/mount -a</span><br><span class="line">mkdir -p /dev/pts</span><br><span class="line">mount -t devpts devpts /dev/pts</span><br><span class="line"><span class="built_in">echo</span> /sbin/mdev &gt; /proc/sys/kernel/hotplug</span><br><span class="line">mdev -s</span><br></pre></td></tr></table></figure></li>
<li>制作<code>/dev</code>目录下必要的文件，<code>sudo mknod console c 5 1</code></li>
</ul>
</li>
<li><p>编译内核</p>
<ul>
<li>Linux源码下载地址，<a href="https://mirrors.edge.kernel.org/pub/linux/kernel/">官网下载地址</a></li>
<li>这里下载<code>4.19.262</code>版本，解压内核源码，将之前生成的根文件目录到内核源码目录  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -xvf linux-4.19.262.tar.xz</span><br><span class="line"><span class="built_in">cd</span> linux-4.19.246</span><br><span class="line">cp -a ../busybox-1.33.1/_install  rootfs -a</span><br><span class="line"><span class="built_in">export</span> ARCH=arm64</span><br><span class="line"><span class="built_in">export</span> CROSS_COMPILE=aarch64-linux-gnu-</span><br><span class="line">make defconfig</span><br><span class="line">make menucofig</span><br></pre></td></tr></table></figure>
  设置Initramfs支持<br>  <img src="https://raw.githubusercontent.com/JackHuang021/images/master/20221107112153.png">  <figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">make</span> <span class="literal">all</span> -j<span class="number">12</span></span><br></pre></td></tr></table></figure></li>
<li>将<code>arch/arm64/boot/Image</code>拷贝到E2000开发板上</li>
</ul>
</li>
</ul>
<h3 id="Qemu启动虚拟机"><a href="#Qemu启动虚拟机" class="headerlink" title="Qemu启动虚拟机"></a>Qemu启动虚拟机</h3><pre><code><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">   qemu-system-aarch64 \</span><br><span class="line">-enable-kvm \</span><br><span class="line">-m 2048 \</span><br><span class="line">-smp 4 \</span><br><span class="line">-cpu host \</span><br><span class="line">-M virt,gic-version=3 \</span><br><span class="line">-kernel Image \</span><br><span class="line">-append <span class="string">&quot;rdinit=/linuxrc console=ttyAMA0 loglevel=8&quot;</span> \</span><br><span class="line">-net none \</span><br><span class="line">-nographic </span><br></pre></td></tr></table></figure>
</code></pre>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>qemu</tag>
        <tag>虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title>rootfs</title>
    <url>/archives/265c268b.html</url>
    <content><![CDATA[<h3 id="根文件系统简介"><a href="#根文件系统简介" class="headerlink" title="根文件系统简介"></a>根文件系统简介</h3><ul>
<li>根文件系统一般也叫做rootfs，Linux中的根文件系统就像是一个文件夹，这个文件夹内包含很多子目录，这些目录中会有很多文件，这些文件是Linux运行所必须的，比如库、常用的软件和命令、设备文件、配置文件等，根文件系统是Linux内核启动以后挂载的第一个文件系统，然后从根文件系统中读取初始化脚本，比如rcS、inittab等，根文件系统和Linux内核是分开的，单独的Linux内核无法正常工作，必须搭配根文件系统。<span id="more"></span></li>
</ul>
<h4 id="根文件系统子目录"><a href="#根文件系统子目录" class="headerlink" title="根文件系统子目录"></a>根文件系统子目录</h4><ul>
<li><p>&#x2F;bin目录：该目录下存放着系统需要的可执行文件，一般都是一些命令，比如ls、mv等，此目录下的所有命令所有用户都能使用</p>
</li>
<li><p>&#x2F;dev目录：dev是device的缩写，此目录下的文件都是和设备相关的，都是设备文件，在Linux下一切皆文件，即使是硬件设备，也是以文件的形式存在，比如说&#x2F;dev&#x2F;ttymxc0就表示串口0，可以通过对文件&#x2F;dev&#x2F;ttymxc0的读写操作来实现串口0的数据收发</p>
</li>
<li><p>&#x2F;etc目录：该目录下存放着各种配置文件，在嵌入式Linux下该目录下文件内容比较少</p>
</li>
<li><p>&#x2F;lib目录：lib是library的简称，也就是库的意思，因此该目录下存放着Linux所必须的库文件，这些库文件是共享库，命令和用户编写的应用程序都需要使用这些库文件</p>
</li>
<li><p>&#x2F;mnt目录：临时挂载目录，一般是空目录，可以在此目录下创建空的子目录，比如&#x2F;mnt&#x2F;sd，&#x2F;mnt&#x2F;usb这样就可以将SD卡或者U盘挂载</p>
</li>
<li><p>&#x2F;porc目录：当Linux系统启动后会将此目录作为proc文件系统的挂载点，proc是个虚拟文件系统，没有实际的存储设备，proc里面的文件都是临时存在的，一般用来存储系统运行信息文件</p>
</li>
<li><p>&#x2F;usr目录：usr的全称是Unix Software Resource，也就是Unix操作系统的软件资源目录，Linux一般被称为类Unix操作系统，&#x2F;usr目录下也存放着很多软件，一般系统安装后此目录占用的空间最多</p>
</li>
<li><p>&#x2F;var目录：此目录存放着一些可以改变的数据</p>
</li>
<li><p>&#x2F;sbin目录：此目录存放着一些可执行文件，但是此目录下的文件或者命令只有管理员才能使用</p>
</li>
<li><p>&#x2F;sys目录：系统启动后此目录作为sysfs文件系统的挂载点，sysfs是一个类似proc文件系统的特殊文件系统，sysfs也是基于ram的文件系统，没有实际的存储设备，此目录是系统设备管理的重要目录，此目录通过一定的组织结构向用户提供详细的内核数据结构信息</p>
</li>
<li><p>&#x2F;opt目录：可选的文件、软件存放区，由用户选择将哪些文件或者软件放到此目录</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>rootfs</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 字符设备驱动开发</title>
    <url>/archives/d281c370.html</url>
    <content><![CDATA[<p>字符设备是Linux驱动中最基本的一类设备驱动，字符设备就是一个一个字节，按照字节流进行读写操作的设备，读写数据是分先后顺序的，这些设备的驱动就叫做字符设备驱动</p>
<span id="more"></span>

<p>应用程序运行在用户空间，Linux驱动属于内核的一部分，因此驱动运行于内核空间，当在用户空间想要实现对内核的操作，比如使用<code>open</code>函数打开<code>/dev/led</code>这个设备，因为用户空间不能直接对内核进行操作，因此必须使用一个叫做“系统调用”的方法来实现从用户空间陷入到内核空间，这样才能实现对底层驱动的操作。</p>
<p>应用程序调用<code>open()</code>函数的流程:<br>应用调用open函数（应用程序） -&gt; C库中的open（）函数 -&gt; open（）系统调用</p>
<p>每一个系统调用在驱动中都有与之对应的一个驱动函数，在Linux内核文件<code>include/linux/fs.h</code>中有一个叫做<code>file_operations</code>的结构体，此结构体就是Linux内核驱动操作函数集合，<br>该结构体内容如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">    <span class="keyword">loff_t</span> (*llseek) (struct file *, <span class="keyword">loff_t</span>, <span class="keyword">int</span>);</span><br><span class="line">    <span class="keyword">ssize_t</span> (*read) (struct file *, <span class="keyword">char</span> __user *, <span class="keyword">size_t</span>, <span class="keyword">loff_t</span> *);</span><br><span class="line">    <span class="keyword">ssize_t</span> (*write) (struct file *, <span class="keyword">const</span> <span class="keyword">char</span> __user *, <span class="keyword">size_t</span>, <span class="keyword">loff_t</span> *);</span><br><span class="line">    <span class="keyword">ssize_t</span> (*read_iter) (struct kiocb *, struct iov_iter *);</span><br><span class="line">    <span class="keyword">ssize_t</span> (*write_iter) (struct kiocb *, struct iov_iter *);</span><br><span class="line">    <span class="keyword">int</span> (*iterate) (struct file *, struct dir_context *);</span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span> <span class="params">(*poll)</span> <span class="params">(struct file *, struct poll_table_struct *)</span></span>;</span><br><span class="line">    <span class="keyword">long</span> (*unlocked_ioctl) (struct file *, <span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>);</span><br><span class="line">    <span class="keyword">long</span> (*compat_ioctl) (struct file *, <span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>);</span><br><span class="line">    <span class="keyword">int</span> (*mmap) (struct file *, struct vm_area_struct *);</span><br><span class="line">    <span class="keyword">int</span> (*mremap)(struct file *, struct vm_area_struct *);</span><br><span class="line">    <span class="keyword">int</span> (*open) (struct inode *, struct file *);</span><br><span class="line">    <span class="keyword">int</span> (*flush) (struct file *, <span class="keyword">fl_owner_t</span> id);</span><br><span class="line">    <span class="keyword">int</span> (*release) (struct inode *, struct file *);</span><br><span class="line">    <span class="keyword">int</span> (*fsync) (struct file *, <span class="keyword">loff_t</span>, <span class="keyword">loff_t</span>, <span class="keyword">int</span> datasync);</span><br><span class="line">    <span class="keyword">int</span> (*aio_fsync) (struct kiocb *, <span class="keyword">int</span> datasync);</span><br><span class="line">    <span class="keyword">int</span> (*fasync) (<span class="keyword">int</span>, struct file *, <span class="keyword">int</span>);</span><br><span class="line">    <span class="keyword">int</span> (*lock) (struct file *, <span class="keyword">int</span>, struct file_lock *);</span><br><span class="line">    <span class="keyword">ssize_t</span> (*sendpage) (struct file *, struct page *, <span class="keyword">int</span>, <span class="keyword">size_t</span>, <span class="keyword">loff_t</span> *, <span class="keyword">int</span>);</span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">long</span> <span class="params">(*get_unmapped_area)</span><span class="params">(struct file *, <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> (*check_flags)(<span class="keyword">int</span>);</span><br><span class="line">    <span class="keyword">int</span> (*flock) (struct file *, <span class="keyword">int</span>, struct file_lock *);</span><br><span class="line">    <span class="keyword">ssize_t</span> (*splice_write)(struct pipe_inode_info *, struct file *, <span class="keyword">loff_t</span> *, <span class="keyword">size_t</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span>);</span><br><span class="line">    <span class="keyword">ssize_t</span> (*splice_read)(struct file *, <span class="keyword">loff_t</span> *, struct pipe_inode_info *, <span class="keyword">size_t</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span>);</span><br><span class="line">    <span class="keyword">int</span> (*setlease)(struct file *, <span class="keyword">long</span>, struct file_lock **, <span class="keyword">void</span> **);</span><br><span class="line">    <span class="keyword">long</span> (*fallocate)(struct file *file, <span class="keyword">int</span> mode, <span class="keyword">loff_t</span> offset,</span><br><span class="line">              <span class="keyword">loff_t</span> len);</span><br><span class="line">    <span class="keyword">void</span> (*show_fdinfo)(struct seq_file *m, struct file *f);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONFIG_MMU</span></span><br><span class="line">    <span class="keyword">unsigned</span> (*mmap_capabilities)(struct file *);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<pre><code>+ `owner`拥有该结构体的模块的指针，一般设置为`THIS_MODULE`  
+ `loff_t (*llseak) (struct file *, loff_t, int)`：该函数用于修改文件当前的读写位置  
+ `ssize_t (*read) (struct file *, char __user *, size_t, loff_t *)`：用于读取设备文件
+ `ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *)`：用于向设备文件写入数据
+ `unsigned int (*poll) (struct file *, struct poll_table_struct *)`：用于查询设备是否可以进行非阻塞的读写
+ `long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long)`：与应用程序中的`ioctl`函数对应
+ `long (*compat_ioctl) (struct file *, unsigned int, unsigned long)`：功能与`unlocked_ioctl()`函数功能一样，区别在于在64位系统上，32位的应用程序调用将会使用此函数，在32位的系统上运行32位的应用程序调用的是`unlocked_ioctl()`
+ `int (*mmap) (struct file *, struct vm_area_struct *)`：用于将设备的内存映射到进程空间（即用户空间），一般帧缓冲设备会使用此函数，比如LCD驱动的显存，将帧缓冲映射到用户空间中以后应用程序就可以直接操作显存了，这样就不用在用户空间和内核空间之间来回复制
+ `int (*open) (struct inode *, struct file *)`、：用于打开设备文件
+ `int (*release) (struct inode *, struct file *)`：用于释放设备文件，与应用程序中的`close()`函数对应
+ `int (*fsync) (int, struct file *, int)`：用于刷新待处理的数据，将缓冲区的数据刷新到磁盘中
</code></pre>
<h4 id="sysfs文件系统目录结构"><a href="#sysfs文件系统目录结构" class="headerlink" title="sysfs文件系统目录结构"></a>sysfs文件系统目录结构</h4><table>
<thead>
<tr>
<th align="center">目录</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>sysfs</code></td>
<td>文件系统提供了一种用户与内核数据结构进行交互的方式，Linux设备模型中设备、驱动、总线组织成拓扑结构，通过<code>sysfs</code>文件系统以目录结构进行展示与管理</td>
</tr>
<tr>
<td align="center"><code>devices</code></td>
<td>内核对系统中所有设备的分层次表达模型，也是<code>/sys</code>文件系统管理设备的最重要的目录结构</td>
</tr>
<tr>
<td align="center"><code>dev</code></td>
<td>这个目录下维护一个按字符设备和块设备的设备号文件(major:minor)链接到真实的设备</td>
</tr>
<tr>
<td align="center"><code>bus</code></td>
<td>内核按照总线类型分层放置的目录结构，<code>devices</code>中的所有设备都是连接于某种总线之下，每一种具体总线之下可以找到每一个具体设备的符号链接，是构成Linux统一设备模型的一部分</td>
</tr>
<tr>
<td align="center"><code>class</code></td>
<td>这是按照设备功能分类的设备模型，如系统所有输入设备都会出现在<code>/sys/class/input</code>之下，不论它们是以何种总线连接到系统，它也是构成Linux统一设备模型的一部分</td>
</tr>
<tr>
<td align="center"><code>block</code></td>
<td>这是系统中当前所有块设备所在的目录，按照功能来说放置在<code>/sys/class</code>下更恰当，由于历史遗留因素而一直存在于<code>/sys/block</code>，在2.6.26内核中已经正式移到<code>/sys/class/block</code>，<code>/sys/block</code>中的内容已经变为指向它们在<code>/sys/devices</code>中真实设备的符号链接文件</td>
</tr>
<tr>
<td align="center"><code>firmware</code></td>
<td>系统加载固件机制的对用户空间的接口</td>
</tr>
<tr>
<td align="center"><code>fs</code></td>
<td>用于描述系统中所有文件系统，包括文件系统本身和按文件系统分类存放的已挂载点</td>
</tr>
<tr>
<td align="center"><code>kernel</code></td>
<td>内核所有可调整参数的位置，目前只有<code>uevent_helper</code>,<code>kexec_loaded</code>,<code>mm</code>和新式的<code>slab</code>分配器等几项较新的设计在使用，其它内核可调整参数仍然位于<code>/proc/sys/kernel</code>接口中</td>
</tr>
<tr>
<td align="center"><code>module</code></td>
<td>系统中所有模块的信息，不论这些模块是以内联方式编译到内核镜像<code>vmlinux</code>中还是编译为外部</td>
</tr>
</tbody></table>
<h4 id="对字符设备的封装：cdev结构体"><a href="#对字符设备的封装：cdev结构体" class="headerlink" title="对字符设备的封装：cdev结构体"></a>对字符设备的封装：<code>cdev</code>结构体</h4><ul>
<li><code>cdev</code>结构体定义在<code>include/linux/cdev.h</code>中  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">    <span class="keyword">dev_t</span> dev;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count;</span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure></li>
<li>其中<a href="https://lwn.net/Articles/722293/"><code>__randomsize_layout</code></a>表示随机化一个结构体，在编译时随机排布结构体中元素的顺序，从而使攻击者无法通过地址偏移的方式获取一些敏感数据成员的信息</li>
<li><code>struct kobject kobj;</code>：抽象出来的用来表示设备模型的数据结构</li>
<li><code>const struct file_operations *ops;</code>：定义了字符设备驱动提供给虚拟文件系统的接口函数集合</li>
<li><code>struct list_head list;</code>：将所有字符设备通过链表进行管理</li>
<li><code>dev_t dev</code>：设备号，<code>dev_t</code>数据结构定义在<code>include/linux/types.h</code>中，包含主设备号和次设备号，实际是一个32位整形数据，其中高12位为主设备号，低20位为次设备号  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// dev_t的定义</span></span><br><span class="line"><span class="keyword">typedef</span> u32 <span class="keyword">__kernel_dev_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">__kernel_dev_t</span>		<span class="keyword">dev_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设备号的一些操作宏</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MINORBITS	20</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MINORMASK	((1U &lt;&lt; MINORBITS) - 1)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAJOR(dev)	((unsigned int) ((dev) &gt;&gt; MINORBITS))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MINOR(dev)	((unsigned int) ((dev) &amp; MINORMASK))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MKDEV(ma,mi)	(((ma) &lt;&lt; MINORBITS) | (mi))</span></span><br></pre></td></tr></table></figure></li>
<li><code>unsigned int count;</code>：属于同主设备号的次设备号的个数</li>
</ul>
<h4 id="设备管理机制：kobject"><a href="#设备管理机制：kobject" class="headerlink" title="设备管理机制：kobject"></a>设备管理机制：<code>kobject</code></h4><ul>
<li><code>kobject</code>是Linux设备驱动模型的基础，也是设备模型中抽象的一部分，它与sysfs文件系统紧密相连，在内核中注册的每个<code>kobject</code>对象对应sysfs文件系统中的一个目录</li>
<li><code>kobject</code>是组成设备模型的基本结构，是所有用来描述设备模型的数据结构的基类，它嵌入在所有的描述设备模型的容器对象中，例如bus,devices,drivers，这些容器通过<code>kobject</code>链接起来，形成一个树形结构</li>
<li>该结构体定义在<code>include/linux/kobject.h</code>中，通过这个数据结构可以使所有设备在底层都具有统一的接口，<code>kobject</code>提供基本的对象管理，结构体内容如下：  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>		*name;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">entry</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span>		*<span class="title">parent</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kset</span>		*<span class="title">kset</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobj_type</span>	*<span class="title">ktype</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kernfs_node</span>	*<span class="title">sd</span>;</span> <span class="comment">/* sysfs directory entry */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kref</span>		<span class="title">kref</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_KOBJECT_RELEASE</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">delayed_work</span>	<span class="title">release</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> state_initialized:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> state_in_sysfs:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> state_add_uevent_sent:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> state_remove_uevent_sent:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> uevent_suppress:<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><code>const char *name;</code>：<code>kobject</code>名字，对应<code>sysfs</code>下的一个目录</li>
<li><code>struct list_head entry;</code>：<code>kobject</code>中插入的的<code>list_head</code>链表结构，用于构造双向链表</li>
<li><code>struct kobject *parent;</code>：指向当前<code>kobject</code>父对象的指针，体现在<code>sysfs</code>中就是包含当前<code>kobject</code>对象的目录对象</li>
<li><code>struct kset *kset;</code>：当前<code>kobject</code>对象所属的集合</li>
<li><code>struct kobj_type *ktype;</code>：当前<code>kobject</code>对象的类型</li>
<li><code>struct kernfs_node *sd;</code>：VFS文件系统的目录项，是设备和文件之间的桥梁，<code>sysfs</code>中的符号链接是通过<code>kernel_node</code>内的联合体实现的</li>
<li><code>struct kref kref;</code>：<code>kobject</code>的引用计数，当计数为0时，回调之前注册的<code>release</code>方法释放对象</li>
<li><code>unsigned int state_initialized:1;</code>：初始化标志位，初始化时被置位</li>
<li><code>unsigned int state_in_sysfs:1;</code>：<code>kobject</code>在<code>sysfs</code>中的状态，在目录中创建则为1，否则为0</li>
<li><code>unsigned int state_add_uevent_sent:1</code>：添加设备的<code>uevent</code>事件是否发送标志，添加设备时向用户控件发送<code>uevent</code>事件，请求新增设备</li>
<li><code>unsigned int state_remove_uevent_sent:1</code>：删除设备的<code>uevent</code>事件是否发送标志，删除设备时向用户控件发送<code>uevent</code>事件，请求卸载设备</li>
<li><code>unsigned int uevent_suppress:1</code>：是否忽略上报<code>uevent</code></li>
</ul>
<h4 id="kobject集合-kset"><a href="#kobject集合-kset" class="headerlink" title="kobject集合 kset"></a><code>kobject</code>集合 <code>kset</code></h4><ul>
<li><code>kset</code>是包含多个<code>kobject</code>的集合，如果在<code>sysfs</code>的目录中包含多个子目录，那需要将它定义成一个<code>kset</code>  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct kset - a set of kobjects of a specific type, belonging to a specific subsystem.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * A kset defines a group of kobjects.  They can be individually</span></span><br><span class="line"><span class="comment"> * different &quot;types&quot; but overall these kobjects all want to be grouped</span></span><br><span class="line"><span class="comment"> * together and operated on in the same manner.  ksets are used to</span></span><br><span class="line"><span class="comment"> * define the attribute callbacks and other common events that happen to</span></span><br><span class="line"><span class="comment"> * a kobject.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @list: the list of all kobjects for this kset</span></span><br><span class="line"><span class="comment"> * @list_lock: a lock for iterating over the kobjects</span></span><br><span class="line"><span class="comment"> * @kobj: the embedded kobject for this kset (recursion, isn&#x27;t it fun...)</span></span><br><span class="line"><span class="comment"> * @uevent_ops: the set of uevent operations for this kset.  These are</span></span><br><span class="line"><span class="comment"> * called whenever a kobject has something happen to it so that the kset</span></span><br><span class="line"><span class="comment"> * can add new environment variables, or filter out the uevents if so</span></span><br><span class="line"><span class="comment"> * desired.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kset</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">    <span class="keyword">spinlock_t</span> list_lock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">kset_uevent_ops</span> *<span class="title">uevent_ops</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><code>struct list_head list;</code>：包含在<code>kset</code>在内的所有<code>kobject</code>构成的一个双向链表</li>
<li><code>spinlock_t list_lock;</code>：遍历<code>kobject</code>时的锁</li>
<li><code>struct kobject kobj;</code>：归属于该<code>kset</code>的所有的<code>kobject</code>的parent</li>
<li><code>const struct kset_uevent_ops *uevent_ops;</code>：<code>kset</code>的<code>uevent</code>操作函数集，当<code>kset</code>中的<code>kobject</code>有状态变化时，会回调这个函数集</li>
</ul>
<h4 id="kobject类型-ktype"><a href="#kobject类型-ktype" class="headerlink" title="kobject类型 ktype"></a><code>kobject</code>类型 <code>ktype</code></h4><ul>
<li><code>kobj_type</code>用于表征<code>kobject</code>的类型，指定了删除<code>kobject</code>时要调用的函数，<code>kobject</code>结构体中有<code>struct kref</code>字段对<code>kobject</code>进行引用计数，当计数值为0时，就会调用<code>kobj_type</code>中的<code>release</code>函数对<code>kobject</code>进行释放</li>
<li><code>kobj_type</code>指定了通过<code>sysfs</code>显示或修改有关<code>kobject</code>的信息时要处理的操作，实际是调用<code>show/store</code>函数  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kobj_type</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> (*release)(struct kobject *kobj);</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sysfs_ops</span> *<span class="title">sysfs_ops</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">attribute</span> **<span class="title">default_attrs</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">kobj_ns_type_operations</span> *(*<span class="title">child_ns_type</span>)(<span class="keyword">struct</span> <span class="title">kobject</span> *<span class="title">kobj</span>);</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">void</span> *(*<span class="keyword">namespace</span>)(struct kobject *kobj);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sysfs_ops</span> &#123;</span></span><br><span class="line">    <span class="keyword">ssize_t</span>	(*show)(struct kobject *, struct attribute *, <span class="keyword">char</span> *);</span><br><span class="line">    <span class="keyword">ssize_t</span>	(*store)(struct kobject *, struct attribute *, <span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">size_t</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">attribute</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>		*name;</span><br><span class="line">    <span class="keyword">umode_t</span>			mode;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_LOCK_ALLOC</span></span><br><span class="line">    <span class="keyword">bool</span>			ignore_lockdep:<span class="number">1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span>	*<span class="title">key</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span>	<span class="title">skey</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><code>void (*release)(struct koject *kobj);</code> 释放<code>kobject</code>对象的接口，有点类似面向对象中的析构</li>
<li><code>const struct sysfs_ops *sysfs_ops;</code> 操作<code>kobject</code>的方法集</li>
<li><code>struct attribute **default_attrs;</code> 所谓的<code>attribute</code>就是内核控件和用户空间进行信息交互的一种方法，例如某个driver定义了一个变量，却希望用户空间程序可以修改该变量，那么可以将该变量以<code>sysfs attribute</code>的形式开放出来</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Driver</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux Cpufreq 框架</title>
    <url>/archives/fbf46cf3.html</url>
    <content><![CDATA[<p>Linux Kernel主要通过三类机制来实现SMP（Symmetric Multiprocessing，对称多核）系统CPU core的电源管理：</p>
<ul>
<li>cpu hotplug: 根据应用场景来up&#x2F;down CPU</li>
<li>cpuidle framework: </li>
<li>cpufreq framework: 根据使用场景和系统负荷来调整CPU的电压和频率</li>
</ul>
<span id="more"></span>

<blockquote>
<p>由于调整是在系统运行的过程中，因此cpufreq framework的功能也称作为Dynamic Voltage&#x2F;Frequency Scaling（动态电压&#x2F;频率调整）</p>
</blockquote>
<p>cpufreq framework中的几个重要概念：</p>
<ol>
<li>policy（策略）：选择合适的调频范围</li>
<li>governor（调节器）：决定如何计算合适的功率</li>
<li>cpufreq driver：来实现真正的调频工作（平台相关）</li>
</ol>
<p>常用的governor类型</p>
<ol>
<li>Performance：总是将CPU置于最高性能的状态，即硬件所支持的最高频率、电压</li>
<li>Powersaving：总是将CPU置于最节能的状态，即硬件所支持的最低频率、电压</li>
<li>Ondemand：设置CPU负载的阈值T，当负载低于T时，调节至一个刚好能够满足当前负载需求的最低频&#x2F;最低压；当负载高于T时，立即提升到最高性能状态</li>
<li>Conservative：跟Ondemand策略类似，设置CPU负载的阈值T，当负载低于T时，调节至一个刚好能够满足当前负载需求的最低频&#x2F;最低压；但当负载高于T时，不是立即设置为最高性能状态，而是逐级升高主频&#x2F;电压</li>
<li>Userspace：将控制接口通过sysfs开放给用户，由用户进行自定义策略</li>
<li>Schedutil：这是从Linux-4.7版本开始才引入的策略，其原理是根据调度器所提供的CPU利用率信息进行电压&#x2F;频率调节，效果上类似于Ondemand策略，但是更加精确和自然</li>
</ol>
<p>sysfs用户层接口，目录位于<code>/sys/devices/system/cpu/cpufreq/policy</code><br><img src="https://raw.githubusercontent.com/JackHuang021/images/master/20221124110212.png"></p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">cpuinfo_max_freq</td>
<td align="left">硬件所支持的最高频率</td>
</tr>
<tr>
<td align="left">cpuinfo_min_freq</td>
<td align="left">硬件所支持的最低频率</td>
</tr>
<tr>
<td align="left">affected_cpus</td>
<td align="left">该policy影响到哪些cpu（没显示offline状态的cpu）</td>
</tr>
<tr>
<td align="left">related_cpus</td>
<td align="left">该policy影响到的所有cpu，包括offline状态的cpu</td>
</tr>
<tr>
<td align="left">scaling_max_freq</td>
<td align="left">该policy支持调整的最高频率</td>
</tr>
<tr>
<td align="left">scaling_min_freq</td>
<td align="left">该policy支持调整的最低频率</td>
</tr>
<tr>
<td align="left">scaling_cur_freq</td>
<td align="left">policy当前设置的频率</td>
</tr>
<tr>
<td align="left">scaling_available_governors</td>
<td align="left">当前系统支持的governor</td>
</tr>
<tr>
<td align="left">scaling_available_frequencies</td>
<td align="left">支持的调频频率</td>
</tr>
<tr>
<td align="left">scaling_driver</td>
<td align="left">当前使用的调频驱动</td>
</tr>
<tr>
<td align="left">scaling_governor</td>
<td align="left">当前使用的governor</td>
</tr>
<tr>
<td align="left">scaling_setspeed</td>
<td align="left">在userspace模式下才能使用，手动设置频率</td>
</tr>
</tbody></table>
<h4 id="cpufreq软件架构"><a href="#cpufreq软件架构" class="headerlink" title="cpufreq软件架构"></a>cpufreq软件架构</h4><p>cpufreq core：把一些公共的逻辑和接口代码抽象出来</p>
<ul>
<li><code>cpufreq</code>作为所有cpu设备的一个功能，注册到了<code>cpu_subsys</code>总线上</li>
<li>对上以sysfs的形式向用户空间提供统一的接口，以notifier的形式向其他driver提供频率变化的通知</li>
<li>对下提供CPU品频率和电压控制的驱动框架，方便底层driver的开发，同时提供governor框架，用于实现不同的频率调整机制</li>
<li>内部封装各种逻辑，主要围绕<code>struct cpufreq_policy</code> <code>struct cpufreq_driver</code> <code>struct cpufreq_governor</code>三个数据结构进行</li>
</ul>
<p><strong><code>struct cpufreq_policy</code>用来抽象cpufreq，所谓的调频策略，即频率调整的范围，它从一定程度上代表了cpufreq的属性</strong></p>
<p><code>cpufreq_policy</code>结构体</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cpufreq_cpuinfo</span> &#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		max_freq;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		min_freq;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* in 10^(-9) s = nanoseconds */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		transition_latency;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cpufreq_policy</span> &#123;</span></span><br><span class="line">	<span class="comment">/* CPUs sharing clock, require sw coordination */</span></span><br><span class="line">	<span class="keyword">cpumask_var_t</span>		cpus;	<span class="comment">/* Online CPUs only */</span></span><br><span class="line">	<span class="keyword">cpumask_var_t</span>		related_cpus; <span class="comment">/* Online + Offline CPUs */</span></span><br><span class="line">	<span class="keyword">cpumask_var_t</span>		real_cpus; <span class="comment">/* Related and present */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		shared_type; <span class="comment">/* ACPI: ANY or ALL affected CPUs</span></span><br><span class="line"><span class="comment">						should set cpufreq */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		cpu;    <span class="comment">/* cpu managing this policy, must be online */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">clk</span>		*<span class="title">clk</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cpufreq_cpuinfo</span>	<span class="title">cpuinfo</span>;</span><span class="comment">/* see above */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		min;    <span class="comment">/* in kHz */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		max;    <span class="comment">/* in kHz */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		cur;    <span class="comment">/* in kHz, only needed if cpufreq</span></span><br><span class="line"><span class="comment">					 * governors are used */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		restore_freq; <span class="comment">/* = policy-&gt;cur before transition */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		suspend_freq; <span class="comment">/* freq to set during suspend */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		policy; <span class="comment">/* see above */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		last_policy; <span class="comment">/* policy before unplug */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cpufreq_governor</span>	*<span class="title">governor</span>;</span> <span class="comment">/* see below */</span></span><br><span class="line">	<span class="keyword">void</span>			*governor_data;</span><br><span class="line">	<span class="keyword">char</span>			last_governor[CPUFREQ_NAME_LEN]; <span class="comment">/* last governor used */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span>	<span class="title">update</span>;</span> <span class="comment">/* if update_policy() needs to be</span></span><br><span class="line"><span class="comment">					 * called, but you&#x27;re in IRQ context */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cpufreq_user_policy</span> <span class="title">user_policy</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cpufreq_frequency_table</span>	*<span class="title">freq_table</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">cpufreq_table_sorting</span> <span class="title">freq_table_sorted</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>        <span class="title">policy_list</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kobject</span>		<span class="title">kobj</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">completion</span>	<span class="title">kobj_unregister</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The rules for this semaphore:</span></span><br><span class="line"><span class="comment">	 * - Any routine that wants to read from the policy structure will</span></span><br><span class="line"><span class="comment">	 *   do a down_read on this semaphore.</span></span><br><span class="line"><span class="comment">	 * - Any routine that will write to the policy structure and/or may take away</span></span><br><span class="line"><span class="comment">	 *   the policy altogether (eg. CPU hotplug), will hold this lock in write</span></span><br><span class="line"><span class="comment">	 *   mode before doing so.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rw_semaphore</span>	<span class="title">rwsem</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Fast switch flags:</span></span><br><span class="line"><span class="comment">	 * - fast_switch_possible should be set by the driver if it can</span></span><br><span class="line"><span class="comment">	 *   guarantee that frequency can be changed on any CPU sharing the</span></span><br><span class="line"><span class="comment">	 *   policy and that the change will affect all of the policy CPUs then.</span></span><br><span class="line"><span class="comment">	 * - fast_switch_enabled is to be set by governors that support fast</span></span><br><span class="line"><span class="comment">	 *   frequency switching with the help of cpufreq_enable_fast_switch().</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">bool</span>			fast_switch_possible;</span><br><span class="line">	<span class="keyword">bool</span>			fast_switch_enabled;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Preferred average time interval between consecutive invocations of</span></span><br><span class="line"><span class="comment">	 * the driver to set the frequency for this policy.  To be set by the</span></span><br><span class="line"><span class="comment">	 * scaling driver (0, which is the default, means no preference).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		transition_delay_us;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Remote DVFS flag (Not added to the driver structure as we don&#x27;t want</span></span><br><span class="line"><span class="comment">	 * to access another structure from scheduler hotpath).</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Should be set if CPUs can do DVFS on behalf of other CPUs from</span></span><br><span class="line"><span class="comment">	 * different cpufreq policies.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">bool</span>			dvfs_possible_from_any_cpu;</span><br><span class="line"></span><br><span class="line">	 <span class="comment">/* Cached frequency lookup from cpufreq_driver_resolve_freq. */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> cached_target_freq;</span><br><span class="line">	<span class="keyword">int</span> cached_resolved_idx;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Synchronization for frequency transitions */</span></span><br><span class="line">	<span class="keyword">bool</span>			transition_ongoing; <span class="comment">/* Tracks transition status */</span></span><br><span class="line">	<span class="keyword">spinlock_t</span>		transition_lock;</span><br><span class="line">	<span class="keyword">wait_queue_head_t</span>	transition_wait;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>	*<span class="title">transition_task</span>;</span> <span class="comment">/* Task which is doing the transition */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* cpufreq-stats */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cpufreq_stats</span>	*<span class="title">stats</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* For cpufreq driver&#x27;s internal use */</span></span><br><span class="line">	<span class="keyword">void</span>			*driver_data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="cpufreq-driver初始化过程"><a href="#cpufreq-driver初始化过程" class="headerlink" title="cpufreq_driver初始化过程"></a>cpufreq_driver初始化过程</h4><p><code>cpufreq_driver</code>结构体如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cpufreq_driver</span> &#123;</span></span><br><span class="line">	<span class="keyword">char</span>		name[CPUFREQ_NAME_LEN];</span><br><span class="line">	u16		    flags;</span><br><span class="line">	<span class="keyword">void</span>		*driver_data;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* needed by all drivers */</span></span><br><span class="line">	<span class="keyword">int</span>		(*init)(struct cpufreq_policy *policy);</span><br><span class="line">	<span class="keyword">int</span>		(*verify)(struct cpufreq_policy_data *policy);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* define one out of two */</span></span><br><span class="line">	<span class="keyword">int</span>		(*setpolicy)(struct cpufreq_policy *policy);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * On failure, should always restore frequency to policy-&gt;restore_freq</span></span><br><span class="line"><span class="comment">	 * (i.e. old freq).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">int</span>		(*target)(struct cpufreq_policy *policy,</span><br><span class="line">				  <span class="keyword">unsigned</span> <span class="keyword">int</span> target_freq,</span><br><span class="line">				  <span class="keyword">unsigned</span> <span class="keyword">int</span> relation);	<span class="comment">/* Deprecated */</span></span><br><span class="line">	<span class="keyword">int</span>		(*target_index)(struct cpufreq_policy *policy,</span><br><span class="line">					<span class="keyword">unsigned</span> <span class="keyword">int</span> index);</span><br><span class="line">	<span class="function"><span class="keyword">unsigned</span> <span class="title">int</span>	<span class="params">(*fast_switch)</span><span class="params">(struct cpufreq_policy *policy,</span></span></span><br><span class="line"><span class="params"><span class="function">				       <span class="keyword">unsigned</span> <span class="keyword">int</span> target_freq)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Caches and returns the lowest driver-supported frequency greater than</span></span><br><span class="line"><span class="comment">	 * or equal to the target frequency, subject to any driver limitations.</span></span><br><span class="line"><span class="comment">	 * Does not set the frequency. Only to be implemented for drivers with</span></span><br><span class="line"><span class="comment">	 * target().</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">unsigned</span> <span class="title">int</span>	<span class="params">(*resolve_freq)</span><span class="params">(struct cpufreq_policy *policy,</span></span></span><br><span class="line"><span class="params"><span class="function">					<span class="keyword">unsigned</span> <span class="keyword">int</span> target_freq)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Only for drivers with target_index() and CPUFREQ_ASYNC_NOTIFICATION</span></span><br><span class="line"><span class="comment">	 * unset.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * get_intermediate should return a stable intermediate frequency</span></span><br><span class="line"><span class="comment">	 * platform wants to switch to and target_intermediate() should set CPU</span></span><br><span class="line"><span class="comment">	 * to that frequency, before jumping to the frequency corresponding</span></span><br><span class="line"><span class="comment">	 * to &#x27;index&#x27;. Core will take care of sending notifications and driver</span></span><br><span class="line"><span class="comment">	 * doesn&#x27;t have to handle them in target_intermediate() or</span></span><br><span class="line"><span class="comment">	 * target_index().</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Drivers can return &#x27;0&#x27; from get_intermediate() in case they don&#x27;t</span></span><br><span class="line"><span class="comment">	 * wish to switch to intermediate frequency for some target frequency.</span></span><br><span class="line"><span class="comment">	 * In that case core will directly call -&gt;target_index().</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">unsigned</span> <span class="title">int</span>	<span class="params">(*get_intermediate)</span><span class="params">(struct cpufreq_policy *policy,</span></span></span><br><span class="line"><span class="params"><span class="function">					    <span class="keyword">unsigned</span> <span class="keyword">int</span> index)</span></span>;</span><br><span class="line">	<span class="keyword">int</span>		(*target_intermediate)(struct cpufreq_policy *policy,</span><br><span class="line">					       <span class="keyword">unsigned</span> <span class="keyword">int</span> index);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* should be defined, if possible */</span></span><br><span class="line">	<span class="function"><span class="keyword">unsigned</span> <span class="title">int</span>	<span class="params">(*get)</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> cpu)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Called to update policy limits on firmware notifications. */</span></span><br><span class="line">	<span class="keyword">void</span>		(*update_limits)(<span class="keyword">unsigned</span> <span class="keyword">int</span> cpu);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* optional */</span></span><br><span class="line">	<span class="keyword">int</span>		(*bios_limit)(<span class="keyword">int</span> cpu, <span class="keyword">unsigned</span> <span class="keyword">int</span> *limit);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span>		(*online)(struct cpufreq_policy *policy);</span><br><span class="line">	<span class="keyword">int</span>		(*offline)(struct cpufreq_policy *policy);</span><br><span class="line">	<span class="keyword">int</span>		(*<span class="built_in">exit</span>)(struct cpufreq_policy *policy);</span><br><span class="line">	<span class="keyword">void</span>		(*stop_cpu)(struct cpufreq_policy *policy);</span><br><span class="line">	<span class="keyword">int</span>		(*suspend)(struct cpufreq_policy *policy);</span><br><span class="line">	<span class="keyword">int</span>		(*resume)(struct cpufreq_policy *policy);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Will be called after the driver is fully initialized */</span></span><br><span class="line">	<span class="keyword">void</span>		(*ready)(struct cpufreq_policy *policy);</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">freq_attr</span> **<span class="title">attr</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* platform specific boost support code */</span></span><br><span class="line">	<span class="keyword">bool</span>		boost_enabled;</span><br><span class="line">	<span class="keyword">int</span>		(*set_boost)(struct cpufreq_policy *policy, <span class="keyword">int</span> state);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>cpufreq_register_driver()</code>函数为cpufreq驱动注册的入口，驱动程序通过调用该函数进行初始化，传入相关的<code>struct cpufreq_driver</code>，<code>cpufreq_register_driver()</code>会调用<code>subsys_interface_register()</code>最终执行回调函数<code>cpufreq_add_dev</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// driver/base/cpu.c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> <span class="title">cpu_subsys</span> =</span> &#123;</span><br><span class="line">	.name = <span class="string">&quot;cpu&quot;</span>,</span><br><span class="line">	.dev_name = <span class="string">&quot;cpu&quot;</span>,</span><br><span class="line">	.match = cpu_subsys_match,</span><br><span class="line">	.online = cpu_subsys_online,</span><br><span class="line">	.offline = cpu_subsys_offline,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">cpufreq_driver</span> *<span class="title">cpufreq_driver</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">subsys_interface</span> <span class="title">cpufreq_interface</span> =</span> &#123;</span><br><span class="line">	.name		= <span class="string">&quot;cpufreq&quot;</span>,</span><br><span class="line">	.subsys		= &amp;cpu_subsys,</span><br><span class="line">	.add_dev	= cpufreq_add_dev,</span><br><span class="line">	.remove_dev	= cpufreq_remove_dev,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">cpufreq_driver</span> <span class="title">scmi_cpufreq_driver</span> =</span> &#123;</span><br><span class="line">	.name	= <span class="string">&quot;scmi&quot;</span>,</span><br><span class="line">	.flags	= CPUFREQ_STICKY | CPUFREQ_HAVE_GOVERNOR_PER_POLICY |</span><br><span class="line">		  CPUFREQ_NEED_INITIAL_FREQ_CHECK,</span><br><span class="line">	.verify	= cpufreq_generic_frequency_table_verify,</span><br><span class="line">	.attr	= cpufreq_generic_attr,</span><br><span class="line">	.target_index	= scmi_cpufreq_set_target,</span><br><span class="line">	.fast_switch	= scmi_cpufreq_fast_switch,</span><br><span class="line">	.get	= scmi_cpufreq_get_rate,</span><br><span class="line">	.init	= scmi_cpufreq_init,</span><br><span class="line">	.<span class="built_in">exit</span>	= scmi_cpufreq_exit,</span><br><span class="line">	.ready	= scmi_cpufreq_ready,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为每个CPU定义一个cpufreq_policy结构体，对每个CPU进行调频管理</span></span><br><span class="line"><span class="comment">// 其中又分别进行cpufreq_driver的初始化和governor的初始化</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">DEFINE_PER_CPU</span><span class="params">(struct cpufreq_policy *, cpufreq_cpu_data)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// cpufreq驱动框架初始化过程，整个过程都围绕着policy这个结构体进行，逐步进行初始化</span></span><br><span class="line">cpufreq_register_driver(&amp;scmi_cpufreq_driver);</span><br><span class="line">	subsys_interface_register(&amp;cpufreq_interface);</span><br><span class="line">		cpufreq_add_dev(dev, sif);</span><br><span class="line">			cpufreq_online(cpu);</span><br><span class="line">				policy = cpufreq_policy_alloc(cpu);</span><br><span class="line">				<span class="comment">// 调用驱动init接口，初始化policy结构体</span></span><br><span class="line">				cpufreq_driver-&gt;init(policy) -&gt; scmi_cpufreq_init(policy)</span><br><span class="line">				cpufreq_table_validate_and_sort(policy);</span><br><span class="line">				add_cpu_dev_symlink();</span><br><span class="line">				freq_qos_and_request();</span><br><span class="line">				blocking_notifier_call_chain();</span><br><span class="line">				<span class="comment">// CPU进行频率调整，使当前运行频率在频率表中</span></span><br><span class="line">				__cpufreq_driver_target();</span><br><span class="line">				<span class="comment">// 创建sys节点</span></span><br><span class="line">				cpufreq_add_dev_interface(policy);</span><br><span class="line">				cpufreq_stats_create_table(policy);</span><br><span class="line">				list_add(&amp;policy-&gt;polic_list, &amp;cpufreq_policy_list);</span><br><span class="line">				<span class="comment">// 初始化governor</span></span><br><span class="line">				cpufreq_init_policy();</span><br></pre></td></tr></table></figure>

<p>cpufreq_driver的初始化过程，这里是调用cpufreq_driver的init接口进行初始化</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// scmi_cpufreq_init(policy)初始化过程</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct scmi_handle - Handle returned to ARM SCMI clients for usage.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @dev: pointer to the SCMI device</span></span><br><span class="line"><span class="comment"> * @version: pointer to the structure containing SCMI version information</span></span><br><span class="line"><span class="comment"> * @power_ops: pointer to set of power protocol operations</span></span><br><span class="line"><span class="comment"> * @perf_ops: pointer to set of performance protocol operations</span></span><br><span class="line"><span class="comment"> * @clk_ops: pointer to set of clock protocol operations</span></span><br><span class="line"><span class="comment"> * @sensor_ops: pointer to set of sensor protocol operations</span></span><br><span class="line"><span class="comment"> * @reset_ops: pointer to set of reset protocol operations</span></span><br><span class="line"><span class="comment"> * @notify_ops: pointer to set of notifications related operations</span></span><br><span class="line"><span class="comment"> * @perf_priv: pointer to private data structure specific to performance</span></span><br><span class="line"><span class="comment"> *	protocol(for internal use only)</span></span><br><span class="line"><span class="comment"> * @clk_priv: pointer to private data structure specific to clock</span></span><br><span class="line"><span class="comment"> *	protocol(for internal use only)</span></span><br><span class="line"><span class="comment"> * @power_priv: pointer to private data structure specific to power</span></span><br><span class="line"><span class="comment"> *	protocol(for internal use only)</span></span><br><span class="line"><span class="comment"> * @sensor_priv: pointer to private data structure specific to sensors</span></span><br><span class="line"><span class="comment"> *	protocol(for internal use only)</span></span><br><span class="line"><span class="comment"> * @reset_priv: pointer to private data structure specific to reset</span></span><br><span class="line"><span class="comment"> *	protocol(for internal use only)</span></span><br><span class="line"><span class="comment"> * @notify_priv: pointer to private data structure specific to notifications</span></span><br><span class="line"><span class="comment"> *	(for internal use only)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">scmi_handle</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">scmi_revision_info</span> *<span class="title">version</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">scmi_perf_ops</span> *<span class="title">perf_ops</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">scmi_clk_ops</span> *<span class="title">clk_ops</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">scmi_power_ops</span> *<span class="title">power_ops</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">scmi_sensor_ops</span> *<span class="title">sensor_ops</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">scmi_reset_ops</span> *<span class="title">reset_ops</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">scmi_notify_ops</span> *<span class="title">notify_ops</span>;</span></span><br><span class="line">	<span class="comment">/* for protocol internal use */</span></span><br><span class="line">	<span class="keyword">void</span> *perf_priv;</span><br><span class="line">	<span class="keyword">void</span> *clk_priv;</span><br><span class="line">	<span class="keyword">void</span> *power_priv;</span><br><span class="line">	<span class="keyword">void</span> *sensor_priv;</span><br><span class="line">	<span class="keyword">void</span> *reset_priv;</span><br><span class="line">	<span class="keyword">void</span> *notify_priv;</span><br><span class="line">	<span class="keyword">void</span> *system_priv;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct scmi_perf_ops - represents the various operations provided</span></span><br><span class="line"><span class="comment"> *	by SCMI Performance Protocol</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @limits_set: sets limits on the performance level of a domain</span></span><br><span class="line"><span class="comment"> * @limits_get: gets limits on the performance level of a domain</span></span><br><span class="line"><span class="comment"> * @level_set: sets the performance level of a domain</span></span><br><span class="line"><span class="comment"> * @level_get: gets the performance level of a domain</span></span><br><span class="line"><span class="comment"> * @device_domain_id: gets the scmi domain id for a given device</span></span><br><span class="line"><span class="comment"> * @transition_latency_get: gets the DVFS transition latency for a given device</span></span><br><span class="line"><span class="comment"> * @device_opps_add: adds all the OPPs for a given device</span></span><br><span class="line"><span class="comment"> * @freq_set: sets the frequency for a given device using sustained frequency</span></span><br><span class="line"><span class="comment"> *	to sustained performance level mapping</span></span><br><span class="line"><span class="comment"> * @freq_get: gets the frequency for a given device using sustained frequency</span></span><br><span class="line"><span class="comment"> *	to sustained performance level mapping</span></span><br><span class="line"><span class="comment"> * @est_power_get: gets the estimated power cost for a given performance domain</span></span><br><span class="line"><span class="comment"> *	at a given frequency</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">scmi_perf_ops</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> (*limits_set)(<span class="keyword">const</span> struct scmi_handle *handle, u32 domain,</span><br><span class="line">			  u32 max_perf, u32 min_perf);</span><br><span class="line">	<span class="keyword">int</span> (*limits_get)(<span class="keyword">const</span> struct scmi_handle *handle, u32 domain,</span><br><span class="line">			  u32 *max_perf, u32 *min_perf);</span><br><span class="line">	<span class="keyword">int</span> (*level_set)(<span class="keyword">const</span> struct scmi_handle *handle, u32 domain,</span><br><span class="line">			 u32 level, <span class="keyword">bool</span> poll);</span><br><span class="line">	<span class="keyword">int</span> (*level_get)(<span class="keyword">const</span> struct scmi_handle *handle, u32 domain,</span><br><span class="line">			 u32 *level, <span class="keyword">bool</span> poll);</span><br><span class="line">	<span class="keyword">int</span> (*device_domain_id)(struct device *dev);</span><br><span class="line">	<span class="keyword">int</span> (*transition_latency_get)(<span class="keyword">const</span> struct scmi_handle *handle,</span><br><span class="line">				      struct device *dev);</span><br><span class="line">	<span class="keyword">int</span> (*device_opps_add)(<span class="keyword">const</span> struct scmi_handle *handle,</span><br><span class="line">			       struct device *dev);</span><br><span class="line">	<span class="keyword">int</span> (*freq_set)(<span class="keyword">const</span> struct scmi_handle *handle, u32 domain,</span><br><span class="line">			<span class="keyword">unsigned</span> <span class="keyword">long</span> rate, <span class="keyword">bool</span> poll);</span><br><span class="line">	<span class="keyword">int</span> (*freq_get)(<span class="keyword">const</span> struct scmi_handle *handle, u32 domain,</span><br><span class="line">			<span class="keyword">unsigned</span> <span class="keyword">long</span> *rate, <span class="keyword">bool</span> poll);</span><br><span class="line">	<span class="keyword">int</span> (*est_power_get)(<span class="keyword">const</span> struct scmi_handle *handle, u32 domain,</span><br><span class="line">			     <span class="keyword">unsigned</span> <span class="keyword">long</span> *rate, <span class="keyword">unsigned</span> <span class="keyword">long</span> *power);</span><br><span class="line">	<span class="keyword">bool</span> (*fast_switch_possible)(<span class="keyword">const</span> struct scmi_handle *handle,</span><br><span class="line">				     struct device *dev);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">scmi_opp</span> &#123;</span></span><br><span class="line">	u32 perf;</span><br><span class="line">	u32 power;</span><br><span class="line">	u32 trans_latency_us;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// scmi_handle这个结构体实现的就是scmi整个协议的处理</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">scmi_handle</span> *<span class="title">handle</span>;</span>	</span><br><span class="line"></span><br><span class="line">scmi_cpufreq_init(policy)</span><br><span class="line">	cpu_dev = get_cpu_device(policy-&gt;cpu);</span><br><span class="line">	handle-&gt;perf_ops-&gt;device_opps_add(handle, cpu_dev);</span><br></pre></td></tr></table></figure>

<p>cpufreq governor的初始化过程，在cpufreq_init_policy(policy)中进行，这里以ondemand为例进行分析</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Common Governor data across policies */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dbs_governor</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cpufreq_governor</span> <span class="title">gov</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kobj_type</span> <span class="title">kobj_type</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Common data for platforms that don&#x27;t set</span></span><br><span class="line"><span class="comment">	 * CPUFREQ_HAVE_GOVERNOR_PER_POLICY</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dbs_data</span> *<span class="title">gdbs_data</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">unsigned</span> <span class="title">int</span> <span class="params">(*gov_dbs_update)</span><span class="params">(struct cpufreq_policy *policy)</span></span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">policy_dbs_info</span> *(*<span class="title">alloc</span>)(<span class="title">void</span>);</span></span><br><span class="line">	<span class="keyword">void</span> (*<span class="built_in">free</span>)(struct policy_dbs_info *policy_dbs);</span><br><span class="line">	<span class="keyword">int</span> (*init)(struct dbs_data *dbs_data);</span><br><span class="line">	<span class="keyword">void</span> (*<span class="built_in">exit</span>)(struct dbs_data *dbs_data);</span><br><span class="line">	<span class="keyword">void</span> (*start)(struct cpufreq_policy *policy);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CPUFREQ_DBS_GOVERNOR_INITIALIZER(_name_)			\</span></span><br><span class="line"><span class="meta">	&#123;								\</span></span><br><span class="line"><span class="meta">		.name = _name_,						\</span></span><br><span class="line"><span class="meta">		.flags = CPUFREQ_GOV_DYNAMIC_SWITCHING,			\</span></span><br><span class="line"><span class="meta">		.owner = THIS_MODULE,					\</span></span><br><span class="line"><span class="meta">		.init = cpufreq_dbs_governor_init,			\</span></span><br><span class="line"><span class="meta">		.exit = cpufreq_dbs_governor_exit,			\</span></span><br><span class="line"><span class="meta">		.start = cpufreq_dbs_governor_start,			\</span></span><br><span class="line"><span class="meta">		.stop = cpufreq_dbs_governor_stop,			\</span></span><br><span class="line"><span class="meta">		.limits = cpufreq_dbs_governor_limits,			\</span></span><br><span class="line"><span class="meta">	&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">dbs_governor</span> <span class="title">od_dbs_gov</span> =</span> &#123;</span><br><span class="line">	.gov = CPUFREQ_DBS_GOVERNOR_INITIALIZER(<span class="string">&quot;ondemand&quot;</span>),</span><br><span class="line">	.kobj_type = &#123; .default_attrs = od_attributes &#125;,</span><br><span class="line">	.gov_dbs_update = od_dbs_update,</span><br><span class="line">	.alloc = od_alloc,</span><br><span class="line">	.<span class="built_in">free</span> = od_free,</span><br><span class="line">	.init = od_init,</span><br><span class="line">	.<span class="built_in">exit</span> = od_exit,</span><br><span class="line">	.start = od_start,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CPU_FREQ_GOV_ONDEMAND	(od_dbs_gov.gov)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从这里开始初始化governor</span></span><br><span class="line"><span class="comment">// 该函数会在所有governor模块驱动的入口函数调用，</span></span><br><span class="line"><span class="comment">// 只要编译该模块，就会注册到cpufreq framework中</span></span><br><span class="line">cpufreq_governor_init(CPU_FREQ_GOV_ONDEMAND);</span><br><span class="line"></span><br><span class="line">cpufreq_init_policy(policy);</span><br><span class="line">	gov = get_governor(default_governor);</span><br><span class="line">	<span class="comment">// 设置新的governor</span></span><br><span class="line">	cpufreq_set_policy(policy, gov, pol);</span><br><span class="line">		cpufreq_init_governor(policy);</span><br><span class="line">			policy-&gt;governor-&gt;init();  -&gt; cpufreq_dbs_governor_init(policy);</span><br><span class="line">				gov-&gt;init(dbs_data); -&gt; odinit(dbs_data);</span><br><span class="line">		cpufreq_start_governor(policy);</span><br><span class="line">			policy-&gt;governor-&gt;start(); -&gt; cpufreq_dbs_governor_start(policy);</span><br><span class="line">				<span class="comment">// 设置governor回调函数</span></span><br><span class="line">				gov_set_update_util(policy_dbs, sampling_rate);</span><br><span class="line">					cpufreq_add_update_util_hook(cpu, &amp;cdbs-&gt;updata_util,</span><br><span class="line">									dbs_update_util_handler);</span><br></pre></td></tr></table></figure>
<p>启动governor中比较重要的是设置调频回调函数,该函数是真正调频时计算合适频率的函数</p>
<p><code>cpufreq_driver</code>必须要实现的几个接口：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> (*verify)(struct cpufreq_policy *policy);</span><br><span class="line"><span class="keyword">int</span> (*init)(struct cpufreq_policy *policy);</span><br><span class="line"><span class="keyword">int</span> (*setpolicy)(struct cpufreq_policy *policy)</span><br><span class="line"><span class="keyword">int</span> (*target_index)(struct cpufreq_policy *policy, <span class="keyword">unsigned</span> <span class="keyword">int</span> index); </span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">subsys_interface</span> <span class="title">cpufreq_interface</span> =</span> &#123;</span><br><span class="line">	.name		= <span class="string">&quot;cpufreq&quot;</span>,</span><br><span class="line">	.subsys		= &amp;cpu_subsys,</span><br><span class="line">	.add_dev	= cpufreq_add_dev,</span><br><span class="line">	.remove_dev	= cpufreq_remove_dev,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// cpufreq driver注册过程</span></span><br><span class="line">cpufreq_register_driver(&amp;scmi_cpufreq_driver);</span><br><span class="line">    subsys_interface_register(&amp;cpufreq_interface);</span><br><span class="line">        cpufreq_add_dev(dev, cpu_subsys);</span><br><span class="line">            cpufreq_online(cpu);</span><br></pre></td></tr></table></figure>


<p>由于bootloader设置的CPU频率值可能不在当前CPU频率表中，CPU在该频率下可能运行不稳定，所以在cpufreq_online(cpu)过程中会进行一次调频</p>
<p>schedutil调度器代码分析</p>
<p>sugov作为一种内核调频策略模块，它主要是根据当前CPU的利用率进行调频。因此，sugov会注册一个callback函数（sugov_update_shared&#x2F;sugov_update_single）到调度器负载跟踪模块，当CPU util发生变化的时候就会调用该callback函数，检查一下当前CPU频率是否和当前的CPU util匹配，如果不匹配，那么就进行提频或者降频。</p>
<p><code>sugov_tunables</code>结构体，用来描述sugov的可调参数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sugov_tunables结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sugov_tunables</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gov_attr_set</span> <span class="title">attr_set</span>;</span></span><br><span class="line">	<span class="comment">// 目前sugov只有这一个可调参数，该参数用来限制连续调频的间隔时间</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> rate_limit_us;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>sugov_policy</code>结构体，sugov为每个cluster构建了该数据结构，记录per-cluster的调频数据信息</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sugov_policy结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sugov_policy</span> &#123;</span></span><br><span class="line">	<span class="comment">// 指向cpufreq framework层的policy对象</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cpufreq_policy</span>	*<span class="title">policy</span>;</span></span><br><span class="line">	<span class="comment">// sugov的可调参数</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sugov_tunables</span>	*<span class="title">tunables</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">tunables_hook</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 保护sugov对象的自旋锁，一旦要修改</span></span><br><span class="line">	<span class="keyword">raw_spinlock_t</span>		update_lock;	<span class="comment">/* For shared policies */</span></span><br><span class="line">	u64			last_freq_update_time;</span><br><span class="line">	s64			freq_update_delay_ns;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		next_freq;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		cached_raw_freq;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* The next fields are only needed if fast switch cannot be used: */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span>			<span class="title">irq_work</span> <span class="title">irq_work</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span>			<span class="title">kthread_work</span> <span class="title">work</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span>			<span class="title">mutex</span> <span class="title">work_lock</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span>			<span class="title">kthread_worker</span> <span class="title">worker</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>	*<span class="title">thread</span>;</span></span><br><span class="line">	<span class="keyword">bool</span>			work_in_progress;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">bool</span>			limits_changed;</span><br><span class="line">	<span class="keyword">bool</span>			need_freq_update;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>sugov_cpu</code>结构体，sugov为每个cpu构建了该数据结构，记录per-cpu的调频数据信息</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sugov_cpu</span> &#123;</span></span><br><span class="line">	<span class="comment">// 保存了cpu util变化后的callback函数</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">update_util_data</span>	<span class="title">update_util</span>;</span></span><br><span class="line">	<span class="comment">// 该sugov_cpu对应的sugov_policy对象</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sugov_policy</span>	*<span class="title">sg_policy</span>;</span></span><br><span class="line">	<span class="comment">// 对应的CPU id</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		cpu;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">bool</span>			iowait_boost_pending;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		iowait_boost;</span><br><span class="line">	<span class="comment">// 上一次cpu负载变化驱动调频的时间点，util更新的时间点</span></span><br><span class="line">	u64			last_update;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		bw_dl;</span><br><span class="line">	<span class="comment">// 该CPU的最大算力，即最大utilities，归一化到1024</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		max;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* The field below is for single-CPU policies only: */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NO_HZ_COMMON</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		saved_idle_calls;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p><code>schedutil_cpu_util()</code>函数分析，用来计算cpu util的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 调用过程</span></span><br><span class="line">sugov_update_single();</span><br><span class="line">	util = sugov_get_util(sg_cpuu);</span><br><span class="line">		schedutil_cpu_util(sg_cpu-&gt;cpu, util, max, FREQUENCY_UTIL, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">schedutil_cpu_util</span><span class="params">(<span class="keyword">int</span> cpu, <span class="keyword">unsigned</span> <span class="keyword">long</span> util_cfs,</span></span></span><br><span class="line"><span class="params"><span class="function">					<span class="keyword">unsigned</span> <span class="keyword">long</span> max, <span class="keyword">enum</span> schedutil_type type,</span></span></span><br><span class="line"><span class="params"><span class="function">					struct task_struct *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> dl_util, util, irq;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span> =</span> cpu_rq(cpu);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!uclamp_is_used() &amp;&amp;</span><br><span class="line">	    type == FREQUENCY_UTIL &amp;&amp; rt_rq_is_runnable(&amp;rq-&gt;rt)) &#123;</span><br><span class="line">		<span class="keyword">return</span> max;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Early check to see if IRQ/steal time saturates the CPU, can be</span></span><br><span class="line"><span class="comment">	 * because of inaccuracies in how we track these -- see</span></span><br><span class="line"><span class="comment">	 * update_irq_load_avg().</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	irq = cpu_util_irq(rq);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(irq &gt;= max))</span><br><span class="line">		<span class="keyword">return</span> max;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Because the time spend on RT/DL tasks is visible as &#x27;lost&#x27; time to</span></span><br><span class="line"><span class="comment">	 * CFS tasks and we use the same metric to track the effective</span></span><br><span class="line"><span class="comment">	 * utilization (PELT windows are synchronized) we can directly add them</span></span><br><span class="line"><span class="comment">	 * to obtain the CPU&#x27;s actual utilization.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * CFS and RT utilization can be boosted or capped, depending on</span></span><br><span class="line"><span class="comment">	 * utilization clamp constraints requested by currently RUNNABLE</span></span><br><span class="line"><span class="comment">	 * tasks.</span></span><br><span class="line"><span class="comment">	 * When there are no CFS RUNNABLE tasks, clamps are released and</span></span><br><span class="line"><span class="comment">	 * frequency will be gracefully reduced with the utilization decay.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">// 累加了cfs和rt任务的utility，根据当前的</span></span><br><span class="line">	util = util_cfs + cpu_util_rt(rq);</span><br><span class="line">	<span class="keyword">if</span> (type == FREQUENCY_UTIL)</span><br><span class="line">		util = uclamp_rq_util_with(rq, util, p);</span><br><span class="line"></span><br><span class="line">	dl_util = cpu_util_dl(rq);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * For frequency selection we do not make cpu_util_dl() a permanent part</span></span><br><span class="line"><span class="comment">	 * of this sum because we want to use cpu_bw_dl() later on, but we need</span></span><br><span class="line"><span class="comment">	 * to check if the CFS+RT+DL sum is saturated (ie. no idle time) such</span></span><br><span class="line"><span class="comment">	 * that we select f_max when there is no idle time.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">NOTE:</span> numerical errors or stop class might cause us to not quite hit</span></span><br><span class="line"><span class="comment">	 * saturation when we should -- something for later.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (util + dl_util &gt;= max)</span><br><span class="line">		<span class="keyword">return</span> max;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * OTOH, for energy computation we need the estimated running time, so</span></span><br><span class="line"><span class="comment">	 * include util_dl and ignore dl_bw.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (type == ENERGY_UTIL)</span><br><span class="line">		util += dl_util;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * There is still idle time; further improve the number by using the</span></span><br><span class="line"><span class="comment">	 * irq metric. Because IRQ/steal time is hidden from the task clock we</span></span><br><span class="line"><span class="comment">	 * need to scale the task numbers:</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 *              max - irq</span></span><br><span class="line"><span class="comment">	 *   U&#x27; = irq + --------- * U</span></span><br><span class="line"><span class="comment">	 *                 max</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	util = scale_irq_capacity(util, irq, max);</span><br><span class="line">	util += irq;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Bandwidth required by DEADLINE must always be granted while, for</span></span><br><span class="line"><span class="comment">	 * FAIR and RT, we use blocked utilization of IDLE CPUs as a mechanism</span></span><br><span class="line"><span class="comment">	 * to gracefully reduce the frequency when no tasks show up for longer</span></span><br><span class="line"><span class="comment">	 * periods of time.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Ideally we would like to set bw_dl as min/guaranteed freq and util +</span></span><br><span class="line"><span class="comment">	 * bw_dl as requested freq. However, cpufreq is not yet ready for such</span></span><br><span class="line"><span class="comment">	 * an interface. So, we only do the latter for now.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (type == FREQUENCY_UTIL)</span><br><span class="line">		util += cpu_bw_dl(rq);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> min(max, util);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Cpufreq</tag>
      </tags>
  </entry>
</search>
