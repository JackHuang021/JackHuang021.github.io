<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>从零开始搭建Hexo博客</title>
    <url>/archives/39fb7b7f.html</url>
    <content><![CDATA[<h2 id="Hexo简介"><a href="#Hexo简介" class="headerlink" title="Hexo简介"></a>Hexo简介</h2><p>引用官网的介绍：A fast, simple &amp; powerful blog framework<br>Hexo是一款基于Node.js的静态博客框架，依赖少易于安装使用，可以方便的生成静态网页托管在GitHub上，是搭建博客的首选框架。</p>
<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>基于Ubuntu20.04安装Hexo配置Next主题</p>
<span id="more"></span>

<h3 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h3><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">sudo apt-<span class="builtin-name">get</span> install git</span><br></pre></td></tr></table></figure>
<p>安装完成后进行配置</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">config</span> --<span class="keyword">global</span> user<span class="variable">.email</span> <span class="string">&quot;you@example.com&quot;</span></span><br><span class="line">git <span class="keyword">config</span> --<span class="keyword">global</span> user<span class="variable">.name</span> <span class="string">&quot;Your Name&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h3><p>使用NVM（Node Version Manager）方式进行安装</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">curl -o- https:<span class="regexp">//</span>raw.githubusercontent.com<span class="regexp">/nvm-sh/</span>nvm<span class="regexp">/v0.35.2/i</span>nstall.sh | bash</span><br></pre></td></tr></table></figure>
<p>安装完成后关闭终端重新打开</p>
<h3 id="安装最新版本node"><a href="#安装最新版本node" class="headerlink" title="安装最新版本node"></a>安装最新版本node</h3><p>安装过程中可能会因为网络问题失败，可以尝试挂梯子,安装完成后更新自带npm</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">nvm install <span class="keyword">node</span></span><br><span class="line"><span class="title">npm</span> install npm -g</span><br></pre></td></tr></table></figure>

<h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><p>安装过程中可能会因为网络问题失败，可以多重试几次或挂梯子</p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-<span class="keyword">cli</span></span><br></pre></td></tr></table></figure>

<h3 id="安装Next主题"><a href="#安装Next主题" class="headerlink" title="安装Next主题"></a>安装Next主题</h3><p>Next主题是Hexo比较知名的第三方主题，极简风格，有相当多的使用者，维护也做得比较好<br>不过Next新旧版本的仓库地址不一样，目前最新的GitHub地址<a href="https://github.com/next-theme/hexo-theme-next.git">hexo-theme-next</a><br>Next主题安装比较简单，直接从仓库clone然后修改Hexo配置文件</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">cd blog</span><br><span class="line">git clone https:<span class="regexp">//gi</span>thub.com<span class="regexp">/next-theme/</span>hexo-theme-<span class="keyword">next</span> themes/<span class="keyword">next</span></span><br></pre></td></tr></table></figure>
<p>修改Hexo配置文件<code>_config.yml</code>，将站点主题改为Next，修改如下</p>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line"># Extensions</span><br><span class="line">## Plugins: https:<span class="comment">//hexo.io/plugins/</span></span><br><span class="line">## Themes: https:<span class="comment">//hexo.io/themes/</span></span><br><span class="line">theme: next</span><br></pre></td></tr></table></figure>

<p>全部安装完成后的版本信息如下</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">jack@linux:~/blog/source/_posts$ hexo -v</span></span><br><span class="line">INFO  Validating config</span><br><span class="line">INFO  ==================================</span><br><span class="line">  ███╗   ██╗███████╗██╗  ██╗████████╗</span><br><span class="line">  ████╗  ██║██╔════╝╚██╗██╔╝╚══██╔══╝</span><br><span class="line">  ██╔██╗ ██║█████╗   ╚███╔╝    ██║</span><br><span class="line">  ██║╚██╗██║██╔══╝   ██╔██╗    ██║</span><br><span class="line">  ██║ ╚████║███████╗██╔╝ ██╗   ██║</span><br><span class="line">  ╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝   ╚═╝</span><br><span class="line">========================================</span><br><span class="line">NexT version 8.11.1</span><br><span class="line"><span class="section">Documentation: https://theme-next.js.org</span></span><br><span class="line">========================================</span><br><span class="line"><span class="section">hexo: 5.4.2</span></span><br><span class="line"><span class="section">hexo-cli: 4.3.0</span></span><br><span class="line"><span class="section">os: linux 5.13.0-40-generic Ubuntu 20.04.4 LTS (Focal Fossa)</span></span><br><span class="line"><span class="section">node: 18.2.0</span></span><br><span class="line"><span class="section">v8: 10.1.124.8-node.13</span></span><br><span class="line"><span class="section">uv: 1.43.0</span></span><br><span class="line"><span class="section">zlib: 1.2.11</span></span><br><span class="line"><span class="section">brotli: 1.0.9</span></span><br><span class="line"><span class="section">ares: 1.18.1</span></span><br><span class="line"><span class="section">modules: 108</span></span><br><span class="line"><span class="section">nghttp2: 1.47.0</span></span><br><span class="line"><span class="section">napi: 8</span></span><br><span class="line"><span class="section">llhttp: 6.0.6</span></span><br><span class="line"><span class="section">openssl: 3.0.3+quic</span></span><br><span class="line"><span class="section">cldr: 41.0</span></span><br><span class="line"><span class="section">icu: 71.1</span></span><br><span class="line"><span class="section">tz: 2022a</span></span><br><span class="line"><span class="section">unicode: 14.0</span></span><br><span class="line"><span class="section">ngtcp2: 0.1.0-DEV</span></span><br><span class="line"><span class="section">nghttp3: 0.1.0-DEV</span></span><br></pre></td></tr></table></figure>

<h3 id="初步运行Hexo进行验证"><a href="#初步运行Hexo进行验证" class="headerlink" title="初步运行Hexo进行验证"></a>初步运行Hexo进行验证</h3><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">hexo init <span class="keyword">blog</span></span><br><span class="line"><span class="keyword"></span>cd <span class="keyword">blog</span></span><br><span class="line"><span class="keyword"></span>npm <span class="keyword">install</span></span><br><span class="line"><span class="keyword"></span>hexo server</span><br></pre></td></tr></table></figure>
<p>运行之后可以通过 <a href="http://localhost:4000/">http://localhost:4000</a> 进行访问</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">INFO  Validating config</span><br><span class="line">INFO  ==================================</span><br><span class="line"><span class="code">  ███╗   ██╗███████╗██╗  ██╗████████╗</span></span><br><span class="line"><span class="code">  ████╗  ██║██╔════╝╚██╗██╔╝╚══██╔══╝</span></span><br><span class="line"><span class="code">  ██╔██╗ ██║█████╗   ╚███╔╝    ██║</span></span><br><span class="line"><span class="code">  ██║╚██╗██║██╔══╝   ██╔██╗    ██║</span></span><br><span class="line"><span class="code">  ██║ ╚████║███████╗██╔╝ ██╗   ██║</span></span><br><span class="line"><span class="section">  ╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝   ╚═╝</span></span><br><span class="line"><span class="section">========================================</span></span><br><span class="line">NexT version 8.11.1</span><br><span class="line"><span class="section">Documentation: https://theme-next.js.org</span></span><br><span class="line"><span class="section">========================================</span></span><br><span class="line">INFO  Start processing</span><br><span class="line">INFO  Hexo is running at http://localhost:4000 . Press Ctrl+C to stop.</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/imageshexo_next_theme.png"></p>
<h3 id="部署GitHub远程服务器"><a href="#部署GitHub远程服务器" class="headerlink" title="部署GitHub远程服务器"></a>部署GitHub远程服务器</h3><h4 id="创建GitHub项目"><a href="#创建GitHub项目" class="headerlink" title="创建GitHub项目"></a>创建GitHub项目</h4><p>在GitHub上注册账号，注册后上传ssh公钥，便于后续的部署操作<br>创建一个与你用户名对应的项目<code>username.github.io</code>，例如我创建的项目地址为<code>https://github.com/JackHuang021/JackHuang021.github.io.git</code>  </p>
<h4 id="进行部署"><a href="#进行部署" class="headerlink" title="进行部署"></a>进行部署</h4><p>部署需要用到<code>hexo deploy</code>上传到GitHub仓库，这里需要下载部署插件，并修改hexo配置文件<code>_config.yml</code>，<br>我们很多的博客设置都可以在这个配置文件里面进行修改<br>首先安装Git部署插件</p>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cd</span> ~<span class="string">/blog</span></span><br><span class="line">npm install hex-deployer-git <span class="params">--save</span></span><br></pre></td></tr></table></figure>
<p>修改博客配置文件<code>_config.yml</code>，增加如下内容</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="meta"># Deployment</span></span><br><span class="line"><span class="meta">## Docs: https:<span class="comment">//hexo.io/docs/one-command-deployment</span></span></span><br><span class="line"><span class="symbol">deploy:</span></span><br><span class="line"><span class="symbol">  type:</span> git</span><br><span class="line"><span class="symbol">  repo:</span> git@github.com:JackHuang021/JackHuang021.github.io.git</span><br><span class="line"><span class="symbol">  branch:</span> master</span><br></pre></td></tr></table></figure>
<p>最后使用<code>hexo d</code>进行上传部署，现在访问<code>username.github.io</code>便可以看到博客页面了<br>后续更新博客设置或者文章的话需要再次进行上传部署<code>hexo g -d</code></p>
<h3 id="Hexo博客备份"><a href="#Hexo博客备份" class="headerlink" title="Hexo博客备份"></a>Hexo博客备份</h3><p>Hexo在进行部署时，是将页面内容解析后放在<code>.depoly_git</code>中进行上传GitHub仓库，博客内文章源文件并未进行上传，所以还需要手动将这些文件进行手动上传。目前比较常用的方法是在原GitHub仓库建立一条分支，将这些文件上传到该分支。</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cd</span> blog </span><br><span class="line">git init </span><br><span class="line">git submodule <span class="built_in">add</span> http<span class="variable">s:</span>//github.<span class="keyword">com</span>/<span class="keyword">next</span>-theme/hexo-theme-<span class="keyword">next</span>.git themes/<span class="keyword">next</span></span><br><span class="line">git <span class="built_in">add</span> .</span><br><span class="line">git commit -<span class="keyword">m</span> <span class="string">&quot;init blog backup&quot;</span></span><br><span class="line">git branch -<span class="keyword">m</span> master hexo</span><br><span class="line">git remote <span class="built_in">add</span> origin git@github.<span class="keyword">com</span>:JackHuang021/JackHuang021.github.io.git</span><br><span class="line">git push -<span class="keyword">u</span> origin hexo</span><br></pre></td></tr></table></figure>

<h3 id="恢复Hexo博客"><a href="#恢复Hexo博客" class="headerlink" title="恢复Hexo博客"></a>恢复Hexo博客</h3><ol>
<li>按照之前的步骤搭建Hexo环境</li>
<li>clone之前备份的hexo分支内容<code>git clone --recursive -b hexo git@github.com:JackHuang021/JackHuang021.github.io.git blog</code></li>
<li>下载npm依赖模块<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> blog</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure></li>
<li>clone master分支内容<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">cd blog</span><br><span class="line">git clone git@github<span class="selector-class">.com</span>:JackHuang021/JackHuang021<span class="selector-class">.github</span><span class="selector-class">.io</span><span class="selector-class">.git</span> <span class="selector-class">.deploy_git</span> </span><br></pre></td></tr></table></figure></li>
<li>正常更新、部署博客<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">hexo g</span></span><br><span class="line"><span class="attribute">hexo s</span></span><br><span class="line"><span class="attribute">hexo d</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="关于Hexo使用的思考"><a href="#关于Hexo使用的思考" class="headerlink" title="关于Hexo使用的思考"></a>关于Hexo使用的思考</h3><p>我觉得Hexo最大的特点就是便捷，借助GitHub可以在多台设备中无缝切换进行博客写作，服务器的维护工作基本不需要作者进行，换设备后直接搭建hexo环境，从GitHub拉取博客内容即可。</p>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
        <tag>博客搭建</tag>
        <tag>博客备份恢复</tag>
      </tags>
  </entry>
  <entry>
    <title>ssh使用密钥实现免密登录</title>
    <url>/archives/37d9659b.html</url>
    <content><![CDATA[<h3 id="本地ssh客户端准备ssh密钥"><a href="#本地ssh客户端准备ssh密钥" class="headerlink" title="本地ssh客户端准备ssh密钥"></a>本地ssh客户端准备ssh密钥</h3><p>ssh密钥默认保存路径<code>~/.ssh</code>，进入该目录查看是否已存在生成的密钥</p>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ls</span> -al ~<span class="string">/.ssh</span></span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220601093641.png"></p>
<span id="more"></span>
<p>如上图，<code>id_rsa.pub</code>和<code>qtc_id.pub</code>都是公钥<br>如果没有公钥，可以使用<code>ssh-keygen</code>生成</p>
<h3 id="上传ssh公钥到ssh服务器"><a href="#上传ssh公钥到ssh服务器" class="headerlink" title="上传ssh公钥到ssh服务器"></a>上传ssh公钥到ssh服务器</h3><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">ssh-<span class="keyword">copy</span>-id -i ~<span class="regexp">/.ssh/i</span>d_rsa.pub username@ip_address</span><br></pre></td></tr></table></figure>
<p>执行后会提示输入服务器用户密码</p>
<h3 id="测试ssh免密登录"><a href="#测试ssh免密登录" class="headerlink" title="测试ssh免密登录"></a>测试ssh免密登录</h3><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">ssh <span class="symbol">username@</span>ip_address</span><br></pre></td></tr></table></figure>
<p>如果可以直接登录，说明已经配置成功<br>都2022年了，不要在输入密码上再浪费更多时间了</p>
<h3 id="删除免密登录"><a href="#删除免密登录" class="headerlink" title="删除免密登录"></a>删除免密登录</h3><p>上传公钥后，服务端<code>.ssh/authorized_keys</code>文件中会添加一行内容，就是本地客户端的公钥，编辑该文件删除改行，即可禁用客户端免密登录<br><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220601094901.png"></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title>imx6ull OpenCV4.5 交叉编译</title>
    <url>/archives/e4359116.html</url>
    <content><![CDATA[<h4 id="交叉编译环境"><a href="#交叉编译环境" class="headerlink" title="交叉编译环境"></a>交叉编译环境</h4><ul>
<li>Ubuntu版本：Ubuntu20.04 64bits</li>
<li>交叉编译工具：arm-linux-gnueabihf-</li>
<li>硬件平台正点原子IMX6ULL (ALPHA)</li>
</ul>
<span id="more"></span>

<h4 id="准备源码和交叉编译工具链"><a href="#准备源码和交叉编译工具链" class="headerlink" title="准备源码和交叉编译工具链"></a>准备源码和交叉编译工具链</h4><p>Linux环境下的编译方法可以参考<a href="https://docs.opencv.org/4.x/d7/d9f/tutorial_linux_install.html">Opencv安装官网教程</a></p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">wget -O opencv.zip https:<span class="regexp">//gi</span>thub.com<span class="regexp">/opencv/</span>opencv<span class="regexp">/archive/</span><span class="number">4</span>.x.zip</span><br><span class="line">unzip opencv.zip</span><br></pre></td></tr></table></figure>
<p>交叉编译工具链版本<br><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220602095241.png"></p>
<h4 id="安装cmake和cmake-gui工具"><a href="#安装cmake和cmake-gui工具" class="headerlink" title="安装cmake和cmake-gui工具"></a>安装cmake和cmake-gui工具</h4><p>在命令行使用cmake工具确实很不方便，cmake-gui配置起来比较省时间<br><code>sudo apt-get install cmake cmake-qt-gui  cmake-curses-gui</code>  </p>
<h4 id="配置交叉编译环境"><a href="#配置交叉编译环境" class="headerlink" title="配置交叉编译环境"></a>配置交叉编译环境</h4><ol>
<li>运行cmake-gui<br><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220602100408.png">  </li>
<li>在第一个框输入OpenCV源码路径，在第二个框输入OpenCV编译目录  </li>
<li>点击<code>Configure</code>配置交叉编译环境<br><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220602100750.png"></li>
<li>选择<code>Spcify options for cross-compile</code>  </li>
<li>按照下图设置交叉编译工具链<br><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220602101028.png"></li>
<li>点击<code>Finish</code>回到cmake-gui主页面，勾选Advanced<br><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220602101237.png"></li>
</ol>
<h4 id="配置cmake选项"><a href="#配置cmake选项" class="headerlink" title="配置cmake选项"></a>配置cmake选项</h4><ol>
<li>在CMAKE_EXE_LINKER_FLAGS处添加上<code>-lpthread -lrt -ldl</code><br><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220602101546.png"></li>
<li>在CMAKE_INSTALL_PREFIX处指定安装目录，如果不指定，它会默认安装到Ubuntu系统目录<code>/usr/local</code>下。  </li>
<li>取消<code>BUILD_opencv_gapi</code>选项，不取消这个选项后续编译的时候会报错</li>
<li>再依次点击<code>Configure</code>， <code>Generate</code>，击了Generate后看到信息像如下图一样，表明生成成功，一般按照上面配置后基本都不会报错。<br><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220602102258.png"></li>
</ol>
<h4 id="编译OpenCV"><a href="#编译OpenCV" class="headerlink" title="编译OpenCV"></a>编译OpenCV</h4><ol>
<li>打开之前设置的imx6编译目录，该目录下有刚才生成的Makefile  </li>
<li>输入<code>make -j12</code>开始编译</li>
<li>编译完成后输入<code>make install</code>，OpenCV的库和头文件会安装到之前设置的<code>CMAKE_INSTALL_PREFIX</code>目录</li>
</ol>
<h4 id="编译过程中遇到的错误"><a href="#编译过程中遇到的错误" class="headerlink" title="编译过程中遇到的错误"></a>编译过程中遇到的错误</h4><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">/home/</span>tanyd<span class="regexp">/zdyz/</span>linaro494<span class="regexp">/arm-linux-gnueabihf/</span>libc<span class="regexp">/usr/i</span>nclude/features.h:<span class="number">311</span>:<span class="number">52</span>: error: operator <span class="string">&#x27;&amp;&amp;&#x27;</span> has no right operand <span class="comment">#if defined _FILE_OFFSET_BITS &amp;&amp; _FILE_OFFSET_BITS == 64</span></span><br></pre></td></tr></table></figure>
<p>解决方法： 在<code>#if defined</code>前面加上 <code>#define _FILE_OFFSET_BITS 64</code>  </p>
<h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><ol>
<li><a href="https://blog.csdn.net/qq_26943851/article/details/104434130">正点原子IMX6ULL移植OpenCV3.4.1</a></li>
<li><a href="https://blog.csdn.net/u011827554/article/details/123657141">imx6ull编译opencv4.4问题整理</a></li>
</ol>
]]></content>
      <categories>
        <category>OpenCV</category>
      </categories>
      <tags>
        <tag>imx6ull OpenCV 交叉编译</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu安装搜狗输入法的问题记录</title>
    <url>/archives/245a6c83.html</url>
    <content><![CDATA[<ul>
<li>最近在帮一个客户安装搜狗输入法时遇到了安装后无候选框的问题，记录一下该问题的解决办法，今天进入官网查看，官网已经修改安装指南，建议按照官网指南安装，本文截图来自搜狗官网</li>
</ul>
<h4 id="Ubuntu搜狗输入法下载"><a href="#Ubuntu搜狗输入法下载" class="headerlink" title="Ubuntu搜狗输入法下载"></a>Ubuntu搜狗输入法下载</h4><ul>
<li><a href="https://pinyin.sogou.com/linux?r=pinyin">搜狗输入法Linux版官网</a>，目前最新版本为V4.0.1</li>
<li><a href="https://pinyin.sogou.com/linux/guide">搜狗输入法Linux版安装指南</a></li>
</ul>
<span id="more"></span>

<h4 id="Ubuntu20-04安装步骤"><a href="#Ubuntu20-04安装步骤" class="headerlink" title="Ubuntu20.04安装步骤"></a>Ubuntu20.04安装步骤</h4><ol>
<li>添加中文语言支持，打开 系统设置——区域和语言——管理已安装的语言——在“语言”tab下——点击“添加或删除语言”<br><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220606092214.png"></li>
<li>弹出“已安装语言”窗口，勾选中文（简体），点击应用<br><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220606092221.png"></li>
<li>安装fcitx输入法框架<code>sudo apt-get install fcitx</code></li>
<li>卸载系统ibus输入法框架<code>sudo apt purge ibus</code></li>
<li>回到“语言支持”窗口，在键盘输入法系统中，选择<code>fcitx</code><br><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220606092226.png"></li>
<li>通过命令行安装搜狗输入法<code>sudo dpkg -i sogoupinyin_版本号_amd64.deb</code>，如果安装过程中提示缺少相关依赖，则执行如下命令解决：<code>sudo apt -f install</code></li>
<li>安装输入法依赖<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">sudo</span> apt install libqt<span class="number">5</span>qml<span class="number">5</span> libqt<span class="number">5</span>quick<span class="number">5</span> libqt<span class="number">5</span>quickwidgets<span class="number">5</span> qml-module-qtquick<span class="number">2</span></span><br><span class="line"><span class="attribute">sudo</span> apt install libgsettings-qt<span class="number">1</span></span><br></pre></td></tr></table></figure></li>
<li>点击“应用到整个系统”，关闭窗口，重启电脑</li>
<li>查看状态栏右上角，可以看到“搜狗”字样，在输入窗口即可使用搜狗输入法。没有“搜狗”字样，选择配置，将搜狗加入输入法列表即可。<br><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220606094224.png"><br><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220606094237.png"><br><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220606094048.png"></li>
</ol>
<h4 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h4><ul>
<li>安装完成后输入候选框不出现，只能输入英文</li>
<li>解决办法，安装qt依赖库可以解决<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">sudo</span> apt install libqt<span class="number">5</span>qml<span class="number">5</span> libqt<span class="number">5</span>quick<span class="number">5</span> libqt<span class="number">5</span>quickwidgets<span class="number">5</span> qml-module-qtquick<span class="number">2</span></span><br><span class="line"><span class="attribute">sudo</span> apt install libgsettings-qt<span class="number">1</span></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>搜狗输入法</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCV图像容器Mat</title>
    <url>/archives/d2c86892.html</url>
    <content><![CDATA[<h4 id="图像的存储"><a href="#图像的存储" class="headerlink" title="图像的存储"></a>图像的存储</h4><p><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220608085010.png"><br>借助官方这张很有代表性的图片，在计算机中以像素值的方式存储图像中的每个像素点，所有像素值以类似矩阵的二维数组形式进行存储。官网给OpenCV的定义：OpenCV是一个计算机视觉库，主要的目的就是在这些像素值上进行处理、计算，所以首先就需要学习OpenCV是怎么存储、处理这些图像的。</p>
<span id="more"></span>

<h4 id="Mat介绍"><a href="#Mat介绍" class="headerlink" title="Mat介绍"></a>Mat介绍</h4><ul>
<li>OpenCV起始于2001年，最开始是基于C语言编写，图像存储在C结构体<code>IplImage</code>。</li>
<li>OpenCV2.0基于C++进行重写，图像以Mat类进行存储。</li>
<li>Mat类包含两部分数据：  <ol>
<li>图像数据头部分，包含图像尺寸、存储方式、图像数据指针等信息</li>
<li>图像数据部分</li>
</ol>
</li>
<li>每个Mat对象都独立的保存数据头部分，但是可能共享图像数据部分。</li>
<li>Mat的拷贝构造只会拷贝数据头部分，数据部分不会进行拷贝。  <figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">Mat A, C;                          <span class="comment">// creates just the header parts</span></span><br><span class="line">A = imread<span class="comment">(argv[1], IMREAD_COLOR)</span>; <span class="comment">// here we&#x27;ll know the method used (allocate matrix)</span></span><br><span class="line">Mat B<span class="comment">(A)</span>;                          <span class="comment">// Use the copy constructor</span></span><br><span class="line">C = A;                             <span class="comment">// Assignment operator</span></span><br></pre></td></tr></table></figure></li>
<li>Mat类有一个引用计数机制，进行拷贝构造时引用加1，Mat对象析构时引用减1，当引用变为0时，释放数据部分内存。</li>
<li>当需要进行数据部分拷贝时，OpenCV提供了<code>cv::Mat::clone()</code>和<code>cv::Mat::copyTo</code>两个方法</li>
</ul>
<h4 id="Mat数据存储方式"><a href="#Mat数据存储方式" class="headerlink" title="Mat数据存储方式"></a>Mat数据存储方式</h4><ul>
<li>根据颜色空间和数据类型来选择图像数据存储方式</li>
</ul>
<h4 id="Mat对象操作"><a href="#Mat对象操作" class="headerlink" title="Mat对象操作"></a>Mat对象操作</h4><ul>
<li>使用<code>cv::Mat::Mat</code>构造函数进行创建<code>Mat img(2, 2, CV_8UC3, Scalar(0, 0, 255))</code>，指定图像的行和列大小、像素数据类型、像素颜色通道，如<code>CV_8UC3</code>表示8位无符号数据，颜色通道为3，由以下方式进行定义<br><code>CV_[The number of bits per item][Signed or Unsigned][Type Prefix]C[The channel number]</code></li>
<li>类似MATLAB方式创建单位矩阵<code>cv::Mat::eyes</code>、零矩阵<code>cv::Mat::zeros</code>、元素全为1的矩阵<code>cv::Mat::ones</code>  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Mat E = Mat::<span class="built_in">eye</span>(<span class="number">4</span>, <span class="number">4</span>, CV_64F);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;E = &quot;</span> &lt;&lt; endl &lt;+ Mat对象的打印</span><br><span class="line"><span class="number">1.</span> 默认输出&lt; <span class="string">&quot; &quot;</span> &lt;&lt; E &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line">Mat O = Mat::<span class="built_in">ones</span>(<span class="number">2</span>, <span class="number">2</span>, CV_32F);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;O = &quot;</span> &lt;&lt; endl &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; O &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line">Mat Z = Mat::<span class="built_in">zeros</span>(<span class="number">3</span>,<span class="number">3</span>, CV_8UC1);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Z = &quot;</span> &lt;&lt; endl &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; Z &lt;&lt; endl &lt;&lt; endl;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>OpenCV</category>
      </categories>
      <tags>
        <tag>OpenCV Mat</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCV图像操作</title>
    <url>/archives/117a3b0c.html</url>
    <content><![CDATA[<h4 id="图像读取和保存"><a href="#图像读取和保存" class="headerlink" title="图像读取和保存"></a>图像读取和保存</h4><ul>
<li>图像读取<code>Mat img = imread(filename)</code></li>
<li>图像保存<code>imwrite(filename, img)</code><span id="more"></span></li>
</ul>
<h4 id="像素级操作"><a href="#像素级操作" class="headerlink" title="像素级操作"></a>像素级操作</h4><ul>
<li>获取单通道灰度图像(x, y)位置像素值<code>Scalar intensity = img.at&lt;uchar&gt;(Point(x, y));</code></li>
<li>修改像素值<code>img.at&lt;uchar&gt;(Point(x, y)) = 128</code></li>
<li>获取3通道BGR颜色空间图像(x, y)位置像素值  <figure class="highlight sml"><table><tr><td class="code"><pre><span class="line"><span class="type">Vec3b</span> <span class="built_in">vector</span> = img.at&lt;<span class="type">Vec3b</span>&gt;(<span class="type">Point</span>(x, y));</span><br><span class="line">uchar blue = <span class="built_in">vector</span>.<span class="keyword">val</span>[<span class="number">0</span>];</span><br><span class="line">uchar green = <span class="built_in">vector</span>.<span class="keyword">val</span>[<span class="number">1</span>];</span><br><span class="line">uchar red = <span class="built_in">vector</span>.<span class="keyword">val</span>[<span class="number">2</span>];</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="图像基本操作"><a href="#图像基本操作" class="headerlink" title="图像基本操作"></a>图像基本操作</h4><ul>
<li>选取图像某个区域  <figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Rect</span> r(<span class="number">10</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line"><span class="attribute">Mat</span> smallImg = img(r);</span><br></pre></td></tr></table></figure></li>
<li>颜色空间转换  <figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">Mat img = imread(<span class="string">&quot;image.jpg&quot;</span>);</span><br><span class="line">Mat gray;</span><br><span class="line">cvt<span class="constructor">Color(<span class="params">img</span>, <span class="params">gray</span>, COLOR_BGR2GRAY)</span>;</span><br></pre></td></tr></table></figure></li>
<li>数据类型转换<code>src.convertTo(dst, CV_32F)</code></li>
<li>图像显示  <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">Mat img = imread(<span class="string">&quot;image.jpg&quot;</span>)<span class="comment">;</span></span><br><span class="line">namedWindow(<span class="string">&quot;image&quot;</span>, WINDOW_AUTOSIZE)<span class="comment">;</span></span><br><span class="line">imshow(<span class="string">&quot;image&quot;</span>, img)<span class="comment">;</span></span><br><span class="line">waitKey()<span class="comment">;</span></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>OpenCV</category>
      </categories>
      <tags>
        <tag>OpenCV Image</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCV 图像处理基本操作</title>
    <url>/archives/6465c2cc.html</url>
    <content><![CDATA[<h4 id="基于Mat类的图像操作"><a href="#基于Mat类的图像操作" class="headerlink" title="基于Mat类的图像操作"></a>基于Mat类的图像操作</h4><p><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220608085010.png"></p>
<ul>
<li>Mat类分为两个数据部分：数据头部分（保存矩阵大小、矩阵存储方式等信息）、矩阵数据部分， 一般的Mat对象复制构造仅拷贝数据头部分，矩阵数据部分共享。也可以通过<code>cv::Mat::copyTo</code>和<code>cv::Mat::clone</code>进行深度拷贝。<span id="more"></span></li>
<li>Mat构造函数<code>Mat img(2, 2, CV_8UC3, Scalar(0, 0, 255))</code>， 需要明确矩阵大小、矩阵存储数据类型、像素颜色通道数、像素值。</li>
<li>CV_8UC3含义表示8位无符号数据，颜色通道为3，含义参考：<code>CV_[The number of bits per item][Signed or Unsigned][Type Prefix]C[The channel number]</code></li>
<li>几种特殊矩阵的构造，<code>cv::Mat::eyes</code>单位矩阵、<code>cv::Mat::zeros</code>零矩阵、<code>cv::Mat::ones</code>全1矩阵</li>
</ul>
<h4 id="图像卷积操作"><a href="#图像卷积操作" class="headerlink" title="图像卷积操作"></a>图像卷积操作</h4><ul>
<li><p>根据kernel矩阵重新计算图像中每个像素的值，<em>h(k, j)</em> 为kernel，使用<code>filter2D</code>进行卷积操作<br>  <img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220609163143.png"></p>
  <figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">CV_EXPORTS_W <span class="type">void</span> filter2D( InputArray src, </span><br><span class="line">                            OutputArray dst, </span><br><span class="line">                            <span class="type">int</span> ddepth, </span><br><span class="line">                            InputArray kernel, </span><br><span class="line">                            <span class="type">Point</span> anchor = <span class="type">Point</span>(<span class="number">-1</span>,<span class="number">-1</span>), </span><br><span class="line">                            <span class="type">double</span> delta = <span class="number">0</span>, </span><br><span class="line">                            <span class="type">int</span> borderType = BORDER_DEFAULT );</span><br></pre></td></tr></table></figure></li>
<li><p>使用图像卷积进行图像模糊（平滑）</p>
<ol>
<li>简单的图像平滑，Kernel模型如下<br>  <img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220609163417.png"></li>
<li>高斯模糊，根据距当前像素点的距离决定平滑的权重，一维高斯核的图像如下<br>  <img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220609163925.png"><br>  二维高斯公式，其中μ为平均值，σ为方差<br>  <img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220609164447.png"></li>
<li>中值滤波，将像素点周围区域内的像素进行排序，采用中间位置的像素值作为当前像素点的值</li>
<li>双边滤波，权重由两部分来决定，第一部分是类似于二维高斯，另一部分由颜色差异来决定，这样可以比较好的保留边缘信息。</li>
</ol>
</li>
<li><p>图像边界处理，使用<code>copyMakeBorder</code>给图像创建一个边框</p>
<ol>
<li><code>BORDER_CONTANT</code>，使用固定像素值填充创建的边框</li>
<li><code>BORDER_REPLICATE</code>，复制原图像中的边界值</li>
</ol>
</li>
<li><p>使用图像卷积进行形态学操作，主要针对阈值化后的图像</p>
<ol>
<li>膨胀 Dilate，使用Kernel范围内的最大值取代当前像素值<br>  膨胀二值化图像<br>  <img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220610150255.png"><br>  膨胀灰度图像<br>  <img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220610150405.png"></li>
<li>腐蚀 Erode，使用Kernel范围内的最小值取代当前像素值<br>  腐蚀二值化图像<br>  <img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220610150527.png"><br>  腐蚀灰度图像<br>  <img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220610150618.png"></li>
<li>开操作 Opening，先腐蚀后膨胀，去除暗黑背景中细小的噪点，原理 *dst &#x3D; open(src, element) &#x3D; dilate(erode(src, element))*， <em>element</em>为kernel</li>
<li>闭操作 Closing，先膨胀后腐蚀，去除明亮背景中的细小噪点，原理 <em>dst &#x3D; close(src, element) &#x3D; erode(dilate(src, element))</em></li>
<li>形态梯度 Morphological Gradient，膨胀图像与腐蚀图像的差，用来找出物体轮廓，原理 <em>dst &#x3D; morphy(src, element) &#x3D; dilate(src, element) - erode(src, element)</em></li>
<li>高帽 Top Hat</li>
</ol>
</li>
<li><p>也可以使用 <em>getStructuringElement</em> 创造指定形状和大小的Kernel，进行图像的特征提取，如官方教程<a href="https://docs.opencv.org/4.x/dd/dd7/tutorial_morph_lines_detection.html">提取乐谱中的直线和音符</a>，就是借助形态学开操作进行直线和音符的提取。</p>
</li>
</ul>
<h4 id="图像融合"><a href="#图像融合" class="headerlink" title="图像融合"></a>图像融合</h4><ul>
<li>图像融合公式<code>dst = src1*alpha + src2*beta + gamma</code>，使用<code>addWeighted()</code>进行融合。  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cv::addWeighted</span><span class="params">( InputArray src1,</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="keyword">double</span> alpha,</span></span></span><br><span class="line"><span class="params"><span class="function">                      InputArray src2,</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="keyword">double</span> beta,</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="keyword">double</span> gamma,</span></span></span><br><span class="line"><span class="params"><span class="function">                      OutputArray dst,</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="keyword">int</span> dtype = <span class="number">-1</span> )</span></span>;	</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="改变图像对比度和亮度"><a href="#改变图像对比度和亮度" class="headerlink" title="改变图像对比度和亮度"></a>改变图像对比度和亮度</h4><ul>
<li>公式<code>g(x)=αf(x)+β</code>改变α的值可以改变图像的对比度，改变β的值可以改变图像的亮度</li>
<li>Gamma校准，使用查找表，按照如下公式对像素值进行一个非线性的转换 <em>O &#x3D; (I &#x2F; 255)^γ × 255</em>，γ越大整体亮度降低。<br><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220609161302.png"></li>
</ul>
<h4 id="图像的缩放"><a href="#图像的缩放" class="headerlink" title="图像的缩放"></a>图像的缩放</h4><ul>
<li>高斯金字塔(Gaussian Pyramid)，从底部开始计数，第 <em>i+1</em> 层表示为 <em>G(i + 1)</em><br><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220613132715.png"></li>
<li>*G(i + 1)<em>层的变换过程，由</em>G(i)*层先进行高斯模糊，然后丢掉偶数行和偶数列的像素，即图像缩小的操作</li>
<li>图像放大的操作，图像放大两倍，在奇数行和奇数列填充0像素，再进行高斯模糊<br><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220613141653.png"></li>
</ul>
<h4 id="图像阈值操作threshold的几种方法"><a href="#图像阈值操作threshold的几种方法" class="headerlink" title="图像阈值操作threshold的几种方法"></a>图像阈值操作<em>threshold</em>的几种方法</h4><ol>
<li>二值化（Threshold Binary），<code>src(x, y)</code>大于阈值<code>threshold</code>则置为最大值，否则置为0</li>
<li>反向二值化（Threshold Binary, Inverted），<code>src(x, y)</code>小于阈值<code>threshold</code>则置为最大值，否则置为0</li>
<li>截取像素值（Truncate），<code>src(x, y)</code>大于阈值<code>threshold</code>则令<code>src(x, y)</code>等于<code>threshold</code>，否则不变</li>
<li>只保留超过阈值部分，<code>src(x, y)</code>大于阈值<code>threshold</code>则置为原值，否则置为0</li>
<li>只保留小于阈值部分，<code>src(x, y)</code>小于阈值<code>threshold</code>则置为0，否则不变</li>
</ol>
<h4 id="图像像素梯度计算"><a href="#图像像素梯度计算" class="headerlink" title="图像像素梯度计算"></a>图像像素梯度计算</h4><ul>
<li><p><code>Sobel</code>边缘检测算子，利用图像边缘像素强度值变化非常显著的特点，使用特殊的卷积核计算水平方向的梯度变化和竖直方向的梯度变化。如下图是图像边缘像素强度的变化曲线的一维图像和该图像像素强度变化梯度图像（即导数图像），像素强度变化最剧烈的地方就可能是物体边缘。<br><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220614155216.png"> <img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220614160139.png">  </p>
</li>
<li><p>利用特殊的卷积核计算水平梯度变化和垂直梯度变化，然后再融合两个梯度图像<br><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220614160526.png"> <img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220614160536.png"><br><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220614160543.png"> <img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220614160552.png"></p>
</li>
<li><p>利用二级导数，像素强度变化剧烈的点即一阶导数极值点，其二级导数值接近0，拉普拉斯算子<code>Laplacian</code>计算水平方向和竖直方向上二级导数的和，OpenCV提供的<code>Laplacian()</code>函数，内部也是通过调用<code>Sobel()</code>来计算的，如下图二级导数图像和拉普拉斯公式。<br><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220624144442.png"><br><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220624144513.png"></p>
</li>
<li><p><code>Canny</code>边缘检测，1986年由John F. Canny提出，被认为是最优的边缘检测算法，其具有三个主要的特点：较低的错误率、较好的边缘定位、较快的检测速度，其检测步骤如下：</p>
<ol>
<li>使用高斯平滑模糊图像</li>
<li>计算图像亮度梯度图像，其过程与Sobel算子类似，分别计算x y方向上的梯度，再进行融合</li>
<li>去掉不是很连续的像素点，认为其不属于边缘</li>
<li>使用两个阈值，一大一小，其比例一般为2:1或者3:1，高于upper阈值认为其为边缘，低于lower阈值丢弃该像素点，介于upper与lower之间的像素点则看邻接像素点是否高于upper，是的话接受其为边缘</li>
</ol>
</li>
</ul>
<h4 id="霍夫变换直线检测"><a href="#霍夫变换直线检测" class="headerlink" title="霍夫变换直线检测"></a>霍夫变换直线检测</h4><ul>
<li>图像转化为灰度颜色，首先进行高斯模糊</li>
<li>再进行边缘检测，使其变成了一个二值化包含边缘的图像</li>
<li>经过该图像上像素点（x0, y0）的所有直线的方程可以表述为如下，霍夫变换检测每一个像素点的经过直线的条数，经过的直线条数到达一定阈值后可认为该</li>
</ul>
]]></content>
      <categories>
        <category>OpenCV</category>
      </categories>
      <tags>
        <tag>OpenCV Core</tag>
      </tags>
  </entry>
  <entry>
    <title>HI3559AV100调试记录</title>
    <url>/archives/7803046f.html</url>
    <content><![CDATA[<h4 id="内核编译与烧写"><a href="#内核编译与烧写" class="headerlink" title="内核编译与烧写"></a>内核编译与烧写</h4><ul>
<li>内核版本4.9.37，Linux内核源码如下<br><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220609101727.png"><span id="more"></span></li>
<li>编译<code>make ARCH=arm64 CROSS_COMPILE=aarch64-himix100-linux- uImage -j12</code>，编译完成结果如下，编译完成后会在arch&#x2F;arm64&#x2F;boot&#x2F;生成UImage<br><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220609101926.png"></li>
<li>arm-trusted-firmware目录中运行mk.sh生成fip.bin<br><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220609110821.png"></li>
<li>主机搭建tftp服务器，将fip.bin拷贝到共享目录</li>
<li>进入uboot，配置ethact ipaddr serverip环境变量<br><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220609111122.png"></li>
<li>从tftp加载内核，测试内核是否能启动、  <figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">tftp</span> fip.bin <span class="number">0</span>x<span class="number">42000000</span></span><br><span class="line"><span class="attribute">bootm</span> <span class="number">0</span>x<span class="number">42000000</span></span><br></pre></td></tr></table></figure></li>
<li>烧写内核到emmc  <figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">tftp</span> fip.bin <span class="number">0</span>x<span class="number">42000000</span></span><br><span class="line"><span class="attribute">mmc</span> dev <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="attribute">mmc</span> write <span class="number">0</span> <span class="number">0</span>x<span class="number">42000000</span> <span class="number">800</span> <span class="number">4800</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="驱动调试"><a href="#驱动调试" class="headerlink" title="驱动调试"></a>驱动调试</h4><ul>
<li>参照正点原子教程搭建驱动调试环境，配置的<em>Makefile</em>内容如下  <figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">KERNEL_DIR = /home/jack/hisi/minimum_system/linux-4.9.y_multi-core</span><br><span class="line">CURRENT_PATH = <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line">obj-m := gpio-pca953x.o</span><br><span class="line"></span><br><span class="line"><span class="section">build: kernel_modules</span></span><br><span class="line"></span><br><span class="line"><span class="section">kernel_modules: </span></span><br><span class="line"><span class="variable">$(MAKE)</span> ARCH=arm64 CROSS_COMPILE=aarch64-himix100-linux- -C <span class="variable">$(KERNEL_DIR)</span> M=<span class="variable">$(CURRENT_PATH)</span> modules</span><br><span class="line"></span><br><span class="line"><span class="section">clean: </span></span><br><span class="line"><span class="variable">$(MAKE)</span> ARCH=arm64 CROSS_COMPILE=aarch64-himix100-linux- -C <span class="variable">$(KERNEL_DIR)</span> M=<span class="variable">$(CURRENT_PATH)</span> clean</span><br></pre></td></tr></table></figure></li>
<li><em>KERNEL_DIR</em>表示Linux内核源码目录，使用绝对路径</li>
<li><em>CURRENT_PATH</em>表示当前路径，直接使用<em>pwd</em>来获取当前路径</li>
<li><em>obj-m</em>表示将这个c文件编译为ko模块</li>
<li><em>modules</em>表示编译模块，*-C*表示将当前的工作目录切换到指定目录中， <em>M</em>表示模块源码目录</li>
<li><em>make modules</em>命令中加入 M&#x3D;dir 以后程序会自动到指定的 dir 目录中读取模块的源码并将其编译为.ko 文件</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Hi3559AV100 Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux Input子系统按键连按驱动调试记录</title>
    <url>/archives/e19e1ecc.html</url>
    <content><![CDATA[<h4 id="Linux-Input子系统介绍"><a href="#Linux-Input子系统介绍" class="headerlink" title="Linux Input子系统介绍"></a>Linux Input子系统介绍</h4><blockquote>
<p>按键、鼠标、键盘、触摸屏等都属于输入(input)设备, Linux 内核为此专门做了一个叫做 input子系统的框架来处理输入事件。输入设备本质上还是字符设备,只是在此基础上套上了 input 框架,用户只需要负责上报输入事件,比如按键值、坐标等信息, input 核心层负责处理这些事件。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220609141734.png"></p>
<span id="more"></span>

<h4 id="input驱动编写流程"><a href="#input驱动编写流程" class="headerlink" title="input驱动编写流程"></a>input驱动编写流程</h4><ul>
<li><p>注册input_dev</p>
<ol>
<li>使用<em>input_allocate_device</em>申请一个<em>input_dev</em>结构体</li>
<li>初始化<em>input_dev</em>的事件类型以及事件值</li>
<li>使用<em>input_register_device</em>函数向系统注册<em>input_dev</em></li>
<li><strong>按键需要实现连按时<em>evbit</em>需要设置<em>EV_REP</em>标志，调按键驱动时在调连按功能时在这里卡了很久</strong>  <figure class="highlight xl"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">chip</span>-&gt;</span>input = input_allocate_device();</span><br><span class="line"><span class="function"><span class="title">if</span> (!chip-&gt;</span>input) </span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_ERR <span class="string">&quot;Unable to allocate the input device !!\n&quot;</span>);</span><br><span class="line">    return -ENOMEM;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">chip</span>-&gt;</span><span class="function"><span class="title">input</span>-&gt;</span><span class="keyword">name</span> = <span class="string">&quot;pca953x_button&quot;</span>;</span><br><span class="line"><span class="function"><span class="title">set_bit</span>(EV_KEY, chip-&gt;</span><span class="function"><span class="title">input</span>-&gt;</span>evbit);     <span class="comment">/* 设置产生按键事件 */</span> </span><br><span class="line"><span class="function"><span class="title">set_bit</span>(EV_REP, chip-&gt;</span><span class="function"><span class="title">input</span>-&gt;</span>evbit);     <span class="comment">/* 设置重复事件  */</span> </span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; ZKEY_NUM + <span class="number">5</span>; i++)	</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="title">set_bit</span>(button_info[i].code, chip-&gt;</span><span class="function"><span class="title">input</span>-&gt;</span>keybit);	<span class="comment">//支持具体按键键码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">status</span> = input_register_device(chip-&gt;</span>input);   <span class="comment">//注册input设备</span></span><br><span class="line"><span class="keyword">if</span>(status)</span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_ERR <span class="string">&quot;input_register_device\n&quot;</span>);</span><br><span class="line">    return -ENOMEM;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="上报输入事件"><a href="#上报输入事件" class="headerlink" title="上报输入事件"></a>上报输入事件</h4></li>
</ol>
</li>
<li><p>使用<em>input_event</em>函数上报指定的事件及对应的值，函数原型如下</p>
  <figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> input_event(<span class="keyword">struct</span> input_dev *dev,</span><br><span class="line">                 <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="keyword">type</span>,</span><br><span class="line">                 <span class="keyword">unsigned</span> <span class="keyword">int</span> code,</span><br><span class="line">                 <span class="keyword">int</span> value)</span><br></pre></td></tr></table></figure>
<p>  dev:需要上报的 input_dev。<br>  type: 上报的事件类型,比如 EV_KEY。<br>  code:事件码,也就是我们注册的按键值,比如 KEY_0、KEY_1 等等。<br>  value:事件值,比如 1 表示按键按下,0 表示按键松开。</p>
</li>
<li><p>上报按键事件，Linux内核也提供了具体的上报函数<em>input_report_key</em></p>
  <figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">static inline void input<span class="constructor">_report_key(<span class="params">struct</span> <span class="params">input_dev</span> <span class="operator">*</span><span class="params">dev</span>, <span class="params">unsigned</span> <span class="params">int</span> <span class="params">code</span>, <span class="params">int</span> <span class="params">value</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    input<span class="constructor">_event(<span class="params">dev</span>, EV_KEY, <span class="params">code</span>, !!<span class="params">value</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  type:事件类型,比如 EV_KEY,表示此次事件为按键事件,此成员变量为 16 位。<br>  code:事件码,比如在 EV_KEY 事件中 code 就表示具体的按键码,如:KEY_0、KEY_1等等这些按键。此成员变量为 16 位。<br>  value:值,比如 EV_KEY 事件中 value 就是按键值,表示按键有没有被按下,如果为1的话说明按键按下,如果为0的话说明按键没有被按下或者按键松开了。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux Driver 按键驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt中串口数据处理机制</title>
    <url>/archives/6e893f38.html</url>
    <content><![CDATA[<p>在嵌入式项目或者工控项目中经常会用到串口通讯，用到串口通讯可能就涉及到串口私有协议（类似 包头 + 帧类型 + 帧长度 + 帧数据 + 校验和 的形式）的解析。在Qt中经常用到<code>QSerialPort</code>类来进行串口数据收发，<code>QSerialPort</code>在串口数据可读时会释放<code>readyRead()</code>信号，接到这个信号再调用<code>readAll()</code>将缓冲区的数据全部读出来（串口数据量比较大，这个过程一般都是在一个独立的接收线程中进行处理）。<span id="more"></span>但是这个<code>readyRead()</code>信号释放时，缓冲区的数据长度是不固定的（一般是几十个字节会释放一次读信号），不过串口私有协议各个帧的长度基本都是固定的，这就导致处理串口数据时需要对<code>readAll()</code>中读出来的数据进行链接，然后进行数据解析。<br>记录一下最近调试Qt串口通讯时用到的方法，这个方法也适用于任何系统的串口数据接收，可以达到不错的处理速度，保证不丢帧的接收。该方法的处理机制比较简单，在槽函数中接收到串口数据后，释放信号将读到的数据传递出去，接收信号方逐字节的按照协议对这些数据进行处理，这样只要<code>QSerialPort</code>将串口上的数据都完整的读出来了，应该是不会出现丢帧的情况。</p>
<h4 id="串口初始化及数据接收"><a href="#串口初始化及数据接收" class="headerlink" title="串口初始化及数据接收"></a>串口初始化及数据接收</h4><ul>
<li>串口类进行初始化后，转移到<code>thread</code>线程中进行处理，在<code>readSerialData()</code>中将数据读取后将数据传递出去。<br>  serialport.h  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SerialPort</span> :</span> <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">SerialPort</span><span class="params">(QObject *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">    ~<span class="built_in">SerialPort</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">startThread</span><span class="params">(<span class="keyword">const</span> QString &amp;port)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">closeSerialPort</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">writeSerialData</span><span class="params">(<span class="keyword">const</span> QByteArray &amp;data)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">openSerialPort</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">readSerialData</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">serialStateChanged</span><span class="params">(<span class="keyword">bool</span> state)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dataReaded</span><span class="params">(<span class="keyword">const</span> QByteArray &amp;data)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QString port;</span><br><span class="line">    qint32 baudrate;</span><br><span class="line">    QSerialPort *serial;</span><br><span class="line">    QThread *thread;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
  serialport.cpp  <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &quot;serialport.h&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@brief</span> SerialPort::SerialPort</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> parent</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">SerialPort::SerialPort(QObject *<span class="built_in">parent</span>) : QObject(<span class="built_in">parent</span>)</span><br><span class="line">&#123;</span><br><span class="line">    serial = <span class="keyword">new</span> QSerialPort;</span><br><span class="line">    thread = <span class="keyword">new</span> QThread;</span><br><span class="line">    this-&gt;moveToThread(thread);</span><br><span class="line">    serial-&gt;moveToThread(thread);</span><br><span class="line">    connect(thread, &amp;QThread::started, this, &amp;SerialPort::openSerialPort);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@brief</span> SerialPort::~SerialPort</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">SerialPort::~SerialPort()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (serial-&gt;isOpen())</span><br><span class="line">    &#123;</span><br><span class="line">        serial-&gt;close();</span><br><span class="line">    &#125;</span><br><span class="line">    serial-&gt;deleteLater();</span><br><span class="line">    thread-&gt;quit();</span><br><span class="line">    thread-&gt;wait();</span><br><span class="line">    thread-&gt;deleteLater();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@brief</span> SerialPort::startThread</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> port serial port name(QSerialPortInfo::name)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">void</span> SerialPort::startThread(<span class="keyword">const</span> QString &amp;port)</span><br><span class="line">&#123;</span><br><span class="line">    this-&gt;port = port;</span><br><span class="line">    qDebug() &lt;&lt; <span class="string">&quot;current port is &quot;</span> &lt;&lt; port;</span><br><span class="line">    <span class="keyword">if</span> (!thread-&gt;isRunning())</span><br><span class="line">    &#123;</span><br><span class="line">        thread-&gt;start();</span><br><span class="line">        qDebug() &lt;&lt; <span class="string">&quot;serialport thread start: &quot;</span> &lt;&lt; QThread::currentThread();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@brief</span> SerialPort::openSerialPort</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">void</span> SerialPort::openSerialPort()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (serial-&gt;isOpen())</span><br><span class="line">    &#123;</span><br><span class="line">        qDebug() &lt;&lt; <span class="string">&quot;serial is opened, return.&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    serial-&gt;setPortName(port);</span><br><span class="line">    serial-&gt;setBaudRate(<span class="number">115200</span>);</span><br><span class="line">    serial-&gt;setDataBits(QSerialPort::Data8);</span><br><span class="line">    serial-&gt;setStopBits(QSerialPort::OneStop);</span><br><span class="line">    serial-&gt;setParity(QSerialPort::NoParity);</span><br><span class="line">    serial-&gt;setFlowControl(QSerialPort::NoFlowControl);</span><br><span class="line">    <span class="keyword">if</span> (serial-&gt;open(QIODevice::ReadWrite))</span><br><span class="line">    &#123;</span><br><span class="line">        qDebug() &lt;&lt; <span class="string">&quot;serial open success.&quot;</span> &lt;&lt; QThread::currentThread();</span><br><span class="line">        connect(serial, &amp;QSerialPort::readyRead,</span><br><span class="line">                this, &amp;SerialPort::readSerialData, Qt::QueuedConnection);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        qDebug() &lt;&lt; <span class="string">&quot;serial open failed.&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@brief</span> SerialPort::readSerialData</span></span><br><span class="line"><span class="comment">* read 16 bytes each time</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">void</span> SerialPort::readSerialData()</span><br><span class="line">&#123;</span><br><span class="line">    QByteArray buf = serial-&gt;readAll();</span><br><span class="line">    emit dataReaded(buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@brief</span> SerialPort::writeSerialData</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> data  buff to write</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">void</span> SerialPort::writeSerialData(<span class="keyword">const</span> QByteArray &amp;data)</span><br><span class="line">&#123;</span><br><span class="line">    serial-&gt;write(data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@brief</span> SerialPort::closeSerialPort</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">void</span> SerialPort::closeSerialPort()</span><br><span class="line">&#123;</span><br><span class="line">    qDebug() &lt;&lt; <span class="string">&quot;close serialport.&quot;</span>;</span><br><span class="line">    serial-&gt;clear();</span><br><span class="line">    serial-&gt;close();</span><br><span class="line">    <span class="keyword">if</span> (thread-&gt;isRunning())</span><br><span class="line">    &#123;</span><br><span class="line">        thread-&gt;quit();</span><br><span class="line">        thread-&gt;wait();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="串口数据处理"><a href="#串口数据处理" class="headerlink" title="串口数据处理"></a>串口数据处理</h4><ul>
<li>数据处理类接收到串口类传递的数据后，按照协议逐字节的进行处理，帧头的处理比较麻烦，因为帧头一般是两个字节，可能被缓冲到前后两个数据缓冲区，所以需要对前后两个帧头的位置关系进行判断。<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uartRecvProcess</span><span class="params">(<span class="keyword">const</span> QByteArray&amp; data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> firstHeadPos = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> frameLen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> frameDataIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> lastLen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">uint8_t</span> frameData[MAX_FRAME_LEN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> PRINT_UART_DEBUG</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; data.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;0x%02x &quot;</span>, (<span class="keyword">uint8_t</span>)data.<span class="built_in">at</span>(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (index &lt; data.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">uint8_t</span> temp = data.<span class="built_in">at</span>(index);</span><br><span class="line"></span><br><span class="line">        <span class="built_in"><span class="keyword">switch</span></span> (step)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="comment">// 查找第一个帧头</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="number">0x55</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                step = <span class="number">1</span>;</span><br><span class="line">                firstHeadPos = index;</span><br><span class="line">                frameData[frameDataIndex++] = temp;</span><br><span class="line">                lastLen = data.<span class="built_in">size</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查找第二个帧头</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> ((temp == <span class="number">0xAA</span>) &amp;&amp;</span><br><span class="line">                ((index == firstHeadPos + <span class="number">1</span>) ||</span><br><span class="line">                ((firstHeadPos == lastLen <span class="number">-1</span>) &amp;&amp; index == <span class="number">0</span>)))</span><br><span class="line">            &#123;</span><br><span class="line">                step = <span class="number">2</span>;</span><br><span class="line">                frameData[frameDataIndex++] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                step = <span class="number">0</span>;</span><br><span class="line">                firstHeadPos = <span class="number">-1</span>;</span><br><span class="line">                frameDataIndex = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 帧类型判断</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">if</span>(temp == CMD_AD)</span><br><span class="line">            &#123;</span><br><span class="line">                frameLen = FRAME_SIZE_AD;</span><br><span class="line">                frameData[frameDataIndex++] = temp;</span><br><span class="line">                step = <span class="number">3</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(temp == CMD_IO)</span><br><span class="line">            &#123;</span><br><span class="line">                frameLen = FRAME_SIZE_IO;</span><br><span class="line">                step = <span class="number">3</span>;</span><br><span class="line">                frameData[frameDataIndex++] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//去掉帧头，重新查找</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;unknow uart frame type\n&quot;</span>);</span><br><span class="line">                step = <span class="number">0</span>;</span><br><span class="line">                frameLen = <span class="number">0</span>;</span><br><span class="line">                firstHeadPos = <span class="number">-1</span>;</span><br><span class="line">                frameDataIndex = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 帧数据接收及解析</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">if</span> (frameDataIndex &lt; frameLen)</span><br><span class="line">                frameData[frameDataIndex++] = temp;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (frameDataIndex == frameLen)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(frameData[frameLen - <span class="number">1</span>] != <span class="built_in">checkSum</span>(frameData, frameLen - <span class="number">1</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;type: %d, checksum error! received is 0x%02x, calculated is 0x%02x\n&quot;</span>,</span><br><span class="line">                           frameLen, frameData[frameLen - <span class="number">1</span>], <span class="built_in">checkSum</span>(frameData, frameLen - <span class="number">1</span>));</span><br><span class="line">                    step = <span class="number">0</span>;</span><br><span class="line">                    frameLen = <span class="number">0</span>;</span><br><span class="line">                    firstHeadPos = <span class="number">-1</span>;</span><br><span class="line">                    frameDataIndex = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;type: %d, uart data handler\n&quot;</span>, frameLen);</span><br><span class="line">                    <span class="built_in">uartDataHandler</span>(frameData, frameLen);</span><br><span class="line">                    step = <span class="number">0</span>;</span><br><span class="line">                    frameLen = <span class="number">0</span>;</span><br><span class="line">                    firstHeadPos = <span class="number">-1</span>;</span><br><span class="line">                    frameDataIndex = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        index ++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>Qt QSerialPort 串口</tag>
      </tags>
  </entry>
  <entry>
    <title>龙芯2K1000内核源码编译</title>
    <url>/archives/67263a86.html</url>
    <content><![CDATA[<h4 id="解压PMON源码pmon-loongson3-tar-gz"><a href="#解压PMON源码pmon-loongson3-tar-gz" class="headerlink" title="解压PMON源码pmon-loongson3.tar.gz"></a>解压PMON源码<em>pmon-loongson3.tar.gz</em></h4><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">tar</span> -xvf pmon-loongson<span class="number">3</span>-nd-<span class="number">33</span>j.tar.gz</span><br></pre></td></tr></table></figure>
<h4 id="配置交叉编译环境"><a href="#配置交叉编译环境" class="headerlink" title="配置交叉编译环境"></a>配置交叉编译环境</h4><ul>
<li>解压交叉编译工具<em>gcc-4.4.0-pmon.tgz</em>，配置环境<span id="more"></span>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">tar</span> -xvf gcc-<span class="number">4</span>.<span class="number">4</span>.<span class="number">0</span>-pmon.tgz</span><br></pre></td></tr></table></figure>
编辑&#x2F;etc&#x2F;profile，配置交叉编译工具路径<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">export PATH=<span class="variable">$PATH</span><span class="symbol">:/home/jack/loongson/tools/gcc-</span><span class="number">4.4</span>.0-pmon/bin</span><br><span class="line">export LD_LIBRARY_PATH=<span class="regexp">/home/jack</span><span class="regexp">/loongson/tools</span><span class="regexp">/gcc-4.4.0-pmon/lib</span><span class="symbol">:</span><span class="variable">$LD_LIBRARY_PATH</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>安装makedepend，<code>sudo apt-get install xutils-dev </code></li>
<li>进入源码目录编译安装pmoncfg<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> install bison flex build-essential patch</span><br><span class="line"><span class="keyword">cd</span> tools/pmoncfg </span><br><span class="line"><span class="keyword">make</span> </span><br><span class="line">sudo <span class="keyword">cp</span> pmoncfg /usr/bin</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="编译PMON源码"><a href="#编译PMON源码" class="headerlink" title="编译PMON源码"></a>编译PMON源码</h4><p>进入PMON源码目录，若只需要修改PMON，可在原来的项目目录基础上进行编译，源码内有脚本文件<em>build.sh</em>，输入格式: <code>./build.sh [cputype] [proID]</code>，比如龙芯2K1000，项目ID hm19047，输入<code>./build.sh ls2k hm19047</code>即可开始编译，编译结果在<em>zloader.ls2k-hm19047</em>目录中，会生成<em>gzrom-dtb.bin</em>，将该文件烧录进flash即可。</p>
<h4 id="PMON网络烧录"><a href="#PMON网络烧录" class="headerlink" title="PMON网络烧录"></a>PMON网络烧录</h4><ul>
<li>主机IP地址为192.168.0.100，搭建tftp服务器</li>
<li>开机按C键进入PMON下，设置IP地址<code>ifconfig syn0 192.168.0.10</code></li>
<li>烧写PMON<code>load -rf 0xbfc00000 tftp://192.168.0.100/gzrom-dtb.bin</code></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>PMON</tag>
        <tag>Loongson</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu编译QFtp并使用</title>
    <url>/archives/1b5a9595.html</url>
    <content><![CDATA[<h4 id="下载QFtp源码"><a href="#下载QFtp源码" class="headerlink" title="下载QFtp源码"></a>下载QFtp源码</h4><p><a href="https://github.com/qt/qtftp.git">QFtp源码</a><br><code>gti clone https://github.com/qt/qtftp.git</code></p>
<h4 id="编译QFtp模块"><a href="#编译QFtp模块" class="headerlink" title="编译QFtp模块"></a>编译QFtp模块</h4><p>在QtCreator上编译出了点问题，只能在终端进行编译</p>
<ul>
<li>进入源码目录<code>cd src/qftp</code>，修改pro文件<code>qftp.pro</code>,修改如下<span id="more"></span>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">load(qt_build_config)</span><br><span class="line"></span><br><span class="line">TARGET = QtFtp</span><br><span class="line">CONFIG += static</span><br><span class="line">CONFIG -= shared</span><br><span class="line">QT = core network</span><br><span class="line"></span><br><span class="line">MODULE_PRI = ../../modules/qt_ftp.pri</span><br><span class="line">MODULE = ftp</span><br><span class="line"></span><br><span class="line">load(qt_module)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Input</span></span><br><span class="line">HEADERS += qftp.h qurlinfo.h</span><br><span class="line">SOURCES += qftp.cpp qurlinfo.cpp</span><br><span class="line"></span><br></pre></td></tr></table></figure>
修改<code>qurlinfo.cpp</code>中的<code>qurlinfo.h</code>路径，修改如下<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &quot;qurlinfo.h&quot;</span><br><span class="line"></span><br><span class="line">#include &quot;qurl.h&quot;</span><br><span class="line">#include &quot;qdir.h&quot;</span><br><span class="line">#include &lt;limits.h&gt;</span><br><span class="line"></span><br><span class="line">QT_BEGIN_NAMESPACE</span><br></pre></td></tr></table></figure></li>
<li>在终端中进入源码目录<code>cd src/qftp</code>，运行<code>qmake</code>，之后会生成Makefile</li>
<li><code>make</code>生成<code>libQt5Ftp.a</code>静态库，pri模块文件</li>
<li><code>make install</code>将生成的库文件及QFtp头文件复制到Qt安装目录</li>
<li>对于交叉编译环境下其他平台的编译也可按照上面的步骤，qmake需要替换交叉编译环境下对应的qmake</li>
</ul>
<h4 id="QFtp使用"><a href="#QFtp使用" class="headerlink" title="QFtp使用"></a>QFtp使用</h4><ul>
<li>官方源码目录example文件夹下有一个例程，网上有大佬稍加修改上传到了GitHub，<a href="https://github.com/chuanstudyup/QFtpExample.git">QFtp例程</a>  </li>
<li>下载这个例程，上述编译步骤没问题的话，直接编译运行即可<br><img src="https://cdn.jsdelivr.net/gh/JackHuang021/images@master/images20220627150335.png"></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>QFtp</tag>
      </tags>
  </entry>
  <entry>
    <title>C/C++ 中宏定义中#和##的作用</title>
    <url>/archives/57aaac13.html</url>
    <content><![CDATA[<h4 id="宏定义中-的功能"><a href="#宏定义中-的功能" class="headerlink" title="宏定义中#的功能"></a>宏定义中#的功能</h4><p>C&#x2F;C++宏定义#中的功能是将其后面的宏参数进行字符串化操作，简单说就是在对它所引用的宏变量通过替换后在其左右各添加一个双引号。</p>
<span id="more"></span>

<h4 id="宏定义中-的功能-1"><a href="#宏定义中-的功能-1" class="headerlink" title="宏定义中##的功能"></a>宏定义中##的功能</h4><p>宏定义中##中的功能是在带参数的宏定义中将##前后的子串进行拼接。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STR(s) #s</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONS(a, b) int(a##e##b)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">STR</span>(hello) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">CONS</span>(<span class="number">2</span>, <span class="number">3</span>) &lt;&lt; endl;     <span class="comment">// CONS(2, 3) -&gt; 2e3 </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line">hello</span><br><span class="line"><span class="number">2000</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>phytium i2c适配器驱动</title>
    <url>/archives/1dd4e6b7.html</url>
    <content><![CDATA[<h4 id="I2C总线驱动"><a href="#I2C总线驱动" class="headerlink" title="I2C总线驱动"></a>I2C总线驱动</h4><p>I2C总线驱动重点是I2C适配器（也就是SOC的I2C接口）控制器驱动，这里涉及到两个重要的数据结构：i2c_adapter和i2c_algorithm，Linux内核将SOC的I2C控制器抽象成i2c_adapter，i2c_adapter定义在include&#x2F;linux&#x2F;i2c.h中，结构体的内容如下：</p>
<span id="more"></span>
<pre><code><figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="type">i2c_adapter</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="type">module</span> *owner;</span><br><span class="line">    unsigned int class;		  <span class="comment">/* classes to allow probing for */</span></span><br><span class="line">    const <span class="keyword">struct</span> <span class="type">i2c_algorithm</span> *algo; <span class="comment">/* the algorithm to access the bus */</span></span><br><span class="line">    void *algo_data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* data fields that are valid for all devices	*/</span></span><br><span class="line">    const <span class="keyword">struct</span> <span class="type">i2c_lock_operations</span> *lock_ops;</span><br><span class="line">    <span class="keyword">struct</span> <span class="type">rt_mutex</span> bus_lock;</span><br><span class="line">    <span class="keyword">struct</span> <span class="type">rt_mutex</span> mux_lock;</span><br><span class="line"></span><br><span class="line">    int timeout;			<span class="comment">/* in jiffies */</span></span><br><span class="line">    int retries;</span><br><span class="line">    <span class="keyword">struct</span> <span class="type">device</span> dev;		<span class="comment">/* the adapter device */</span></span><br><span class="line"></span><br><span class="line">    int nr;</span><br><span class="line">    char name[<span class="number">48</span>];</span><br><span class="line">    <span class="keyword">struct</span> <span class="type">completion</span> dev_released;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="type">mutex</span> userspace_clients_lock;</span><br><span class="line">    <span class="keyword">struct</span> <span class="type">list_head</span> userspace_clients;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="type">i2c_bus_recovery_info</span> *bus_recovery_info;</span><br><span class="line">    const <span class="keyword">struct</span> <span class="type">i2c_adapter_quirks</span> *quirks;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="type">irq_domain</span> *host_notify_domain;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
其中algo成员为i2c适配器对外提供的API读写操作函数，i2c_algorithm为I2C适配器和I2C设备通信的方法，i2c_algorithm结构体的内容如下：
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> i2c_algorithm &#123;</span><br><span class="line">    <span class="comment">/* If an adapter algorithm can&#x27;t do I2C-level access, set master_xfer</span></span><br><span class="line"><span class="comment">       to NULL. If an adapter algorithm can do SMBus access, set</span></span><br><span class="line"><span class="comment">       smbus_xfer. If set to NULL, the SMBus protocol is simulated</span></span><br><span class="line"><span class="comment">       using common I2C messages */</span></span><br><span class="line">    <span class="comment">/* master_xfer should return the number of messages successfully</span></span><br><span class="line"><span class="comment">       processed, or a negative value on error */</span></span><br><span class="line">    <span class="keyword">int</span> (*master_xfer)(<span class="keyword">struct</span> i2c_adapter *adap, <span class="keyword">struct</span> i2c_msg *msgs,</span><br><span class="line">               <span class="keyword">int</span> num);</span><br><span class="line">    <span class="keyword">int</span> (*smbus_xfer) (<span class="keyword">struct</span> i2c_adapter *adap, u16 addr,</span><br><span class="line">               <span class="keyword">unsigned</span> <span class="keyword">short</span> flags, <span class="keyword">char</span> read_write,</span><br><span class="line">               u8 command, <span class="keyword">int</span> size, <span class="keyword">union</span> i2c_smbus_data *data);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* To determine what the adapter supports */</span></span><br><span class="line">    u32 (*functionality) (<span class="keyword">struct</span> i2c_adapter *);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> IS_ENABLED(CONFIG_I2C_SLAVE)</span></span><br><span class="line">    <span class="keyword">int</span> (*reg_slave)(<span class="keyword">struct</span> i2c_client *client);</span><br><span class="line">    <span class="keyword">int</span> (*unreg_slave)(<span class="keyword">struct</span> i2c_client *client);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
+ master_xfer是I2C适配器的的传输函数
+ smbus_xfer是SMBUS总线的传输函数
</code></pre>
<ul>
<li>I2C适配器驱动的主要工作就是初始化i2c_adapter的结构体变量，然后实现i2c_algorithm中的传输函数，完成后通过<em>i2c_add_numbered_adapter</em>或者<em>i2c_add_adapter</em>这两个函数向系统注册设置好的i2c_adapter，函数原型如下：<br><code>int i2c_add_adapter(struct i2c_adapter *adapter)</code><br><code>int i2c_add_numbered_adapter(struct i2c_adapter *adap)</code><br>i2c_add_adapter()使用动态的总线号，i2c_add_numbered_adapter()使用静态的总线号</li>
</ul>
<h4 id="phytium-i2c适配器驱动分析"><a href="#phytium-i2c适配器驱动分析" class="headerlink" title="phytium i2c适配器驱动分析"></a>phytium i2c适配器驱动分析</h4><ul>
<li><p>phytium i2c设备树节点内容</p>
  <figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="symbol">mio14:</span> <span class="class">i2c@28030000 </span>&#123;</span><br><span class="line">    compatible = <span class="string">&quot;phytium,i2c&quot;</span>;</span><br><span class="line">    reg = <span class="params">&lt;<span class="number">0x0</span> <span class="number">0x28030000</span> <span class="number">0x0</span> <span class="number">0x1000</span>&gt;</span>;</span><br><span class="line">    interrupts = <span class="params">&lt;GIC_SPI <span class="number">106</span> IRQ_TYPE_LEVEL_HIGH&gt;</span>;</span><br><span class="line">    clocks = <span class="params">&lt;<span class="variable">&amp;sysclk_50mhz</span>&gt;</span>;</span><br><span class="line">    <span class="meta">#address-cells = &lt;1&gt;;</span></span><br><span class="line">    <span class="meta">#size-cells = &lt;0&gt;;</span></span><br><span class="line">    status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>  对应的驱动文件为<em>drivers&#x2F;i2c&#x2F;busses&#x2F;i2c-phytium-platform.c</em></p>
</li>
<li><p>phytium i2c适配器驱动为一个标准的platform驱动</p>
  <figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">static struct platform_driver <span class="attr">phytium_i2c_driver</span> = &#123;</span><br><span class="line">    .<span class="attr">probe</span> = phytium_i2c_plat_probe,</span><br><span class="line">    .<span class="attr">remove</span> = phytium_i2c_plat_remove,</span><br><span class="line">    .<span class="attr">driver</span> = &#123;</span><br><span class="line">        .<span class="attr">name</span> = DRV_NAME,</span><br><span class="line">        .<span class="attr">of_match_table</span> = of_match_ptr(phytium_i2c_of_match),</span><br><span class="line">        .<span class="attr">acpi_match_table</span> = ACPI_PTR(phytium_i2c_acpi_match),</span><br><span class="line">        .<span class="attr">pm</span> = &amp;phytium_i2c_dev_pm_ops,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<em>of_device_id</em>与设备树mio14节点相匹配，在platform_match函数中进行匹配</p>
  <figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">static const <span class="keyword">struct</span> of_device_id phytium_i2c_of_match<span class="literal">[]</span> = &#123;</span><br><span class="line">    &#123; .compatible = <span class="string">&quot;phytium,i2c&quot;</span>, &#125;,</span><br><span class="line">    &#123;   &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="constructor">MODULE_DEVICE_TABLE(<span class="params">of</span>, <span class="params">phytium_i2c_of_match</span>)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>当设备和驱动匹配完成后，<em>phytium_i2c_plat_probe</em>函数就会执行，完成i2c适配器的初始化工作，probe中的工作如下：</p>
<ul>
<li>调用platform_get_irq()函数获取中断号</li>
<li>调用platform_get_resource()函数获取I2C控制器的寄存器物理基地址，获取到物理基地址后再使用devm_ioremap_resource()函数对其进行内存映射，得到可以在Linux内核中使用的虚拟内存地址</li>
<li>设置I2C设备总线速度</li>
<li>根据I2C地址第30位数据来判断当前I2C适配器配置成slave模式还是master模式，填充phytium_i2c_dev数据成员，主要设计适配器工作能力等一些参数标志</li>
<li>使能I2C总线时钟</li>
<li>调用i2c_phytium_probe()函数，该函数位于drivers&#x2F;i2c&#x2F;busses&#x2F;i2c-phytium-master.c，在i2c_phytium_probe()里面继续完善adapter数据成员</li>
</ul>
</li>
<li><p>phytium_i2c_dev结构体</p>
  <figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">struct phytium_i2c_dev &#123;</span><br><span class="line">    struct device		*dev<span class="comment">;</span></span><br><span class="line">    void __iomem		*base<span class="comment">;</span></span><br><span class="line">    int			irq<span class="comment">;</span></span><br><span class="line">    u32			flags<span class="comment">;</span></span><br><span class="line">    struct completion	cmd_complete<span class="comment">;</span></span><br><span class="line">    struct clk		*clk<span class="comment">;</span></span><br><span class="line">    struct reset_control	*rst<span class="comment">;</span></span><br><span class="line">    int			mode<span class="comment">;</span></span><br><span class="line">    struct i2c_client	*slave<span class="comment">;</span></span><br><span class="line">    u32			(*get_clk_rate_khz)(struct phytium_i2c_dev *dev)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    struct i2c_adapter	adapter<span class="comment">;</span></span><br><span class="line">    struct i2c_client	*ara<span class="comment">;</span></span><br><span class="line">    struct i2c_smbus_alert_setup alert_data<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    struct phytium_pci_i2c *controller<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    unsigned int		status<span class="comment">;</span></span><br><span class="line">    int			cmd_err<span class="comment">;</span></span><br><span class="line">    u32			abort_source<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    struct i2c_msg		*msgs<span class="comment">;</span></span><br><span class="line">    int			msgs_num<span class="comment">;</span></span><br><span class="line">    int			msg_write_idx<span class="comment">;</span></span><br><span class="line">    int			msg_read_idx<span class="comment">;</span></span><br><span class="line">    int			msg_err<span class="comment">;</span></span><br><span class="line">    u32			tx_buf_len<span class="comment">;</span></span><br><span class="line">    u8			*tx_buf<span class="comment">;</span></span><br><span class="line">    u32			rx_buf_len<span class="comment">;</span></span><br><span class="line">    u8			*rx_buf<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    u32			master_cfg<span class="comment">;</span></span><br><span class="line">    u32			slave_cfg<span class="comment">;</span></span><br><span class="line">    u32			functionality<span class="comment">;</span></span><br><span class="line">    unsigned int		tx_fifo_depth<span class="comment">;</span></span><br><span class="line">    unsigned int		rx_fifo_depth<span class="comment">;</span></span><br><span class="line">    int			rx_outstanding<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    struct i2c_timings	timings<span class="comment">;</span></span><br><span class="line">    u32			sda_hold_time<span class="comment">;</span></span><br><span class="line">    u16			ss_hcnt<span class="comment">;</span></span><br><span class="line">    u16			ss_lcnt<span class="comment">;</span></span><br><span class="line">    u16			fs_hcnt<span class="comment">;</span></span><br><span class="line">    u16			fs_lcnt<span class="comment">;</span></span><br><span class="line">    u16			fp_hcnt<span class="comment">;</span></span><br><span class="line">    u16			fp_lcnt<span class="comment">;</span></span><br><span class="line">    u16			hs_hcnt<span class="comment">;</span></span><br><span class="line">    u16			hs_lcnt<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    bool			pm_disabled<span class="comment">;</span></span><br><span class="line">    void			(*disable)(struct phytium_i2c_dev *dev)<span class="comment">;</span></span><br><span class="line">    void			(*disable_int)(struct phytium_i2c_dev *dev)<span class="comment">;</span></span><br><span class="line">    int			(*init)(struct phytium_i2c_dev *dev)<span class="comment">;</span></span><br><span class="line">&#125;<span class="comment">;</span></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>I2C</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux根文件系统</title>
    <url>/archives/265c268b.html</url>
    <content><![CDATA[<h3 id="根文件系统简介"><a href="#根文件系统简介" class="headerlink" title="根文件系统简介"></a>根文件系统简介</h3><p>根文件系统一般也叫做rootfs，Linux中的根文件系统就像是一个文件夹，这个文件夹内包含很多子目录，这些目录中会有很多文件，这些文件是Linux运行所必须的，比如库、常用的软件和命令、设备文件、配置文件等，根文件系统是Linux内核启动以后挂载的第一个文件系统，然后从根文件系统中读取初始化脚本，比如rcS、inittab等，根文件系统和Linux内核是分开的，单独的Linux内核无法正常工作，必须搭配根文件系统。</p>
<span id="more"></span>

<h4 id="根文件系统子目录"><a href="#根文件系统子目录" class="headerlink" title="根文件系统子目录"></a>根文件系统子目录</h4><ul>
<li><p>&#x2F;bin目录：该目录下存放着系统需要的可执行文件，一般都是一些命令，比如ls、mv等，此目录下的所有命令所有用户都能使用</p>
</li>
<li><p>&#x2F;dev目录：dev是device的缩写，此目录下的文件都是和设备相关的，都是设备文件，在Linux下一切皆文件，即使是硬件设备，也是以文件的形式存在，比如说&#x2F;dev&#x2F;ttymxc0就表示串口0，可以通过对文件&#x2F;dev&#x2F;ttymxc0的读写操作来实现串口0的数据收发</p>
</li>
<li><p>&#x2F;etc目录：该目录下存放着各种配置文件，在嵌入式Linux下该目录下文件内容比较少</p>
</li>
<li><p>&#x2F;lib目录：lib是library的简称，也就是库的意思，因此该目录下存放着Linux所必须的库文件，这些库文件是共享库，命令和用户编写的应用程序都需要使用这些库文件</p>
</li>
<li><p>&#x2F;mnt目录：临时挂载目录，一般是空目录，可以在此目录下创建空的子目录，比如&#x2F;mnt&#x2F;sd，&#x2F;mnt&#x2F;usb这样就可以将SD卡或者U盘挂载</p>
</li>
<li><p>&#x2F;porc目录：当Linux系统启动后会将此目录作为proc文件系统的挂载点，proc是个虚拟文件系统，没有实际的存储设备，proc里面的文件都是临时存在的，一般用来存储系统运行信息文件</p>
</li>
<li><p>&#x2F;usr目录：usr的全称是Unix Software Resource，也就是Unix操作系统的软件资源目录，Linux一般被称为类Unix操作系统，&#x2F;usr目录下也存放着很多软件，一般系统安装后此目录占用的空间最多</p>
</li>
<li><p>&#x2F;var目录：此目录存放着一些可以改变的数据</p>
</li>
<li><p>&#x2F;sbin目录：此目录存放着一些可执行文件，但是此目录下的文件或者命令只有管理员才能使用</p>
</li>
<li><p>&#x2F;sys目录：系统启动后此目录作为sysfs文件系统的挂载点，sysfs是一个类似proc文件系统的特殊文件系统，sysfs也是基于ram的文件系统，没有实际的存储设备，此目录是系统设备管理的重要目录，此目录通过一定的组织结构向用户提供详细的内核数据结构信息</p>
</li>
<li><p>&#x2F;opt目录：可选的文件、软件存放区，由用户选择将哪些文件或者软件放到此目录</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>rootfs</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux字符设备驱动开发</title>
    <url>/archives/d281c370.html</url>
    <content><![CDATA[<p>字符设备是Linux驱动中最基本的一类设备驱动，字符设备就是一个一个字节，按照字节流进行读写操作的设备，读写数据是分先后顺序的，这些设备的驱动就叫做字符设备驱动</p>
<span id="more"></span>

<p>应用程序运行在用户空间，Linux驱动属于内核的一部分，因此驱动运行于内核空间，当在用户空间想要实现对内核的操作，比如使用<code>open</code>函数打开<code>/dev/led</code>这个设备，因为用户空间不能直接对内核进行操作，因此必须使用一个叫做“系统调用”的方法来实现从用户空间陷入到内核空间，这样才能实现对底层驱动的操作。</p>
<p>应用程序调用<code>open()</code>函数的流程:<br>应用调用open函数（应用程序） -&gt; C库中的open（）函数 -&gt; open（）系统调用</p>
<p>每一个系统调用在驱动中都有与之对应的一个驱动函数，在Linux内核文件<code>include/linux/fs.h</code>中有一个叫做<code>file_operations</code>的结构体，此结构体就是Linux内核驱动操作函数集合，<br>该结构体内容如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">    <span class="keyword">loff_t</span> (*llseek) (struct file *, <span class="keyword">loff_t</span>, <span class="keyword">int</span>);</span><br><span class="line">    <span class="keyword">ssize_t</span> (*read) (struct file *, <span class="keyword">char</span> __user *, <span class="keyword">size_t</span>, <span class="keyword">loff_t</span> *);</span><br><span class="line">    <span class="keyword">ssize_t</span> (*write) (struct file *, <span class="keyword">const</span> <span class="keyword">char</span> __user *, <span class="keyword">size_t</span>, <span class="keyword">loff_t</span> *);</span><br><span class="line">    <span class="keyword">ssize_t</span> (*read_iter) (struct kiocb *, struct iov_iter *);</span><br><span class="line">    <span class="keyword">ssize_t</span> (*write_iter) (struct kiocb *, struct iov_iter *);</span><br><span class="line">    <span class="keyword">int</span> (*iterate) (struct file *, struct dir_context *);</span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span> <span class="params">(*poll)</span> <span class="params">(struct file *, struct poll_table_struct *)</span></span>;</span><br><span class="line">    <span class="keyword">long</span> (*unlocked_ioctl) (struct file *, <span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>);</span><br><span class="line">    <span class="keyword">long</span> (*compat_ioctl) (struct file *, <span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>);</span><br><span class="line">    <span class="keyword">int</span> (*mmap) (struct file *, struct vm_area_struct *);</span><br><span class="line">    <span class="keyword">int</span> (*mremap)(struct file *, struct vm_area_struct *);</span><br><span class="line">    <span class="keyword">int</span> (*open) (struct inode *, struct file *);</span><br><span class="line">    <span class="keyword">int</span> (*flush) (struct file *, <span class="keyword">fl_owner_t</span> id);</span><br><span class="line">    <span class="keyword">int</span> (*release) (struct inode *, struct file *);</span><br><span class="line">    <span class="keyword">int</span> (*fsync) (struct file *, <span class="keyword">loff_t</span>, <span class="keyword">loff_t</span>, <span class="keyword">int</span> datasync);</span><br><span class="line">    <span class="keyword">int</span> (*aio_fsync) (struct kiocb *, <span class="keyword">int</span> datasync);</span><br><span class="line">    <span class="keyword">int</span> (*fasync) (<span class="keyword">int</span>, struct file *, <span class="keyword">int</span>);</span><br><span class="line">    <span class="keyword">int</span> (*lock) (struct file *, <span class="keyword">int</span>, struct file_lock *);</span><br><span class="line">    <span class="keyword">ssize_t</span> (*sendpage) (struct file *, struct page *, <span class="keyword">int</span>, <span class="keyword">size_t</span>, <span class="keyword">loff_t</span> *, <span class="keyword">int</span>);</span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">long</span> <span class="params">(*get_unmapped_area)</span><span class="params">(struct file *, <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> (*check_flags)(<span class="keyword">int</span>);</span><br><span class="line">    <span class="keyword">int</span> (*flock) (struct file *, <span class="keyword">int</span>, struct file_lock *);</span><br><span class="line">    <span class="keyword">ssize_t</span> (*splice_write)(struct pipe_inode_info *, struct file *, <span class="keyword">loff_t</span> *, <span class="keyword">size_t</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span>);</span><br><span class="line">    <span class="keyword">ssize_t</span> (*splice_read)(struct file *, <span class="keyword">loff_t</span> *, struct pipe_inode_info *, <span class="keyword">size_t</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span>);</span><br><span class="line">    <span class="keyword">int</span> (*setlease)(struct file *, <span class="keyword">long</span>, struct file_lock **, <span class="keyword">void</span> **);</span><br><span class="line">    <span class="keyword">long</span> (*fallocate)(struct file *file, <span class="keyword">int</span> mode, <span class="keyword">loff_t</span> offset,</span><br><span class="line">              <span class="keyword">loff_t</span> len);</span><br><span class="line">    <span class="keyword">void</span> (*show_fdinfo)(struct seq_file *m, struct file *f);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONFIG_MMU</span></span><br><span class="line">    <span class="keyword">unsigned</span> (*mmap_capabilities)(struct file *);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<pre><code>+ `owner`拥有该结构体的模块的指针，一般设置为`THIS_MODULE`  
+ `loff_t (*llseak) (struct file *, loff_t, int)`：该函数用于修改文件当前的读写位置  
+ `ssize_t (*read) (struct file *, char __user *, size_t, loff_t *)`：用于读取设备文件
+ `ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *)`：用于向设备文件写入数据
+ `unsigned int (*poll) (struct file *, struct poll_table_struct *)`：用于查询设备是否可以进行非阻塞的读写
+ `long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long)`：与应用程序中的`ioctl`函数对应
+ `long (*compat_ioctl) (struct file *, unsigned int, unsigned long)`：功能与`unlocked_ioctl()`函数功能一样，区别在于在64位系统上，32位的应用程序调用将会使用此函数，在32位的系统上运行32位的应用程序调用的是`unlocked_ioctl()`
+ `int (*mmap) (struct file *, struct vm_area_struct *)`：用于将设备的内存映射到进程空间（即用户空间），一般帧缓冲设备会使用此函数，比如LCD驱动的显存，将帧缓冲映射到用户空间中以后应用程序就可以直接操作显存了，这样就不用在用户空间和内核空间之间来回复制
+ `int (*open) (struct inode *, struct file *)`、：用于打开设备文件
+ `int (*release) (struct inode *, struct file *)`：用于释放设备文件，与应用程序中的`close()`函数对应
+ `int (*fsync) (int, struct file *, int)`：用于刷新待处理的数据，将缓冲区的数据刷新到磁盘中
</code></pre>
<h4 id="sysfs文件系统目录结构"><a href="#sysfs文件系统目录结构" class="headerlink" title="sysfs文件系统目录结构"></a>sysfs文件系统目录结构</h4><table>
<thead>
<tr>
<th align="center">目录</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>sysfs</code></td>
<td>文件系统提供了一种用户与内核数据结构进行交互的方式，Linux设备模型中设备、驱动、总线组织成拓扑结构，通过<code>sysfs</code>文件系统以目录结构进行展示与管理</td>
</tr>
<tr>
<td align="center"><code>devices</code></td>
<td>内核对系统中所有设备的分层次表达模型，也是<code>/sys</code>文件系统管理设备的最重要的目录结构</td>
</tr>
<tr>
<td align="center"><code>dev</code></td>
<td>这个目录下维护一个按字符设备和块设备的设备号文件(major:minor)链接到真实的设备</td>
</tr>
<tr>
<td align="center"><code>bus</code></td>
<td>内核按照总线类型分层放置的目录结构，<code>devices</code>中的所有设备都是连接于某种总线之下，每一种具体总线之下可以找到每一个具体设备的符号链接，是构成Linux统一设备模型的一部分</td>
</tr>
<tr>
<td align="center"><code>class</code></td>
<td>这是按照设备功能分类的设备模型，如系统所有输入设备都会出现在<code>/sys/class/input</code>之下，不论它们是以何种总线连接到系统，它也是构成Linux统一设备模型的一部分</td>
</tr>
<tr>
<td align="center"><code>block</code></td>
<td>这是系统中当前所有块设备所在的目录，按照功能来说放置在<code>/sys/class</code>下更恰当，由于历史遗留因素而一直存在于<code>/sys/block</code>，在2.6.26内核中已经正式移到<code>/sys/class/block</code>，<code>/sys/block</code>中的内容已经变为指向它们在<code>/sys/devices</code>中真实设备的符号链接文件</td>
</tr>
<tr>
<td align="center"><code>firmware</code></td>
<td>系统加载固件机制的对用户空间的接口</td>
</tr>
<tr>
<td align="center"><code>fs</code></td>
<td>用于描述系统中所有文件系统，包括文件系统本身和按文件系统分类存放的已挂载点</td>
</tr>
<tr>
<td align="center"><code>kernel</code></td>
<td>内核所有可调整参数的位置，目前只有<code>uevent_helper</code>,<code>kexec_loaded</code>,<code>mm</code>和新式的<code>slab</code>分配器等几项较新的设计在使用，其它内核可调整参数仍然位于<code>/proc/sys/kernel</code>接口中</td>
</tr>
<tr>
<td align="center"><code>module</code></td>
<td>系统中所有模块的信息，不论这些模块是以内联方式编译到内核镜像<code>vmlinux</code>中还是编译为外部</td>
</tr>
</tbody></table>
<h4 id="对字符设备的封装：cdev结构体"><a href="#对字符设备的封装：cdev结构体" class="headerlink" title="对字符设备的封装：cdev结构体"></a>对字符设备的封装：<code>cdev</code>结构体</h4><ul>
<li><code>cdev</code>结构体定义在<code>include/linux/cdev.h</code>中  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">    <span class="keyword">dev_t</span> dev;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count;</span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure></li>
<li>其中<a href="https://lwn.net/Articles/722293/"><code>__randomsize_layout</code></a>表示随机化一个结构体，在编译时随机排布结构体中元素的顺序，从而使攻击者无法通过地址偏移的方式获取一些敏感数据成员的信息</li>
<li><code>struct kobject kobj;</code>：抽象出来的用来表示设备模型的数据结构</li>
<li><code>const struct file_operations *ops;</code>：定义了字符设备驱动提供给虚拟文件系统的接口函数集合</li>
<li><code>struct list_head list;</code>：将所有字符设备通过链表进行管理</li>
<li><code>dev_t dev</code>：设备号，<code>dev_t</code>数据结构定义在<code>include/linux/types.h</code>中，包含主设备号和次设备号，实际是一个32位整形数据，其中高12位为主设备号，低20位为次设备号  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// dev_t的定义</span></span><br><span class="line"><span class="keyword">typedef</span> u32 <span class="keyword">__kernel_dev_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">__kernel_dev_t</span>		<span class="keyword">dev_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设备号的一些操作宏</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MINORBITS	20</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MINORMASK	((1U &lt;&lt; MINORBITS) - 1)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAJOR(dev)	((unsigned int) ((dev) &gt;&gt; MINORBITS))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MINOR(dev)	((unsigned int) ((dev) &amp; MINORMASK))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MKDEV(ma,mi)	(((ma) &lt;&lt; MINORBITS) | (mi))</span></span><br></pre></td></tr></table></figure></li>
<li><code>unsigned int count;</code>：属于同主设备号的次设备号的个数</li>
</ul>
<h4 id="设备管理机制：kobject"><a href="#设备管理机制：kobject" class="headerlink" title="设备管理机制：kobject"></a>设备管理机制：<code>kobject</code></h4><ul>
<li><code>kobject</code>是Linux设备驱动模型的基础，也是设备模型中抽象的一部分，它与sysfs文件系统紧密相连，在内核中注册的每个<code>kobject</code>对象对应sysfs文件系统中的一个目录</li>
<li><code>kobject</code>是组成设备模型的基本结构，是所有用来描述设备模型的数据结构的基类，它嵌入在所有的描述设备模型的容器对象中，例如bus,devices,drivers，这些容器通过<code>kobject</code>链接起来，形成一个树形结构</li>
<li>该结构体定义在<code>include/linux/kobject.h</code>中，通过这个数据结构可以使所有设备在底层都具有统一的接口，<code>kobject</code>提供基本的对象管理，结构体内容如下：  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>		*name;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">entry</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span>		*<span class="title">parent</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kset</span>		*<span class="title">kset</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobj_type</span>	*<span class="title">ktype</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kernfs_node</span>	*<span class="title">sd</span>;</span> <span class="comment">/* sysfs directory entry */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kref</span>		<span class="title">kref</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_KOBJECT_RELEASE</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">delayed_work</span>	<span class="title">release</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> state_initialized:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> state_in_sysfs:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> state_add_uevent_sent:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> state_remove_uevent_sent:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> uevent_suppress:<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><code>const char *name;</code>：<code>kobject</code>名字，对应<code>sysfs</code>下的一个目录</li>
<li><code>struct list_head entry;</code>：<code>kobject</code>中插入的的<code>list_head</code>链表结构，用于构造双向链表</li>
<li><code>struct kobject *parent;</code>：指向当前<code>kobject</code>父对象的指针，体现在<code>sysfs</code>中就是包含当前<code>kobject</code>对象的目录对象</li>
<li><code>struct kset *kset;</code>：当前<code>kobject</code>对象所属的集合</li>
<li><code>struct kobj_type *ktype;</code>：当前<code>kobject</code>对象的类型</li>
<li><code>struct kernfs_node *sd;</code>：VFS文件系统的目录项，是设备和文件之间的桥梁，<code>sysfs</code>中的符号链接是通过<code>kernel_node</code>内的联合体实现的</li>
<li><code>struct kref kref;</code>：<code>kobject</code>的引用计数，当计数为0时，回调之前注册的<code>release</code>方法释放对象</li>
<li><code>unsigned int state_initialized:1;</code>：初始化标志位，初始化时被置位</li>
<li><code>unsigned int state_in_sysfs:1;</code>：<code>kobject</code>在<code>sysfs</code>中的状态，在目录中创建则为1，否则为0</li>
<li><code>unsigned int state_add_uevent_sent:1</code>：添加设备的<code>uevent</code>事件是否发送标志，添加设备时向用户控件发送<code>uevent</code>事件，请求新增设备</li>
<li><code>unsigned int state_remove_uevent_sent:1</code>：删除设备的<code>uevent</code>事件是否发送标志，删除设备时向用户控件发送<code>uevent</code>事件，请求卸载设备</li>
<li><code>unsigned int uevent_suppress:1</code>：是否忽略上报<code>uevent</code></li>
</ul>
<h4 id="kobject集合-kset"><a href="#kobject集合-kset" class="headerlink" title="kobject集合 kset"></a><code>kobject</code>集合 <code>kset</code></h4><ul>
<li><code>kset</code>是包含多个<code>kobject</code>的集合，如果在<code>sysfs</code>的目录中包含多个子目录，那需要将它定义成一个<code>kset</code>  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct kset - a set of kobjects of a specific type, belonging to a specific subsystem.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * A kset defines a group of kobjects.  They can be individually</span></span><br><span class="line"><span class="comment"> * different &quot;types&quot; but overall these kobjects all want to be grouped</span></span><br><span class="line"><span class="comment"> * together and operated on in the same manner.  ksets are used to</span></span><br><span class="line"><span class="comment"> * define the attribute callbacks and other common events that happen to</span></span><br><span class="line"><span class="comment"> * a kobject.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @list: the list of all kobjects for this kset</span></span><br><span class="line"><span class="comment"> * @list_lock: a lock for iterating over the kobjects</span></span><br><span class="line"><span class="comment"> * @kobj: the embedded kobject for this kset (recursion, isn&#x27;t it fun...)</span></span><br><span class="line"><span class="comment"> * @uevent_ops: the set of uevent operations for this kset.  These are</span></span><br><span class="line"><span class="comment"> * called whenever a kobject has something happen to it so that the kset</span></span><br><span class="line"><span class="comment"> * can add new environment variables, or filter out the uevents if so</span></span><br><span class="line"><span class="comment"> * desired.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kset</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">    <span class="keyword">spinlock_t</span> list_lock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">kset_uevent_ops</span> *<span class="title">uevent_ops</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><code>struct list_head list;</code>：包含在<code>kset</code>在内的所有<code>kobject</code>构成的一个双向链表</li>
<li><code>spinlock_t list_lock;</code>：遍历<code>kobject</code>时的锁</li>
<li><code>struct kobject kobj;</code>：归属于该<code>kset</code>的所有的<code>kobject</code>的parent</li>
<li><code>const struct kset_uevent_ops *uevent_ops;</code>：<code>kset</code>的<code>uevent</code>操作函数集，当<code>kset</code>中的<code>kobject</code>有状态变化时，会回调这个函数集</li>
</ul>
<h4 id="kobject类型-ktype"><a href="#kobject类型-ktype" class="headerlink" title="kobject类型 ktype"></a><code>kobject</code>类型 <code>ktype</code></h4><ul>
<li><code>kobj_type</code>用于表征<code>kobject</code>的类型，指定了删除<code>kobject</code>时要调用的函数，<code>kobject</code>结构体中有<code>struct kref</code>字段对<code>kobject</code>进行引用计数，当计数值为0时，就会调用<code>kobj_type</code>中的<code>release</code>函数对<code>kobject</code>进行释放</li>
<li><code>kobj_type</code>指定了通过<code>sysfs</code>显示或修改有关<code>kobject</code>的信息时要处理的操作，实际是调用<code>show/store</code>函数  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kobj_type</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> (*release)(struct kobject *kobj);</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sysfs_ops</span> *<span class="title">sysfs_ops</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">attribute</span> **<span class="title">default_attrs</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">kobj_ns_type_operations</span> *(*<span class="title">child_ns_type</span>)(<span class="keyword">struct</span> <span class="title">kobject</span> *<span class="title">kobj</span>);</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">void</span> *(*<span class="keyword">namespace</span>)(struct kobject *kobj);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sysfs_ops</span> &#123;</span></span><br><span class="line">    <span class="keyword">ssize_t</span>	(*show)(struct kobject *, struct attribute *, <span class="keyword">char</span> *);</span><br><span class="line">    <span class="keyword">ssize_t</span>	(*store)(struct kobject *, struct attribute *, <span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">size_t</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">attribute</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>		*name;</span><br><span class="line">    <span class="keyword">umode_t</span>			mode;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_LOCK_ALLOC</span></span><br><span class="line">    <span class="keyword">bool</span>			ignore_lockdep:<span class="number">1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span>	*<span class="title">key</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span>	<span class="title">skey</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><code>void (*release)(struct koject *kobj);</code> 释放<code>kobject</code>对象的接口，有点类似面向对象中的析构</li>
<li><code>const struct sysfs_ops *sysfs_ops;</code> 操作<code>kobject</code>的方法集</li>
<li><code>struct attribute **default_attrs;</code> 所谓的<code>attribute</code>就是内核控件和用户空间进行信息交互的一种方法，例如某个driver定义了一个变量，却希望用户空间程序可以修改该变量，那么可以将该变量以<code>sysfs attribute</code>的形式开放出来</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Driver</tag>
      </tags>
  </entry>
  <entry>
    <title>git使用记录</title>
    <url>/archives/21d76c15.html</url>
    <content><![CDATA[<p>本文记录git使用过程中用到的一些功能</p>
<span id="more"></span>

<h4 id="创建worktree"><a href="#创建worktree" class="headerlink" title="创建worktree"></a>创建worktree</h4><p>在各个差异较大的分支中切换，工程需要做全局编译，导致开发效率下降，创建worktree可以在多个分支并行开发，从而实多个工程环境的缓存，达到提升开发效率的目的，特点：</p>
<ul>
<li>可为一个分支创建一个工作区</li>
<li>每个工作区的工程环境独立运行</li>
<li>每个工作区共享同一个版本仓库信息</li>
</ul>
<p>相比通过git clone方式创建多个独立工程环境的工作区，git worktree的优点在于：</p>
<ul>
<li><strong>更节省硬盘空间</strong>：<code>git clone</code>方式下，每个工作区都有一个版本仓库，<code>git worktree</code>方式下，每个工作区共享同一个版本仓库，节省了n-1&#x2F;n（n为工作区数量）的硬盘空间</li>
<li><strong>各个工作区之间的更新同步更快</strong>：<code>git clone</code>方式下，A工作区和B工作区同步更新的步骤，A工作区commit -&gt; A工作区push -&gt; B工作区pull，<code>git worktree</code>方式下，A工作区只要本地提交更新后，其他工作区就能立即收到</li>
</ul>
<p><strong>git worktree使用</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入工程目录</span></span><br><span class="line"><span class="built_in">cd</span> path/to/project</span><br><span class="line"><span class="comment"># 创建worktree</span></span><br><span class="line">git worktree add worktree test_branch</span><br><span class="line"><span class="comment"># 进入工作区worktree上进行开发</span></span><br><span class="line"><span class="built_in">cd</span> worktree</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除工作区</span></span><br><span class="line">rm -rf worktree</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清理工作区信息</span></span><br><span class="line">git worktree prune</span><br></pre></td></tr></table></figure>

<h4 id="合并其他分支commit到当前分支"><a href="#合并其他分支commit到当前分支" class="headerlink" title="合并其他分支commit到当前分支"></a>合并其他分支commit到当前分支</h4><p>使用<code>git cherry-pick</code>将其他分支的commit合并到另一个分支</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git cherry-pick &lt;commit-id&gt;</span><br></pre></td></tr></table></figure>
<p>同时也支持批量合并，一次可以cherry-pick一个区间内的commit</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git cherry-pick &lt;start-commit-id&gt;..&lt;end-commit-id&gt;</span><br></pre></td></tr></table></figure>

<h4 id="git生成patch"><a href="#git生成patch" class="headerlink" title="git生成patch"></a>git生成patch</h4><p>使用<code>git format-patch</code>生成patch</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成单个commit的patch</span></span><br><span class="line">git format-patch -1 &lt;commit id&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成最近1次commit的patch</span></span><br><span class="line">git format-patch HEAD^</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成最近2次commit的patch</span></span><br><span class="line">git format-patch HEAD^^</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成两个commit间的修改的patch</span></span><br><span class="line"><span class="comment"># 生成的patch不包含commit id1</span></span><br><span class="line">git format-patch &lt;commit id1&gt;..&lt;commit id2&gt;</span><br></pre></td></tr></table></figure>
<p>合入patch</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 检查patch是否能正常合入</span></span><br><span class="line">git apply --check &lt;path/to/patch&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合入patch</span></span><br><span class="line">git apply &lt;path/to/patch&gt;</span><br></pre></td></tr></table></figure>

<h4 id="git-PR过程"><a href="#git-PR过程" class="headerlink" title="git PR过程"></a>git PR过程</h4><ol>
<li><p>在Git主页fork开源项目，然后将fork后的项目仓库clone到本地</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@gitlab.phytium.com.cn:huangjie1663/linux-kernel.git</span><br></pre></td></tr></table></figure></li>
<li><p>添加远程代码仓库地址</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jack@linux: git remote add upstream git@gitlab.phytium.com.cn:embedded/linux/linux-kernel.git</span><br><span class="line">jack@linux: git remote -v</span><br><span class="line">origin	git@gitlab.phytium.com.cn:huangjie1663/linux-kernel.git (fetch)</span><br><span class="line">origin	git@gitlab.phytium.com.cn:huangjie1663/linux-kernel.git (push)</span><br><span class="line">upstream	git@gitlab.phytium.com.cn:embedded/linux/linux-kernel.git (fetch)</span><br><span class="line">upstream	git@gitlab.phytium.com.cn:embedded/linux/linux-kernel.git (push)</span><br></pre></td></tr></table></figure>
<p>这时总共包含三个仓库信息：本地仓库、origin仓库、upstream仓库</p>
</li>
<li><p>更新git remote中所有远程仓库所包含分支的最新commit，并合并upstream</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git fetch upstream</span><br><span class="line">git merge upstream/branch</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="git代码回滚"><a href="#git代码回滚" class="headerlink" title="git代码回滚"></a>git代码回滚</h4><p>git代码回滚常用的两种方式：<code>git revert</code>和<code>git reset</code></p>
<p>git reset，将提交的commit从历史记录中删除，用途如下：</p>
<ul>
<li>新提交的commit有问题，想要撤销该笔提交，并保留修改的内容<code>git reset --soft HEAD^</code></li>
<li>撤销新提交的commit，不保留修改的内容<code>git reset --hard HEAD^</code></li>
</ul>
<h4 id="git暂存文件转为unstage"><a href="#git暂存文件转为unstage" class="headerlink" title="git暂存文件转为unstage"></a>git暂存文件转为unstage</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 当前所有暂存文件全部转为unstage状态</span></span><br><span class="line">git restore --staged .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将某个暂存文件转为unstage状态</span></span><br><span class="line">git restore --staged &lt;filename&gt;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux percpu机制</title>
    <url>/archives/cda25bee.html</url>
    <content><![CDATA[<h4 id="percpu机制"><a href="#percpu机制" class="headerlink" title="percpu机制"></a>percpu机制</h4><p>在SMP架构中，每个CPU都拥有自己的高速缓存，通常，L1 cache是CPU独占的，每个CPU都有一份，它的速度自然是最快的，当CPU载入一个全局数据时，会逐级地查看高速缓存，如果没有在缓存中命中，就从内存中载入，并加入到各级cache中，当下次需要读取这个值时，直接读取cache将获得非常快的速度，比直接读取内存高出几个数量级。</p>
<span id="more"></span>

<p>对于读而言，cache带来了巨大的性能提升，当涉及到修改时，也是在缓存中进行操作，然后同步到内存中，对于单CPU而言，这没有什么问题，但是对于SMP架构而言，一个CPU对全局数据的修改将会导致所有其它CPU上对该全局数据的缓存失效，需要全部进行更新，这个操作将带来性能上的损失。</p>
<p>而最好的同步机制就是抑制同步产生的条件，因为每一种显式的同步机制都有着不可忽视的性能开销，percpu就是这样一种同步机制：为了避免多个CPU对全局数据的竞争而导致的性能损失，percpu直接为每个CPU生成一份独有的数据备份，每个数据备份占用独立的内存，CPU不应该修改不属于自己的这部分数据，这样就避免了多CPU对全局数据的竞争问题。</p>
<p>事实上，percpu只适合在特殊条件下使用：也就是当它确定在系统的CPU上的<strong>数据在逻辑上是独立的</strong>时候。正因为它的这种应用场景，CPU之间的percpu变量并不需要同步，在整个percpu的生命周期内，percpu变量对应的CPU副本都被对应的CPU独占使用。</p>
<h4 id="percpu的存储"><a href="#percpu的存储" class="headerlink" title="percpu的存储"></a>percpu的存储</h4><p>在linux内核的Image中，存在各种不同的section，在内核代码中也时常可以看到__attribute__关键字自定义section ：<code>__attribute__(section(&quot;.section&quot;))</code></p>
<p><code>__attribute__(section())</code>的作用就是将所修饰的对象放在编译生成二进制文件的指定 section中，最常见的section有.data .bss，在程序链接的阶段将会确定每个section最终的加载地址</p>
<p>对于普通的变量而言，</p>
<h4 id="percpu变量的使用"><a href="#percpu变量的使用" class="headerlink" title="percpu变量的使用"></a>percpu变量的使用</h4><h5 id="percpu的定义：静态定义和动态定义"><a href="#percpu的定义：静态定义和动态定义" class="headerlink" title="percpu的定义：静态定义和动态定义"></a>percpu的定义：静态定义和动态定义</h5><p>静态地定义一个percpu变量</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DEFINE_PER_CPU(type, name);</span><br><span class="line"><span class="comment">// include/linux/percpu-defs.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFINE_PER_CPU(type, name) \</span></span><br><span class="line"><span class="meta">    DEFINE_PER_CPU_SECTION(type, name, <span class="meta-string">&quot;&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFINE_PER_CPU_SECTION(type, name, sec) \</span></span><br><span class="line"><span class="meta">    __PCPU_ATTRS(sec) __typeof__(type) name</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __PCPU_ATTRS(sec) \</span></span><br><span class="line"><span class="meta">    __percpu __attribute__((section(PER_CPU_BASE_SECTION sec))) \</span></span><br><span class="line"><span class="meta">    PER_CPU_ATTRIBUTES</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// include/asm-generic/percpu.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PER_CPU_BASE_SECTION <span class="meta-string">&quot;.data..percpu&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 宏展开后为</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFINE_PER_CPU(type, name) \</span></span><br><span class="line"><span class="meta">    __percpu __attribute__((section(<span class="meta-string">&quot;.data..percpu&quot;</span>))) __typeof__(type) name;\</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> \</span></span><br><span class="line"><span class="meta">    __percpu __attribute__((section(<span class="meta-string">&quot;.data&quot;</span>))) __typeof__(type) name; \</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>整个定义翻译过来就是：在SMP架构下，被定义的percpu变量在编译后放在<code>.data..percpu</code>这个section中</p>
<h5 id="percpu读写"><a href="#percpu读写" class="headerlink" title="percpu读写"></a>percpu读写</h5><p>对于静态定义的percpu变量，通常使用以下的接口</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">get_cpu_var(name);</span><br><span class="line">put_cpu_var(name);</span><br></pre></td></tr></table></figure>
<p>使用通常是这样的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DEFINE_PER_CPU(<span class="keyword">int</span>, val);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *p = &amp;get_cpu_val(val);</span><br><span class="line">*p++;</span><br><span class="line">put_cpu_var(val);</span><br></pre></td></tr></table></figure>

<p>事实上，put_cpu_var 并非字面上理解的：将变量放回内存，事实上它仅仅是使能了在 get_cpu_var 函数中关闭的内核抢占。所以，put_cpu_var()和get_cpu_var()是成对出现的，因为这段时间内核抢占处于关闭状态，他们之间的代码不宜执行太长时间。</p>
<p>动态percpu变量操作的接口</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 动态percpu变量操作</span></span><br><span class="line">per_cpu_ptr(ptr, cpu);</span><br></pre></td></tr></table></figure>
<p>与静态变量的操作接口不一样，这个接口允许指定CPU，不再是只能获取当前CPU的值，而第一个参数是动态申请时返回的指针，通过该指针加上offset来获取percpu变量的地址，通常操作如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *ptr = alloc_percpu(<span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *p = per_cpu_ptr(ptr, raw_smp_processor_id());</span><br><span class="line">(*p)++;</span><br></pre></td></tr></table></figure>
<p>其中，raw_smp_processor_id()函数返回当前CPU num，这个示例也就是操作当前CPU的percpu变量，这个接口并不需要禁止内核抢占，因为不管进程被切换到哪个CPU上执行，它所操作的都是第二个参数提供的CPU</p>
<h4 id="percpu实现"><a href="#percpu实现" class="headerlink" title="percpu实现"></a>percpu实现</h4><h5 id="percpu内存块描述数据结构"><a href="#percpu内存块描述数据结构" class="headerlink" title="percpu内存块描述数据结构"></a>percpu内存块描述数据结构</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pcpu_alloc_info</span> &#123;</span></span><br><span class="line">    <span class="keyword">size_t</span>  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="percpu内存的初始化"><a href="#percpu内存的初始化" class="headerlink" title="percpu内存的初始化"></a>percpu内存的初始化</h5><p>percpu主要的初始化函数为<code>setup_per_cpu_areas()</code>，这个函数在<code>start_kernel()</code>中被直接调用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/linux/percpu.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PERCPU_MODULE_RESERVE   (8 &lt;&lt; 10)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// mm/percpu.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> __init <span class="title">setup_per_cpu_areas</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> delta;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> cpu;</span><br><span class="line">	<span class="keyword">int</span> rc;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Always reserve area for module percpu variables.  That&#x27;s</span></span><br><span class="line"><span class="comment">	 * what the legacy allocator did.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">// 申请并初始化内存块</span></span><br><span class="line">	rc = pcpu_embed_first_chunk(PERCPU_MODULE_RESERVE,</span><br><span class="line">				    PERCPU_DYNAMIC_RESERVE, PAGE_SIZE, <span class="literal">NULL</span>,</span><br><span class="line">				    pcpu_dfl_fc_alloc, pcpu_dfl_fc_free);</span><br><span class="line">	<span class="keyword">if</span> (rc &lt; <span class="number">0</span>)</span><br><span class="line">		panic(<span class="string">&quot;Failed to initialize percpu areas.&quot;</span>);</span><br><span class="line"></span><br><span class="line">	delta = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)pcpu_base_addr - (<span class="keyword">unsigned</span> <span class="keyword">long</span>)__per_cpu_start;</span><br><span class="line">    <span class="comment">// 计算每个cpu相对于源内存地址的偏移量</span></span><br><span class="line">    <span class="comment">// 当使用get_cpu_var(name)来获取变量地址时，首先找到的是源变量，然后通过地址偏移找到对应</span></span><br><span class="line">    <span class="comment">// cpu的percpu变量</span></span><br><span class="line">	for_each_possible_cpu(cpu)</span><br><span class="line">		__per_cpu_offset[cpu] = delta + pcpu_unit_offsets[cpu];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * pcpu_embed_first_chunk - embed the first percpu chunk into bootmem</span></span><br><span class="line"><span class="comment"> * @reserved_size: the size of reserved percpu area in bytes</span></span><br><span class="line"><span class="comment"> * @dyn_size: minimum free size for dynamic allocation in bytes</span></span><br><span class="line"><span class="comment"> * @atom_size: allocation atom size</span></span><br><span class="line"><span class="comment"> * @cpu_distance_fn: callback to determine distance between cpus, optional</span></span><br><span class="line"><span class="comment"> * @alloc_fn: function to allocate percpu page</span></span><br><span class="line"><span class="comment"> * @free_fn: function to free percpu page</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This is a helper to ease setting up embedded first percpu chunk and</span></span><br><span class="line"><span class="comment"> * can be called where pcpu_setup_first_chunk() is expected.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If this function is used to setup the first chunk, it is allocated</span></span><br><span class="line"><span class="comment"> * by calling @alloc_fn and used as-is without being mapped into</span></span><br><span class="line"><span class="comment"> * vmalloc area.  Allocations are always whole multiples of @atom_size</span></span><br><span class="line"><span class="comment"> * aligned to @atom_size.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This enables the first chunk to piggy back on the linear physical</span></span><br><span class="line"><span class="comment"> * mapping which often uses larger page size.  Please note that this</span></span><br><span class="line"><span class="comment"> * can result in very sparse cpu-&gt;unit mapping on NUMA machines thus</span></span><br><span class="line"><span class="comment"> * requiring large vmalloc address space.  Don&#x27;t use this allocator if</span></span><br><span class="line"><span class="comment"> * vmalloc space is not orders of magnitude larger than distances</span></span><br><span class="line"><span class="comment"> * between node memory addresses (ie. 32bit NUMA machines).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @dyn_size specifies the minimum dynamic area size.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If the needed size is smaller than the minimum or specified unit</span></span><br><span class="line"><span class="comment"> * size, the leftover is returned using @free_fn.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * RETURNS:</span></span><br><span class="line"><span class="comment"> * 0 on success, -errno on failure.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 生成percpu内存块</span></span><br><span class="line"><span class="comment">// 保留大小为8k字节</span></span><br><span class="line"><span class="comment">// percpu动态分配区域大小为28k</span></span><br><span class="line"><span class="comment">// atom_size 12k</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> __init <span class="title">pcpu_embed_first_chunk</span><span class="params">(<span class="keyword">size_t</span> reserved_size, <span class="keyword">size_t</span> dyn_size,</span></span></span><br><span class="line"><span class="params"><span class="function">				  <span class="keyword">size_t</span> atom_size,</span></span></span><br><span class="line"><span class="params"><span class="function">				  <span class="keyword">pcpu_fc_cpu_distance_fn_t</span> cpu_distance_fn,</span></span></span><br><span class="line"><span class="params"><span class="function">				  <span class="keyword">pcpu_fc_alloc_fn_t</span> alloc_fn,</span></span></span><br><span class="line"><span class="params"><span class="function">				  <span class="keyword">pcpu_fc_free_fn_t</span> free_fn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">void</span> *base = (<span class="keyword">void</span> *)ULONG_MAX;</span><br><span class="line">	<span class="keyword">void</span> **areas = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pcpu_alloc_info</span> *<span class="title">ai</span>;</span></span><br><span class="line">	<span class="keyword">size_t</span> size_sum, areas_size;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> max_distance;</span><br><span class="line">	<span class="keyword">int</span> group, i, highest_group, rc = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	ai = pcpu_build_alloc_info(reserved_size, dyn_size, atom_size,</span><br><span class="line">				   cpu_distance_fn);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(ai))</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(ai);</span><br><span class="line"></span><br><span class="line">	size_sum = ai-&gt;static_size + ai-&gt;reserved_size + ai-&gt;dyn_size;</span><br><span class="line">	areas_size = PFN_ALIGN(ai-&gt;nr_groups * <span class="keyword">sizeof</span>(<span class="keyword">void</span> *));</span><br><span class="line"></span><br><span class="line">	areas = memblock_alloc(areas_size, SMP_CACHE_BYTES);</span><br><span class="line">	<span class="keyword">if</span> (!areas) &#123;</span><br><span class="line">		rc = -ENOMEM;</span><br><span class="line">		<span class="keyword">goto</span> out_free;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* allocate, copy and determine base address &amp; max_distance */</span></span><br><span class="line">	highest_group = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (group = <span class="number">0</span>; group &lt; ai-&gt;nr_groups; group++) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">pcpu_group_info</span> *<span class="title">gi</span> =</span> &amp;ai-&gt;groups[group];</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">int</span> cpu = NR_CPUS;</span><br><span class="line">		<span class="keyword">void</span> *ptr;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; gi-&gt;nr_units &amp;&amp; cpu == NR_CPUS; i++)</span><br><span class="line">			cpu = gi-&gt;cpu_map[i];</span><br><span class="line">		BUG_ON(cpu == NR_CPUS);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* allocate space for the whole group */</span></span><br><span class="line">		ptr = alloc_fn(cpu, gi-&gt;nr_units * ai-&gt;unit_size, atom_size);</span><br><span class="line">		<span class="keyword">if</span> (!ptr) &#123;</span><br><span class="line">			rc = -ENOMEM;</span><br><span class="line">			<span class="keyword">goto</span> out_free_areas;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/* kmemleak tracks the percpu allocations separately */</span></span><br><span class="line">		kmemleak_free(ptr);</span><br><span class="line">		areas[group] = ptr;</span><br><span class="line"></span><br><span class="line">		base = min(ptr, base);</span><br><span class="line">		<span class="keyword">if</span> (ptr &gt; areas[highest_group])</span><br><span class="line">			highest_group = group;</span><br><span class="line">	&#125;</span><br><span class="line">	max_distance = areas[highest_group] - base;</span><br><span class="line">	max_distance += ai-&gt;unit_size * ai-&gt;groups[highest_group].nr_units;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* warn if maximum distance is further than 75% of vmalloc space */</span></span><br><span class="line">	<span class="keyword">if</span> (max_distance &gt; VMALLOC_TOTAL * <span class="number">3</span> / <span class="number">4</span>) &#123;</span><br><span class="line">		pr_warn(<span class="string">&quot;max_distance=0x%lx too large for vmalloc space 0x%lx\n&quot;</span>,</span><br><span class="line">				max_distance, VMALLOC_TOTAL);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NEED_PER_CPU_PAGE_FIRST_CHUNK</span></span><br><span class="line">		<span class="comment">/* and fail if we have fallback */</span></span><br><span class="line">		rc = -EINVAL;</span><br><span class="line">		<span class="keyword">goto</span> out_free_areas;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Copy data and free unused parts.  This should happen after all</span></span><br><span class="line"><span class="comment">	 * allocations are complete; otherwise, we may end up with</span></span><br><span class="line"><span class="comment">	 * overlapping groups.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">for</span> (group = <span class="number">0</span>; group &lt; ai-&gt;nr_groups; group++) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">pcpu_group_info</span> *<span class="title">gi</span> =</span> &amp;ai-&gt;groups[group];</span><br><span class="line">		<span class="keyword">void</span> *ptr = areas[group];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; gi-&gt;nr_units; i++, ptr += ai-&gt;unit_size) &#123;</span><br><span class="line">			<span class="keyword">if</span> (gi-&gt;cpu_map[i] == NR_CPUS) &#123;</span><br><span class="line">				<span class="comment">/* unused unit, free whole */</span></span><br><span class="line">				free_fn(ptr, ai-&gt;unit_size);</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">/* copy and return the unused part */</span></span><br><span class="line">			<span class="built_in">memcpy</span>(ptr, __per_cpu_load, ai-&gt;static_size);</span><br><span class="line">			free_fn(ptr + size_sum, ai-&gt;unit_size - size_sum);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* base address is now known, determine group base offsets */</span></span><br><span class="line">	<span class="keyword">for</span> (group = <span class="number">0</span>; group &lt; ai-&gt;nr_groups; group++) &#123;</span><br><span class="line">		ai-&gt;groups[group].base_offset = areas[group] - base;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pr_info(<span class="string">&quot;Embedded %zu pages/cpu s%zu r%zu d%zu u%zu\n&quot;</span>,</span><br><span class="line">		PFN_DOWN(size_sum), ai-&gt;static_size, ai-&gt;reserved_size,</span><br><span class="line">		ai-&gt;dyn_size, ai-&gt;unit_size);</span><br><span class="line"></span><br><span class="line">	pcpu_setup_first_chunk(ai, base);</span><br><span class="line">	<span class="keyword">goto</span> out_free;</span><br><span class="line"></span><br><span class="line">out_free_areas:</span><br><span class="line">	<span class="keyword">for</span> (group = <span class="number">0</span>; group &lt; ai-&gt;nr_groups; group++)</span><br><span class="line">		<span class="keyword">if</span> (areas[group])</span><br><span class="line">			free_fn(areas[group],</span><br><span class="line">				ai-&gt;groups[group].nr_units * ai-&gt;unit_size);</span><br><span class="line">out_free:</span><br><span class="line">	pcpu_free_alloc_info(ai);</span><br><span class="line">	<span class="keyword">if</span> (areas)</span><br><span class="line">		memblock_free_early(__pa(areas), areas_size);</span><br><span class="line">	<span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="section的处理与链接"><a href="#section的处理与链接" class="headerlink" title="section的处理与链接"></a>section的处理与链接</h5><p>在链接脚本arch&#x2F;arm64&#x2F;kernel&#x2F;vmlinux.lds中，对<code>.data..percpu section</code>进行了重定位，为该section 分别加载地址</p>
<figure class="highlight cos"><table><tr><td class="code"><pre><span class="line">. = ALIGN((<span class="number">1</span> &lt;&lt; <span class="number">12</span>))<span class="comment">; </span></span><br><span class="line">.data<span class="built_in">..percpu</span> : AT(ADDR(.data<span class="built_in">..percpu</span>) - <span class="number">0</span>) &#123; </span><br><span class="line">    __per_cpu_load = .<span class="comment">; </span></span><br><span class="line">    __per_cpu_start = .<span class="comment">; </span></span><br><span class="line">    *(.data<span class="built_in">..percpu</span><span class="built_in">..first</span>) . = ALIGN((<span class="number">1</span> &lt;&lt; <span class="number">12</span>))<span class="comment">; </span></span><br><span class="line">    *(.data<span class="built_in">..percpu</span><span class="built_in">..page</span>_aligned) . = ALIGN((<span class="number">1</span> &lt;&lt; (<span class="number">6</span>)))<span class="comment">; </span></span><br><span class="line">    *(.data<span class="built_in">..percpu</span><span class="built_in">..read</span>_mostly) . = ALIGN((<span class="number">1</span> &lt;&lt; (<span class="number">6</span>)))<span class="comment">; </span></span><br><span class="line">    *(.data<span class="built_in">..percpu</span>) *(.data<span class="built_in">..percpu</span><span class="built_in">..shared</span>_aligned) __per_cpu_end = .<span class="comment">; </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用alloc_percpu动态地分配一个percpu变量，返回percpu变量的地址，但是这个返回的地址并非是可以直接使用的变量地址，就像静态定义的那样，这只是一个原始数据，真正被使用的数据被copy成n份分别保存在每个CPU独占的地址空间中，在访问percpu变量时就是对每个副本进行访问</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">type __percpu *ptr <span class="title">alloc_percpu</span><span class="params">(type)</span></span>;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>percpu</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核likely()和unlikely()</title>
    <url>/archives/8c0c86d5.html</url>
    <content><![CDATA[<p>Linux内核中多次出现<code>likely()</code>，<code>unlikely()</code>的使用，他们的定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> likely(x)     __builtin_expect(!!(x), 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> unlikely(x)   __builtin_expect(!!(x), 0)</span></span><br></pre></td></tr></table></figure>

<span id="more"></span>
<p><code>__builtin_expect</code>是GCC提供的内置函数（built-in functions），函数原型是</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> __builtin_expect(<span class="keyword">long</span> <span class="built_in">exp</span>, <span class="keyword">long</span> c);</span><br></pre></td></tr></table></figure>
<p>函数的返回值就是<code>exp</code>，不过他告诉编译器，代码期望的是<code>exp == c</code>， 如果<code>exp == c</code>条件成立的机会占绝大多数，那么程序运行性能将会得到提升，否则性能反而会下降</p>
<p><code>builtin_expect()</code>用来引导gcc进行条件分支预测，在一条指令执行时，由于流水线的作用，CPU可以同时完成下一条指令的预取，这样可以提高CPU的利用率，在执行条件分支时，CPU也会预期下一条指令，但是如果预测的结果不为<code>exp == c</code>那么CPU预取的下一条指令就没用了，这样就降低了流水线的效率，跳转指令相对于顺序执行的指令会多消CPU时间，如果可以尽可能不执行跳转，也可以提高CPU性能。</p>
<p>表面上看<code>if(likely(value))</code>和<code>if(unlikely(value))</code>都等同于<code>if(value)</code>，也就是<code>likely()</code>和<code>unlikely()</code>作用是一样的，但是实际上执行的效果是不同的（从指令预测的角度上来说），加<code>likely</code>的意思是value为真的可能性更大一些，那么预测执行if的可能性要大些，<code>unlikely</code>正好相反。</p>
<p>加上这种修饰，编译成二进制代码时<code>likely</code>使得if后面的执行语句紧跟着前面的程序，<code>unlikely</code>使得else后面的语句紧跟着前面的程序，这样就会被cache预读取，增加程序的执行速度。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>ARMv8体系架构</title>
    <url>/archives/17165b72.html</url>
    <content><![CDATA[<h3 id="ARMv8-A架构及其对应处理器特性"><a href="#ARMv8-A架构及其对应处理器特性" class="headerlink" title="ARMv8-A架构及其对应处理器特性"></a>ARMv8-A架构及其对应处理器特性</h3><p><img src="https://raw.githubusercontent.com/JackHuang021/images/master/20230128094507.png"></p>
<span id="more"></span>

<h3 id="ARMv8异常等级"><a href="#ARMv8异常等级" class="headerlink" title="ARMv8异常等级"></a>ARMv8异常等级</h3><p><strong>软件运行异常级别</strong>：</p>
<ul>
<li>EL0: 普通用户应用程序</li>
<li>EL1: 操作系统内核通常被描述为具有特权的</li>
<li>EL2: 管理程序</li>
<li>EL3: 低级固件，包括安全监视器<br><img src="https://raw.githubusercontent.com/JackHuang021/images/master/20230128095322.png"></li>
</ul>
<p>ARMv8体系架构提供两种安全状态：secure和non-secure，每种安全状态有独立的物理地址空间范围，在Secure state，PE可以访问Secure和Non-secure的物理地址空间范围，在Non-secure state，PE只能访问Non-secure的物理地址空间范围，Secure state和Non-secure state将运行环境划分为Normal world和Secure world，且EL3存在于Secure state</p>
<p>异常等级切换规则：</p>
<ul>
<li>当发生一个异常时，异常等级只能上升或者维持不变</li>
<li>当从一个异常返回时，异常等级只能下降或者维持不变</li>
<li>一个异常要进入的异常等级称作target exception level，EL0不能作为target exception level，也就是说所有异常都不会在EL0中处理</li>
</ul>
<h3 id="ARMv8执行状态"><a href="#ARMv8执行状态" class="headerlink" title="ARMv8执行状态"></a>ARMv8执行状态</h3><p>ARMv8体系结构提供了2种执行状态，AArch64和AArch32，其中AArch32执行状态用于实现与ARMv7体系结构兼容</p>
<p>执行状态定义了PE的执行环境，包括：</p>
<ul>
<li>寄存器宽度</li>
<li>指令集</li>
<li>异常模式</li>
<li>虚拟内存系统架构</li>
<li>编程模型</li>
</ul>
<p>AArch64执行状态：</p>
<ul>
<li>提供31个64位的通用寄存器（X0~X30）</li>
<li>提供64位的程序计数寄存器PC，栈指针寄存器SP，异常链接寄存器ELR</li>
<li>提供32个128位的用于SIMD与浮点运算寄存器</li>
<li>提供A64指令集</li>
<li>使用ARMv8异常模型，支持4个异常等级（EL0~EL3）</li>
<li>支持64位的虚拟内存寻址</li>
<li>使用一组处理器状态（PSTATE）寄存器保存PE状态</li>
<li>每个系统寄存器命名时，带有异常等级后缀，该后缀决定了可访问该寄存器的最低异常等级</li>
</ul>
<p>AArch32执行状态</p>
<ul>
<li>提供13个32位的通用寄存器</li>
<li>提供32位的程序计数寄存器PC、栈指针寄存器SP、链接寄存器LR，其中LR同时也用作ELR</li>
<li>提供32个64位的用于SIMD和浮点运算的寄存器</li>
<li>提供A32和T32指令集</li>
<li>支持ARMv7-A异常模型，实现时将PE模式映射到ARMv8的异常模型</li>
<li>支持32位的虚拟地址寻址</li>
<li>使用一组处理器状态（PSTATE）寄存器保存PE状态，A32和T32指令通过APSR和CPSR访问</li>
</ul>
<p>执行状态切换：</p>
<ul>
<li>如果需要在一个64位操作系统上运行32位的应用程序，就需要将执行状态从AArch64切换到AArch32</li>
<li>当32位应用程序运行完成时，或者需要陷入64位操作系统执行时，就需要将执行状态从AArch32再切换回AArch64</li>
</ul>
<p>执行状态切换规则：只能通过异常陷入更高的异常等级，才能进行执行状态的切换，例如在64位操作系统（EL1）上需要运行32位和64位应用程序（EL0），假设当前32位应用程序正在运行，那么他需要通过SVC指令或者接收到一个中断从而陷入到EL1的64位操作系统。此时操作系统可以进行任务调度，从而切换到64位的应用程序运行</p>
<h3 id="ARMv8寄存器组"><a href="#ARMv8寄存器组" class="headerlink" title="ARMv8寄存器组"></a>ARMv8寄存器组</h3><p>AArch64的执行状态提供了可在所有时间和所有异常级别访问的31个64位通用寄存器，分别是X0<del>X30，每一个64位的通用寄存器(X0</del>X30)的低32位又由32位的寄存器(W0~W30)组成<br><img src="https://raw.githubusercontent.com/JackHuang021/images/master/20230128094339.png"></p>
<h4 id="AArch64特殊寄存器"><a href="#AArch64特殊寄存器" class="headerlink" title="AArch64特殊寄存器"></a>AArch64特殊寄存器</h4><p><img src="https://raw.githubusercontent.com/JackHuang021/images/master/20230128102622.png"></p>
<p>当访问Zero寄存器，所有的写入都被忽略，所有的读取都返回0，AArch32执行状态使用WZR指令访问zero寄存器，使用WSP指令访问当前栈指针寄存器；AArch64执行状态使用XZR访问zero寄存器，使用SP指令访问当前栈指针寄存器，AArch32和AArch64执行状态下都使用PC指令访问程序计数寄存器<br><img src="https://raw.githubusercontent.com/JackHuang021/images/master/20230128104400.png"></p>
<p>每个异常级别中都有专用的SP寄存器，退出该异常级别时不需要保存<br><img src="https://raw.githubusercontent.com/JackHuang021/images/master/20230128104005.png"></p>
<p><strong>Zero寄存器</strong><br>当Zero寄存器当作源寄存器读取时，会得到0值，当Zero寄存器当作目的寄存器写入时，写入的值被丢弃，</p>
<p><strong>Stack Pointer寄存器</strong><br>在ARMv8架构中，每个异常级别都拥有栈指针寄存器，即拥有4个栈指针寄存器。在默认情况下，异常级别ELn对应SP_ELn，当处理器的执行状态为AArch64且不处于异常级别EL0，则可以使用与异常级别相关的专用64位堆栈指针(SP_ELn)和异常级别EL0相关的堆栈指针寄存器(SP_EL0)，各个异常级别与可使用的栈寄存器关系如下图所示（后缀t表示使用SP_EL0堆栈指针，h表示使用SP_ELx堆栈指针）<br><img src="https://raw.githubusercontent.com/JackHuang021/images/master/20230128134348.png"></p>
<p><strong>Program Counter寄存器</strong><br>ARMv8架构中删除了对PC寄存器的直接访问，PC寄存器不能作为命名寄存器访问，而是通过确定的指令隐含的访问</p>
<p><strong>Exception Link寄存器</strong><br>ELR寄存器保存了异常返回地址，ARMv8定义了3个ELR寄存器，分别对应异常级别EL1, EL2, EL3，当异常发生时，异常返回地址将被保存在target exception level的ELR寄存器，当异常返回时，将使用的ELR寄存器中的值恢复到PC寄存器，和SPSR寄存器一样，异常发生时也只能使用与targe exception level相应的ELR_ELn</p>
<p><strong>Saved Process Status寄存器</strong><br>当异常发生时，处理器的状态将会被保存到相关的SPSR寄存器中，异常发生后，在处理异常之前，处理器会自动的将PSTATE寄存器的内容保存到SPSR中，异常返回时，会将SPSR保存的处理器状态恢复到PSTATE中，ARMv8定义的SPSR寄存器如下，兼容ARMv7中的SPSR寄存器，只使用低32位。在ARMv8架构中，有3个SPSR寄存器，分别为SPSR_EL1、SPSR_EL2、SPSR_EL3，使用那个SPSR寄存器依赖于异常级别<br><img src="https://raw.githubusercontent.com/JackHuang021/images/master/20230128135732.png"><br>各个位的定义如下：</p>
<ul>
<li>N：符号位</li>
<li>Z：0标志</li>
<li>C：操作进位</li>
<li>V：溢出标志</li>
<li>SS：用于软件调试，异常发生的时候，可通过设置启用单步调试机制</li>
<li>IL：不合法的执行状态，保存自PSTATE.IL</li>
<li>D：处理器状态调试掩码，指示是否屏蔽来自观察点、断电和软件单步调试事件的调试异常</li>
<li>A：系统错误掩码</li>
<li>I：IRQ掩码位</li>
<li>F：FIQ掩码位</li>
<li>M[4]：发生异常时处理器的执行状态，0表示AArch64</li>
<li>M[3:0]：M[3:2]发生异常的级别，M[1]保留，M[0]根据此选择栈指针寄存器，0表示t，1表示h</li>
</ul>
<h4 id="Processor-State"><a href="#Processor-State" class="headerlink" title="Processor State"></a>Processor State</h4><p>AArch64没有类似ARMv7 Current Program Status Register（CPSR）的寄存器，在AArch64的执行状态中，处理器状态要用PSTATE描述，但PSTATE不是寄存器，而是处理器状态各个位域的总称，PSTATE的大部分位域和传统CPSR寄存器中的位域相同。EL0可以访问PSTATE的N、Z、C、V位域，DAIF标志位需要经过配置对EL0才可见，其他域只能在EL1及更高的异常级别中访问。PSTATE的位域如下图所示：<br><img src="https://raw.githubusercontent.com/JackHuang021/images/master/20230128144328.png"></p>
<p>PSTATE状态位的访问：ARMv8体系架构提供了一组特殊寄存器，用于访问PSTATE状态位</p>
<h4 id="System-Registers"><a href="#System-Registers" class="headerlink" title="System Registers"></a>System Registers</h4><p>ARMv8体系架构中定义了很多系统寄存器，通过访问和设置这些系统寄存器（通过MRS &#x2F; MSR指令）来完成对处理器的功能设置，<register_name>_ELn，其中ELn标识了可访问该寄存器的最低异常等级</p>
<p>AMRv8体系架构支持如下7类系统寄存器</p>
<ol>
<li>通用系统控制寄存器</li>
<li>调试寄存器</li>
<li>性能监控寄存器</li>
<li>活动监控寄存器</li>
<li>统计扩展寄存器</li>
<li>通用定时器寄存器</li>
</ol>
]]></content>
      <categories>
        <category>ARM</category>
      </categories>
      <tags>
        <tag>ARMv8</tag>
        <tag>Register</tag>
      </tags>
  </entry>
  <entry>
    <title>arm64 vmlinux.lds分析</title>
    <url>/archives/1a380da4.html</url>
    <content><![CDATA[<p>vmlinux.lds.S主要是用来组织内核每个函数存放在内核镜像文件的位置，编译内核源码生成内核文件的过程分两步，一个是编译过程，另一个是链接过程。vmlinux.lds.S要做的就是告诉编译器如何链接编译好的各个.o文件，未经编译的内核源码是不存在vmlinux.lds链接脚本的，在<code>arch/arm64/kernel</code>目录只有vmlinux.lds.S文件，以及在<code>include/asm-generic</code>目录有一个与之关联的vmlinux.lds.h文件，在内核编译的时候会根据一些宏定义和传入的参数构建出针对特定平台、特定架构的vmlinux.lds链接脚本</p>
<span id="more"></span>

<h3 id="链接器"><a href="#链接器" class="headerlink" title="链接器"></a>链接器</h3><p>现代软件工程中，一个大的程序通常都由多个源文件组成，其中包含以高级计算机语言编写的源文件以及汇编语言编写的汇编文件。在编译构建过程中会分别对这些源文件进行汇编或者编译并生成目标文件，这些目录文件包含代码段、数据段、符号表等内容。而链接则是把这些目标文件的代码段、数据段以及符号表等内容收集起来并按照某种格式（例如ELF）组合成一个可执行二进制文件的过程。而这个过程是使用<strong>链接器</strong>来完成的。</p>
<p>链接器在链接过程中会使用到一个链接脚本文件，该文件用于描述链接的过程，当没有通过“-T”参数指定链接脚本时，链接器会使用内置的链接脚本。链接脚本控制着如何把输入文件中的段合并到输出文件的段中，以及这些段的地址空间布局等。本质上则是把在编译构建过程中大量的二进制文件（.o文件）合并成一个可执行的二进制文件。</p>
<h4 id="常用段说明"><a href="#常用段说明" class="headerlink" title="常用段说明"></a>常用段说明</h4><table>
<thead>
<tr>
<th align="center">段名称</th>
<th align="center">主要作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">init段</td>
<td align="center">Linux定义的一种初始化过程中才会用到的段，一旦初始化完成，那么这些段所占用的内存会被释放掉</td>
</tr>
<tr>
<td align="center">text段</td>
<td align="center">代码段，通常是指用来存放程序代码的一块内存区域，这部分区域的大小在程序运行前就已经确定</td>
</tr>
<tr>
<td align="center">data段</td>
<td align="center">数据段，通常是指用来存放程序中已初始化的全局变量的一块内存区域，数据段属于静态内存分配</td>
</tr>
<tr>
<td align="center">bss段</td>
<td align="center">通常是指用来存放程序中未初始化的全局变量和静态变量的一块内存区域，属于静态内存分配</td>
</tr>
</tbody></table>
<h4 id="地址解释"><a href="#地址解释" class="headerlink" title="地址解释"></a>地址解释</h4><p><strong>运行地址：</strong> CPU执行一条程序中指令时的执行地址，也就是PC寄存器中的值。更简单的讲，就是要寻址到一个指令或者变量所使用的地址<br><strong>加载地址：</strong> 程序中指令和变量等加载到RAM上的地址<br><strong>链接地址：</strong> 链接过程中链接器为指令和变量分配的地址</p>
<p><strong>地址之间的联系</strong></p>
<ul>
<li>如果没有打开MMU，并且使用的是位置相关设计，那么加载地址、运行地址、链接地址三者需要一致</li>
<li>当打开MMU之前，如果使用的是位置无关设计，那么运行地址和加载地址应该是一致的</li>
</ul>
<h3 id="链接脚本分析"><a href="#链接脚本分析" class="headerlink" title="链接脚本分析"></a>链接脚本分析</h3><p>链接脚本最终要把.o文件生成最终的二进制可执行文件，也就是把每一个.o文件整合到一个大文件中，这个大文件有总的text、data、bss段，还有一些别的段</p>
<p>示例</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SECTIONS</span><br><span class="line">(</span><br><span class="line">    . = <span class="number">0x10000</span>;        <span class="comment">/* 链接地址为0x10000，即指定了后面text段的地址 */</span></span><br><span class="line">    .text = &#123;*(.text)&#125;  <span class="comment">/* 输出文件的text段内容，由所有文件的text段组成（* 理解为所有的.o文件）*/</span></span><br><span class="line">    . = <span class="number">0x8000000</span>;      <span class="comment">/* 链接地址改变为0x8000000，指定了后面data段的链接地址 */</span></span><br><span class="line">    .data = &#123;*(.data)&#125;  <span class="comment">/* 输出文件的data段由所有输入文件的data段组成 */</span></span><br><span class="line">    .bss = &#123;*(.bss)&#125;    <span class="comment">/* 输出文件的bss段由所有输入文件的bss段组成 */</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>链接脚本语法：</p>
<ul>
<li>在链接脚本中，有一个特殊的符号：“.”，用于表示当前位置计数器。在vmlinux.lds.S文件中很多地方都会使用到</li>
<li>在链接脚本中有一个常用的编程技巧：为每个段（或者多个段）设置一些符号，用于标识内存位置的开始和结束，这样便可以在C语言代码中访问每个段（或者多个段）的起始地址和结束地址</li>
</ul>
<h4 id="vmlinux-lds-S文件"><a href="#vmlinux-lds-S文件" class="headerlink" title="vmlinux.lds.S文件"></a>vmlinux.lds.S文件</h4><p>linux内核针对ARM64架构的链接脚本放置于<code>arch/arm64/kernel/vmlinux.lds.S</code>文件中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* SPDX-License-Identifier: GPL-2.0 */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ld script to make ARM Linux kernel</span></span><br><span class="line"><span class="comment"> * taken from the i386 version by Russell King</span></span><br><span class="line"><span class="comment"> * Written by Martin Mares &lt;mj@atrey.karlin.mff.cuni.cz&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RO_EXCEPTION_TABLE_ALIGN	8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RUNTIME_DISCARD_EXIT</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm-generic/vmlinux.lds.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/cache.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/hyp_image.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/kernel-pgtable.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/memory.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/page.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;image.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">OUTPUT_ARCH(aarch64)</span><br><span class="line"><span class="comment">/* 设置程序入口为_text */</span></span><br><span class="line">ENTRY(_text)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义jiffies参数值，jiffies_64定义在kernel/time/timer.c中 */</span></span><br><span class="line">jiffies = jiffies_64;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_KVM</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HYPERVISOR_EXTABLE					\</span></span><br><span class="line"><span class="meta">	. = ALIGN(SZ_8);					\</span></span><br><span class="line"><span class="meta">	__start___kvm_ex_table = .;				\</span></span><br><span class="line"><span class="meta">	*(__kvm_ex_table)					\</span></span><br><span class="line"><span class="meta">	__stop___kvm_ex_table = .;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HYPERVISOR_PERCPU_SECTION				\</span></span><br><span class="line"><span class="meta">	. = ALIGN(PAGE_SIZE);					\</span></span><br><span class="line"><span class="meta">	HYP_SECTION_NAME(.data..percpu) : &#123;			\</span></span><br><span class="line"><span class="meta">		*(HYP_SECTION_NAME(.data..percpu))		\</span></span><br><span class="line"><span class="meta">	&#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> <span class="comment">/* CONFIG_KVM */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HYPERVISOR_EXTABLE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HYPERVISOR_PERCPU_SECTION</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HYPERVISOR_TEXT					\</span></span><br><span class="line"><span class="meta">	<span class="comment">/*						\</span></span></span><br><span class="line"><span class="comment"><span class="meta">	 * Align to 4 KB so that			\</span></span></span><br><span class="line"><span class="comment"><span class="meta">	 * a) the HYP vector table is at its minimum	\</span></span></span><br><span class="line"><span class="comment"><span class="meta">	 *    alignment of 2048 bytes			\</span></span></span><br><span class="line"><span class="comment"><span class="meta">	 * b) the HYP init code will not cross a page	\</span></span></span><br><span class="line"><span class="comment"><span class="meta">	 *    boundary if its size does not exceed	\</span></span></span><br><span class="line"><span class="comment"><span class="meta">	 *    4 KB (see related ASSERT() below)		\</span></span></span><br><span class="line"><span class="comment"><span class="meta">	 */</span>						\</span></span><br><span class="line"><span class="meta">	. = ALIGN(SZ_4K);				\</span></span><br><span class="line"><span class="meta">	__hyp_idmap_text_start = .;			\</span></span><br><span class="line"><span class="meta">	*(.hyp.idmap.text)				\</span></span><br><span class="line"><span class="meta">	__hyp_idmap_text_end = .;			\</span></span><br><span class="line"><span class="meta">	__hyp_text_start = .;				\</span></span><br><span class="line"><span class="meta">	*(.hyp.text)					\</span></span><br><span class="line"><span class="meta">	HYPERVISOR_EXTABLE				\</span></span><br><span class="line"><span class="meta">	__hyp_text_end = .;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IDMAP_TEXT					\</span></span><br><span class="line"><span class="meta">	. = ALIGN(SZ_4K);				\</span></span><br><span class="line"><span class="meta">	__idmap_text_start = .;				\</span></span><br><span class="line"><span class="meta">	*(.idmap.text)					\</span></span><br><span class="line"><span class="meta">	__idmap_text_end = .;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_HIBERNATION</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HIBERNATE_TEXT					\</span></span><br><span class="line"><span class="meta">	. = ALIGN(SZ_4K);				\</span></span><br><span class="line"><span class="meta">	__hibernate_exit_text_start = .;		\</span></span><br><span class="line"><span class="meta">	*(.hibernate_exit.text)				\</span></span><br><span class="line"><span class="meta">	__hibernate_exit_text_end = .;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HIBERNATE_TEXT</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_UNMAP_KERNEL_AT_EL0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRAMP_TEXT					\</span></span><br><span class="line"><span class="meta">	. = ALIGN(PAGE_SIZE);				\</span></span><br><span class="line"><span class="meta">	__entry_tramp_text_start = .;			\</span></span><br><span class="line"><span class="meta">	*(.entry.tramp.text)				\</span></span><br><span class="line"><span class="meta">	. = ALIGN(PAGE_SIZE);				\</span></span><br><span class="line"><span class="meta">	__entry_tramp_text_end = .;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRAMP_TEXT</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The size of the PE/COFF section that covers the kernel image, which</span></span><br><span class="line"><span class="comment"> * runs from _stext to _edata, must be a round multiple of the PE/COFF</span></span><br><span class="line"><span class="comment"> * FileAlignment, which we set to its minimum value of 0x200. &#x27;_stext&#x27;</span></span><br><span class="line"><span class="comment"> * itself is 4 KB aligned, so padding out _edata to a 0x200 aligned</span></span><br><span class="line"><span class="comment"> * boundary should be sufficient.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">PECOFF_FILE_ALIGNMENT = <span class="number">0x200</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_EFI</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PECOFF_EDATA_PADDING	\</span></span><br><span class="line"><span class="meta">	.pecoff_edata_padding : &#123; BYTE(0); . = ALIGN(PECOFF_FILE_ALIGNMENT); &#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PECOFF_EDATA_PADDING</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* SECTIONS&#123;&#125;是链接脚本语法中的关键命令，用于描述输出文件的内存布局 */</span></span><br><span class="line"><span class="comment">/* SECTIONS命令告诉链接文件如何把输入文件的段映射到输出文件的各个段中 */</span></span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">XXX:</span> The linker does not define how output sections are</span></span><br><span class="line"><span class="comment">	 * assigned to input sections when there are multiple statements</span></span><br><span class="line"><span class="comment">	 * matching the same input section name.  There is no documented</span></span><br><span class="line"><span class="comment">	 * order of matching.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">/* /DISCARD/是一个特殊的输出段，该段引入的任何输入段将不会出现在输出文件中 */</span></span><br><span class="line">	DISCARDS</span><br><span class="line">	/DISCARD/ : &#123;</span><br><span class="line">		*(.interp .dynamic)</span><br><span class="line">		*(.dynsym .dynstr .hash .gnu.hash)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 把代码段的链接地址设置为KIMAGE_VADDR */</span></span><br><span class="line">	. = KIMAGE_VADDR;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* HEAD_TEXT在include/asm-generic/vmlinux.lds.h中定义 */</span></span><br><span class="line">    <span class="comment">/* #define HEAD_TEXT  KEEP(*(.head.text)) */</span></span><br><span class="line">    <span class="comment">/* .head.text输出段，对应输入段为HEAD_TEXT（本质为*(.head.text)） */</span></span><br><span class="line">    <span class="comment">/* 意思是将所有目标文件中的.head.text段放入.head.text输出段中 */</span></span><br><span class="line">    <span class="comment">/* _text = .; 用于标识_text段的开始 */</span></span><br><span class="line">	.head.text : &#123;</span><br><span class="line">		_text = .;</span><br><span class="line">		HEAD_TEXT</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 代码段，会汇集目标文件中的多个输入段到.text中 */</span></span><br><span class="line">	.text : &#123;			<span class="comment">/* Real text segment		*/</span></span><br><span class="line">		_stext = .;		<span class="comment">/* Text and read-only data	*/</span></span><br><span class="line">			IRQENTRY_TEXT</span><br><span class="line">			SOFTIRQENTRY_TEXT</span><br><span class="line">			ENTRY_TEXT</span><br><span class="line">			TEXT_TEXT</span><br><span class="line">			SCHED_TEXT</span><br><span class="line">			CPUIDLE_TEXT</span><br><span class="line">			LOCK_TEXT</span><br><span class="line">			KPROBES_TEXT</span><br><span class="line">			HYPERVISOR_TEXT</span><br><span class="line">			IDMAP_TEXT</span><br><span class="line">			HIBERNATE_TEXT</span><br><span class="line">			TRAMP_TEXT</span><br><span class="line">			*(.fixup)</span><br><span class="line">			*(.gnu.warning)</span><br><span class="line">		. = ALIGN(<span class="number">16</span>);</span><br><span class="line">		*(.got)			<span class="comment">/* Global offset table		*/</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Make sure that the .got.plt is either completely empty or it</span></span><br><span class="line"><span class="comment">	 * contains only the lazy dispatch entries.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	.got.plt : &#123; *(.got.plt) &#125;</span><br><span class="line">	ASSERT(SIZEOF(.got.plt) == <span class="number">0</span> || SIZEOF(.got.plt) == <span class="number">0x18</span>,</span><br><span class="line">	       <span class="string">&quot;Unexpected GOT/PLT entries detected!&quot;</span>)</span><br><span class="line"></span><br><span class="line">	. = ALIGN(SEGMENT_ALIGN);</span><br><span class="line">	_etext = .;			<span class="comment">/* End of text section */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* everything from this point to __init_begin will be marked RO NX */</span></span><br><span class="line">  	RO_DATA(PAGE_SIZE)</span><br><span class="line"></span><br><span class="line">	idmap_pg_dir = .;</span><br><span class="line">	. += IDMAP_DIR_SIZE;</span><br><span class="line">	idmap_pg_end = .;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_UNMAP_KERNEL_AT_EL0</span></span><br><span class="line">	tramp_pg_dir = .;</span><br><span class="line">	. += PAGE_SIZE;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_ARM64_SW_TTBR0_PAN</span></span><br><span class="line">	reserved_ttbr0 = .;</span><br><span class="line">	. += RESERVED_TTBR0_SIZE;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	swapper_pg_dir = .;</span><br><span class="line">	. += PAGE_SIZE;</span><br><span class="line">	swapper_pg_end = .;</span><br><span class="line"></span><br><span class="line">	. = ALIGN(SEGMENT_ALIGN);</span><br><span class="line">	__init_begin = .;</span><br><span class="line">	__inittext_begin = .;</span><br><span class="line"></span><br><span class="line">	INIT_TEXT_SECTION(<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">	__exittext_begin = .;</span><br><span class="line">	.<span class="built_in">exit</span>.text : &#123;</span><br><span class="line">		EXIT_TEXT</span><br><span class="line">	&#125;</span><br><span class="line">	__exittext_end = .;</span><br><span class="line"></span><br><span class="line">	. = ALIGN(<span class="number">4</span>);</span><br><span class="line">	.altinstructions : &#123;</span><br><span class="line">		__alt_instructions = .;</span><br><span class="line">		*(.altinstructions)</span><br><span class="line">		__alt_instructions_end = .;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	. = ALIGN(SEGMENT_ALIGN);</span><br><span class="line">	__inittext_end = .;</span><br><span class="line">	__initdata_begin = .;</span><br><span class="line"></span><br><span class="line">	.init.data : &#123;</span><br><span class="line">		<span class="function">INIT_DATA</span></span><br><span class="line"><span class="function">		<span class="title">INIT_SETUP</span><span class="params">(<span class="number">16</span>)</span></span></span><br><span class="line"><span class="function">		INIT_CALLS</span></span><br><span class="line"><span class="function">		CON_INITCALL</span></span><br><span class="line"><span class="function">		INIT_RAM_FS</span></span><br><span class="line"><span class="function">		*<span class="params">(.init.rodata.* .init.bss)</span>	<span class="comment">/* from the EFI stub */</span></span></span><br><span class="line"><span class="function">	&#125;</span></span><br><span class="line"><span class="function">	.<span class="built_in">exit</span>.data : </span>&#123;</span><br><span class="line">		EXIT_DATA</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	PERCPU_SECTION(L1_CACHE_BYTES)</span><br><span class="line">	HYPERVISOR_PERCPU_SECTION</span><br><span class="line"></span><br><span class="line">	.rela.dyn : ALIGN(<span class="number">8</span>) &#123;</span><br><span class="line">		*(.rela .rela*)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	__rela_offset	= ABSOLUTE(ADDR(.rela.dyn) - KIMAGE_VADDR);</span><br><span class="line">	__rela_size	= SIZEOF(.rela.dyn);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_RELR</span></span><br><span class="line">	.relr.dyn : ALIGN(<span class="number">8</span>) &#123;</span><br><span class="line">		*(.relr.dyn)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	__relr_offset	= ABSOLUTE(ADDR(.relr.dyn) - KIMAGE_VADDR);</span><br><span class="line">	__relr_size	= SIZEOF(.relr.dyn);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	. = ALIGN(SEGMENT_ALIGN);</span><br><span class="line">	__initdata_end = .;</span><br><span class="line">	__init_end = .;</span><br><span class="line"></span><br><span class="line">	_data = .;</span><br><span class="line">	_sdata = .;</span><br><span class="line">	RW_DATA(L1_CACHE_BYTES, PAGE_SIZE, THREAD_ALIGN)</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Data written with the MMU off but read with the MMU on requires</span></span><br><span class="line"><span class="comment">	 * cache lines to be invalidated, discarding up to a Cache Writeback</span></span><br><span class="line"><span class="comment">	 * Granule (CWG) of data from the cache. Keep the section that</span></span><br><span class="line"><span class="comment">	 * requires this type of maintenance to be in its own Cache Writeback</span></span><br><span class="line"><span class="comment">	 * Granule (CWG) area so the cache maintenance operations don&#x27;t</span></span><br><span class="line"><span class="comment">	 * interfere with adjacent data.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	.mmuoff.data.write : ALIGN(SZ_2K) &#123;</span><br><span class="line">		__mmuoff_data_start = .;</span><br><span class="line">		*(.mmuoff.data.write)</span><br><span class="line">	&#125;</span><br><span class="line">	. = ALIGN(SZ_2K);</span><br><span class="line">	.mmuoff.data.read : &#123;</span><br><span class="line">		*(.mmuoff.data.read)</span><br><span class="line">		__mmuoff_data_end = .;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	PECOFF_EDATA_PADDING</span><br><span class="line">	__pecoff_data_rawsize = ABSOLUTE(. - __initdata_begin);</span><br><span class="line">	_edata = .;</span><br><span class="line"></span><br><span class="line">	BSS_SECTION(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">	. = ALIGN(PAGE_SIZE);</span><br><span class="line">	init_pg_dir = .;</span><br><span class="line">	. += INIT_DIR_SIZE;</span><br><span class="line">	init_pg_end = .;</span><br><span class="line"></span><br><span class="line">	. = ALIGN(SEGMENT_ALIGN);</span><br><span class="line">	__pecoff_data_size = ABSOLUTE(. - __initdata_begin);</span><br><span class="line">	_end = .;</span><br><span class="line"></span><br><span class="line">	STABS_DEBUG</span><br><span class="line">	DWARF_DEBUG</span><br><span class="line">	ELF_DETAILS</span><br><span class="line"></span><br><span class="line">	HEAD_SYMBOLS</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Sections that should stay zero sized, which is safer to</span></span><br><span class="line"><span class="comment">	 * explicitly check instead of blindly discarding.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	.plt : &#123;</span><br><span class="line">		*(.plt) *(.plt.*) *(.iplt) *(.igot .igot.plt)</span><br><span class="line">	&#125;</span><br><span class="line">	ASSERT(SIZEOF(.plt) == <span class="number">0</span>, <span class="string">&quot;Unexpected run-time procedure linkages detected!&quot;</span>)</span><br><span class="line"></span><br><span class="line">	.data.rel.ro : &#123; *(.data.rel.ro) &#125;</span><br><span class="line">	ASSERT(SIZEOF(.data.rel.ro) == <span class="number">0</span>, <span class="string">&quot;Unexpected RELRO detected!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;image-vars.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The HYP init code and ID map text can&#x27;t be longer than a page each,</span></span><br><span class="line"><span class="comment"> * and should not cross a page boundary.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ASSERT(__hyp_idmap_text_end - (__hyp_idmap_text_start &amp; ~(SZ_4K - <span class="number">1</span>)) &lt;= SZ_4K,</span><br><span class="line">	<span class="string">&quot;HYP init code too big or misaligned&quot;</span>)</span><br><span class="line">ASSERT(__idmap_text_end - (__idmap_text_start &amp; ~(SZ_4K - <span class="number">1</span>)) &lt;= SZ_4K,</span><br><span class="line">	<span class="string">&quot;ID map text too big or misaligned&quot;</span>)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_HIBERNATION</span></span><br><span class="line">ASSERT(__hibernate_exit_text_end - (__hibernate_exit_text_start &amp; ~(SZ_4K - <span class="number">1</span>))</span><br><span class="line">	&lt;= SZ_4K, <span class="string">&quot;Hibernate exit text too big or misaligned&quot;</span>)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_UNMAP_KERNEL_AT_EL0</span></span><br><span class="line">ASSERT((__entry_tramp_text_end - __entry_tramp_text_start) == PAGE_SIZE,</span><br><span class="line">	<span class="string">&quot;Entry trampoline text too big&quot;</span>)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If padding is applied before .head.text, virt&lt;-&gt;phys conversions will fail.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ASSERT(_text == KIMAGE_VADDR, <span class="string">&quot;HEAD is misaligned&quot;</span>)</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>vmlinux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux CPU状态管理</title>
    <url>/archives/cedbb48.html</url>
    <content><![CDATA[<h4 id="cpumask定义"><a href="#cpumask定义" class="headerlink" title="cpumask定义"></a>cpumask定义</h4><p>内核使用cpumask来记录CPU的状态，cpumask提供了系统中CPU集合的位图，一个bit代表了一个CPU的状态</p>
<span id="more"></span>

<p>cpumask结构体</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// include/linux/threads.h</span></span><br><span class="line"><span class="comment">// 在E2000 5.10内核中配置为256，即最大支持256个CPU</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NR_CPUS     CONFIG_NR_CPUS</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// include/linux/bits.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BITS_PER_BYTE       8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// include/uapi/linux/kernel.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __KERNEL_DIV_ROUND_UP(n, d) (((n) + (d) - 1) / (d))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// include/linux/kernel.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DIV_ROUND_UP __KERNEL_DIV_ROUND_UP</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// include/linux/bitops.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BITS_PER_TYPE(type) (sizeof(type) * BITS_PER_BYTE)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BITS_TO_LONGS(nr)   DIV_ROUND_UP(nr, BITS_PER_TYPE(long))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BITS_TO_BYTES(nr)   DIV_ROUND_UP(nr, BITS_PER_TYPE(char))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// include/linux/types.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DECLARE_BITMAP(name, bits) \</span></span><br><span class="line"><span class="meta">        unsigned long name[BITS_TO_LONGS(bits)]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// include/linux/cpumask.h</span></span><br><span class="line"><span class="comment">// 实际就是定义一个足够大的unsigned long数组，其中数据中的每个bit表示CPU的一个状态</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">cpumask</span> &#123;</span> DECLARE_BITMAP&#123;bits, NR_CPUS&#125;; &#125; <span class="keyword">cpumask_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换后</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">cpumask</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> bits[BITS_TO_LONGS(NR_CPUS)];</span><br><span class="line">&#125; <span class="keyword">cpumask_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">cpumask</span> <span class="title">cpumask_var_t</span>[1];</span></span><br></pre></td></tr></table></figure>

<h4 id="cpumask接口"><a href="#cpumask接口" class="headerlink" title="cpumask接口"></a>cpumask接口</h4><h5 id="to-cpumask"><a href="#to-cpumask" class="headerlink" title="to_cpumask"></a>to_cpumask</h5><p>这里就是强转为cpumask类型</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> to_cpumask(bitmap) \</span></span><br><span class="line"><span class="meta">	((struct cpumask *)(1 ? (bitmap) \</span></span><br><span class="line"><span class="meta">		: (void *)sizeof(__check_is_bitmap(bitmap))))</span></span><br></pre></td></tr></table></figure>

<h5 id="cpumask-test-cpu"><a href="#cpumask-test-cpu" class="headerlink" title="cpumask_test_cpu"></a>cpumask_test_cpu</h5><p>查看cpu对应位的状态</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">cpumask_test_cpu</span><span class="params">(<span class="keyword">int</span> cpu, <span class="keyword">const</span> struct cpumask *cpumask)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> test_bit(cpumask_check(cpu), cpumask_bits((cpumask)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="cpumask-next"><a href="#cpumask-next" class="headerlink" title="cpumask_next"></a>cpumask_next</h5><p><code>unsigned int cpumask_next(int n, const struct cpumask *srcp)</code>，查找下一个状态非0的CPU标号</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/linux/cpumask.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> nr_cpumask_bits     ((unsigned int)NR_CPUS)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// include/linux/bitmap.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BITMAP_FIRST_WORD_MASK(start) (~0UL &lt;&lt; ((start) &amp; (BITS_PER_LONG - 1)))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// include/linux/kernel.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __round_mask(x, y)  ((__typeof__(x))((y) - 1))</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * round_down - round down to next specified power of 2</span></span><br><span class="line"><span class="comment"> * @x: the value to round</span></span><br><span class="line"><span class="comment"> * @y: multiple to round down to (must be a power of 2)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Rounds @x down to next multiple of @y (which must be a power of 2).</span></span><br><span class="line"><span class="comment"> * To perform arbitrary rounding down, use rounddown() below.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> round_down(x, y) ((x) &amp; ~__round_mask(x, y))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// include/asm-generic/bitops/builtin-__ffs.h</span></span><br><span class="line"><span class="comment">// 返回第一个非0bit的位置</span></span><br><span class="line"><span class="keyword">static</span> __always_inline <span class="keyword">unsigned</span> <span class="keyword">long</span> __ffs(<span class="keyword">unsigned</span> <span class="keyword">long</span> word)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 这个内建函数作用是返回输入数二进制表示从最低位开始(右起)的连续的0的个数</span></span><br><span class="line">    <span class="keyword">return</span> __builtin_ctzl(word);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// lib/find_bit.c</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This is a common helper function for find_next_bit, find_next_zero_bit, and</span></span><br><span class="line"><span class="comment"> * find_next_and_bit. The differences are:</span></span><br><span class="line"><span class="comment"> *  - The &quot;invert&quot; argument, which is XORed with each fetched word before</span></span><br><span class="line"><span class="comment"> *    searching it for one bits.</span></span><br><span class="line"><span class="comment"> *  - The optional &quot;addr2&quot;, which is anded with &quot;addr1&quot; if present.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> _find_next_bit(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> *addr1,</span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> *addr2, <span class="keyword">unsigned</span> <span class="keyword">long</span> nbits,</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> start, <span class="keyword">unsigned</span> <span class="keyword">long</span> invert, <span class="keyword">unsigned</span> <span class="keyword">long</span> le)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> tmp, mask;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(start &gt;= nbits))</span><br><span class="line">		<span class="keyword">return</span> nbits;</span><br><span class="line">    <span class="comment">// 获取start对应bit在数组所在位置的数据</span></span><br><span class="line">	tmp = addr1[start / BITS_PER_LONG];</span><br><span class="line">	<span class="keyword">if</span> (addr2)</span><br><span class="line">		tmp &amp;= addr2[start / BITS_PER_LONG];</span><br><span class="line">	tmp ^= invert;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Handle 1st word. */</span></span><br><span class="line">    <span class="comment">// mask就是start到高64位为1，其余低于start的位置为0</span></span><br><span class="line">	mask = BITMAP_FIRST_WORD_MASK(start);</span><br><span class="line">	<span class="keyword">if</span> (le)</span><br><span class="line">		mask = swab(mask);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取start到高64位的数据</span></span><br><span class="line">	tmp &amp;= mask;</span><br><span class="line"></span><br><span class="line">	start = round_down(start, BITS_PER_LONG);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (!tmp) &#123;</span><br><span class="line">		start += BITS_PER_LONG;</span><br><span class="line">		<span class="keyword">if</span> (start &gt;= nbits)</span><br><span class="line">			<span class="keyword">return</span> nbits;</span><br><span class="line"></span><br><span class="line">		tmp = addr1[start / BITS_PER_LONG];</span><br><span class="line">		<span class="keyword">if</span> (addr2)</span><br><span class="line">			tmp &amp;= addr2[start / BITS_PER_LONG];</span><br><span class="line">		tmp ^= invert;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (le)</span><br><span class="line">		tmp = swab(tmp);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> min(start + __ffs(tmp), nbits);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从offset开始查找下一个非0bit的位置</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">find_next_bit</span><span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> *addr, <span class="keyword">unsigned</span> <span class="keyword">long</span> size,</span></span></span><br><span class="line"><span class="params"><span class="function">			    <span class="keyword">unsigned</span> <span class="keyword">long</span> offset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> _find_next_bit(addr, <span class="literal">NULL</span>, size, offset, <span class="number">0UL</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(find_next_bit);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// lib/cpumask.c</span></span><br><span class="line"><span class="comment">// 查找下一个状态非0的CPU标号</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">cpumask_next</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">const</span> struct cpumask *srcp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n != <span class="number">-1</span>)</span><br><span class="line">        cpumask_check(n);</span><br><span class="line">    <span class="keyword">return</span> find_next_bit(cpumask_bits(srcp), nr_cpumask_bits, n + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="for-each-cpu"><a href="#for-each-cpu" class="headerlink" title="for_each_cpu"></a>for_each_cpu</h5><p>for_each_cpu(cpu, mask)，从cpu_mask中遍历所有非0bit的CPU</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> for_each_cpu(cpu, mask) \</span></span><br><span class="line"><span class="meta">    for ((cpu) = -1; \</span></span><br><span class="line"><span class="meta">        (cpu) = cpumask_next((cpu), (mask)), \</span></span><br><span class="line"><span class="meta">        (cpu) &lt; nr_cpu_ids;)</span></span><br></pre></td></tr></table></figure>

<h5 id="cpumask-copy"><a href="#cpumask-copy" class="headerlink" title="cpumask_copy"></a>cpumask_copy</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实际就是对cpumask里面long数组的拷贝</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">cpumask_copy</span><span class="params">(struct cpumask *dstp,</span></span></span><br><span class="line"><span class="params"><span class="function">						<span class="keyword">const</span> struct cpumask *srcp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	bitmap_copy(cpumask_bits(dstp), cpumask_bits(srcp), nr_cpumask_bits);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="cpumask-of"><a href="#cpumask-of" class="headerlink" title="cpumask_of"></a>cpumask_of</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> cpumask_of(cpu) (get_cpu_mask(cpu))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">const</span> struct cpumask *<span class="title">get_cpu_mask</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> cpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> *p = cpu_bit_bitmap[<span class="number">1</span> + cpu % BITS_PER_LONG];</span><br><span class="line">	p -= cpu / BITS_PER_LONG;</span><br><span class="line">	<span class="keyword">return</span> to_cpumask(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>coumask</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核链表结构</title>
    <url>/archives/4896cd7d.html</url>
    <content><![CDATA[<p>Linux内核中，对于数据管理，提供了2种类型的双向链表，一种是使用list_head结构体构成的双向环形链表。<br><img src="https://raw.githubusercontent.com/JackHuang021/images/master/20221103103152.png"></p>
<span id="more"></span>
<h3 id="list-head链表"><a href="#list-head链表" class="headerlink" title="list_head链表"></a>list_head链表</h3><h4 id="list-head定义"><a href="#list-head定义" class="headerlink" title="list_head定义"></a>list_head定义</h4><p><code>list_head</code>结构体定义在<code>include/linux/types.h</code>中，定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">next</span>, *<span class="title">prev</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>list_head</code>组成的双向链表，仅包含两个成员，<code>next</code>和<code>prev</code>指针，分别指向下一个和前一个<code>list_head</code></p>
<p><code>list_head</code>一般不是单独使用的，一般用来嵌入到其他结构体中，知道<code>list_head</code>指针时就可以通过<code>include/linux/list.h</code>中提供的<code>list_entry</code>宏来获取它父结构的地址，其中调用了<code>container_of</code>宏，该宏定义在<code>include/linux/kernel</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* list_head 使用示例 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_list</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *item;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* list_entry */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* list_entry - get the struct for this entry</span></span><br><span class="line"><span class="comment">* @ptr:	the &amp;struct list_head pointer.</span></span><br><span class="line"><span class="comment">* @type:	the type of the struct this is embedded in.</span></span><br><span class="line"><span class="comment">* @member:	the name of the list_head within the struct.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_entry(ptr, type, member) \</span></span><br><span class="line"><span class="meta">    container_of(ptr, type, member)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* container_of - cast a member of a structure out to the containing structure</span></span><br><span class="line"><span class="comment">* @ptr:	the pointer to the member.</span></span><br><span class="line"><span class="comment">* @type:	the type of the container struct this is embedded in.</span></span><br><span class="line"><span class="comment">* @member:	the name of the member within the struct.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> container_of(ptr, type, member) (&#123; \</span></span><br><span class="line"><span class="meta">    void *__mptr = (void *)(ptr); \</span></span><br><span class="line"><span class="meta">    ((type *)(__mptr - offsetof(type, member))); &#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* offsetof */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> offsetof(TYPE, MEMBER) ((size_t) &amp;((TYPE *)0)-&gt;MEMBER)</span></span><br></pre></td></tr></table></figure>
<p><code>offsetof</code>获取结构体成员在结构体中地址的偏移量<br><code>container_of</code>的作用是通过结构体的成员地址获取结构体变量的地址，container_of一共需要传入三个参数，<code>ptr</code>指针地址，<code>type</code>结构体类型，<code>member</code>结构体成员名称，具体的做法就是通过成员的指针地址，减去成员在结构体中偏移的地址</p>
<h4 id="list-head链表操作"><a href="#list-head链表操作" class="headerlink" title="list_head链表操作"></a><code>list_head</code>链表操作</h4><h5 id="list-head初始化"><a href="#list-head初始化" class="headerlink" title="list_head初始化"></a><code>list_head</code>初始化</h5><p><strong>静态初始化</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIST_HEAD_INIT(name) &#123; &amp;(name), &amp;(name) &#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIST_HEAD(name) struct list_head name = LIST_HEAD_INIT(name)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 例如 */</span></span><br><span class="line">LIST_HEAD(my_list);</span><br><span class="line"><span class="comment">/* 展开即为 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">mylist</span> =</span> &#123; &amp;(mylist), &amp;(mylist) &#125;;</span><br></pre></td></tr></table></figure>

<p><strong>动态初始化</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIST_HEAD_INIT(name) &#123; &amp;(name), &amp;(name) &#125;</span></span><br><span class="line"><span class="comment">/* 或者 */</span></span><br><span class="line"><span class="function">struct <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">INIT_LIST_HEAD</span><span class="params">(struct list_head *<span class="built_in">list</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    WRITE_ONCE(<span class="built_in">list</span>-&gt;next, <span class="built_in">list</span>);</span><br><span class="line">    <span class="built_in">list</span>-&gt;prev = <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 例如 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">mylist</span> =</span> LIST_HEAD_INIT(mylist);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">mylist2</span>;</span></span><br><span class="line">INIT_LIST_HEAD(&amp;mylist2);</span><br></pre></td></tr></table></figure>

<h5 id="从list-head中获取对象结构体"><a href="#从list-head中获取对象结构体" class="headerlink" title="从list_head中获取对象结构体"></a>从<code>list_head</code>中获取对象结构体</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @ptr:	the list head to take the element from.</span></span><br><span class="line"><span class="comment"> * @type:	the type of the struct this is embedded in.</span></span><br><span class="line"><span class="comment"> * @member:	the name of the list_head within the struct.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 实际就是使用container_of通过list_head地址来获取原结构体的地址</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_entry(ptr, type, member) \</span></span><br><span class="line"><span class="meta">    container_of(ptr, type, member)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取链表上的第一个节点，这里ptr传入的默认应该是链表头节点，且传入的这个ptr不能为空指针</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_first_enrty(ptr, type, member) \</span></span><br><span class="line"><span class="meta">    container_of((ptr)-&gt;next, type, member)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取链表上的最后一个节点，通过双向链表的prev指针来获取</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_last_entry(ptr, type, member) \</span></span><br><span class="line"><span class="meta">    container_of((ptr)-&gt;prev, type, member)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断当前给入的链表是否为空链表，不为空表返回下一个节点对应的结构体地址</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_first_enrty_or_null(ptr, type, member) (&#123; \</span></span><br><span class="line"><span class="meta">    struct list_head *head__ = (ptr); \</span></span><br><span class="line"><span class="meta">    struct list_head *pos__ = READ_ONCE(head__-&gt;next); \</span></span><br><span class="line"><span class="meta">    pos__ != head__ ? list_entry(pos__, type, member) : NULL; \</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* @pos:     含list_head结构体对象的指针</span></span><br><span class="line"><span class="comment">* @member:  list_head在这个结构体中的成员名</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 通过结构体对象的指针来获取链表中下一个节点的结构体对象地址</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_next_entry(pos, member) \</span></span><br><span class="line"><span class="meta">    list_entry((pos)-&gt;member.next, typeof(*(pos)), member)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过结构体对象的指针来获取链表中上一个节点的结构体对象地址</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_prev_entry(pos, member) \</span></span><br><span class="line"><span class="meta">    list_entry((pos)-&gt;member.prev, typeof(*(pos)), member)</span></span><br></pre></td></tr></table></figure>

<h5 id="list-head增加节点"><a href="#list-head增加节点" class="headerlink" title="list_head增加节点"></a><code>list_head</code>增加节点</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> __list_add(struct list_head *<span class="keyword">new</span>,</span><br><span class="line">                struct list_head *prev,</span><br><span class="line">                struct list_head *next)</span><br><span class="line">&#123;</span><br><span class="line">    next-&gt;prev = <span class="keyword">new</span>;</span><br><span class="line">    <span class="keyword">new</span>-&gt;next = next;</span><br><span class="line">    <span class="keyword">new</span>-&gt;prev = prev;</span><br><span class="line">    prev-&gt;next = <span class="keyword">new</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* new插入到head后 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">list_add</span><span class="params">(struct list_head *<span class="keyword">new</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                struct list_head *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __list_add(<span class="keyword">new</span>, head, head-&gt;next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* new插入到head之前 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">list_add_tail</span><span class="params">(struct list_head *<span class="keyword">new</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                struct list_node *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __list_add(<span class="keyword">new</span>, head-&gt;prev, head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="list-head删除节点"><a href="#list-head删除节点" class="headerlink" title="list_head删除节点"></a><code>list_head</code>删除节点</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Delete a list entry by making the prev/next entries</span></span><br><span class="line"><span class="comment"> * point to each other.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * This is only for internal list manipulation where we know</span></span><br><span class="line"><span class="comment"> * the prev/next entries already!</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> __list_del(struct list_head *prev, struct list_head *next)</span><br><span class="line">&#123;</span><br><span class="line">    next-&gt;prev = prev;</span><br><span class="line">    prev-&gt;next = next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除entry这个节点</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> __list_del_entry(struct list_head *entry)</span><br><span class="line">&#123;</span><br><span class="line">    __list_del(entry-&gt;prev, entry-&gt;next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// include/linux/poison.h</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * These are non-NULL pointers that will result in page faults</span></span><br><span class="line"><span class="comment"> * under normal circumstances, used to verify that nobody uses</span></span><br><span class="line"><span class="comment"> * non-initialized list entries.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIST_POISON1  ((void *) 0x100 + POISON_POINTER_DELTA)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIST_POISON2  ((void *) 0x122 + POISON_POINTER_DELTA)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * list_del - deletes entry from list.</span></span><br><span class="line"><span class="comment"> * @entry: the element to delete from the list.</span></span><br><span class="line"><span class="comment"> * Note: list_empty() on entry dose not return true after this, the entry</span></span><br><span class="line"><span class="comment"> * is in an undefined state.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 删除entry这个节点，并让其prev、next指向一个错误地址</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">list_del</span><span class="params">(struct list_head *entry)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __list_del_entry(entry);</span><br><span class="line">    entry-&gt;next = LIST_POISON1;</span><br><span class="line">    entry-&gt;prev = LIST_POISON2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="遍历list-head"><a href="#遍历list-head" class="headerlink" title="遍历list_head"></a>遍历<code>list_head</code></h5><p>通过<code>list_head</code>的头节点向后遍历整个链表</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @pos:    the &amp;struct list_head to use as a loop cursor</span></span><br><span class="line"><span class="comment"> * @head:   the head for your list</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_for_each(pos, head) \</span></span><br><span class="line"><span class="meta">    for (pos = (head)-&gt;next; pos != (head); pos = pos-&gt;next)</span></span><br></pre></td></tr></table></figure>

<p>通过<code>list_head</code>的头节点向前遍历整个链表</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_for_each_prev(pos, head) \</span></span><br><span class="line"><span class="meta">    for (pos = (head)-&gt;prev; pos != (head); pos = pos-&gt;prev)</span></span><br></pre></td></tr></table></figure>

<p>通过<code>list_head</code>的头节点向后遍历链表，这里使用<code>n</code>来存储<code>pos</code>指向的下一个节点的原因主要就是若：当前循环对<code>pos</code>进行了删除操作，因为<code>n</code>存储了下一个节点，那么可以保证遍历安全的进行下去</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @pos:    the &amp;struct list_head to use as a loop cursor</span></span><br><span class="line"><span class="comment"> * @n:      another &amp;struct list_head to use a temporary storage</span></span><br><span class="line"><span class="comment"> * @head:   the head for your list</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_for_each_safe(pos, n, head) \</span></span><br><span class="line"><span class="meta">    for (pos = (head)-&gt;next, n = pos-&gt;next; pos != head; \</span></span><br><span class="line"><span class="meta">        pos = n, n = pos-&gt;next)</span></span><br></pre></td></tr></table></figure>

<p>通过<code>list_head</code>的头节点向前遍历链表</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_for_each_prev_safe(pos, n, head) \</span></span><br><span class="line"><span class="meta">    for (pos = (head)-&gt;prev, n = pos-&gt;prev; pos != head; \</span></span><br><span class="line"><span class="meta">        pos = n, n = pos-&gt;prev)</span></span><br></pre></td></tr></table></figure>

<p>通过<code>list_head</code>指针来向后遍历链表上的所有结构体对象</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_for_each_entry(pos, head, member) \</span></span><br><span class="line"><span class="meta">    for (pos = list_first_entry((head), typeof(*pos), member); \</span></span><br><span class="line"><span class="meta">        &amp;pos-&gt;member != (head); \</span></span><br><span class="line"><span class="meta">        pos = list_next_entry(pos, member))</span></span><br></pre></td></tr></table></figure>

<p>通过<code>list_head</code>指针来向前遍历链表上的所有的结构体对象</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_for_each_entry_reverse(pos, head, member) \</span></span><br><span class="line"><span class="meta">    for (pos = list_last_entry((head), typeof(*pos), member); \</span></span><br><span class="line"><span class="meta">        &amp;pos-&gt;member != (head); \</span></span><br><span class="line"><span class="meta">        pos = list_prev_entry(pos, member))</span></span><br></pre></td></tr></table></figure>

<p>通过给定的结构体指针<code>pos</code>和链表头，<code>pos</code>不能为空，从下一个节点开始继续向后遍历链表</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_for_each_entry_continue(pos, head, member) \</span></span><br><span class="line"><span class="meta">    for (pos = list_next_entry(pos, member); \</span></span><br><span class="line"><span class="meta">        &amp;pos-&gt;member != (head); \</span></span><br><span class="line"><span class="meta">        pos = list_next_entry(pos, member))</span></span><br></pre></td></tr></table></figure>

<p>通过给定的结构体指针<code>pos</code>和链表头，<code>pos</code>不能为空，从上一个节点开始继续向前遍历链表</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_for_each_entry_continue_reverse(pos, head, member) \</span></span><br><span class="line"><span class="meta">    for (pos = list_prev_entry(pos, member); \</span></span><br><span class="line"><span class="meta">        &amp;pos-&gt;member != (head); \</span></span><br><span class="line"><span class="meta">        pos = list_prev_entry(pos, member))</span></span><br></pre></td></tr></table></figure>

<p>通过给定的结构体指针<code>pos</code>和链表头，<code>pos</code>不能为空，从当前节点开始继续向后遍历链表</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_for_each_entry_from(pos, head, member) \</span></span><br><span class="line"><span class="meta">    for (; &amp;pos-&gt;member != (head); \</span></span><br><span class="line"><span class="meta">        pos = list_next_entry(pos, member))</span></span><br></pre></td></tr></table></figure>

<p>通过给定的结构体指针<code>pos</code>和链表头，来安全的遍历链表，可以在循环中对当前遍历的结构体进行删除操作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* list_for_each_entry_safe - iterate over list of given type safe against removal of list entry</span></span><br><span class="line"><span class="comment">* @pos:	    the type * to use as a loop cursor.</span></span><br><span class="line"><span class="comment">* @n:		another type * to use as temporary storage</span></span><br><span class="line"><span class="comment">* @head:	the head for your list.</span></span><br><span class="line"><span class="comment">* @member:	the name of the list_head within the struct.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_for_each_entry_safe(pos, n, head, member)			\</span></span><br><span class="line"><span class="meta">    for (pos = list_first_entry(head, typeof(*pos), member),	\</span></span><br><span class="line"><span class="meta">        n = list_next_entry(pos, member);			\</span></span><br><span class="line"><span class="meta">        !list_entry_is_head(pos, head, member); 			\</span></span><br><span class="line"><span class="meta">        pos = n, n = list_next_entry(n, member))</span></span><br></pre></td></tr></table></figure>

<p><code>platform</code>总线初始化的时候<code>platform_bus_init()</code>会调用<code>early_platform_clean()</code>来清除<code>early_platform_device_list</code>链表上的节点，代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> __initdata <span class="title">LIST_HEAD</span><span class="params">(early_platform_device_list)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * early_platform_cleanup - clean up early platform code</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> __init <span class="title">early_platform_cleanup</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> *<span class="title">pd</span>, *<span class="title">pd2</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* clean up the devres list used to chain devices */</span></span><br><span class="line">    list_for_each_entry_safe(pd, pd2, &amp;early_platform_device_list,</span><br><span class="line">                dev.devres_head) &#123;</span><br><span class="line">        list_del(&amp;pd-&gt;dev.devres_head);</span><br><span class="line">        <span class="built_in">memset</span>(&amp;pd-&gt;dev.devres_head, <span class="number">0</span>, <span class="keyword">sizeof</span>(pd-&gt;dev.devres_head));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>采用这种遍历的方式可以安全的删除当前遍历的节点</p>
<h3 id="klist链表"><a href="#klist链表" class="headerlink" title="klist链表"></a>klist链表</h3><p>Linux内核提供了两个封装list_head的结构体，链表头klist和链表节点klist_node，klist是list的线程安全版本，在结构体中提供了自旋锁，对链表的操作进行锁保护，klist的链表节点数据结构klist_node使用了引用计数器，只有当节点的引用计数为0时，才允许该节点从klist链表中移除</p>
<h4 id="klist链表定义"><a href="#klist链表定义" class="headerlink" title="klist链表定义"></a>klist链表定义</h4><p>首先来看klist的定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/linux/klist.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">klist</span> &#123;</span></span><br><span class="line">    <span class="keyword">spinlock_t</span> k_lock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">k_list</span>;</span></span><br><span class="line">    <span class="keyword">void</span> (*get)(struct klist_node *);</span><br><span class="line">    <span class="keyword">void</span> (*put)(struct klist_node *);</span><br><span class="line">&#125; __attribute__ ((aligned (<span class="keyword">sizeof</span>(<span class="keyword">void</span> *))));</span><br></pre></td></tr></table></figure>
<ul>
<li>k_lock：链接节点操作的自旋锁</li>
<li>k_list：双向链表</li>
<li>get：用于对链表内的节点增加引用计数</li>
<li>put：用于对链表内的节点减少引用计数</li>
</ul>
<p>klist_node结构体定义如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">klist_node</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *n_klist;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">n_node</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kref</span> <span class="title">n_ref</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>n_klist：用来指向链表头</li>
<li>n_node：用来链接前后节点</li>
<li>n_ref：引用计数，实际就是一个int类型变量</li>
</ul>
<h4 id="klist初始化"><a href="#klist初始化" class="headerlink" title="klist初始化"></a>klist初始化</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//include/linux/klist.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KLIST_INIT(_name, _get, _put) \</span></span><br><span class="line"><span class="meta">    &#123; .k_lock = __SPIN_LOCK_UNLOCKED(_name.k_lock), \</span></span><br><span class="line"><span class="meta">      .k_list = LIST_HEAD_INIT(_name.k_list), \</span></span><br><span class="line"><span class="meta">      .get = _get, \</span></span><br><span class="line"><span class="meta">      .put = _put, &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFINE_KLIST(_name, _get, _put) \</span></span><br><span class="line"><span class="meta">    struct klist _name = KLIST_INIT(_name, _get, _put)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">klist_init</span><span class="params">(struct klist *k, <span class="keyword">void</span> (*get)(struct klist_node *),</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">void</span> (*put)(struct klist_node *))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    INIT_LIST_HEAD(&amp;k-&gt;k_list);</span><br><span class="line">    spin_lock_init(&amp;k-&gt;k_lock);</span><br><span class="line">    k-&gt;get = get;</span><br><span class="line">    k-&gt;put = put;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>klist_node初始化</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lib/klist.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">klist_node_init</span><span class="params">(struct klist *k, struct klist_node *n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    INIT_LIST_HEAD(&amp;n-&gt;n_node);</span><br><span class="line">    <span class="comment">// klist_node引用计数加1</span></span><br><span class="line">    kref_init(&amp;n-&gt;n_ref);</span><br><span class="line">    <span class="comment">// 将n_klist指向klist，即指向头节点</span></span><br><span class="line">    knode_set_klist(n, k);</span><br><span class="line">    <span class="keyword">if</span> (k-&gt;get)</span><br><span class="line">        k-&gt;get(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="klist操作接口"><a href="#klist操作接口" class="headerlink" title="klist操作接口"></a>klist操作接口</h4><h5 id="klist增加节点"><a href="#klist增加节点" class="headerlink" title="klist增加节点"></a>klist增加节点</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将新节点n初始化并添加节点到链表尾部</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">klist_add_tail</span><span class="params">(struct klist_node *n, struct klist *k)</span></span>;</span><br><span class="line"><span class="comment">// 将新节点n初始化并添加节点到链表头部</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">klist_add_head</span><span class="params">(struct klist_node *n, struct klist *k)</span></span>;</span><br><span class="line"><span class="comment">// 将新节点n初始化并将节点插到pos节点后</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">klist_add_behind</span><span class="params">(struct klist_node *n, struct klist_node *pos)</span></span>;</span><br><span class="line"><span class="comment">// 将新节点n初始化并将节点插到pos节点前</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">klist_add_before</span><span class="params">(struct klist_node *n, struct klist_node *pos)</span></span>;</span><br></pre></td></tr></table></figure>
<h5 id="klist删除节点"><a href="#klist删除节点" class="headerlink" title="klist删除节点"></a>klist删除节点</h5><p>在链表节点klist_node中，引入了一个引用计数器，使用kref实现了节点的动态删除，当引用计数器为0时，就会调用<code>klist_release()</code>函数将节点进行脱离，之前有线程申请删除某节点，但节点的引用计数仍在，所以只能把请求删除的线程阻塞，在klist_release()调用时还要将阻塞的线程唤醒</p>
<p>klist_remove()会调用klist_del()减少引用计数，还会一直阻塞到节点被删除，若某个线程需要删除某个节点，需要调用这个klist_remove()接口</p>
<p>klist_del接口</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">klist_waiter</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span>          <span class="comment">// 将等待删除的节点链起来</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">klist_node</span> *<span class="title">node</span>;</span>        <span class="comment">// 当前等待删除的节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">process</span>;</span>    <span class="comment">// 进程或者线程指针</span></span><br><span class="line">    <span class="keyword">int</span> woken;                      <span class="comment">// 进程唤醒标记</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">DEFINE_SPINLOCK</span><span class="params">(klist_remove_lock)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">LIST_HEAD</span><span class="params">(klist_remove_waiters)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用klist_node最低位标记该节点是否被删除</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KNODE_DEAD          1LU</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KNODE_KLIST_MASK    ~KNODE_DEAD</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 取得klist node对应的klist头节点</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct klist *<span class="title">knode_klist</span><span class="params">(struct klist_node *knode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// n_klist是指向链表头的，可以通过它查找klist</span></span><br><span class="line">    <span class="comment">// 这里最低位默认是置零的</span></span><br><span class="line">    <span class="keyword">return</span> (struct klist *)</span><br><span class="line">        ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)knode-&gt;n_klist &amp; KNODE_KLIST_MASK);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计数为0时调用klist_release</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">klist_release</span><span class="params">(struct kref *kref)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">klist_waiter</span> *<span class="title">waiter</span>, *<span class="title">tmp</span>;</span></span><br><span class="line">    <span class="comment">// 通过kref获取klist_node指针</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">klist_node</span> *<span class="title">n</span> =</span> container_of(kref, struct klist_node, n_ref);</span><br><span class="line"></span><br><span class="line">	WARN_ON(!knode_dead(n));</span><br><span class="line">    <span class="comment">// 删除该节点</span></span><br><span class="line">	list_del(&amp;n-&gt;n_node);</span><br><span class="line">	spin_lock(&amp;n_lock);</span><br><span class="line">    <span class="comment">// 通过klist_remove_waiters链表头遍历整个remove链表</span></span><br><span class="line">	list_for_each_entry_safe(waiter, tmp, &amp;klist_remove_waiters, <span class="built_in">list</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (waiter-&gt;node != n)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 删除该klist节点对应的remove waiter节点</span></span><br><span class="line">		list_del(&amp;waiter-&gt;<span class="built_in">list</span>);</span><br><span class="line">		waiter-&gt;woken = <span class="number">1</span>;</span><br><span class="line">		mb();</span><br><span class="line">		wake_up_process(waiter-&gt;process);</span><br><span class="line">	&#125;</span><br><span class="line">	spin_unlock(&amp;klist_remove_lock);</span><br><span class="line">	knode_set_klist(n, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">klist_dec_and_del</span><span class="params">(struct klist_node *n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// klist节点引用计数减1，当引用计数到0时调用klist_release</span></span><br><span class="line">    <span class="keyword">return</span> kref_put(&amp;n-&gt;nref, klist_release);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">klist_put</span><span class="params">(struct klist_node *n, <span class="keyword">bool</span> kill)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 取得链表头</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">klist</span> *<span class="title">k</span> =</span> knode_klist(n);</span><br><span class="line">    <span class="keyword">void</span> (*put)(struct klist_node *) = k-&gt;put;</span><br><span class="line"></span><br><span class="line">    spin_lock(&amp;k-&gt;k_lock);</span><br><span class="line">    <span class="comment">// 将klist_node的n_klist标记为dead</span></span><br><span class="line">    <span class="keyword">if</span> (kill)</span><br><span class="line">        knode_kill(n);</span><br><span class="line">    <span class="keyword">if</span> (!klist_dev_and_del(n))</span><br><span class="line">        put = <span class="literal">NULL</span>;</span><br><span class="line">    spin_unlock(&amp;k-&gt;k_lock);</span><br><span class="line">    <span class="keyword">if</span> (put)</span><br><span class="line">        put(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">klist_del</span><span class="params">(struct klist_node *n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    klist_put(n, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>klist中引入dead标识的原因：当一个线程要让某个klist_node无效时，不能简单地从klist中删除，因为有可能还有其它线程还在使用这个节点，因此只能减少klist_node的引用计数，节点还在klist中，遍历的时候将对这个节点dead标识进行判断，避开这些申请删除的节点，当其它线程不引用该节点后，引用计数为0，该节点会自动从klist链表中移除</p>
</blockquote>
<p>klist_remove()接口</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">klist_remove</span><span class="params">(struct klist_node *n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">klist_waiter</span> <span class="title">waiter</span>;</span></span><br><span class="line">    </span><br><span class="line">    waiter.node = n;</span><br><span class="line">    waiter.process = current;</span><br><span class="line">    waiter.woken = <span class="number">0</span>;</span><br><span class="line">    spin_lock(&amp;klist_remove_lock);</span><br><span class="line">    list_add(&amp;waiter.<span class="built_in">list</span>, &amp;klist_remove_waiters);</span><br><span class="line">    spin_unlock(&amp;klist_remove_lock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 减少引用计数，如果当前节点的引用计数为1会直接删除该节点</span></span><br><span class="line">    klist_del(n);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 引用计数减少后还没到0，会阻塞当前进程</span></span><br><span class="line">    <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">        set_current_state(TASK_UNINTERRUPTIBLE);</span><br><span class="line">        <span class="keyword">if</span> (waiter.woken)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        schedule();</span><br><span class="line">    &#125;</span><br><span class="line">    __set_current_state(TASK_RUNNING);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="遍历klist"><a href="#遍历klist" class="headerlink" title="遍历klist"></a>遍历klist</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">klist_iter</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">klist</span> *<span class="title">i_klist</span>;</span>      <span class="comment">// 当前遍历的klist链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">klist_node</span> *<span class="title">i_cur</span>;</span>   <span class="comment">// 当前遍历的节点</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>迭代器初始化</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从链表头开始遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">klist_iter_init</span><span class="params">(struct klist *k, struct klist_iter *i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    klist_iter_init_node(k, i, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 若n不为空，则从节点n进行遍历，从节点n初始化迭代器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">klist_iter_init_node</span><span class="params">(struct klist *k, struct klist_iter *i,</span></span></span><br><span class="line"><span class="params"><span class="function">                    struct klist_node *n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    i-&gt;i_klist = k;</span><br><span class="line">    i-&gt;i_cur = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 若节点不为空需要对该节点增加引用计数</span></span><br><span class="line">    <span class="keyword">if</span> (n &amp;&amp; kref_get_unless_zero(&amp;n-&gt;n_ref))</span><br><span class="line">        i-&gt;i_cur = n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">klist_iter_exit</span><span class="params">(struct klist_iter *i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i-&gt;i_cur) &#123;</span><br><span class="line">        klist_put(i-&gt;i_cur, <span class="literal">false</span>);</span><br><span class="line">        i-&gt;i_cur = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>klist向前遍历</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct klist_node *<span class="title">to_klist_node</span><span class="params">(struct list_head *n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> container_of(n, struct klist_node, n_node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">struct klist_node *<span class="title">klist_prev</span><span class="params">(struct klist_iter *i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> (*put)(struct klist_node *) = i-&gt;i_klist-&gt;put;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">klist_node</span> *<span class="title">last</span> =</span> i-&gt;i_cur;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">klist_node</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"></span><br><span class="line">    spin_lock_irqsave(&amp;i-&gt;i_klist-&gt;k_lock, flags);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 假如是从链表头进行遍历</span></span><br><span class="line">    <span class="keyword">if</span> (last) &#123;</span><br><span class="line">        prev = to_klist_node(last-&gt;node.prev);</span><br><span class="line">        <span class="comment">// 对之前节点的引用计数进行减一操作</span></span><br><span class="line">        <span class="keyword">if</span> (!klist_dec_and_del(last))</span><br><span class="line">            put = <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        prev = to_klist_node(i-&gt;i_klist-&gt;k_list.prev);</span><br><span class="line"></span><br><span class="line">    i-&gt;i_cur = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 往前找一个非dead节点</span></span><br><span class="line">    <span class="keyword">while</span> (prev != to_klist_node(&amp;i-&gt;i_klist-&gt;k_list)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (likely(!knode_dead(prev))) &#123;</span><br><span class="line">            <span class="comment">// 找到了节点，增加它的引用计数</span></span><br><span class="line">            kref_get(&amp;prev-&gt;n_ref);</span><br><span class="line">            i-&gt;i_cur = prev;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        prev = to_klist_node(prev-&gt;n_node.prev);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    spin_unlock_irqrestore(&amp;i-&gt;i_klist-&gt;k_lock, flags);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (put &amp;&amp; last)</span><br><span class="line">        put(last);</span><br><span class="line">    <span class="keyword">return</span> i-&gt;i_cur;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>klist向后遍历</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">struct klist_node *<span class="title">klist_next</span><span class="params">(struct klist_iter *i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> (*put)(struct klist_node *) = i-&gt;i_klist-&gt;put;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">klist_node</span> *<span class="title">last</span> =</span> i-&gt;i_cur;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">klist_node</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"></span><br><span class="line">    spin_lock_irqsave(&amp;i-&gt;i_klist-&gt;k_lock, flags);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (last) &#123;</span><br><span class="line">        next = to_klist_node(last-&gt;node.next);</span><br><span class="line">        <span class="keyword">if</span> (!klist_dec_and_del(last))</span><br><span class="line">            put = <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        next = to_klist_node(i-&gt;i_klist-&gt;k_list.next);</span><br><span class="line"></span><br><span class="line">    i-&gt;i_cur = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (next != to_klist_node(&amp;i-&gt;i_klist-&gt;klist)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (likely(!knode_dead(next))) &#123;</span><br><span class="line">            kref_get(&amp;next-&gt;n_ref);</span><br><span class="line">            i-&gt;i_cur = next;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    spin_unlock_irqrestore(&amp;i-&gt;klist-&gt;k_lock, flags);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (put &amp;&amp; last)</span><br><span class="line">        put(last);</span><br><span class="line">    <span class="keyword">return</span> i-&gt;i_cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>List</tag>
      </tags>
  </entry>
  <entry>
    <title>Platform设备驱动模型</title>
    <url>/archives/f8def83d.html</url>
    <content><![CDATA[<h4 id="Platform平台驱动模型"><a href="#Platform平台驱动模型" class="headerlink" title="Platform平台驱动模型"></a>Platform平台驱动模型</h4><p>Linux内核在2.6版本引入设备驱动模型，简化了驱动程序的编写，Linux设备驱动模型包含<strong>设备（device）、总线（bus）、类（class）和驱动（driver）</strong>，其中<strong>设备</strong>和<strong>驱动</strong>通过<strong>总线</strong>绑定在一起，由于某些外设是没有总线这个概念的，但是又要使用总线、驱动和设备模型的话，就需要使用<code>platform</code>这个虚拟总线，相应的就有<code>platform_device</code>和<code>platform_driver</code></p>
<span id="more"></span>

<p>Linux内核中，分别用<code>bus_type</code>、<code>device_driver</code>和<code>device</code>结构体来描述总线、驱动和设备，结构体定义在<code>include/linux/device.h</code>，设备和对应的驱动必须依附于同一种总线，因此<code>device_driver</code>和<code>device</code>结构体中都包含<code>bus_type</code>指针</p>
<h4 id="Platform总线"><a href="#Platform总线" class="headerlink" title="Platform总线"></a>Platform总线</h4><p>Linux内核使用<code>bus_type</code>结构体表示总线，该结构体定义在<code>include/linux/device/bus.h</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/linux/device/bus.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>		*name;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>		*dev_name;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span>		*<span class="title">dev_root</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> **<span class="title">bus_groups</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> **<span class="title">dev_groups</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> **<span class="title">drv_groups</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> (*match)(struct device *dev, struct device_driver *drv);</span><br><span class="line">    <span class="keyword">int</span> (*uevent)(struct device *dev, struct kobj_uevent_env *env);</span><br><span class="line">    <span class="keyword">int</span> (*probe)(struct device *dev);</span><br><span class="line">    <span class="keyword">int</span> (*remove)(struct device *dev);</span><br><span class="line">    <span class="keyword">void</span> (*shutdown)(struct device *dev);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> (*online)(struct device *dev);</span><br><span class="line">    <span class="keyword">int</span> (*offline)(struct device *dev);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> (*suspend)(struct device *dev, <span class="keyword">pm_message_t</span> state);</span><br><span class="line">    <span class="keyword">int</span> (*resume)(struct device *dev);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> (*num_vf)(struct device *dev);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> (*dma_configure)(struct device *dev);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dev_pm_ops</span> *<span class="title">pm</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">iommu_ops</span> *<span class="title">iommu_ops</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">subsys_private</span> *<span class="title">p</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">lock_key</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> need_parent_lock;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>设备和驱动的匹配函数：<br><code>int (*match)(struct device *dev, struct device_driver*drv)</code><br>match函数有两个参数dev和driver，这两个参数分别为<code>device</code>和<code>device_driver</code>类型，也就是设备和驱动</p>
<p>platform总线是<code>bus_type</code>的一个具体实例，定义在<code>driver/base/platform.c</code>中，同时也定义了设备<code>platform_bus</code>，用来管理所有挂载在platform总线下的设备，定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// driver/base/platform.c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> <span class="title">platform_bus_type</span> =</span> &#123;</span><br><span class="line">    .name		= <span class="string">&quot;platform&quot;</span>,</span><br><span class="line">    .dev_groups	= platform_dev_groups,</span><br><span class="line">    .match		= platform_match,</span><br><span class="line">    .uevent		= platform_uevent,</span><br><span class="line">    .dma_configure	= platform_dma_configure,</span><br><span class="line">    .pm		= &amp;platform_dev_pm_ops,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> <span class="title">platform_bus</span> =</span> &#123;</span><br><span class="line">    .init_name = <span class="string">&quot;platform&quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="Platform总线初始化过程"><a href="#Platform总线初始化过程" class="headerlink" title="Platform总线初始化过程"></a>Platform总线初始化过程</h5><p>内核在初始化过程中调用<code>platform_bus_init()</code>来初始化Platform总线，调用流程如下<br><code>kernel_init_freeable() -&gt; do_basic_setup() -&gt; driver_init() -&gt; platform_bus_init()</code><br>其中<code>platform_bus_init()</code>函数定义在<code>drivers/base/platform.c</code>中，内容如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// drivers/base/platform.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> __init <span class="title">platform_bus_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line"></span><br><span class="line">    early_platform_cleanup();</span><br><span class="line"></span><br><span class="line">    error = device_register(&amp;platform_bus);</span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        put_device(&amp;platform_bus);</span><br><span class="line">        <span class="keyword">return</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">    error = bus_register(&amp;platform_bus_type);</span><br><span class="line">    <span class="keyword">if</span> (error)</span><br><span class="line">        device_unregister(&amp;platform_bus);</span><br><span class="line">    of_platform_register_reconfig_notifier();</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先来看<code>early_platform_cleanup()</code>这个函数，位于<code>arch/sh/drivers/platform_early.c</code>中，这个函数主要的功能就是清除所有和early device&#x2F;driver相关的代码，执行到这里的时候，证明系统已经完成了early阶段的启动，转而进行正常的设备初始化、启动操作，所以不再需要early platform相关的东西</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/linux/init.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __initdata __section(<span class="meta-string">&quot;.init.data&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> _initdata <span class="title">LIST_HEAD</span><span class="params">(sh_early_platform_device_list)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * early_platform_cleanup - clean up early platform code</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> __init <span class="title">early_platform_cleanup</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> *<span class="title">pd</span>, *<span class="title">pd2</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* clean up the devres list used to chain devices */</span></span><br><span class="line">    list_for_each_entry_safe(pd, pd2, &amp;sh_early_platform_device_list,</span><br><span class="line">                        dev.devres_head) &#123;</span><br><span class="line">        list_del(&amp;pd-&gt;dev.devres_head);</span><br><span class="line">        <span class="built_in">memset</span>(&amp;pd-&gt;dev.devres_head, <span class="number">0</span>, <span class="keyword">sizeof</span>(pd-&gt;dev.devres_head));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着来看<code>device_register(&amp;platform_bus)</code>，将<code>platform_bus</code>设备注册到驱动模型中，该步骤会在sysfs中创建<code>/sys/device/platform/</code>目录，所有的platform设备都会包含在此目录下，所有的platform设备都会包含在此目录下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// drivers/base/core.c</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * device_register - register a device with the system.</span></span><br><span class="line"><span class="comment"> * @dev: pointer to the device structure</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This happens in two clean steps - initialize the device</span></span><br><span class="line"><span class="comment"> * and add it to the system. The two steps can be called</span></span><br><span class="line"><span class="comment"> * separately, but this is the easiest and most common.</span></span><br><span class="line"><span class="comment"> * I.e. you should only call the two helpers separately if</span></span><br><span class="line"><span class="comment"> * have a clearly defined need to use and refcount the device</span></span><br><span class="line"><span class="comment"> * before it is added to the hierarchy.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * For more information, see the kerneldoc for device_initialize()</span></span><br><span class="line"><span class="comment"> * and device_add().</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">NOTE:</span> _Never_ directly free @dev after calling this function, even</span></span><br><span class="line"><span class="comment"> * if it returned an error! Always use put_device() to give up the</span></span><br><span class="line"><span class="comment"> * reference initialized in this function instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">device_register</span><span class="params">(struct device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    device_initialize(dev);</span><br><span class="line">    <span class="keyword">return</span> device_add(dev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后是<code>bus_register(&amp;platform_bus_type);</code>，将<code>platform</code>总线注册到Linux的总线系统中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// drivers/base/base.h</span></span><br><span class="line"><span class="comment">// 子系统私有数据的数据结构定义</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct subsys_private - structure to hold the private to the driver core portions of the bus_type/class structure.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @subsys - the struct kset that defines this subsystem</span></span><br><span class="line"><span class="comment"> * @devices_kset - the subsystem&#x27;s &#x27;devices&#x27; directory</span></span><br><span class="line"><span class="comment"> * @interfaces - list of subsystem interfaces associated</span></span><br><span class="line"><span class="comment"> * @mutex - protect the devices, and interfaces lists.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @drivers_kset - the list of drivers associated</span></span><br><span class="line"><span class="comment"> * @klist_devices - the klist to iterate over the @devices_kset</span></span><br><span class="line"><span class="comment"> * @klist_drivers - the klist to iterate over the @drivers_kset</span></span><br><span class="line"><span class="comment"> * @bus_notifier - the bus notifier list for anything that cares about things</span></span><br><span class="line"><span class="comment"> *                 on this bus.</span></span><br><span class="line"><span class="comment"> * @bus - pointer back to the struct bus_type that this structure is associated</span></span><br><span class="line"><span class="comment"> *        with.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @glue_dirs - &quot;glue&quot; directory to put in-between the parent device to</span></span><br><span class="line"><span class="comment"> *              avoid namespace conflicts</span></span><br><span class="line"><span class="comment"> * @class - pointer back to the struct class that this structure is associated</span></span><br><span class="line"><span class="comment"> *          with.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This structure is the one that is the actual kobject allowing struct</span></span><br><span class="line"><span class="comment"> * bus_type/class to be statically allocated safely.  Nothing outside of the</span></span><br><span class="line"><span class="comment"> * driver core should ever touch these fields.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">subsys_private</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kset</span> <span class="title">subsys</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kset</span> *<span class="title">devices_kset</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">interfaces</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">mutex</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kset</span> *<span class="title">drivers_kset</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">klist</span> <span class="title">klist_devices</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">klist</span> <span class="title">klist_drivers</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">blocking_notifier_head</span> <span class="title">bus_notifier</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> drivers_autoprobe:<span class="number">1</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> *<span class="title">bus</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kset</span> <span class="title">glue_dirs</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * bus_register - register a driver-core subsystem</span></span><br><span class="line"><span class="comment"> * @bus: bus to register</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Once we have that, we register the bus with the kobject</span></span><br><span class="line"><span class="comment"> * infrastructure, then register the children subsystems it has:</span></span><br><span class="line"><span class="comment"> * the devices and drivers that belong to the subsystem.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bus_register</span><span class="params">(struct bus_type *bus)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> retval;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">subsys_private</span> *<span class="title">priv</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> *<span class="title">key</span> =</span> &amp;bus-&gt;lock_key;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化bus的私有数据</span></span><br><span class="line">	priv = kzalloc(<span class="keyword">sizeof</span>(struct subsys_private), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!priv)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	priv-&gt;bus = bus;</span><br><span class="line">	bus-&gt;p = priv;</span><br><span class="line"></span><br><span class="line">	BLOCKING_INIT_NOTIFIER_HEAD(&amp;priv-&gt;bus_notifier);</span><br><span class="line"></span><br><span class="line">	retval = kobject_set_name(&amp;priv-&gt;subsys.kobj, <span class="string">&quot;%s&quot;</span>, bus-&gt;name);</span><br><span class="line">	<span class="keyword">if</span> (retval)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	priv-&gt;subsys.kobj.kset = bus_kset;</span><br><span class="line">	priv-&gt;subsys.kobj.ktype = &amp;bus_ktype;</span><br><span class="line">	priv-&gt;drivers_autoprobe = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	retval = kset_register(&amp;priv-&gt;subsys);</span><br><span class="line">	<span class="keyword">if</span> (retval)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	retval = bus_create_file(bus, &amp;bus_attr_uevent);</span><br><span class="line">	<span class="keyword">if</span> (retval)</span><br><span class="line">		<span class="keyword">goto</span> bus_uevent_fail;</span><br><span class="line"></span><br><span class="line">	priv-&gt;devices_kset = kset_create_and_add(<span class="string">&quot;devices&quot;</span>, <span class="literal">NULL</span>,</span><br><span class="line">						 &amp;priv-&gt;subsys.kobj);</span><br><span class="line">	<span class="keyword">if</span> (!priv-&gt;devices_kset) &#123;</span><br><span class="line">		retval = -ENOMEM;</span><br><span class="line">		<span class="keyword">goto</span> bus_devices_fail;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	priv-&gt;drivers_kset = kset_create_and_add(<span class="string">&quot;drivers&quot;</span>, <span class="literal">NULL</span>,</span><br><span class="line">						 &amp;priv-&gt;subsys.kobj);</span><br><span class="line">	<span class="keyword">if</span> (!priv-&gt;drivers_kset) &#123;</span><br><span class="line">		retval = -ENOMEM;</span><br><span class="line">		<span class="keyword">goto</span> bus_drivers_fail;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	INIT_LIST_HEAD(&amp;priv-&gt;interfaces);</span><br><span class="line">	__mutex_init(&amp;priv-&gt;mutex, <span class="string">&quot;subsys mutex&quot;</span>, key);</span><br><span class="line">	klist_init(&amp;priv-&gt;klist_devices, klist_devices_get, klist_devices_put);</span><br><span class="line">	klist_init(&amp;priv-&gt;klist_drivers, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	retval = add_probe_files(bus);</span><br><span class="line">	<span class="keyword">if</span> (retval)</span><br><span class="line">		<span class="keyword">goto</span> bus_probe_files_fail;</span><br><span class="line"></span><br><span class="line">	retval = bus_add_groups(bus, bus-&gt;bus_groups);</span><br><span class="line">	<span class="keyword">if</span> (retval)</span><br><span class="line">		<span class="keyword">goto</span> bus_groups_fail;</span><br><span class="line"></span><br><span class="line">	pr_debug(<span class="string">&quot;bus: &#x27;%s&#x27;: registered\n&quot;</span>, bus-&gt;name);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">bus_groups_fail:</span><br><span class="line">	remove_probe_files(bus);</span><br><span class="line">bus_probe_files_fail:</span><br><span class="line">	kset_unregister(bus-&gt;p-&gt;drivers_kset);</span><br><span class="line">bus_drivers_fail:</span><br><span class="line">	kset_unregister(bus-&gt;p-&gt;devices_kset);</span><br><span class="line">bus_devices_fail:</span><br><span class="line">	bus_remove_file(bus, &amp;bus_attr_uevent);</span><br><span class="line">bus_uevent_fail:</span><br><span class="line">	kset_unregister(&amp;bus-&gt;p-&gt;subsys);</span><br><span class="line">out:</span><br><span class="line">	kfree(bus-&gt;p);</span><br><span class="line">	bus-&gt;p = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(bus_register);</span><br></pre></td></tr></table></figure>

<h4 id="Platform驱动"><a href="#Platform驱动" class="headerlink" title="Platform驱动"></a>Platform驱动</h4><p><code>platform_driver</code>结构体表示<code>platform</code>驱动，定义在<code>include/linux/platform.h</code>里面</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> (*probe)(struct platform_device *);</span><br><span class="line">    <span class="keyword">int</span> (*remove)(struct platform_device *);</span><br><span class="line">    <span class="keyword">void</span> (*shutdown)(struct platform_device *);</span><br><span class="line">    <span class="keyword">int</span> (*suspend)(struct platform_device *, <span class="keyword">pm_message_t</span> state);</span><br><span class="line">    <span class="keyword">int</span> (*resume)(struct platform_device *);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_driver</span> <span class="title">driver</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_device_id</span> *<span class="title">id_table</span>;</span></span><br><span class="line">    <span class="keyword">bool</span> prevent_deferred_probe;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当驱动和设备匹配成功后<code>platform_driver</code>的<code>probe</code>函数就会执行，<code>driver</code>成员为<code>device_driver</code>结构体变量，<code>device_driver</code>相当于基类，提供了最基础的驱动框架，<code>platform_driver</code>相当于继承了这个基类，在这个基类基础上添加了一些特有的成员变量</p>
<p><code>device_driver</code>结构体定义在*<code>include/linux/device.h</code>，内容如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_driver</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>		*name;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span>		*<span class="title">bus</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span>		*<span class="title">owner</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>		*mod_name;	<span class="comment">/* used for built-in modules */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> suppress_bind_attrs;	<span class="comment">/* disables bind/unbind via sysfs */</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">probe_type</span> <span class="title">probe_type</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span>	*<span class="title">of_match_table</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">acpi_device_id</span>	*<span class="title">acpi_match_table</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> (*probe) (struct device *dev);</span><br><span class="line">    <span class="keyword">int</span> (*remove) (struct device *dev);</span><br><span class="line">    <span class="keyword">void</span> (*shutdown) (struct device *dev);</span><br><span class="line">    <span class="keyword">int</span> (*suspend) (struct device *dev, <span class="keyword">pm_message_t</span> state);</span><br><span class="line">    <span class="keyword">int</span> (*resume) (struct device *dev);</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> **<span class="title">groups</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dev_pm_ops</span> *<span class="title">pm</span>;</span></span><br><span class="line">    <span class="keyword">void</span> (*coredump) (struct device *dev);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">driver_private</span> *<span class="title">p</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在编写<code>platform</code>驱动的时候，首先需要定义一个<code>platform_driver</code>结构体变量，实现结构体中的成员变量，重点是实现匹配方法和<code>probe</code>函数，具体的驱动程序在<code>probe</code>里面编写</p>
<p>定义好<code>platform_driver</code>结构体变量以后，需要在驱动入口函数里面调用<code>platform_driver_register()</code>函数向内核注册一个platform驱动，<code>platform_driver_register()</code>函数的原型如下：<br><code>int platform_driver_register(struct platform_driver *driver)</code></p>
<p>还需要在驱动卸载函数中通过<code>platform_driver_unregister()</code>来卸载platform驱动，函数原型如下：<br><code>int platform_driver_unregister(struct platform_driver *driver)</code></p>
<h4 id="Platform设备"><a href="#Platform设备" class="headerlink" title="Platform设备"></a>Platform设备</h4><p><code>platform_device</code>结构体表示<code>platfrom</code>设备，如果内核支持设备树的话，就不需要使用<code>platform_device</code>来描述设备，改用设备树来描述，<code>platform_device</code>结构体定义在<em>include&#x2F;linux&#x2F;platform_device.h</em>中，结构体的内容如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>	*name;</span><br><span class="line">    <span class="keyword">int</span>		id;</span><br><span class="line">    <span class="keyword">bool</span>		id_auto;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span>	<span class="title">dev</span>;</span></span><br><span class="line">    u32		num_resources;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">resource</span>	*<span class="title">resource</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_device_id</span>	*<span class="title">id_entry</span>;</span></span><br><span class="line">    <span class="keyword">char</span> *driver_override; <span class="comment">/* Driver name to force a match */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* MFD cell pointer */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mfd_cell</span> *<span class="title">mfd_cell</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* arch specific additions */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pdev_archdata</span>	<span class="title">archdata</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>name</code>表示设备的名字，要和所使用的<code>platform_driver</code>的<code>name</code>字段相同，否则设备无法匹配到对应的驱动</li>
<li><code>resource</code>表示资源，一般用来表示设备的寄存器信息，结构体内容如下  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">resource</span> &#123;</span></span><br><span class="line">    <span class="keyword">resource_size_t</span> start;</span><br><span class="line">    <span class="keyword">resource_size_t</span> end;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> desc;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">parent</span>, *<span class="title">sibling</span>, *<span class="title">child</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
  <code>start</code>和<code>end</code>分别表示资源的起始和终止信息，对于内存类资源就表示内存起始和终止地址，<code>name</code>表示资源名称，<code>flag</code>表示资源类型</li>
</ul>
<p>Linux支持设备树之后就不需要用户去手动注册<code>platform</code>设备了，因为设备信息都放到设备树中去描述，Linux内核启动的时候会从设备树中读取设备信息，然后将其组织成<code>platform_device</code>形式</p>
<h4 id="Platform驱动匹配过程"><a href="#Platform驱动匹配过程" class="headerlink" title="Platform驱动匹配过程"></a>Platform驱动匹配过程</h4><p>这里使用phytium i2c适配器驱动分析，驱动文件位于<code>drivers/i2c/busses/i2c-phytium-platform.c</code>，在<code>module_platform_driver(phytium_i2c_driver)</code>进行<code>platform_drvier</code>的注册，<code>module_platform_driver</code>是一个宏定义，该宏定义定义在<code>include/linux/platform_device.h</code>其内容如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> module_platform_driver(__platform_drvier) module_driver(__platform_drvier, platform_drvier_register, platform_drvier_unregister)</span></span><br></pre></td></tr></table></figure>
<p>继续对<em>module_driver</em>宏进行展开，其内容如下：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> module_driver(__driver, __register, __unregister, ...) \</span></span><br><span class="line"><span class="meta">static int __init __driver##_init(void) \</span></span><br><span class="line"><span class="meta">&#123; \</span></span><br><span class="line"><span class="meta">    return __register(&amp;(__driver) , ##__VA_ARGS__); \</span></span><br><span class="line"><span class="meta">&#125; \</span></span><br><span class="line"><span class="meta">module_init(__driver##_init); \</span></span><br><span class="line"><span class="meta">static void __exit __driver##_exit(void) \</span></span><br><span class="line"><span class="meta">&#123; \</span></span><br><span class="line"><span class="meta">    __unregister(&amp;(__driver) , ##__VA_ARGS__); \</span></span><br><span class="line"><span class="meta">&#125; \</span></span><br><span class="line"><span class="meta">module_exit(__driver##_exit);</span></span><br></pre></td></tr></table></figure>
<p>最终展开后的内容相当于：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">phytium_i2c_driver_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> platform_driver_register(&amp;(phytium_i2c_driver));</span><br><span class="line">&#125;</span><br><span class="line">module_init(phytium_i2c_driver_init);</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __exit <span class="title">phytium_i2c_driver_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> platform_driver_unregister(&amp;(phytium_i2c_driver));</span><br><span class="line">&#125;</span><br><span class="line">moudle_exit(phytium_i2c_driver_exit);</span><br></pre></td></tr></table></figure>

<p>在<code>moudle_init</code>中调用了<code>platform_drvier_register(&amp;phytium_i2c_driver)</code>，<code>platform_driver_regsiter</code>又是一个宏定义，定义在<code>include/linux/platform_device.h</code>中，其内容如下：<br><code>#define platform_driver_regsiter(drv) __platform_drvier_register(drv, THIS_MODULE)</code><br>其中<code>__platform_drvier_register()</code>函数的定义如下：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// drivers/base/platform.c</span></span><br><span class="line"><span class="keyword">int</span> __platform_drvier_register(struct platform_driver *drv, struct <span class="keyword">module</span> *owner)`</span><br><span class="line">&#123;</span><br><span class="line">    drv-&gt;driver.owner = owner;</span><br><span class="line">    <span class="comment">// bus_type指向platform_bus_type</span></span><br><span class="line">    drv-&gt;driver.bus = &amp;platform_bus_type;</span><br><span class="line">    drv-&gt;driver.probe = platform_drv_porbe;</span><br><span class="line">    drv-&gt;driver.remove = platform_drv_remove;</span><br><span class="line">    drv-&gt;driver.shutdown = platform_drv_shutdown;</span><br><span class="line">    <span class="comment">// 继续调用device_driver注册设备驱动</span></span><br><span class="line">    <span class="keyword">return</span> driver_register(&amp;drv-&gt;driver);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>driver</code>成员的类型为之前提到的<code>device_driver</code>结构体，<code>driver-&gt;bus</code>指向了<code>platform_bus_type</code></p>
<p>继续来看<code>driver_register(&amp;drv-&gt;driver)</code>，该函数位于<code>drivers/base/driver.c</code>中，其内容如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// drivers/base/driver.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">driver_register</span><span class="params">(struct device_driver *drv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_driver</span> *<span class="title">other</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!drv-&gt;bus-&gt;p) &#123;</span><br><span class="line">        pr_err(<span class="string">&quot;Driver &#x27;%s&#x27; was unable to register with bus_type &#x27;%s&#x27; because the bus was not initialized.\n&quot;</span>,</span><br><span class="line">            drv-&gt;name, drv-&gt;bus-&gt;name);</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 检测总线的操作函数和驱动的操作函数是否都已经定义好 */</span></span><br><span class="line">    <span class="keyword">if</span> ((drv-&gt;bus-&gt;probe &amp;&amp; drv-&gt;probe) ||</span><br><span class="line">        (drv-&gt;bus-&gt;remove &amp;&amp; drv-&gt;remove) ||</span><br><span class="line">        (drv-&gt;bus-&gt;shutdown &amp;&amp; drv-&gt;shutdown))</span><br><span class="line">        printk(KERN_WARNING <span class="string">&quot;Driver &#x27;%s&#x27; needs updating - please use &quot;</span></span><br><span class="line">            <span class="string">&quot;bus_type methods\n&quot;</span>, drv-&gt;name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查driver是否已经在bus上注册</span></span><br><span class="line">    <span class="comment">// 已经注册的话会返回device_driver结构</span></span><br><span class="line">    other = driver_find(drv-&gt;name, drv-&gt;bus);</span><br><span class="line">    <span class="keyword">if</span> (other) &#123;</span><br><span class="line">        printk(KERN_ERR <span class="string">&quot;Error: Driver &#x27;%s&#x27; is already registered, &quot;</span></span><br><span class="line">            <span class="string">&quot;aborting...\n&quot;</span>, drv-&gt;name);</span><br><span class="line">        <span class="keyword">return</span> -EBUSY;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将该device_driver注册到总线</span></span><br><span class="line">    ret = bus_add_driver(drv);</span><br><span class="line">    <span class="keyword">if</span> (ret)</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    ret = driver_add_groups(drv, drv-&gt;groups);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        bus_remove_driver(drv);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    kobject_uevent(&amp;drv-&gt;p-&gt;kobj, KOBJ_ADD);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>driver_register()</code>中调用了<code>bus_add_driver(drv)</code>，该函数位于<code>driver/base/bus.c</code>中，<code>bus_add_driver()</code>源码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * bus_add_driver - Add a driver to the bus.</span></span><br><span class="line"><span class="comment">    * @drv: driver.</span></span><br><span class="line"><span class="comment">    */</span>,<span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bus_add_driver</span><span class="params">(struct device_driver *drv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> *<span class="title">bus</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">driver_private</span> *<span class="title">priv</span>;</span></span><br><span class="line">    <span class="keyword">int</span> error = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 增加该bus的kobject引用计数，这里返回的bus就是platform bus</span></span><br><span class="line">    bus = bus_get(drv-&gt;bus);</span><br><span class="line">    <span class="keyword">if</span> (!bus)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    pr_debug(<span class="string">&quot;bus: &#x27;%s&#x27;: add driver %s\n&quot;</span>, bus-&gt;name, drv-&gt;name);</span><br><span class="line">    <span class="comment">// device_drvier的私有数据</span></span><br><span class="line">    priv = kzalloc(<span class="keyword">sizeof</span>(*priv), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!priv) &#123;</span><br><span class="line">        error = -ENOMEM;</span><br><span class="line">        <span class="keyword">goto</span> out_put_bus;</span><br><span class="line">    &#125;</span><br><span class="line">    klist_init(&amp;priv-&gt;klist_devices, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    priv-&gt;driver = drv;</span><br><span class="line">    drv-&gt;p = priv;</span><br><span class="line">    <span class="comment">// drivers_kset 本bus下所有的device_driver kobject集合</span></span><br><span class="line">    priv-&gt;kobj.kset = bus-&gt;p-&gt;drivers_kset;</span><br><span class="line">    <span class="comment">// 初始化私有数据kobject</span></span><br><span class="line">    error = kobject_init_and_add(&amp;priv-&gt;kobj, &amp;driver_ktype, <span class="literal">NULL</span>,</span><br><span class="line">                        <span class="string">&quot;%s&quot;</span>, drv-&gt;name);</span><br><span class="line">    <span class="keyword">if</span> (error)</span><br><span class="line">        <span class="keyword">goto</span> out_unregister;</span><br><span class="line">    <span class="comment">// 将该driver链接到bus的klist_driver上</span></span><br><span class="line">    klist_add_tail(&amp;priv-&gt;knode_bus, &amp;bus-&gt;p-&gt;klist_drivers);</span><br><span class="line">    <span class="comment">// 进入到autoprobe里面</span></span><br><span class="line">    <span class="keyword">if</span> (drv-&gt;bus-&gt;p-&gt;drivers_autoprobe) &#123;</span><br><span class="line">        error = driver_attach(drv);</span><br><span class="line">        <span class="keyword">if</span> (error)</span><br><span class="line">            <span class="keyword">goto</span> out_unregister;</span><br><span class="line">    &#125;</span><br><span class="line">    module_add_driver(drv-&gt;owner, drv);</span><br><span class="line"></span><br><span class="line">    error = driver_create_file(drv, &amp;driver_attr_uevent);</span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        printk(KERN_ERR <span class="string">&quot;%s: uevent attr (%s) failed\n&quot;</span>,</span><br><span class="line">            __func__, drv-&gt;name);</span><br><span class="line">    &#125;</span><br><span class="line">    error = driver_add_groups(drv, bus-&gt;drv_groups);</span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        <span class="comment">/* How the hell do we get out of this pickle? Give up */</span></span><br><span class="line">        printk(KERN_ERR <span class="string">&quot;%s: driver_create_groups(%s) failed\n&quot;</span>,</span><br><span class="line">            __func__, drv-&gt;name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!drv-&gt;suppress_bind_attrs) &#123;</span><br><span class="line">        error = add_bind_files(drv);</span><br><span class="line">        <span class="keyword">if</span> (error) &#123;</span><br><span class="line">            <span class="comment">/* Ditto */</span></span><br><span class="line">            printk(KERN_ERR <span class="string">&quot;%s: add_bind_files(%s) failed\n&quot;</span>,</span><br><span class="line">                __func__, drv-&gt;name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">out_unregister:</span><br><span class="line">    kobject_put(&amp;priv-&gt;kobj);</span><br><span class="line">    <span class="comment">/* drv-&gt;p is freed in driver_release()  */</span></span><br><span class="line">    drv-&gt;p = <span class="literal">NULL</span>;</span><br><span class="line">out_put_bus:</span><br><span class="line">    bus_put(bus);</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续来看driver_attach</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// drivers/base/dd.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">driver_attach</span><span class="params">(struct device_driver *drv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 遍历bus上所有的device</span></span><br><span class="line">    <span class="keyword">return</span> bus_for_each_dev(drv-&gt;bus, <span class="literal">NULL</span>, drv, __driver_attach);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// drivers/base/dd.c</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __driver_attach(struct device *dev, <span class="keyword">void</span> *data)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_driver</span> *<span class="title">drv</span> =</span> data;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Lock device and try to bind to it. We drop the error</span></span><br><span class="line"><span class="comment">	 * here and always return 0, because we need to keep trying</span></span><br><span class="line"><span class="comment">	 * to bind to devices and some drivers will return an error</span></span><br><span class="line"><span class="comment">	 * simply if it didn&#x27;t support the device.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * driver_probe_device() will spit a warning if there</span></span><br><span class="line"><span class="comment">	 * is an error.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">// 这里会调用platform_match(drv, dev)</span></span><br><span class="line">    <span class="comment">// 不匹配的时候会返回0</span></span><br><span class="line">	ret = driver_match_device(drv, dev);</span><br><span class="line">	<span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">/* no match */</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret == -EPROBE_DEFER) &#123;</span><br><span class="line">		dev_dbg(dev, <span class="string">&quot;Device match requests probe deferral\n&quot;</span>);</span><br><span class="line">		driver_deferred_probe_add(dev);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		dev_dbg(dev, <span class="string">&quot;Bus failed to match device: %d\n&quot;</span>, ret);</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125; <span class="comment">/* ret &gt; 0 means positive match */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (driver_allows_async_probing(drv)) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Instead of probing the device synchronously we will</span></span><br><span class="line"><span class="comment">		 * probe it asynchronously to allow for more parallelism.</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * We only take the device lock here in order to guarantee</span></span><br><span class="line"><span class="comment">		 * that the dev-&gt;driver and async_driver fields are protected</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		dev_dbg(dev, <span class="string">&quot;probing driver %s asynchronously\n&quot;</span>, drv-&gt;name);</span><br><span class="line">		device_lock(dev);</span><br><span class="line">		<span class="keyword">if</span> (!dev-&gt;driver) &#123;</span><br><span class="line">			get_device(dev);</span><br><span class="line">			dev-&gt;p-&gt;async_driver = drv;</span><br><span class="line">			async_schedule_dev(__driver_attach_async_helper, dev);</span><br><span class="line">		&#125;</span><br><span class="line">		device_unlock(dev);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 进行驱动的初始化工作，即调用probe</span></span><br><span class="line">	device_driver_attach(drv, dev);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>driver_match_device中会调用platform_match来进行驱动和设备的匹配</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// drivers/base/base.h</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">driver_match_device</span><span class="params">(struct device_driver *drv,</span></span></span><br><span class="line"><span class="params"><span class="function">                                struct device &amp;dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> drv-&gt;bus-&gt;match ? drv-&gt;bus-&gt;match(dev, drv) : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// drivers/base/platform.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">platform_match</span><span class="params">(struct device *dev, struct device_driver *drv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> *<span class="title">pdev</span> =</span> to_platform_device(dev);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> *<span class="title">pdrv</span> =</span> to_platform_driver(drv);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* When driver_override is set, only bind to the matching driver */</span></span><br><span class="line">	<span class="keyword">if</span> (pdev-&gt;driver_override)</span><br><span class="line">		<span class="keyword">return</span> !<span class="built_in">strcmp</span>(pdev-&gt;driver_override, drv-&gt;name);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Attempt an OF style match first */</span></span><br><span class="line">	<span class="keyword">if</span> (of_driver_match_device(dev, drv))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Then try ACPI style match */</span></span><br><span class="line">	<span class="keyword">if</span> (acpi_driver_match_device(dev, drv))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Then try to match against the id table */</span></span><br><span class="line">	<span class="keyword">if</span> (pdrv-&gt;id_table)</span><br><span class="line">		<span class="keyword">return</span> platform_match_id(pdrv-&gt;id_table, pdev) != <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* fall-back to driver name match */</span></span><br><span class="line">	<span class="keyword">return</span> (<span class="built_in">strcmp</span>(pdev-&gt;name, drv-&gt;name) == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设备和驱动匹配顺序：</p>
<ol>
<li>先用设备树中的compatible属性和platform_driver中的driver中的of_match_table来匹配</li>
<li>再用platform_driver的id_table中的name和platform_device中的name来匹配</li>
<li>最后用platform_device中的name和platform_driver中的driver中的name来匹配</li>
</ol>
<p>接着来看device_driver_attach()</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// drivers/base/dd.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">device_driver_attach</span><span class="params">(struct device_driver *drv, struct device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 给当前device上锁</span></span><br><span class="line">	__device_driver_lock(dev, dev-&gt;parent);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If device has been removed or someone has already successfully</span></span><br><span class="line"><span class="comment">	 * bound a driver before us just skip the driver probe call.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">// 为device绑定驱动</span></span><br><span class="line">    <span class="comment">// dead标志该device已经从系统移除</span></span><br><span class="line">	<span class="keyword">if</span> (!dev-&gt;p-&gt;dead &amp;&amp; !dev-&gt;driver)</span><br><span class="line">		ret = driver_probe_device(drv, dev);</span><br><span class="line"></span><br><span class="line">	__device_driver_unlock(dev, dev-&gt;parent);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再继续来看driver_probe_device()</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// drivers/base/dd.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">driver_probe_device</span><span class="params">(struct device_driver *drv, struct device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过该device的kobject中的state_in_sysfs这个标志判断该设备是否已经注册</span></span><br><span class="line">	<span class="keyword">if</span> (!device_is_registered(dev))</span><br><span class="line">		<span class="keyword">return</span> -ENODEV;</span><br><span class="line"></span><br><span class="line">	pr_debug(<span class="string">&quot;bus: &#x27;%s&#x27;: %s: matched device %s with driver %s\n&quot;</span>,</span><br><span class="line">		 drv-&gt;bus-&gt;name, __func__, dev_name(dev), drv-&gt;name);</span><br><span class="line"></span><br><span class="line">	pm_runtime_get_suppliers(dev);</span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;parent)</span><br><span class="line">		pm_runtime_get_sync(dev-&gt;parent);</span><br><span class="line"></span><br><span class="line">	pm_runtime_barrier(dev);</span><br><span class="line">	<span class="keyword">if</span> (initcall_debug)</span><br><span class="line">		ret = really_probe_debug(dev, drv);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		ret = really_probe(dev, drv);</span><br><span class="line">	pm_request_idle(dev);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;parent)</span><br><span class="line">		pm_runtime_put(dev-&gt;parent);</span><br><span class="line"></span><br><span class="line">	pm_runtime_put_suppliers(dev);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续看really_probe()</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">really_probe</span><span class="params">(struct device *dev, struct device_driver *drv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret = -EPROBE_DEFER;</span><br><span class="line">	<span class="keyword">int</span> local_trigger_count = atomic_read(&amp;deferred_trigger_count);</span><br><span class="line">	<span class="keyword">bool</span> test_remove = IS_ENABLED(CONFIG_DEBUG_TEST_DRIVER_REMOVE) &amp;&amp;</span><br><span class="line">			   !drv-&gt;suppress_bind_attrs;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果正处于S3或者S4状态，需要延迟进行驱动初始化</span></span><br><span class="line">	<span class="keyword">if</span> (defer_all_probes) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Value of defer_all_probes can be set only by</span></span><br><span class="line"><span class="comment">		 * device_block_probing() which, in turn, will call</span></span><br><span class="line"><span class="comment">		 * wait_for_device_probe() right after that to avoid any races.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		dev_dbg(dev, <span class="string">&quot;Driver %s force probe deferral\n&quot;</span>, drv-&gt;name);</span><br><span class="line">		driver_deferred_probe_add(dev);</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ret = device_links_check_suppliers(dev);</span><br><span class="line">	<span class="keyword">if</span> (ret == -EPROBE_DEFER)</span><br><span class="line">		driver_deferred_probe_add_trigger(dev, local_trigger_count);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">	atomic_inc(&amp;probe_count);</span><br><span class="line">	pr_debug(<span class="string">&quot;bus: &#x27;%s&#x27;: %s: probing driver %s with device %s\n&quot;</span>,</span><br><span class="line">		 drv-&gt;bus-&gt;name, __func__, drv-&gt;name, dev_name(dev));</span><br><span class="line">	<span class="keyword">if</span> (!list_empty(&amp;dev-&gt;devres_head)) &#123;</span><br><span class="line">		dev_crit(dev, <span class="string">&quot;Resources present before probing\n&quot;</span>);</span><br><span class="line">		ret = -EBUSY;</span><br><span class="line">		<span class="keyword">goto</span> done;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">re_probe:</span><br><span class="line">	dev-&gt;driver = drv;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* If using pinctrl, bind pins now before probing */</span></span><br><span class="line">	ret = pinctrl_bind_pins(dev);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">goto</span> pinctrl_bind_failed;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;bus-&gt;dma_configure) &#123;</span><br><span class="line">		ret = dev-&gt;bus-&gt;dma_configure(dev);</span><br><span class="line">		<span class="keyword">if</span> (ret)</span><br><span class="line">			<span class="keyword">goto</span> probe_failed;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (driver_sysfs_add(dev)) &#123;</span><br><span class="line">		pr_err(<span class="string">&quot;%s: driver_sysfs_add(%s) failed\n&quot;</span>,</span><br><span class="line">		       __func__, dev_name(dev));</span><br><span class="line">		<span class="keyword">goto</span> probe_failed;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;pm_domain &amp;&amp; dev-&gt;pm_domain-&gt;activate) &#123;</span><br><span class="line">		ret = dev-&gt;pm_domain-&gt;activate(dev);</span><br><span class="line">		<span class="keyword">if</span> (ret)</span><br><span class="line">			<span class="keyword">goto</span> probe_failed;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 这里调用platform_drv_probe()</span></span><br><span class="line">    <span class="comment">// 在platform_drv_probe()里面会调用driver-&gt;probe()</span></span><br><span class="line">    <span class="comment">// 这里即phytium_i2c_plat_probe()</span></span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;bus-&gt;probe) &#123;</span><br><span class="line">		ret = dev-&gt;bus-&gt;probe(dev);</span><br><span class="line">		<span class="keyword">if</span> (ret)</span><br><span class="line">			<span class="keyword">goto</span> probe_failed;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (drv-&gt;probe) &#123;</span><br><span class="line">		ret = drv-&gt;probe(dev);</span><br><span class="line">		<span class="keyword">if</span> (ret)</span><br><span class="line">			<span class="keyword">goto</span> probe_failed;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (device_add_groups(dev, drv-&gt;dev_groups)) &#123;</span><br><span class="line">		dev_err(dev, <span class="string">&quot;device_add_groups() failed\n&quot;</span>);</span><br><span class="line">		<span class="keyword">goto</span> dev_groups_failed;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dev_has_sync_state(dev) &amp;&amp;</span><br><span class="line">	    device_create_file(dev, &amp;dev_attr_state_synced)) &#123;</span><br><span class="line">		dev_err(dev, <span class="string">&quot;state_synced sysfs add failed\n&quot;</span>);</span><br><span class="line">		<span class="keyword">goto</span> dev_sysfs_state_synced_failed;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (test_remove) &#123;</span><br><span class="line">		test_remove = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">		device_remove_file(dev, &amp;dev_attr_state_synced);</span><br><span class="line">		device_remove_groups(dev, drv-&gt;dev_groups);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (dev-&gt;bus-&gt;remove)</span><br><span class="line">			dev-&gt;bus-&gt;remove(dev);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (drv-&gt;remove)</span><br><span class="line">			drv-&gt;remove(dev);</span><br><span class="line"></span><br><span class="line">		devres_release_all(dev);</span><br><span class="line">		driver_sysfs_remove(dev);</span><br><span class="line">		dev-&gt;driver = <span class="literal">NULL</span>;</span><br><span class="line">		dev_set_drvdata(dev, <span class="literal">NULL</span>);</span><br><span class="line">		<span class="keyword">if</span> (dev-&gt;pm_domain &amp;&amp; dev-&gt;pm_domain-&gt;dismiss)</span><br><span class="line">			dev-&gt;pm_domain-&gt;dismiss(dev);</span><br><span class="line">		pm_runtime_reinit(dev);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">goto</span> re_probe;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pinctrl_init_done(dev);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;pm_domain &amp;&amp; dev-&gt;pm_domain-&gt;sync)</span><br><span class="line">		dev-&gt;pm_domain-&gt;sync(dev);</span><br><span class="line"></span><br><span class="line">	driver_bound(dev);</span><br><span class="line">	ret = <span class="number">1</span>;</span><br><span class="line">	pr_debug(<span class="string">&quot;bus: &#x27;%s&#x27;: %s: bound device %s to driver %s\n&quot;</span>,</span><br><span class="line">		 drv-&gt;bus-&gt;name, __func__, dev_name(dev), drv-&gt;name);</span><br><span class="line">	<span class="keyword">goto</span> done;</span><br><span class="line"></span><br><span class="line">dev_sysfs_state_synced_failed:</span><br><span class="line">	device_remove_groups(dev, drv-&gt;dev_groups);</span><br><span class="line">dev_groups_failed:</span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;bus-&gt;remove)</span><br><span class="line">		dev-&gt;bus-&gt;remove(dev);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (drv-&gt;remove)</span><br><span class="line">		drv-&gt;remove(dev);</span><br><span class="line">probe_failed:</span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;bus)</span><br><span class="line">		blocking_notifier_call_chain(&amp;dev-&gt;bus-&gt;p-&gt;bus_notifier,</span><br><span class="line">					     BUS_NOTIFY_DRIVER_NOT_BOUND, dev);</span><br><span class="line">pinctrl_bind_failed:</span><br><span class="line">	device_links_no_driver(dev);</span><br><span class="line">	devres_release_all(dev);</span><br><span class="line">	arch_teardown_dma_ops(dev);</span><br><span class="line">	driver_sysfs_remove(dev);</span><br><span class="line">	dev-&gt;driver = <span class="literal">NULL</span>;</span><br><span class="line">	dev_set_drvdata(dev, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;pm_domain &amp;&amp; dev-&gt;pm_domain-&gt;dismiss)</span><br><span class="line">		dev-&gt;pm_domain-&gt;dismiss(dev);</span><br><span class="line">	pm_runtime_reinit(dev);</span><br><span class="line">	dev_pm_set_driver_flags(dev, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (ret) &#123;</span><br><span class="line">	<span class="keyword">case</span> -EPROBE_DEFER:</span><br><span class="line">		<span class="comment">/* Driver requested deferred probing */</span></span><br><span class="line">		dev_dbg(dev, <span class="string">&quot;Driver %s requests probe deferral\n&quot;</span>, drv-&gt;name);</span><br><span class="line">		driver_deferred_probe_add_trigger(dev, local_trigger_count);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> -ENODEV:</span><br><span class="line">	<span class="keyword">case</span> -ENXIO:</span><br><span class="line">		pr_debug(<span class="string">&quot;%s: probe of %s rejects match %d\n&quot;</span>,</span><br><span class="line">			 drv-&gt;name, dev_name(dev), ret);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="comment">/* driver matched but the probe failed */</span></span><br><span class="line">		pr_warn(<span class="string">&quot;%s: probe of %s failed with error %d\n&quot;</span>,</span><br><span class="line">			drv-&gt;name, dev_name(dev), ret);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Ignore errors returned by -&gt;probe so that the next driver can try</span></span><br><span class="line"><span class="comment">	 * its luck.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ret = <span class="number">0</span>;</span><br><span class="line">done:</span><br><span class="line">	atomic_dec(&amp;probe_count);</span><br><span class="line">	wake_up_all(&amp;probe_waitqueue);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Platform</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux设备模型</title>
    <url>/archives/f8def83d.html</url>
    <content><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>为了降低设备多样性带来的Linux驱动开发的复杂度，以及设备热插拔处理，电源管理等，Linux内核提出了设备模型（Driver Model）的概念。设备模型将硬件设备归纳、分类，然后抽象出一套标准的数据结构和接口，驱动的开发，就简化为对内核所规定的数据结构的填充和实现</p>
<span id="more"></span>

<h4 id="设备模型基本概念"><a href="#设备模型基本概念" class="headerlink" title="设备模型基本概念"></a>设备模型基本概念</h4><h5 id="Linux设备模型组成"><a href="#Linux设备模型组成" class="headerlink" title="Linux设备模型组成"></a>Linux设备模型组成</h5><p>硬件拓扑描述Linux设备模型中四个重要概念：Bus、Class、Device、Device Driver</p>
<ol>
<li>Bus：总线是CPU和一个或多个设备之间信息交互的通道，而为了方便设备模型的抽象，所有的设备都应连接到总线上</li>
<li>Class：在Linux设备模型中，Class的概念非常类似面向对象程序设计中的Class，它主要是集合具有相似功能或属性的设备，这样就可以抽象出一套可以在多个设备之间共用的数据结构和接口函数，因为从属于相同Class的设备和驱动程序就不需要重复定义这些公共资源，直接从Class中继承</li>
<li>Device：抽象系统中所有的硬件设备，描述它的名字、属性、从属的Bus、从属的Class</li>
<li>Device Driver：Linux设备模型用Driver抽象硬件设备的驱动程序，它包含设备初始化、电源管理相关的接口实现，Linux内核中的驱动开发，基本都围绕该抽象进行实现</li>
</ol>
<h5 id="设备模型的核心思想"><a href="#设备模型的核心思想" class="headerlink" title="设备模型的核心思想"></a>设备模型的核心思想</h5><p>Linux设备模型的核心思想</p>
<ol>
<li>用Device和Device Driver两个数据结构，分别从“有什么用”和“怎么用”两个角度描述硬件设备，统一了编写设备驱动的格式</li>
<li>通过<code>Bus-&gt;Device</code>类型的树状结构解决设备之间的依赖，启动某一个设备前，内核会检查该设备是否依赖其它设备或者总线，如果依赖，则检查所依赖的对象是否已经启动，如果没有，则会先启动它们，直到启动该设备的条件具备为止。而驱动开发人员需要做的，就是在编写设备驱动时，告知内核该设备的依赖关系即可</li>
<li>使用Class结构，在设备模型中引入面向对象的概念，这样可以最大限度地抽象共性，减少驱动开发过程中的重复劳动，降低工作量</li>
</ol>
<h4 id="KObject"><a href="#KObject" class="headerlink" title="KObject"></a>KObject</h4><p>Linux内核中有大量的驱动，而这些驱动往往具有类似的结构，根据面向对象的思想，可以将共同的部分提取为父类，这个父类就是<code>kobject</code>，<code>kobject</code>中包含了大量设备的必须信息，三大类设备驱动都需要包含这个<code>kobject</code>结构，从面向对象的思想来看，即继承自<code>kobject</code>，一个<code>kobject</code>对象往往就对应sysfs中的一个目录，<code>kobject</code>是组成设备模型的基本结构，<code>kobject</code>需要处理的基本任务如下：</p>
<ul>
<li>通过parent指针，可以将所有kobject以层次结构的形式组合起来</li>
<li>对象的引用计数，当一个内核对象被创建时，不知道该对象的存活时间，跟踪该对象的生命周期的一个方法就是使用引用计数，当内核中没有代码持有该对象的引用时，说明该对象可以被销毁了</li>
<li>和sysfs虚拟文件系统配合，将每一个kobject及其特性，以文件的形式开放到用户空间</li>
</ul>
<p><em>注1：在Linux中，kobject几乎不会单独存在，它的主要功能就是内嵌在一个大型的数据结构中，为这个数据结构提供一些底层的功能实现</em></p>
<p><em>注2：Linux driver开发者，很少会直接使用Kobject以及它提供的接口，而是使用构建在Kobject之上的设备模型接口</em></p>
<p>kobject, kset, ktype三者的概念</p>
<ul>
<li>kobject是基本数据类型，每个kobject都会在<code>/sys</code>文件系统中以目录的形式出现</li>
<li>ktype代表kobject的属性操作集合，</li>
<li>Kset是一个特殊的Kobject（因此它也会在<code>/sys</code>文件系统中以目录的形式出现），它用来集合相似的Kobject</li>
</ul>
<p><code>kobject</code>的结构体定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/linux/kobject.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>		*name;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">entry</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span>		*<span class="title">parent</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kset</span>		*<span class="title">kset</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobj_type</span>	*<span class="title">ktype</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kernfs_node</span>	*<span class="title">sd</span>;</span> <span class="comment">/* sysfs directory entry */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kref</span>		<span class="title">kref</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_KOBJECT_RELEASE</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">delayed_work</span>	<span class="title">release</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> state_initialized:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> state_in_sysfs:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> state_add_uevent_sent:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> state_remove_uevent_sent:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> uevent_suppress:<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>name: 表示<code>kobject</code>对象的名字，对应sysfs下的一个目录</li>
<li>entry: <code>list_head</code>链表，用来链接各个<code>kobject</code>对象</li>
<li>parent: 指向当前<code>kobject</code>父对象的指针</li>
<li>kset: 表示当前<code>kobject</code>所属的集合</li>
<li>ktype: 表示当前<code>kobject</code>的类型</li>
<li>sd: 在sysfs中的表示</li>
<li>kref: 为<code>kobject</code>的引用计数，当引用计数为0时，就回调<code>release</code>方法释放该对象</li>
<li>state_initialized: 初始化标志位，在对象初始化时被置位，表示对象是否被初始化</li>
<li>state_in_sysfs: 表示<code>kobject</code>在sysfs中的状态，在对应目录中被创建则为1，否则为0</li>
<li>state_add_uevent_sent: 添加设备的uevent事件是否被发送标志</li>
<li>state_remove_uevent_sent: 删除设备的uevent事件是否被发送标志</li>
<li>uevent_suppress：如果该字段为1，则表示忽略所有上报的uevent事件</li>
</ul>
<p><em>uevent提供了“用户空间通知”的功能实现，通过该功能，当内核中有kobject的增加、删除、修改等动作时，会通知用户空间</em></p>
<p>kset的结构体定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//include/linux/kobject.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kset</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">    <span class="keyword">spinlock_t</span> list_lock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">kset_uevent_ops</span> *<span class="title">uevent_ops</span>;</span></span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure>
<ul>
<li>list, list_lock：用于保存该kset下所有的kobject链表</li>
<li>kobj，该kset自己的kobject（kset是一个特殊的kobject，也会在sysfs中以目录的形式体现）</li>
<li>uevent_ops：该kset的uevent操作函数集。当任何Kobject需要上报uevent时，都要调用它所从属的kset的uevent_ops，添加环境变量，或者过滤event（kset可以决定哪些event可以上报）。因此，如果一个kobject不属于任何kset时，是不允许发送uevent的</li>
</ul>
<p>ktype的结构体定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//include/linux/ktype.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kobj_type</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> (*release)(struct kobject *kobj);</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sysfs_ops</span> *<span class="title">sysfs_ops</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">attribute</span> **<span class="title">default_attrs</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> **<span class="title">default_groups</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">kobj_ns_type_operations</span> *(*<span class="title">child_ns_type</span>)（<span class="keyword">struct</span> <span class="title">kobject</span> *<span class="title">kobj</span>）;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">void</span> *(*<span class="keyword">namespace</span>)(struct kobject *kobj);</span><br><span class="line">    <span class="keyword">void</span> (*get_ownership)(struct kobject *kobj, <span class="keyword">kuid_t</span> *uid, <span class="keyword">kgid_t</span> *gid);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>release: 通过该回调函数，可以将包含该种类型kobject的数据结构的内存空间释放掉</li>
<li>sysfs_ops：该种类型的kobject的sysfs文件系统接口</li>
<li>default_attrs：该种类型的kobject的atrribute列表（所谓attribute，就是sysfs文件系统中的一个文件）。将会在Kobject添加到内核时，一并注册到sysfs中</li>
<li>child_ns_type, namespace：和文件系统（sysfs）的命名空间有关</li>
</ul>
<p>每一个内嵌kobject的数据结构，例如kset、device、device_driver等等，都要实现一个ktype，并定义其中的回调函数，sysfs的相关操作也一样，必须经过ktype的中转，因为sysfs看到的是kobject，而真正的文件操作的主体，是内嵌kobject的上层数据结构</p>
<h5 id="kobject使用流程"><a href="#kobject使用流程" class="headerlink" title="kobject使用流程"></a>kobject使用流程</h5><p>kobject在大多数情况下会嵌在其他数据结构中使用，使用流程如下：</p>
<ol>
<li>定义一个<code>struct kset</code>类型的指针，并在初始化时为它分配空间，添加到内核中</li>
<li>根据实际情况，定义自己所需的数据结构原型，该数据结构中包含有kobjet</li>
<li>定义一个适合自己的ktype，并实现其中回调函数</li>
<li>在需要用到包含kobject的数据结构中，动态分配该数据结构，并分配kobject空间，添加到内核中</li>
<li>每一次引用数据结构时，调用<code>kobject_get</code>接口增加引用计数；引用结束时，调用<code>kobject_put</code>接口，减少引用计数</li>
<li>当引用计数减少为0时，kobject模块调用ktype所提供的release接口，释放上层数据结构以及kobject的内存空间</li>
</ol>
<h4 id="Uevent"><a href="#Uevent" class="headerlink" title="Uevent"></a>Uevent</h4><h5 id="Uevent的功能"><a href="#Uevent的功能" class="headerlink" title="Uevent的功能"></a>Uevent的功能</h5><p>Uevent是kobject的一部分，用于在kobject状态发生改变时，例如增加、移除等，通知用户空间程序，用户空间程序收到这样的事件后，会做相应的处理</p>
<p>该机制通常是用来支持热拔插设备的，例如U盘插入后，USB相关的驱动软件会动态创建用于表示该U盘的device结构（相应的也包括其中的kobject），并告知用户空间程序，为该U盘动态的创建&#x2F;dev&#x2F;目录下的设备节点，更进一步，可以通知其它的应用程序，将该U盘设备mount到系统中，从而动态的支持该设备。</p>
<h5 id="Uevent代码实现"><a href="#Uevent代码实现" class="headerlink" title="Uevent代码实现"></a>Uevent代码实现</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/linux/kobject.h</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">kobject_action</span> &#123;</span></span><br><span class="line">    KOBJ_ADD,</span><br><span class="line">    KOBJ_REMOVE,</span><br><span class="line">    KOBJ_CHANGE,</span><br><span class="line">    KOBJ_MOVE,</span><br><span class="line">    KOBJ_ONLINE,</span><br><span class="line">    KOBJ_OFFLINE,</span><br><span class="line">    KOBJ_BIND,</span><br><span class="line">    KOBJ_UNBIND,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>ADD&#x2F;REMOVE: kobject（或上层数据结构）的添加、移除事件</li>
<li>ONLINE&#x2F;OFFLINE： kobject（或上层数据结构）的上线、下线事件</li>
<li>CHANGE：Kobject（或上层数据结构）的状态或者内容发生改变</li>
<li>MOVE：Kobject（或上层数据结构）更改名称或者更改Parent（意味着在sysfs中更改了目录结构）</li>
<li>CHANGE：如果设备驱动需要上报的事件不再上面事件的范围内，或者是自定义的事件，可以使用该event，并携带相应的参数</li>
</ul>
<p>在利用kmod向用户空间上报event事件时，会直接执行用户空间的可执行文件，而在Linux系统，可执行文件的执行依赖于环境变量，因此<code>kobj_uevent_env</code>用于组织此次事件上报时的环境变量</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/linux/kobject.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UEVENT_NUM_ENVP         64</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UEVENT_BUFFER_SIZE      2048</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kobj_uevent_env</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> *argv[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">char</span> *envp[UEVENT_NUM_ENVP];</span><br><span class="line">    <span class="keyword">int</span> envp_idx;</span><br><span class="line">    <span class="keyword">char</span> buf[UEVENT_BUFFER_SIZE];</span><br><span class="line">    <span class="keyword">int</span> buflen;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>envp：指针数组，用于保存每个环境变量的地址，最多可支持的环境变量数量为UEVENT_NUM_ENVP</li>
<li>envp_idx：用于访问环境变量指针数组的index</li>
<li>buf：保存环境变量的buffer，最大为UEVENT_BUFFER_SIZE</li>
<li>buflen：访问buf的变量</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kset_uevent_ops</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> (* <span class="keyword">const</span> filter)(struct kset *kset, struct kobject *kobj);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *(* <span class="keyword">const</span> name)(struct kset *kset, struct kobject *kobj);</span><br><span class="line">    <span class="keyword">int</span> (* <span class="keyword">const</span> uevent)(struct kset *kset, struct kobject *kobj,</span><br><span class="line">                        struct kobj_uevent_env *env);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>kset_uevent_ops</code>是为kset定制的一个数据结构，里面包含filter和uevent两个回调函数，用处如下：</p>
<ul>
<li>filter：当任何kobject需要上报uevent时，它所属的kset可以通过该接口过滤，阻止不希望上报的event，从而达到从整体上管理的目的</li>
<li>name：该接口可以返回kset的名称，如果一个kset没有合法的名称，则其下的所有kobject将不允许上报uevent</li>
<li>uevent：当任何kobject需要上报uevent时，它所属的kset可以通过给接口统一为这些event添加环境变量，因为很多时候上报uevent时的环境变量都是相同的，因此可以由kset统一处理，就不需要让每个Kobject独自添加了</li>
</ul>
<h4 id="sysfs"><a href="#sysfs" class="headerlink" title="sysfs"></a>sysfs</h4><h5 id="sysfs介绍"><a href="#sysfs介绍" class="headerlink" title="sysfs介绍"></a>sysfs介绍</h5><p>sysfs是一个基于RAM的文件系统，他和kobject一起，可以将kernel的数据结构导出到用户空间，以文件目录结构的形式，提供对这些数据结构的访问支持</p>
<h5 id="sysfs和kobject的关系"><a href="#sysfs和kobject的关系" class="headerlink" title="sysfs和kobject的关系"></a>sysfs和kobject的关系</h5><p>每一个kobject都会对应sysfs中的一个目录，因此在将kobject添加到kernel时，<code>create_dir</code>接口会调用sysfs文件系统的创建目录接口，创建和kobject对应的目录</p>
<h5 id="attribute功能"><a href="#attribute功能" class="headerlink" title="attribute功能"></a>attribute功能</h5><p>attribute是对应kobject而言的，指的是kobject的属性，sysfs中的目录描述了kobject，而kobject是特定数据结构类型变量（如struct device）的体现，因此kobject的属性，就是这些变量的属性，它可以是任何东西，名称、内部变量、字符串等，而attribute在sysfs文件系统中是以文件的形式提供的</p>
<p>attribute就是内核空间和用户空间进行信息交互的一种方法，例如某个driver定义了一个变量，却希望用户空间程序可以修改这个变量，以控制driver的运行行为，那么就可以将该变量以sysfs attribute的形式开放出来</p>
<h5 id="attribute定义"><a href="#attribute定义" class="headerlink" title="attribute定义"></a>attribute定义</h5><p>Linux内核中，attribute分为普通的attribute和二进制attribute，定义如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/linux/types.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">umode_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// include/linux/sysfs.h </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">attribute</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">umode_t</span> mode;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// include/linux/sysfs.h </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bin_attribute</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">attribute</span> <span class="title">attr</span>;</span></span><br><span class="line">    <span class="keyword">size_t</span> size;</span><br><span class="line">    <span class="keyword">void</span>  *<span class="keyword">private</span>;</span><br><span class="line">    <span class="keyword">ssize_t</span> (*read)(struct file *, struct kobject *,</span><br><span class="line">                struct bin_attribute *, <span class="keyword">char</span> *, <span class="keyword">loff_t</span>, <span class="keyword">size_t</span>);</span><br><span class="line">    <span class="keyword">ssize_t</span> (*write)(struct file *, struct kobject *,</span><br><span class="line">                struct bin_attribute );</span><br><span class="line">    <span class="keyword">int</span> (*mmap)(struct file *, struct kobject *, </span><br><span class="line">                struct bin_attribute *attr, struct vm_area_struct *vma);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>struct attribute</code>为普通的attribute，使用该attribute生成的sysfs文件，只能用字符串的形式读写，而<code>struct bin_attribute</code>在<code>struct attribute</code>的基础上增加了read、write等函数，因此它所生成的sysfs文件可以用任何方式读写</p>
<h4 id="device和device-driver"><a href="#device和device-driver" class="headerlink" title="device和device driver"></a>device和device driver</h4><h5 id="关键数据结构"><a href="#关键数据结构" class="headerlink" title="关键数据结构"></a>关键数据结构</h5><p>struct device数据结构</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span>		*<span class="title">parent</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_private</span>	*<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>		*init_name; <span class="comment">/* initial name of the device */</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">device_type</span> *<span class="title">type</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span>	*<span class="title">bus</span>;</span>		<span class="comment">/* type of bus device is on */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_driver</span> *<span class="title">driver</span>;</span>	<span class="comment">/* which driver has allocated this</span></span><br><span class="line"><span class="comment">					   device */</span></span><br><span class="line">	<span class="keyword">void</span>		*platform_data;	<span class="comment">/* Platform specific data, device</span></span><br><span class="line"><span class="comment">					   core doesn&#x27;t touch it */</span></span><br><span class="line">	<span class="keyword">void</span>		*driver_data;	<span class="comment">/* Driver data, set and get with</span></span><br><span class="line"><span class="comment">					   dev_set_drvdata/dev_get_drvdata */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PROVE_LOCKING</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>		<span class="title">lockdep_mutex</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>		<span class="title">mutex</span>;</span>	<span class="comment">/* mutex to synchronize calls to</span></span><br><span class="line"><span class="comment">					 * its driver.</span></span><br><span class="line"><span class="comment">					 */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dev_links_info</span>	<span class="title">links</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dev_pm_info</span>	<span class="title">power</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dev_pm_domain</span>	*<span class="title">pm_domain</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_ENERGY_MODEL</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">em_perf_domain</span>	*<span class="title">em_pd</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_GENERIC_MSI_IRQ_DOMAIN</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_domain</span>	*<span class="title">msi_domain</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PINCTRL</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dev_pin_info</span>	*<span class="title">pins</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_GENERIC_MSI_IRQ</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">msi_list</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DMA_OPS</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dma_map_ops</span> *<span class="title">dma_ops</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	u64		*dma_mask;	<span class="comment">/* dma mask (if dma&#x27;able device) */</span></span><br><span class="line">	u64		coherent_dma_mask;<span class="comment">/* Like dma_mask, but for</span></span><br><span class="line"><span class="comment">					     alloc_coherent mappings as</span></span><br><span class="line"><span class="comment">					     not all hardware supports</span></span><br><span class="line"><span class="comment">					     64 bit addresses for consistent</span></span><br><span class="line"><span class="comment">					     allocations such descriptors. */</span></span><br><span class="line">	u64		bus_dma_limit;	<span class="comment">/* upstream dma constraint */</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">bus_dma_region</span> *<span class="title">dma_range_map</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_dma_parameters</span> *<span class="title">dma_parms</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">dma_pools</span>;</span>	<span class="comment">/* dma pools (if dma&#x27;ble) */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DMA_DECLARE_COHERENT</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dma_coherent_mem</span>	*<span class="title">dma_mem</span>;</span> <span class="comment">/* internal for coherent mem</span></span><br><span class="line"><span class="comment">					     override */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DMA_CMA</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cma</span> *<span class="title">cma_area</span>;</span>		<span class="comment">/* contiguous memory area for dma</span></span><br><span class="line"><span class="comment">					   allocations */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="comment">/* arch specific additions */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dev_archdata</span>	<span class="title">archdata</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span>	*<span class="title">of_node</span>;</span> <span class="comment">/* associated device tree node */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fwnode_handle</span>	*<span class="title">fwnode</span>;</span> <span class="comment">/* firmware device node */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line">	<span class="keyword">int</span>		numa_node;	<span class="comment">/* NUMA node this device is close to */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">dev_t</span>			devt;	<span class="comment">/* dev_t, creates the sysfs &quot;dev&quot; */</span></span><br><span class="line">	u32			id;	<span class="comment">/* device instance */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">spinlock_t</span>		devres_lock;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">devres_head</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="keyword">class</span>		*<span class="keyword">class</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> **<span class="title">groups</span>;</span>	<span class="comment">/* optional groups */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">void</span>	(*release)(struct device *dev);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">iommu_group</span>	*<span class="title">iommu_group</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dev_iommu</span>	*<span class="title">iommu</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">bool</span>			offline_disabled:<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">bool</span>			offline:<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">bool</span>			of_node_reused:<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">bool</span>			state_synced:<span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_ARCH_HAS_SYNC_DMA_FOR_DEVICE) || \</span></span><br><span class="line"><span class="meta">    defined(CONFIG_ARCH_HAS_SYNC_DMA_FOR_CPU) || \</span></span><br><span class="line"><span class="meta">    defined(CONFIG_ARCH_HAS_SYNC_DMA_FOR_CPU_ALL)</span></span><br><span class="line">	<span class="keyword">bool</span>			dma_coherent:<span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DMA_OPS_BYPASS</span></span><br><span class="line">	<span class="keyword">bool</span>			dma_ops_bypass : <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>parent: 该设备的父设备，一般是该设备所从属的bus controller等设备</li>
<li>p：一个用于struct device的私有数据结构指针，该指针中保存子设备链表，用于添加到bus&#x2F;driver&#x2F;parent等设备中的链表头等</li>
<li>kobj：该数据结构对应的kobject</li>
<li>init_name：设备名称，在设备模型中，名称是一个非常重要的变量，任何注册到内核中的设备，都必须有一个合法的名称，可以在初始化时给出，也可以由内核根据”bus_name + device id”的方式去创造</li>
<li>type：<code>struct device_type</code>它和<code>struct device</code>的关系非常类似<code>struct kobject</code>和<code>struct kobj_type</code>之间的关系</li>
<li>bus：该device属于哪个总线</li>
<li>driver：该device对应的device driver</li>
<li>platform_data：用于保存具体的平台相关的数据，可以将一些私有的数据暂存在这里，需要使用的时候，再拿出来</li>
<li>driver_data：用于保存和driver相关的私有数据</li>
<li>dev_t：一个32位的整数，由（major和minor）组成，以设备节点的形式向用户空间提供接口的设备中，当作设备号使用，该变量主要用于在sys文件系统中，为每个具有设备号的device，创建<code>/sys/dev/*</code>下的对应目录</li>
<li>class：该设备属于哪个class</li>
<li>group：该设备的默认attribute集合，将会在设备注册时自动在sysfs中创建对应的文件</li>
</ul>
<p>struct device_driver数据结构</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/linux/device/driver.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_driver</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> *<span class="title">bus</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *mod_name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> suppress_bind_attrs;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">probe_type</span> <span class="title">probe_type</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> *<span class="title">of_match_table</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">acpi_device_id</span> *<span class="title">acpi_match_table</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> (*probe) (struct devcie *dev);</span><br><span class="line">    <span class="keyword">void</span> (*sync_state)(struct device *dev);</span><br><span class="line">    <span class="keyword">int</span> (*remove) (struct device *dev);</span><br><span class="line">    <span class="keyword">void</span> (*shutdown) (struct device *dev);</span><br><span class="line">    <span class="keyword">int</span> (*suspend) (struct device *dev, <span class="keyword">pm_message_t</span> state);</span><br><span class="line">    <span class="keyword">int</span> (*resume) (struct device *dev);</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> **<span class="title">groups</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> **<span class="title">dev_groups</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dev_pm_ops</span> *<span class="title">pm</span>;</span></span><br><span class="line">    <span class="keyword">void</span> (*coredump) (struct device *dev);</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">drvier_private</span> *<span class="title">p</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>name：driver名称，和device结构一样，名称非常重要</li>
<li>bus：该driver所驱动设备的bus，内核要保证在driver运行前，设备所依赖的总线正确初始化</li>
<li>owner, mod_name：内核module相关的变量</li>
<li>suppres_bind_attrs：是否在sysfs中启用bind和unbind attribute</li>
<li>probe, remove：这两个接口函数用于实现driver逻辑的开始和结束，在设备模型的结构下，只有driver和device同时存在时，才需要开始执行driver的代码逻辑。这也是probe和remove两个接口名称的由来：检测到了设备和移除了设备</li>
<li>shutdown、suspend、resume、pm：电源管理相关的内容</li>
<li>groups：和struct device结构中的同名变量类似，driver也可以定义一些默认attribute，这样在将driver注册到内核中时，内核设备模型部分的代码（driver&#x2F;base&#x2F;driver.c）会自动将这些attribute添加到sysfs中</li>
<li>p：driver的私有数据指针，其他模块不能访问</li>
</ul>
<h5 id="设备模型框架下驱动开发的基本步骤"><a href="#设备模型框架下驱动开发的基本步骤" class="headerlink" title="设备模型框架下驱动开发的基本步骤"></a>设备模型框架下驱动开发的基本步骤</h5><p>在设备模型框架下，设备驱动的开发主要包括2个步骤</p>
<ol>
<li>分配一个<code>struct device</code>类型的变量，填充必要的信息后，把它注册到内核中</li>
<li>分配一个<code>struct device_driver</code>类型的变量，填充必要的信息后，把它注册到内核中</li>
</ol>
<p>这两步完成后，内核会在合适的时机，调用<code>struct device_driver</code>变量中的probe, remove, suspend, resume等回调函数，从而触发或终结设备驱动的执行，所有的驱动程序逻辑都会由这些回调函数实现</p>
<p><em>一般情况下，Linux驱动开发很少直接使用device和device_driver，因为内核在它们之上又封装了一层，如platform_device等，这些层次提供的接口更为简单，易用</em></p>
<h4 id="Bus"><a href="#Bus" class="headerlink" title="Bus"></a>Bus</h4><p>在Linux设备模型中，Bus（总线）是一类特殊的设备，它是连接处理器和其它设备之间的通道（channel）。为了方便设备模型的实现，内核规定，系统中的每个设备都要连接在一个Bus上，这个Bus可以是一个内部Bus、虚拟Bus或者Platform Bus</p>
<h5 id="bus定义"><a href="#bus定义" class="headerlink" title="bus定义"></a>bus定义</h5><p>内核通过<code>struct bus_type</code>结构抽象bus</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/linux/device/bus.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *dev_name;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev_root</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> **<span class="title">bus_groups</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> **<span class="title">dev_groups</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> **<span class="title">drv_groups</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> (*match)(struct device *dev, struct device_driver *drv);</span><br><span class="line">    <span class="keyword">int</span> (*uevent)(struct device *dev, struct kobj_uevent_env *env);</span><br><span class="line">    <span class="keyword">int</span> (*probe)(struct device *dev);</span><br><span class="line">    <span class="keyword">void</span> (*sync_state)(struct device *dev);</span><br><span class="line">    <span class="keyword">int</span> (*remove)(struct device *dev);</span><br><span class="line">    <span class="keyword">void</span> (*shutdown)(struct device *dev);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> (*online)(struct device *dev);</span><br><span class="line">    <span class="keyword">int</span> (*offline)(struct device *dev);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> (*suspend)(struct device *dev, <span class="keyword">pm_message_t</span> state);</span><br><span class="line">    <span class="keyword">int</span> (*resume)(struct device *dev);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> (*num_vf)(struct device *dev);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> (*dma_configure)(struct device *dev);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dev_pm_ops</span> *<span class="title">pm</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">iommu_ops</span> *<span class="title">iommu_ops</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">subsys_private</span> *<span class="title">p</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">lock_key</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> need_parent_lock;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>name: 该bus的名称，会在sysfs中以目录的形式存在，platform bus在sysfs中表现为”&#x2F;sys&#x2F;bus&#x2F;platform”</li>
<li>dev_name: 该名称和<code>struct device</code>结构中的init_name有关，对有些设备而言（例如批量化的USB设备），设计者根本就懒得为它起名字的，而内核也支持这种懒惰，允许将设备的名字留空。这样当设备注册到内核后，设备模型的核心逻辑就会用”bus-&gt;dev_name+device ID”的形式，为这样的设备生成一个名称</li>
<li>dev_root：和sub system功能有关</li>
<li>bus_groups, dev_groups, drv_groups：一些默认的attribute组</li>
<li>match：一个由具体的bus driver实现的回调函数，当任何属于该bus的device或device_driver添加到内核时，内核都会调用该接口，如果新加的device或device_driver匹配上了自己的另一半的话，该接口返回非零值，此时bus模块的核心逻辑就会执行后续的处理</li>
<li>uevent：一个由具体的bus driver实现的回调函数，当任何属于该Bus的device，发生添加、移除或者其它动作时，bus模块的核心逻辑就会调用该接口，以便bus driver能够修改环境变量</li>
<li>probe, remove：这两个回调函数，和device_driver中的非常类似，如果probe指定的device的话，需要保证该device所在的bus是被初始化过、确保能正确工作的，这就需要在执行device_driver的probe前，先执行它的bus的probe</li>
<li>shutdown, suspend, resume：和probe, remove的原理类似，这些是电源管理相关的实现</li>
</ul>
<p>subsys_private定义，subsys_private可以看做是bus的私有数据</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// drivers/base/base.h </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">subsys_private</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kset</span> <span class="title">subsys</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kset</span> *<span class="title">devices_kset</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">interfaces</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">mutex</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kset</span> *<span class="title">drivers_kset</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">klist</span> <span class="title">klist_devices</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">klist</span> <span class="title">klist_drivers</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">blocking_notifier_head</span> <span class="title">bus_notifier</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> drivers_autoprobe:<span class="number">1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> *<span class="title">bus</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kset</span> <span class="title">glue_dirs</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>subsys, devices_kset, drivers_kset：subsys代表了本bus的kobject集合，它下面可以包含其它的kset或者其它的kobject，devices_kset和drivers_kset则是bus下面的两个kset（如&#x2F;sys&#x2F;bus&#x2F;spi&#x2F;devices和&#x2F;sys&#x2F;bus&#x2F;spi&#x2F;drivers），分别包括本bus下所有的device和device_driver</li>
<li>interfaces：一个list_head链表，用于保存该bus下所有的interface</li>
<li>klist_devices和klist_drivers：这两个链表分别保存了本bus下所有的device和device_driver指针，以方便查找</li>
<li>drivers_autoprobe：用于控制该bus下的drivers或者devices是否自动probe</li>
<li>bus, class：分别保存上层的bus和class指针</li>
</ul>
<p>bus模块的功能包括：</p>
<ul>
<li>bus的注册和注销</li>
<li>本bus下device或者device_driver注册或注销到内核的处理</li>
<li>device_driver的probe处理</li>
<li>管理bus下的所有device和device_driver</li>
</ul>
<p>bus的注册是由<code>bus_register()</code>接口实现的，在接口的原型在<code>include/linux/device.h</code>中声明，在<code>drivers/base/bus.c</code>中实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// drivers/base/bus.c</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * bus_register - register a driver-core subsystem</span></span><br><span class="line"><span class="comment"> * @bus: bus to register</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Once we have that, we register the bus with the kobject</span></span><br><span class="line"><span class="comment"> * infrastructure, then register the children subsystems it has:</span></span><br><span class="line"><span class="comment"> * the devices and drivers that belong to the subsystem.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bus_register</span><span class="params">(struct bus_type *bus)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> retval;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">subsys_private</span> *<span class="title">priv</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> *<span class="title">key</span> =</span> &amp;bus-&gt;lock_key;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为subsys_private指针分配空间</span></span><br><span class="line">	priv = kzalloc(<span class="keyword">sizeof</span>(struct subsys_private), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!priv)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新priv-&gt;bus和bus-&gt;p的值</span></span><br><span class="line">	priv-&gt;bus = bus;</span><br><span class="line">	bus-&gt;p = priv;</span><br><span class="line"></span><br><span class="line">	BLOCKING_INIT_NOTIFIER_HEAD(&amp;priv-&gt;bus_notifier);</span><br><span class="line"></span><br><span class="line">	retval = kobject_set_name(&amp;priv-&gt;subsys.kobj, <span class="string">&quot;%s&quot;</span>, bus-&gt;name);</span><br><span class="line">	<span class="keyword">if</span> (retval)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	priv-&gt;subsys.kobj.kset = bus_kset;</span><br><span class="line">	priv-&gt;subsys.kobj.ktype = &amp;bus_ktype;</span><br><span class="line">	priv-&gt;drivers_autoprobe = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	retval = kset_register(&amp;priv-&gt;subsys);</span><br><span class="line">	<span class="keyword">if</span> (retval)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向bus目录下添加一个uevent attribute</span></span><br><span class="line">	retval = bus_create_file(bus, &amp;bus_attr_uevent);</span><br><span class="line">	<span class="keyword">if</span> (retval)</span><br><span class="line">		<span class="keyword">goto</span> bus_uevent_fail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向内核添加devices kset和drivers kset，并在sysfs中添加目录</span></span><br><span class="line">	priv-&gt;devices_kset = kset_create_and_add(<span class="string">&quot;devices&quot;</span>, <span class="literal">NULL</span>,</span><br><span class="line">						 &amp;priv-&gt;subsys.kobj);</span><br><span class="line">	<span class="keyword">if</span> (!priv-&gt;devices_kset) &#123;</span><br><span class="line">		retval = -ENOMEM;</span><br><span class="line">		<span class="keyword">goto</span> bus_devices_fail;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	priv-&gt;drivers_kset = kset_create_and_add(<span class="string">&quot;drivers&quot;</span>, <span class="literal">NULL</span>,</span><br><span class="line">						 &amp;priv-&gt;subsys.kobj);</span><br><span class="line">	<span class="keyword">if</span> (!priv-&gt;drivers_kset) &#123;</span><br><span class="line">		retval = -ENOMEM;</span><br><span class="line">		<span class="keyword">goto</span> bus_drivers_fail;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化链表 锁</span></span><br><span class="line">	INIT_LIST_HEAD(&amp;priv-&gt;interfaces);</span><br><span class="line">	__mutex_init(&amp;priv-&gt;mutex, <span class="string">&quot;subsys mutex&quot;</span>, key);</span><br><span class="line">	klist_init(&amp;priv-&gt;klist_devices, klist_devices_get, klist_devices_put);</span><br><span class="line">	klist_init(&amp;priv-&gt;klist_drivers, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在bus下添加drivers_probe和drivers_autoprobe两个attribute</span></span><br><span class="line">    <span class="comment">// 其中drivers_probe允许用户空间主动发出指定bus下的device_driver的probe动作</span></span><br><span class="line">    <span class="comment">// drivers_autoprobe控制是否在device或device_driver添加到内核时自动执行probe</span></span><br><span class="line">	retval = add_probe_files(bus);</span><br><span class="line">	<span class="keyword">if</span> (retval)</span><br><span class="line">		<span class="keyword">goto</span> bus_probe_files_fail;</span><br><span class="line"></span><br><span class="line">	retval = bus_add_groups(bus, bus-&gt;bus_groups);</span><br><span class="line">	<span class="keyword">if</span> (retval)</span><br><span class="line">		<span class="keyword">goto</span> bus_groups_fail;</span><br><span class="line"></span><br><span class="line">	pr_debug(<span class="string">&quot;bus: &#x27;%s&#x27;: registered\n&quot;</span>, bus-&gt;name);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">bus_groups_fail:</span><br><span class="line">	remove_probe_files(bus);</span><br><span class="line">bus_probe_files_fail:</span><br><span class="line">	kset_unregister(bus-&gt;p-&gt;drivers_kset);</span><br><span class="line">bus_drivers_fail:</span><br><span class="line">	kset_unregister(bus-&gt;p-&gt;devices_kset);</span><br><span class="line">bus_devices_fail:</span><br><span class="line">	bus_remove_file(bus, &amp;bus_attr_uevent);</span><br><span class="line">bus_uevent_fail:</span><br><span class="line">	kset_unregister(&amp;bus-&gt;p-&gt;subsys);</span><br><span class="line">out:</span><br><span class="line">	kfree(bus-&gt;p);</span><br><span class="line">	bus-&gt;p = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(bus_register);</span><br></pre></td></tr></table></figure>

<p>device和driver添加到bus中，内核提供了<code>device_register()</code>和<code>driver_register()</code>两个接口，供各个driver模块使用，这两个接口的核心逻辑是通过bus模块的<code>bus_add_device()</code>和<code>bus_add_driver()</code>来实现的</p>
<p><code>bus_add_device()</code>的实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// drivers/base/bus.c</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * bus_add_device - add device to bus</span></span><br><span class="line"><span class="comment"> * @dev: device being added</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * - Add device&#x27;s bus attributes.</span></span><br><span class="line"><span class="comment"> * - Create links to device&#x27;s bus.</span></span><br><span class="line"><span class="comment"> * - Add the device to its bus&#x27;s list of devices.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bus_add_device</span><span class="params">(struct device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> *<span class="title">bus</span> =</span> bus_get(dev-&gt;bus);</span><br><span class="line">	<span class="keyword">int</span> error = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (bus) &#123;</span><br><span class="line">		pr_debug(<span class="string">&quot;bus: &#x27;%s&#x27;: add device %s\n&quot;</span>, bus-&gt;name, dev_name(dev));</span><br><span class="line">		error = device_add_groups(dev, bus-&gt;dev_groups);</span><br><span class="line">		<span class="keyword">if</span> (error)</span><br><span class="line">			<span class="keyword">goto</span> out_put;</span><br><span class="line">        <span class="comment">// 将该device在sysfs中真正的位置，连接到bus的device目录下</span></span><br><span class="line">		error = sysfs_create_link(&amp;bus-&gt;p-&gt;devices_kset-&gt;kobj,</span><br><span class="line">						&amp;dev-&gt;kobj, dev_name(dev));</span><br><span class="line">		<span class="keyword">if</span> (error)</span><br><span class="line">			<span class="keyword">goto</span> out_groups;</span><br><span class="line">        <span class="comment">// 为该device的目录下创建一个名为subsystem的链接，链接到该device所在的bus目录</span></span><br><span class="line">		error = sysfs_create_link(&amp;dev-&gt;kobj,</span><br><span class="line">				&amp;dev-&gt;bus-&gt;p-&gt;subsys.kobj, <span class="string">&quot;subsystem&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (error)</span><br><span class="line">			<span class="keyword">goto</span> out_subsys;</span><br><span class="line">        <span class="comment">// 将该device添加到链表</span></span><br><span class="line">		klist_add_tail(&amp;dev-&gt;p-&gt;knode_bus, &amp;bus-&gt;p-&gt;klist_devices);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">out_subsys:</span><br><span class="line">	sysfs_remove_link(&amp;bus-&gt;p-&gt;devices_kset-&gt;kobj, dev_name(dev));</span><br><span class="line">out_groups:</span><br><span class="line">	device_remove_groups(dev, bus-&gt;dev_groups);</span><br><span class="line">out_put:</span><br><span class="line">	bus_put(dev-&gt;bus);</span><br><span class="line">	<span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h4><p>class是虚拟出来的，为了抽象设备的共性，class为一些相似的device提供通用的接口，定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> **<span class="title">class_groups</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> **<span class="title">dev_groups</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> *<span class="title">dev_kobj</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> (*dev_uevent)(struct device *dev, struct kobj_uevent_env *env);</span><br><span class="line">    <span class="keyword">char</span> *(*devnode)(struct device *dev, <span class="keyword">umode_t</span> *mode);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> (*class_release)(struct class *class);</span><br><span class="line">    <span class="keyword">void</span> (*dev_release)(struct device *device);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> (*shutdown_pre)(struct device *dev);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">kobj_ns_type_operations</span> *<span class="title">ns_type</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">void</span> *(*<span class="keyword">namespace</span>)(struct device *dev);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> (*get_ownership)(struct device *dev, <span class="keyword">kuid_t</span> *uid, <span class="keyword">kgid_t</span> *gid);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dev_pm_ops</span> *<span class="title">pm</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">subsys_private</span> *<span class="title">p</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>name：class的名称，会在<code>/sys/class/</code>下体现</li>
<li>class_groups：</li>
<li>dev_groups：</li>
<li>dev_kobj：表示该class下的设备在<code>/sys/dev/</code>下的目录，现在一般有char和block两个，如果dev_kobj为空，则默认选择char</li>
<li>class_release：用于release自身的回调函数</li>
<li>dev_release：用于release class内设备的回调函数</li>
<li>p：class私有数据</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Platform</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux GPIO驱动框架</title>
    <url>/archives/2b4bdb51.html</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Linux内核中对GPIO资源进行了抽象，抽象为gpiolib，管理GPIO资源</p>
<p>gpiolib汇总了GPIO的通用操作，根据GPIO的特性，gpiolib对上（其他用到GPIO的driver）提供一套统一的操作GPIO的软件接口，屏蔽了不同芯片的具体实现；对下（specific chip driver）提供了针对不同芯片操作的一套框架，针对不同芯片，只需要实现这套框架，然后使用gpiolib提供的注册函数，将其挂接到gpiolib上，就完成了gpio驱动的编写</p>
<span id="more"></span>

<h3 id="gpiolib相关数据结构"><a href="#gpiolib相关数据结构" class="headerlink" title="gpiolib相关数据结构"></a>gpiolib相关数据结构</h3><p><code>struct gpio_chip</code>，这个结构是为了抽象GPIO的所有操作，这个结构是要开出去给其他芯片进行特定的操作赋值的，gpio_chip的抽象是针对GPIO一组bank的抽象，通常在硬件上，一个芯片的IO口，分为了很多个bank，每个bank分为了N组GPIO，可以理解为每一个bank有一组gpio操作的寄存器，可以通过这些寄存器对该bank的GPIO进行配置</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/linux/gpio/driver.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gpio_chip</span> &#123;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>		*label;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_device</span>	*<span class="title">gpiodev</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span>		*<span class="title">parent</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">module</span>		*<span class="title">owner</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span>			(*request)(struct gpio_chip *chip,</span><br><span class="line">						<span class="keyword">unsigned</span> offset);</span><br><span class="line">	<span class="keyword">void</span>			(*<span class="built_in">free</span>)(struct gpio_chip *chip,</span><br><span class="line">						<span class="keyword">unsigned</span> offset);</span><br><span class="line">	<span class="keyword">int</span>			(*get_direction)(struct gpio_chip *chip,</span><br><span class="line">						<span class="keyword">unsigned</span> offset);</span><br><span class="line">	<span class="keyword">int</span>			(*direction_input)(struct gpio_chip *chip,</span><br><span class="line">						<span class="keyword">unsigned</span> offset);</span><br><span class="line">	<span class="keyword">int</span>			(*direction_output)(struct gpio_chip *chip,</span><br><span class="line">						<span class="keyword">unsigned</span> offset, <span class="keyword">int</span> value);</span><br><span class="line">	<span class="keyword">int</span>			(*get)(struct gpio_chip *chip,</span><br><span class="line">						<span class="keyword">unsigned</span> offset);</span><br><span class="line">	<span class="keyword">int</span>			(*get_multiple)(struct gpio_chip *chip,</span><br><span class="line">						<span class="keyword">unsigned</span> <span class="keyword">long</span> *mask,</span><br><span class="line">						<span class="keyword">unsigned</span> <span class="keyword">long</span> *bits);</span><br><span class="line">	<span class="keyword">void</span>			(*<span class="built_in">set</span>)(struct gpio_chip *chip,</span><br><span class="line">						<span class="keyword">unsigned</span> offset, <span class="keyword">int</span> value);</span><br><span class="line">	<span class="keyword">void</span>			(*set_multiple)(struct gpio_chip *chip,</span><br><span class="line">						<span class="keyword">unsigned</span> <span class="keyword">long</span> *mask,</span><br><span class="line">						<span class="keyword">unsigned</span> <span class="keyword">long</span> *bits);</span><br><span class="line">	<span class="keyword">int</span>			(*set_config)(struct gpio_chip *chip,</span><br><span class="line">					      <span class="keyword">unsigned</span> offset,</span><br><span class="line">					      <span class="keyword">unsigned</span> <span class="keyword">long</span> config);</span><br><span class="line">	<span class="keyword">int</span>			(*to_irq)(struct gpio_chip *chip,</span><br><span class="line">						<span class="keyword">unsigned</span> offset);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">void</span>			(*dbg_show)(struct seq_file *s,</span><br><span class="line">						struct gpio_chip *chip);</span><br><span class="line">	<span class="keyword">int</span>			base;</span><br><span class="line">	u16			ngpio;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>		*<span class="keyword">const</span> *names;</span><br><span class="line">	<span class="keyword">bool</span>			can_sleep;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> IS_ENABLED(CONFIG_GPIO_GENERIC)</span></span><br><span class="line">	<span class="function"><span class="keyword">unsigned</span> <span class="title">long</span> <span class="params">(*read_reg)</span><span class="params">(<span class="keyword">void</span> __iomem *reg)</span></span>;</span><br><span class="line">	<span class="keyword">void</span> (*write_reg)(<span class="keyword">void</span> __iomem *reg, <span class="keyword">unsigned</span> <span class="keyword">long</span> data);</span><br><span class="line">	<span class="keyword">bool</span> be_bits;</span><br><span class="line">	<span class="keyword">void</span> __iomem *reg_dat;</span><br><span class="line">	<span class="keyword">void</span> __iomem *reg_set;</span><br><span class="line">	<span class="keyword">void</span> __iomem *reg_clr;</span><br><span class="line">	<span class="keyword">void</span> __iomem *reg_dir;</span><br><span class="line">	<span class="keyword">bool</span> bgpio_dir_inverted;</span><br><span class="line">	<span class="keyword">int</span> bgpio_bits;</span><br><span class="line">	<span class="keyword">spinlock_t</span> bgpio_lock;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> bgpio_data;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> bgpio_dir;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_GPIOLIB_IRQCHIP</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * With CONFIG_GPIOLIB_IRQCHIP we get an irqchip inside the gpiolib</span></span><br><span class="line"><span class="comment">	 * to handle IRQs for most practical cases.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * @irq:</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Integrates interrupt chip functionality with the GPIO chip. Can be</span></span><br><span class="line"><span class="comment">	 * used to handle IRQs for most practical cases.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_irq_chip</span> <span class="title">irq</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * @need_valid_mask:</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * If set core allocates @valid_mask with all bits set to one.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">bool</span> need_valid_mask;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * @valid_mask:</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * If not %NULL holds bitmask of GPIOs which are valid to be used</span></span><br><span class="line"><span class="comment">	 * from the chip.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> *valid_mask;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_OF_GPIO)</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If CONFIG_OF is enabled, then all GPIO controllers described in the</span></span><br><span class="line"><span class="comment">	 * device tree automatically may have an OF translation</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * @of_node:</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Pointer to a device tree node representing this GPIO controller.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">of_node</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * @of_gpio_n_cells:</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Number of cells used to form the GPIO specifier.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> of_gpio_n_cells;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * @of_xlate:</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Callback to translate a device tree GPIO specifier into a chip-</span></span><br><span class="line"><span class="comment">	 * relative GPIO number and flags.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">int</span> (*of_xlate)(struct gpio_chip *gc,</span><br><span class="line">			<span class="keyword">const</span> struct of_phandle_args *gpiospec, u32 *flags);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>struct gpio_desc</code>结构体，每个GPIO由一个gpio_desc来描述，看起来<code>gpio_chip</code>和<code>gpio_desc</code>是包含关系，但是kernel中并没有直接将其两个结构联系上，而是通过另一个结构体将其联系在一起，这个结构就是<code>gpio_device</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gpio_desc</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_device</span>	*<span class="title">gdev</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		flags;</span><br><span class="line"><span class="comment">/* flag symbols are bit numbers */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FLAG_REQUESTED	0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FLAG_IS_OUT	1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FLAG_EXPORT	2	<span class="comment">/* protected by sysfs_lock */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FLAG_SYSFS	3	<span class="comment">/* exported via /sys/class/gpio/control */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FLAG_ACTIVE_LOW	6	<span class="comment">/* value has active low */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FLAG_OPEN_DRAIN	7	<span class="comment">/* Gpio is open drain type */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FLAG_OPEN_SOURCE 8	<span class="comment">/* Gpio is open source type */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FLAG_USED_AS_IRQ 9	<span class="comment">/* GPIO is connected to an IRQ */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FLAG_IS_HOGGED	11	<span class="comment">/* GPIO is hogged */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FLAG_TRANSITORY 12	<span class="comment">/* GPIO may lose value in sleep or reset */</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Connection label */</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>		*label;</span><br><span class="line">	<span class="comment">/* Name of the GPIO */</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>		*name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>gdev指针指向了这个gpio_desc所属的gpio_device，flag代表了该GPIO的属性状态</p>
<p><code>struct gpio_device</code>结构，<code>gpio_device</code>是软件层面上对一个bank的GPIO进行管理的单元</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct gpio_device - internal state container for GPIO devices</span></span><br><span class="line"><span class="comment"> * @id: numerical ID number for the GPIO chip</span></span><br><span class="line"><span class="comment"> * @dev: the GPIO device struct</span></span><br><span class="line"><span class="comment"> * @chrdev: character device for the GPIO device</span></span><br><span class="line"><span class="comment"> * @mockdev: class device used by the deprecated sysfs interface (may be</span></span><br><span class="line"><span class="comment"> * NULL)</span></span><br><span class="line"><span class="comment"> * @owner: helps prevent removal of modules exporting active GPIOs</span></span><br><span class="line"><span class="comment"> * @chip: pointer to the corresponding gpiochip, holding static</span></span><br><span class="line"><span class="comment"> * data for this device</span></span><br><span class="line"><span class="comment"> * @descs: array of ngpio descriptors.</span></span><br><span class="line"><span class="comment"> * @ngpio: the number of GPIO lines on this GPIO device, equal to the size</span></span><br><span class="line"><span class="comment"> * of the @descs array.</span></span><br><span class="line"><span class="comment"> * @base: GPIO base in the DEPRECATED global Linux GPIO numberspace, assigned</span></span><br><span class="line"><span class="comment"> * at device creation time.</span></span><br><span class="line"><span class="comment"> * @label: a descriptive name for the GPIO device, such as the part number</span></span><br><span class="line"><span class="comment"> * or name of the IP component in a System on Chip.</span></span><br><span class="line"><span class="comment"> * @data: per-instance data assigned by the driver</span></span><br><span class="line"><span class="comment"> * @list: links gpio_device:s together for traversal</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This state container holds most of the runtime variable data</span></span><br><span class="line"><span class="comment"> * for a GPIO device and can hold references and live on after the</span></span><br><span class="line"><span class="comment"> * GPIO chip has been removed, if it is still being used from</span></span><br><span class="line"><span class="comment"> * userspace.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gpio_device</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span>			id;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span>		<span class="title">dev</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cdev</span>		<span class="title">chrdev</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span>		*<span class="title">mockdev</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">module</span>		*<span class="title">owner</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_chip</span>	*<span class="title">chip</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_desc</span>	*<span class="title">descs</span>;</span></span><br><span class="line">	<span class="keyword">int</span>			base;</span><br><span class="line">	u16			ngpio;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>		*label;</span><br><span class="line">	<span class="keyword">void</span>			*data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>        <span class="title">list</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PINCTRL</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If CONFIG_PINCTRL is enabled, then gpio controllers can optionally</span></span><br><span class="line"><span class="comment">	 * describe the actual pin range which they serve in an SoC. This</span></span><br><span class="line"><span class="comment">	 * information would be used by pinctrl subsystem to configure</span></span><br><span class="line"><span class="comment">	 * corresponding pins for gpio usage.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">pin_ranges</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>struct gpio_device</code>中包含了<code>struct gpio_chip</code>和<code>struct gpio_desc</code>，这个结构体贯穿了整个gpiolib，因为gpio_device是代表的一个bank，所以在kernel中，对gpio_device的组织是由一个gpio_device的链表构成的</p>
<h3 id="gpiolib对接芯片底层"><a href="#gpiolib对接芯片底层" class="headerlink" title="gpiolib对接芯片底层"></a>gpiolib对接芯片底层</h3><p>底层需要对接的是实现对gpio的一些通用操作，这里主要是实现<code>gpio_chip</code>这个结构体，然后通过调用<code>gpiochip_add_data()</code>这个接口注册GPIO资源，或者使用<code>devm_gpiochip_add_data()</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/linux/gpio/driver.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> gpiochip_add_data(chip, data) gpiochip_add_data_with_key(chip, data, NULL, NULL)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// drivers/gpio/gpiolib.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gpiochip_add_data_with_key</span><span class="params">(struct gpio_chip *chip, <span class="keyword">void</span> *data,</span></span></span><br><span class="line"><span class="params"><span class="function">			       struct lock_class_key *lock_key,</span></span></span><br><span class="line"><span class="params"><span class="function">			       struct lock_class_key *request_key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>	flags;</span><br><span class="line">	<span class="keyword">int</span>		status = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">unsigned</span>	i;</span><br><span class="line">	<span class="keyword">int</span>		base = chip-&gt;base;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_device</span> *<span class="title">gdev</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * First: allocate and populate the internal stat container, and</span></span><br><span class="line"><span class="comment">	 * set up the struct device.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">// 首先分配gpio_device结构体来管理gpio资源</span></span><br><span class="line">    <span class="comment">// 对gdev-&gt;chip进行赋值</span></span><br><span class="line">    <span class="comment">// 对chip-&gt;gpiodev进行赋值</span></span><br><span class="line">	gdev = kzalloc(<span class="keyword">sizeof</span>(*gdev), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!gdev)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	gdev-&gt;dev.bus = &amp;gpio_bus_type;</span><br><span class="line">	gdev-&gt;chip = chip;</span><br><span class="line">	chip-&gt;gpiodev = gdev;</span><br><span class="line">	<span class="keyword">if</span> (chip-&gt;parent) &#123;</span><br><span class="line">		gdev-&gt;dev.parent = chip-&gt;parent;</span><br><span class="line">		gdev-&gt;dev.of_node = chip-&gt;parent-&gt;of_node;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_OF_GPIO</span></span><br><span class="line">	<span class="comment">/* If the gpiochip has an assigned OF node this takes precedence */</span></span><br><span class="line">	<span class="keyword">if</span> (chip-&gt;of_node)</span><br><span class="line">		gdev-&gt;dev.of_node = chip-&gt;of_node;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		chip-&gt;of_node = gdev-&gt;dev.of_node;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	gdev-&gt;id = ida_simple_get(&amp;gpio_ida, <span class="number">0</span>, <span class="number">0</span>, GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (gdev-&gt;id &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		status = gdev-&gt;id;</span><br><span class="line">		<span class="keyword">goto</span> err_free_gdev;</span><br><span class="line">	&#125;</span><br><span class="line">	dev_set_name(&amp;gdev-&gt;dev, <span class="string">&quot;gpiochip%d&quot;</span>, gdev-&gt;id);</span><br><span class="line">	device_initialize(&amp;gdev-&gt;dev);</span><br><span class="line">	dev_set_drvdata(&amp;gdev-&gt;dev, gdev);</span><br><span class="line">	<span class="keyword">if</span> (chip-&gt;parent &amp;&amp; chip-&gt;parent-&gt;driver)</span><br><span class="line">		gdev-&gt;owner = chip-&gt;parent-&gt;driver-&gt;owner;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (chip-&gt;owner)</span><br><span class="line">		<span class="comment">/* <span class="doctag">TODO:</span> remove chip-&gt;owner */</span></span><br><span class="line">		gdev-&gt;owner = chip-&gt;owner;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		gdev-&gt;owner = THIS_MODULE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配ngpio个gpio_desc结构体</span></span><br><span class="line">	gdev-&gt;descs = kcalloc(chip-&gt;ngpio, <span class="keyword">sizeof</span>(gdev-&gt;descs[<span class="number">0</span>]), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!gdev-&gt;descs) &#123;</span><br><span class="line">		status = -ENOMEM;</span><br><span class="line">		<span class="keyword">goto</span> err_free_ida;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (chip-&gt;ngpio == <span class="number">0</span>) &#123;</span><br><span class="line">		chip_err(chip, <span class="string">&quot;tried to insert a GPIO chip with zero lines\n&quot;</span>);</span><br><span class="line">		status = -EINVAL;</span><br><span class="line">		<span class="keyword">goto</span> err_free_descs;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (chip-&gt;ngpio &gt; FASTPATH_NGPIO)</span><br><span class="line">		chip_warn(chip, <span class="string">&quot;line cnt %u is greater than fast path cnt %u\n&quot;</span>,</span><br><span class="line">		chip-&gt;ngpio, FASTPATH_NGPIO);</span><br><span class="line"></span><br><span class="line">	gdev-&gt;label = kstrdup_const(chip-&gt;label ?: <span class="string">&quot;unknown&quot;</span>, GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!gdev-&gt;label) &#123;</span><br><span class="line">		status = -ENOMEM;</span><br><span class="line">		<span class="keyword">goto</span> err_free_descs;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	gdev-&gt;ngpio = chip-&gt;ngpio;</span><br><span class="line">    <span class="comment">// 将GPIO驱动指针存放到gpio_device-&gt;data中</span></span><br><span class="line">	gdev-&gt;data = data;</span><br><span class="line"></span><br><span class="line">	spin_lock_irqsave(&amp;gpio_lock, flags);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">TODO:</span> this allocates a Linux GPIO number base in the global</span></span><br><span class="line"><span class="comment">	 * GPIO numberspace for this chip. In the long run we want to</span></span><br><span class="line"><span class="comment">	 * get *rid* of this numberspace and use only descriptors, but</span></span><br><span class="line"><span class="comment">	 * it may be a pipe dream. It will not happen before we get rid</span></span><br><span class="line"><span class="comment">	 * of the sysfs interface anyways.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">// base代表每个bank的编号</span></span><br><span class="line">	<span class="keyword">if</span> (base &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		base = gpiochip_find_base(chip-&gt;ngpio);</span><br><span class="line">		<span class="keyword">if</span> (base &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			status = base;</span><br><span class="line">			spin_unlock_irqrestore(&amp;gpio_lock, flags);</span><br><span class="line">			<span class="keyword">goto</span> err_free_label;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">TODO:</span> it should not be necessary to reflect the assigned</span></span><br><span class="line"><span class="comment">		 * base outside of the GPIO subsystem. Go over drivers and</span></span><br><span class="line"><span class="comment">		 * see if anyone makes use of this, else drop this and assign</span></span><br><span class="line"><span class="comment">		 * a poison instead.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		chip-&gt;base = base;</span><br><span class="line">	&#125;</span><br><span class="line">	gdev-&gt;base = base;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将该gpio_device挂到gpio_devices链表中进行管理</span></span><br><span class="line">	status = gpiodev_add_to_list(gdev);</span><br><span class="line">	<span class="keyword">if</span> (status) &#123;</span><br><span class="line">		spin_unlock_irqrestore(&amp;gpio_lock, flags);</span><br><span class="line">		<span class="keyword">goto</span> err_free_label;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	spin_unlock_irqrestore(&amp;gpio_lock, flags);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化该组bank中每个gpio的gpio_desc的信息</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; chip-&gt;ngpio; i++) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">gpio_desc</span> *<span class="title">desc</span> =</span> &amp;gdev-&gt;descs[i];</span><br><span class="line"></span><br><span class="line">		desc-&gt;gdev = gdev;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* REVISIT: most hardware initializes GPIOs as inputs (often</span></span><br><span class="line"><span class="comment">		 * with pullups enabled) so power usage is minimized. Linux</span></span><br><span class="line"><span class="comment">		 * code should set the gpio direction first thing; but until</span></span><br><span class="line"><span class="comment">		 * it does, and in case chip-&gt;get_direction is not set, we may</span></span><br><span class="line"><span class="comment">		 * expose the wrong direction in sysfs.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		desc-&gt;flags = !chip-&gt;direction_input ? (<span class="number">1</span> &lt;&lt; FLAG_IS_OUT) : <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PINCTRL</span></span><br><span class="line">	INIT_LIST_HEAD(&amp;gdev-&gt;pin_ranges);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	status = gpiochip_set_desc_names(chip);</span><br><span class="line">	<span class="keyword">if</span> (status)</span><br><span class="line">		<span class="keyword">goto</span> err_remove_from_list;</span><br><span class="line"></span><br><span class="line">	status = gpiochip_irqchip_init_valid_mask(chip);</span><br><span class="line">	<span class="keyword">if</span> (status)</span><br><span class="line">		<span class="keyword">goto</span> err_remove_from_list;</span><br><span class="line"></span><br><span class="line">	status = gpiochip_init_valid_mask(chip);</span><br><span class="line">	<span class="keyword">if</span> (status)</span><br><span class="line">		<span class="keyword">goto</span> err_remove_irqchip_mask;</span><br><span class="line"></span><br><span class="line">	status = gpiochip_add_irqchip(chip, lock_key, request_key);</span><br><span class="line">	<span class="keyword">if</span> (status)</span><br><span class="line">		<span class="keyword">goto</span> err_remove_chip;</span><br><span class="line"></span><br><span class="line">	status = of_gpiochip_add(chip);</span><br><span class="line">	<span class="keyword">if</span> (status)</span><br><span class="line">		<span class="keyword">goto</span> err_remove_chip;</span><br><span class="line"></span><br><span class="line">	acpi_gpiochip_add(chip);</span><br><span class="line"></span><br><span class="line">	machine_gpiochip_add(chip);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * By first adding the chardev, and then adding the device,</span></span><br><span class="line"><span class="comment">	 * we get a device node entry in sysfs under</span></span><br><span class="line"><span class="comment">	 * /sys/bus/gpio/devices/gpiochipN/dev that can be used for</span></span><br><span class="line"><span class="comment">	 * coldplug of device nodes and other udev business.</span></span><br><span class="line"><span class="comment">	 * We can do this only if gpiolib has been initialized.</span></span><br><span class="line"><span class="comment">	 * Otherwise, defer until later.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (gpiolib_initialized) &#123;</span><br><span class="line">		status = gpiochip_setup_dev(gdev);</span><br><span class="line">		<span class="keyword">if</span> (status)</span><br><span class="line">			<span class="keyword">goto</span> err_remove_chip;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err_remove_chip:</span><br><span class="line">	acpi_gpiochip_remove(chip);</span><br><span class="line">	gpiochip_free_hogs(chip);</span><br><span class="line">	of_gpiochip_remove(chip);</span><br><span class="line">	gpiochip_free_valid_mask(chip);</span><br><span class="line">err_remove_irqchip_mask:</span><br><span class="line">	gpiochip_irqchip_free_valid_mask(chip);</span><br><span class="line">err_remove_from_list:</span><br><span class="line">	spin_lock_irqsave(&amp;gpio_lock, flags);</span><br><span class="line">	list_del(&amp;gdev-&gt;<span class="built_in">list</span>);</span><br><span class="line">	spin_unlock_irqrestore(&amp;gpio_lock, flags);</span><br><span class="line">err_free_label:</span><br><span class="line">	kfree_const(gdev-&gt;label);</span><br><span class="line">err_free_descs:</span><br><span class="line">	kfree(gdev-&gt;descs);</span><br><span class="line">err_free_ida:</span><br><span class="line">	ida_simple_remove(&amp;gpio_ida, gdev-&gt;id);</span><br><span class="line">err_free_gdev:</span><br><span class="line">	<span class="comment">/* failures here can mean systems won&#x27;t boot... */</span></span><br><span class="line">	pr_err(<span class="string">&quot;%s: GPIOs %d..%d (%s) failed to register, %d\n&quot;</span>, __func__,</span><br><span class="line">	       gdev-&gt;base, gdev-&gt;base + gdev-&gt;ngpio - <span class="number">1</span>,</span><br><span class="line">	       chip-&gt;label ? : <span class="string">&quot;generic&quot;</span>, status);</span><br><span class="line">	kfree(gdev);</span><br><span class="line">	<span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(gpiochip_add_data_with_key);</span><br></pre></td></tr></table></figure>

<h3 id="对GPIO中断的管理"><a href="#对GPIO中断的管理" class="headerlink" title="对GPIO中断的管理"></a>对GPIO中断的管理</h3><p><code>struct gpio_irq_chip</code>结构体，GPIO中断控制器</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/linux/gpio/driver.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gpio_irq_chip</span> &#123;</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * @chip:</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * GPIO IRQ chip implementation, provided by GPIO driver.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_chip</span> *<span class="title">chip</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * @domain:</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Interrupt translation domain; responsible for mapping between GPIO</span></span><br><span class="line"><span class="comment">	 * hwirq number and Linux IRQ number.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_domain</span> *<span class="title">domain</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * @domain_ops:</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Table of interrupt domain operations for this IRQ chip.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">irq_domain_ops</span> *<span class="title">domain_ops</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * @handler:</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * The IRQ handler to use (often a predefined IRQ core function) for</span></span><br><span class="line"><span class="comment">	 * GPIO IRQs, provided by GPIO driver.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">irq_flow_handler_t</span> handler;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * @default_type:</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Default IRQ triggering type applied during GPIO driver</span></span><br><span class="line"><span class="comment">	 * initialization, provided by GPIO driver.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> default_type;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * @lock_key:</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Per GPIO IRQ chip lockdep classes.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> *<span class="title">lock_key</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> *<span class="title">request_key</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * @parent_handler:</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * The interrupt handler for the GPIO chip&#x27;s parent interrupts, may be</span></span><br><span class="line"><span class="comment">	 * NULL if the parent interrupts are nested rather than cascaded.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">irq_flow_handler_t</span> parent_handler;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * @parent_handler_data:</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Data associated, and passed to, the handler for the parent</span></span><br><span class="line"><span class="comment">	 * interrupt.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">void</span> *parent_handler_data;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * @num_parents:</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * The number of interrupt parents of a GPIO chip.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> num_parents;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * @parent_irq:</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * For use by gpiochip_set_cascaded_irqchip()</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> parent_irq;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * @parents:</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * A list of interrupt parents of a GPIO chip. This is owned by the</span></span><br><span class="line"><span class="comment">	 * driver, so the core will only reference this list, not modify it.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> *parents;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * @map:</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * A list of interrupt parents for each line of a GPIO chip.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> *<span class="built_in">map</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * @threaded:</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * True if set the interrupt handling uses nested threads.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">bool</span> threaded;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * @need_valid_mask:</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * If set core allocates @valid_mask with all bits set to one.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">bool</span> need_valid_mask;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * @valid_mask:</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * If not %NULL holds bitmask of GPIOs which are valid to be included</span></span><br><span class="line"><span class="comment">	 * in IRQ domain of the chip.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> *valid_mask;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * @first:</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Required for static IRQ allocation. If set, irq_domain_add_simple()</span></span><br><span class="line"><span class="comment">	 * will allocate and map all IRQs during initialization.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> first;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="phytium-gpio驱动"><a href="#phytium-gpio驱动" class="headerlink" title="phytium gpio驱动"></a>phytium gpio驱动</h4><p>phytium_gpio结构体定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">phytium_gpio</span> &#123;</span></span><br><span class="line">	<span class="keyword">raw_spinlock_t</span>		lock;</span><br><span class="line">	<span class="keyword">void</span> __iomem		*regs;</span><br><span class="line">	<span class="comment">// 用来表示一个gpio控制器</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_chip</span>	<span class="title">gc</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_chip</span>		<span class="title">irq_chip</span>;</span></span><br><span class="line">	<span class="comment">// 用来表示gpio个数</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		ngpio[<span class="number">2</span>];</span><br><span class="line">	<span class="comment">// gpio中断号数组</span></span><br><span class="line">	<span class="keyword">int</span>			irq[<span class="number">32</span>];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PM_SLEEP</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">phytium_gpio_ctx</span>	<span class="title">ctx</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>例如Phytium E2000 CPU共6个GPIO控制器，每个控制器提供16个GPIO信号<br><img src="https://raw.githubusercontent.com/JackHuang021/images/master/20230506100520.png"></p>
<h3 id="Linux中断通用框架"><a href="#Linux中断通用框架" class="headerlink" title="Linux中断通用框架"></a>Linux中断通用框架</h3><p>在linux中引入了irq_domain的概念，一个中断控制器就是一个irq_domain，中断控制器出现级联的布局，利用树状的结构可以充分的利用irq数目，每一个irq_domain可以去管理自己interrupt的特性</p>
<h4 id="IRQ-domain"><a href="#IRQ-domain" class="headerlink" title="IRQ domain"></a>IRQ domain</h4><p><code>irq_domain</code>用于将硬件的中断号，转换为Linux系统中的中断号（virq）</p>
<ul>
<li>每个中断控制器都对应一个irq_domain</li>
<li>中断控制器驱动通过irq_domain_add()接口来创建irq_domain</li>
<li>irq_domain支持三种映射方式：linear map，tree map，no map<ul>
<li>linear map：线性映射，维护固定大小的表，索引是硬件中断号，如果硬件中断最大数量固定，数值不大，可以选择线性映射</li>
<li>tree map：硬件中断号可能很大，可以选择树映射</li>
<li>no map：硬件中断号直接就是linux的中断号</li>
</ul>
</li>
<li>各个控制器的硬件中断号可以一样，最终在Linux内核中映射的中断号是唯一的</li>
</ul>
<p>每一个中断控制器对应多个中断号，而硬件中断号在不同的中断控制器上是会重复编码的，因此linux kernel提供了一个虚拟中断号的概念</p>
<h4 id="与中断相关的数据结构"><a href="#与中断相关的数据结构" class="headerlink" title="与中断相关的数据结构"></a>与中断相关的数据结构</h4><p>在看硬件中断号映射到虚拟中断号之前，来看几个比较重要的数据结构</p>
<p><code>struct irq_chip</code>结构体描述中断控制器的底层操作函数集，这些函数集最终完成对控制器硬件的操作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irq_chip</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span>	*<span class="title">parent_device</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>	*name;</span><br><span class="line">	<span class="function"><span class="keyword">unsigned</span> <span class="title">int</span>	<span class="params">(*irq_startup)</span><span class="params">(struct irq_data *data)</span></span>;</span><br><span class="line">	<span class="keyword">void</span>		(*irq_shutdown)(struct irq_data *data);</span><br><span class="line">	<span class="keyword">void</span>		(*irq_enable)(struct irq_data *data);</span><br><span class="line">	<span class="keyword">void</span>		(*irq_disable)(struct irq_data *data);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">void</span>		(*irq_ack)(struct irq_data *data);</span><br><span class="line">	<span class="keyword">void</span>		(*irq_mask)(struct irq_data *data);</span><br><span class="line">	<span class="keyword">void</span>		(*irq_mask_ack)(struct irq_data *data);</span><br><span class="line">	<span class="keyword">void</span>		(*irq_unmask)(struct irq_data *data);</span><br><span class="line">	<span class="keyword">void</span>		(*irq_eoi)(struct irq_data *data);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span>		(*irq_set_affinity)(struct irq_data *data, <span class="keyword">const</span> struct cpumask *dest, <span class="keyword">bool</span> force);</span><br><span class="line">	<span class="keyword">int</span>		(*irq_retrigger)(struct irq_data *data);</span><br><span class="line">	<span class="keyword">int</span>		(*irq_set_type)(struct irq_data *data, <span class="keyword">unsigned</span> <span class="keyword">int</span> flow_type);</span><br><span class="line">	<span class="keyword">int</span>		(*irq_set_wake)(struct irq_data *data, <span class="keyword">unsigned</span> <span class="keyword">int</span> on);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">void</span>		(*irq_bus_lock)(struct irq_data *data);</span><br><span class="line">	<span class="keyword">void</span>		(*irq_bus_sync_unlock)(struct irq_data *data);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">void</span>		(*irq_cpu_online)(struct irq_data *data);</span><br><span class="line">	<span class="keyword">void</span>		(*irq_cpu_offline)(struct irq_data *data);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">void</span>		(*irq_suspend)(struct irq_data *data);</span><br><span class="line">	<span class="keyword">void</span>		(*irq_resume)(struct irq_data *data);</span><br><span class="line">	<span class="keyword">void</span>		(*irq_pm_shutdown)(struct irq_data *data);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">void</span>		(*irq_calc_mask)(struct irq_data *data);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">void</span>		(*irq_print_chip)(struct irq_data *data, struct seq_file *p);</span><br><span class="line">	<span class="keyword">int</span>		(*irq_request_resources)(struct irq_data *data);</span><br><span class="line">	<span class="keyword">void</span>		(*irq_release_resources)(struct irq_data *data);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">void</span>		(*irq_compose_msi_msg)(struct irq_data *data, struct msi_msg *msg);</span><br><span class="line">	<span class="keyword">void</span>		(*irq_write_msi_msg)(struct irq_data *data, struct msi_msg *msg);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span>		(*irq_get_irqchip_state)(struct irq_data *data, <span class="keyword">enum</span> irqchip_irq_state which, <span class="keyword">bool</span> *state);</span><br><span class="line">	<span class="keyword">int</span>		(*irq_set_irqchip_state)(struct irq_data *data, <span class="keyword">enum</span> irqchip_irq_state which, <span class="keyword">bool</span> state);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span>		(*irq_set_vcpu_affinity)(struct irq_data *data, <span class="keyword">void</span> *vcpu_info);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">void</span>		(*ipi_send_single)(struct irq_data *data, <span class="keyword">unsigned</span> <span class="keyword">int</span> cpu);</span><br><span class="line">	<span class="keyword">void</span>		(*ipi_send_mask)(struct irq_data *data, <span class="keyword">const</span> struct cpumask *dest);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span>		(*irq_nmi_setup)(struct irq_data *data);</span><br><span class="line">	<span class="keyword">void</span>		(*irq_nmi_teardown)(struct irq_data *data);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>	flags;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>struct irq_desc</code>描述一个外设的中断，称为中断描述符</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irq_desc</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_common_data</span>	<span class="title">irq_common_data</span>;</span></span><br><span class="line">	<span class="comment">// 中断控制器的硬件数据</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_data</span>		<span class="title">irq_data</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> __percpu	*kstat_irqs;</span><br><span class="line">	<span class="comment">// 中断控制器驱动的处理函数</span></span><br><span class="line">	<span class="keyword">irq_flow_handler_t</span>	handle_irq;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irqaction</span>	*<span class="title">action</span>;</span>	<span class="comment">/* IRQ action list */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		status_use_accessors;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		core_internal_state__do_not_mess_with_it;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		depth;		<span class="comment">/* nested irq disables */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		wake_depth;	<span class="comment">/* nested wake enables */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		tot_count;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		irq_count;	<span class="comment">/* For detecting broken IRQs */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		last_unhandled;	<span class="comment">/* Aging timer for unhandled count */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		irqs_unhandled;</span><br><span class="line">	<span class="keyword">atomic_t</span>		threads_handled;</span><br><span class="line">	<span class="keyword">int</span>			threads_handled_last;</span><br><span class="line">	<span class="keyword">raw_spinlock_t</span>		lock;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cpumask</span>		*<span class="title">percpu_enabled</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cpumask</span>	*<span class="title">percpu_affinity</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cpumask</span>	*<span class="title">affinity_hint</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_affinity_notify</span> *<span class="title">affinity_notify</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_GENERIC_PENDING_IRQ</span></span><br><span class="line">	<span class="keyword">cpumask_var_t</span>		pending_mask;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		threads_oneshot;</span><br><span class="line">	<span class="keyword">atomic_t</span>		threads_active;</span><br><span class="line">	<span class="keyword">wait_queue_head_t</span>       wait_for_threads;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PM_SLEEP</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		nr_actions;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		no_suspend_depth;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		cond_suspend_depth;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		force_resume_depth;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PROC_FS</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">proc_dir_entry</span>	*<span class="title">dir</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_GENERIC_IRQ_DEBUGFS</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dentry</span>		*<span class="title">debugfs_file</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>		*dev_name;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SPARSE_IRQ</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span>		<span class="title">rcu</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kobject</span>		<span class="title">kobj</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>		<span class="title">request_mutex</span>;</span></span><br><span class="line">	<span class="keyword">int</span>			parent_irq;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">module</span>		*<span class="title">owner</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>		*name;</span><br><span class="line">&#125; ____cacheline_internodealigned_in_smp;</span><br></pre></td></tr></table></figure>

<p><code>struct irq_data</code>包含中断控制器的硬件数据</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irq_data</span> &#123;</span></span><br><span class="line">	u32			mask;</span><br><span class="line">	<span class="comment">// 虚拟中断号</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		irq;</span><br><span class="line">	<span class="comment">// 硬件中断号</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		hwirq;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_common_data</span>	*<span class="title">common</span>;</span></span><br><span class="line">	<span class="comment">// 对应的irq_chip数据结构</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_chip</span>		*<span class="title">chip</span>;</span></span><br><span class="line">	<span class="comment">// 对应的irq_domain数据结构</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_domain</span>	*<span class="title">domain</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span>	CONFIG_IRQ_DOMAIN_HIERARCHY</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_data</span>		*<span class="title">parent_data</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">void</span>			*chip_data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>struct irq_domain</code>与中断控制器对应，完成硬件中断hwirq到virq的映射</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irq_domain</span> &#123;</span></span><br><span class="line">	<span class="comment">// 用于将irq_domain链接到全局链表irq_domain_list中</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">link</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">	<span class="comment">// irq_domain映射操作函数集</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">irq_domain_ops</span> *<span class="title">ops</span>;</span></span><br><span class="line">	<span class="comment">// 在GIC中断控制器驱动中，指向了irq_dic_data</span></span><br><span class="line">	<span class="keyword">void</span> *host_data;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> flags;</span><br><span class="line">	<span class="comment">// 映射中断的个数</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> mapcount;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Optional data */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fwnode_handle</span> *<span class="title">fwnode</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">irq_domain_bus_token</span> <span class="title">bus_token</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_domain_chip_generic</span> *<span class="title">gc</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span>	CONFIG_IRQ_DOMAIN_HIERARCHY</span></span><br><span class="line">	<span class="comment">// 支持中断级联的话，指向父设备</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_domain</span> *<span class="title">parent</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_GENERIC_IRQ_DEBUGFS</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dentry</span>		*<span class="title">debugfs_file</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* reverse map data. The linear map gets appended to the irq_domain */</span></span><br><span class="line">	<span class="comment">// irq_domain支持中断数量的最大值</span></span><br><span class="line">	<span class="keyword">irq_hw_number_t</span> hwirq_max;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> revmap_direct_max_irq;</span><br><span class="line">	<span class="comment">// 线性映射的大小</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> revmap_size;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">radix_tree_root</span> <span class="title">revmap_tree</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">revmap_tree_mutex</span>;</span></span><br><span class="line">	<span class="comment">// 线性映射用到的查找表</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> linear_revmap[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>struct irq_domain</code>结构体，用于irq_domain映射操作的函数集</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irq_domain_ops</span> &#123;</span></span><br><span class="line">	<span class="comment">// 用于中断控制器和irq domain的匹配</span></span><br><span class="line">	<span class="keyword">int</span> (*match)(struct irq_domain *d, struct device_node *node,</span><br><span class="line">		     <span class="keyword">enum</span> irq_domain_bus_token bus_token);</span><br><span class="line">	<span class="keyword">int</span> (*select)(struct irq_domain *d, struct irq_fwspec *fwspec,</span><br><span class="line">		      <span class="keyword">enum</span> irq_domain_bus_token bus_token);</span><br><span class="line">	<span class="comment">// 用于硬件中断号和linux中断号的映射</span></span><br><span class="line">	<span class="keyword">int</span> (*<span class="built_in">map</span>)(struct irq_domain *d, <span class="keyword">unsigned</span> <span class="keyword">int</span> virq, <span class="keyword">irq_hw_number_t</span> hw);</span><br><span class="line">	<span class="keyword">void</span> (*unmap)(struct irq_domain *d, <span class="keyword">unsigned</span> <span class="keyword">int</span> virq);</span><br><span class="line">	<span class="keyword">int</span> (*xlate)(struct irq_domain *d, struct device_node *node,</span><br><span class="line">		     <span class="keyword">const</span> u32 *intspec, <span class="keyword">unsigned</span> <span class="keyword">int</span> intsize,</span><br><span class="line">		     <span class="keyword">unsigned</span> <span class="keyword">long</span> *out_hwirq, <span class="keyword">unsigned</span> <span class="keyword">int</span> *out_type);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span>	CONFIG_IRQ_DOMAIN_HIERARCHY</span></span><br><span class="line">	<span class="comment">/* extended V2 interfaces to support hierarchy irq_domains */</span></span><br><span class="line">	<span class="keyword">int</span> (*alloc)(struct irq_domain *d, <span class="keyword">unsigned</span> <span class="keyword">int</span> virq,</span><br><span class="line">		     <span class="keyword">unsigned</span> <span class="keyword">int</span> nr_irqs, <span class="keyword">void</span> *arg);</span><br><span class="line">	<span class="keyword">void</span> (*<span class="built_in">free</span>)(struct irq_domain *d, <span class="keyword">unsigned</span> <span class="keyword">int</span> virq,</span><br><span class="line">		     <span class="keyword">unsigned</span> <span class="keyword">int</span> nr_irqs);</span><br><span class="line">	<span class="keyword">int</span> (*activate)(struct irq_domain *d, struct irq_data *irqd, <span class="keyword">bool</span> reserve);</span><br><span class="line">	<span class="keyword">void</span> (*deactivate)(struct irq_domain *d, struct irq_data *irq_data);</span><br><span class="line">	<span class="keyword">int</span> (*translate)(struct irq_domain *d, struct irq_fwspec *fwspec,</span><br><span class="line">			 <span class="keyword">unsigned</span> <span class="keyword">long</span> *out_hwirq, <span class="keyword">unsigned</span> <span class="keyword">int</span> *out_type);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_GENERIC_IRQ_DEBUGFS</span></span><br><span class="line">	<span class="keyword">void</span> (*debug_show)(struct seq_file *m, struct irq_domain *d,</span><br><span class="line">			   struct irq_data *irqd, <span class="keyword">int</span> ind);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>struct irqaction</code>用来存储设备驱动注册的中断处理函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irqaction</span> &#123;</span></span><br><span class="line">	<span class="comment">// 设备驱动里的中断处理函数</span></span><br><span class="line">	<span class="keyword">irq_handler_t</span>		handler;</span><br><span class="line">	<span class="comment">// 设备id</span></span><br><span class="line">	<span class="keyword">void</span>			*dev_id;</span><br><span class="line">	<span class="keyword">void</span> __percpu		*percpu_dev_id;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irqaction</span>	*<span class="title">next</span>;</span></span><br><span class="line">	<span class="keyword">irq_handler_t</span>		thread_fn;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>	*<span class="title">thread</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irqaction</span>	*<span class="title">secondary</span>;</span></span><br><span class="line">	<span class="comment">// 中断号</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		irq;</span><br><span class="line">	<span class="comment">// 中断标志</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		flags;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		thread_flags;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		thread_mask;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>		*name;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">proc_dir_entry</span>	*<span class="title">dir</span>;</span></span><br><span class="line">&#125; ____cacheline_internodealigned_in_smp;</span><br></pre></td></tr></table></figure>

<p>其核心是围绕着<code>struct irq_desc</code>来展开的<br><img src="https://raw.githubusercontent.com/JackHuang021/images/master/20230506140748.png"></p>
<p>中断的处理主要有以下几个功能模块</p>
<ul>
<li>硬件中断号到linux irq中断号的映射，并创建好irq_desc中断描述符</li>
<li>中断注册时，先获取设备的中断号，根据中断号找到对应的irq_desc，并将设备的中断处理函数添加到irq_desc</li>
<li>设备触发中断信号时，根据硬件中断号得到linux irq中断号，找到对应的irq_desc，最终调用到设备的中断处理函数</li>
</ul>
<h5 id="如何取得linux-irq中断号"><a href="#如何取得linux-irq中断号" class="headerlink" title="如何取得linux irq中断号"></a>如何取得linux irq中断号</h5><p>硬件设备的中断信息都在设备树中进行了描述，在系统启动过程中，这些信息都已经解析并加载到了内存中，驱动中通常会使用<code>platform_get_irq()</code>接口，去根据设备树的信息去创建映射关系，硬件中断号到linux irq中断号映射，</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">setenv bootargs console=ttyAMA1,115200 earlycon=pl011,0x28001000 root=/dev/sda rootwait rw;ext4load scsi 0:0 0x90100000 boot/d2000/d2000-devboard-dsk.dtb;ext4load scsi 0:0 0x90200000 boot/d2000/Image;booti 0x90200000 - 0x90100000</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">108:          0          0  28036000.gpio   5 Edge      es8336_interrupt</span><br><span class="line"></span><br><span class="line">109:          0          0  28038000.gpio  11 Edge      gpiomon</span><br></pre></td></tr></table></figure>







]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>GPIO</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux DMA驱动框架</title>
    <url>/archives/1990ed3c.html</url>
    <content><![CDATA[<h4 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h4><p>DMA是Direct Memory Access的缩写，就是绕开CPU进行内存的访问，DMA控制器就是用来协助CPU在memory和memory或者memory和设备之间搬运数据</p>
<p><img src="https://raw.githubusercontent.com/JackHuang021/images/master/20230526141809.png"></p>
<span id="more"></span>
<h5 id="DMA-channels"><a href="#DMA-channels" class="headerlink" title="DMA channels"></a>DMA channels</h5><p>一个DMA可以“同时”进行DMA传输的个数是有限的，这称作DMA channels，这里的channel只是一个逻辑上的概念</p>
<blockquote>
<p>鉴于总线访问的冲突，以及内存一致性的考量，从物理的角度看，不大可能会同时进行两个（及以上）的DMA传输。因而DMA channel不太可能是物理上独立的通道；</p>
<p>很多时候，DMA channels是DMA controller为了方便，抽象出来的概念，让consumer以为独占了一个channel，实际上所有channel的DMA传输请求都会在DMA controller中进行仲裁，进而串行传输；</p>
<p>因此，软件也可以基于controller提供的channel（我们称为“物理”channel），自行抽象更多的“逻辑”channel，软件会管理这些逻辑channel上的传输请求。实际上很多平台都这样做了，在DMA Engine framework中，不会区分这两种channel（本质上没区别）。</p>
</blockquote>
<h5 id="DMA-request-line"><a href="#DMA-request-line" class="headerlink" title="DMA request line"></a>DMA request line</h5><p>DMA传输是由CPU发起的，CPU会告诉DMA控制器，把xxx地方的数据搬运到xxx地方，而DMA控制器，除了负责怎么搬之外还要决定一件非常重要的事情：何时开始搬运？</p>
<p>因为，CPU发起DMA传输的时候，并不知道当前是否具备传输条件，例如source设备是否有数据、dest设备的FIFO是否空闲等等。那谁知道是否可以传输呢？设备！因此，需要DMA传输的设备和DMA控制器之间，会有几条物理的连接线（称作DMA request，DRQ），用于通知DMA控制器可以开始传输了。</p>
<p>通常来说，每一个数据收发的节点（称作endpoint），和DMA controller之间，就有一条DMA request line。</p>
<h5 id="传输参数"><a href="#传输参数" class="headerlink" title="传输参数"></a>传输参数</h5><p><strong>transfer size:</strong> 在每一个时钟周期，DMA controller将1 byte的数据从一个buffer搬到另一个buffer，直到搬完transfer size个byte即可停止</p>
<p><strong>transfer width:</strong> 传输的数据宽度，在一个时钟周期中，传输指定的bit的数据，DDMA固定为4字节</p>
<p><strong>buffer size:</strong> DMA控制器内部可缓存的数据量大小</p>
<p><strong>scatter-gather:</strong> DMA传输一般情况下只能处理物理上连续的buffer，在某些场景下将一些非连续的buffer拷贝到一个连续的buffer中，这样的操作称为scatter-gather，对于这种非连续的传输，大多时候都是通过软件，将传输分成多个连续的小块（chunk）,例如在dmaengine中的scatterlist</p>
<p><strong>burst size:</strong> DMA控制器内部可缓存的数据量大小，按照DDMA的手册描述应该是固定为64字节，一次搬64字节</p>
<h4 id="Linux-dmaengine"><a href="#Linux-dmaengine" class="headerlink" title="Linux dmaengine"></a>Linux dmaengine</h4><p>从方向上来说：DMA传输可以分为4类，memory到memory，memory到device，device到memory以及device到device，从linux kernel的角度，外设都是slave，因此这些有device参与的传输（MEM2DEV, DEV2MEM, DEV2DEV）为Slave-DMA传输，另一种memory到memory的传输，被称为Async TX</p>
<p>因为Linux为了方便基于DMA的memcpy、memset等操作，在dma engine之上，封装了一层更为简洁的API，这种API就是Async TX API（以async_开头，例如async_memcpy、async_memset、async_xor等）。因为memory到memory的DMA传输有了比较简洁的API，没必要直接使用dma engine提供的API，最后就导致dma engine所提供的API就特指为Slave-DMA API</p>
<p>Slave-DMA中的slave指的是参与DMA传输的设备，对应的master就是指DMA controller自身</p>
<h5 id="重要数据结构"><a href="#重要数据结构" class="headerlink" title="重要数据结构"></a>重要数据结构</h5><p><code>struct dma_device</code>，用于抽象dma controller</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* include/linux/dmaengine.h */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dma_device</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kref</span> <span class="title">ref</span>;</span></span><br><span class="line">	<span class="comment">/* 当前支持的dma通道数，读取设备树的dma-channels值 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> chancnt;</span><br><span class="line">	<span class="comment">/* 已经申请的dma通道数 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> privatecnt;</span><br><span class="line">  	<span class="comment">/* 用于保存该controller支持的所有dma channel */</span></span><br><span class="line">  	<span class="comment">/* 初始化的时候需要将所有的channel加入到链表头中 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">channels</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">global_node</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dma_filter</span> <span class="title">filter</span>;</span></span><br><span class="line">  	<span class="comment">/* 用于指示dma controller所具备的功能，DDMA仅具有DMA_SLAVE的功能 */</span></span><br><span class="line">	<span class="keyword">dma_cap_mask_t</span>  cap_mask;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* dma controller支持的源数据宽度类型，DDMA只支持4字节 */</span></span><br><span class="line">	u32 src_addr_widths;</span><br><span class="line">	<span class="comment">/* dma controller支持的目的数据宽度类型，DDMA只支持4字节 */</span></span><br><span class="line">	u32 dst_addr_widths;</span><br><span class="line">	<span class="comment">/* dma controller支持的传输方向，DDMA只支持MEM_TO_DEV DEV_TO_MEM */</span></span><br><span class="line">	u32 directions;</span><br><span class="line">	u32 min_burst;</span><br><span class="line">	u32 max_burst;</span><br><span class="line">	<span class="comment">/* 单次传输的一个散列表中支持的最大长度，DDMA驱动里面设置是4KB */</span></span><br><span class="line">	u32 max_sg_burst;</span><br><span class="line">	<span class="comment">/* 报告传输剩余数据长度的功能 */</span></span><br><span class="line">	<span class="keyword">bool</span> descriptor_reuse;</span><br><span class="line">	<span class="comment">/* 剩余数据长度报告的类型，一共有三种：无法上报、传输完成后即可上报、每个brust传输后报告 */</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">dma_residue_granularity</span> <span class="title">residue_granularity</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 分配通道的接口 */</span></span><br><span class="line">	<span class="keyword">int</span> (*device_alloc_chan_resources)(struct dma_chan *chan);</span><br><span class="line">	<span class="comment">/* 释放通道的接口 */</span></span><br><span class="line">	<span class="keyword">void</span> (*device_free_chan_resources)(struct dma_chan *chan);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* dma通道准备传输的接口 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dma_async_tx_descriptor</span> *(*<span class="title">device_prep_slave_sg</span>)(</span></span><br><span class="line"><span class="class">		<span class="keyword">struct</span> <span class="title">dma_chan</span> *<span class="title">chan</span>, <span class="keyword">struct</span> <span class="title">scatterlist</span> *<span class="title">sgl</span>,</span></span><br><span class="line"><span class="class">		<span class="title">unsigned</span> <span class="title">int</span> <span class="title">sg_len</span>, <span class="title">enum</span> <span class="title">dma_transfer_direction</span> <span class="title">direction</span>,</span></span><br><span class="line"><span class="class">		<span class="title">unsigned</span> <span class="title">long</span> <span class="title">flags</span>, <span class="title">void</span> *<span class="title">context</span>);</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">void</span> (*device_caps)(struct dma_chan *chan,</span><br><span class="line">			    struct dma_slave_caps *caps);</span><br><span class="line">	<span class="comment">/* 对dma通道进行配置的接口 */</span></span><br><span class="line">	<span class="keyword">int</span> (*device_config)(struct dma_chan *chan,</span><br><span class="line">			     struct dma_slave_config *config);</span><br><span class="line">	<span class="comment">/* 暂停传输的接口 */</span></span><br><span class="line">	<span class="keyword">int</span> (*device_pause)(struct dma_chan *chan);</span><br><span class="line">	<span class="comment">/* 恢复传输的接口 */</span></span><br><span class="line">	<span class="keyword">int</span> (*device_resume)(struct dma_chan *chan);</span><br><span class="line">	<span class="comment">/* 终止dma通道传输的接口 */</span></span><br><span class="line">	<span class="keyword">int</span> (*device_terminate_all)(struct dma_chan *chan);</span><br><span class="line">	<span class="comment">/* 获取本次传输状态和已经传输完的长度 */</span></span><br><span class="line">	<span class="function"><span class="keyword">enum</span> <span class="title">dma_status</span> <span class="params">(*device_tx_status)</span><span class="params">(struct dma_chan *chan,</span></span></span><br><span class="line"><span class="params"><span class="function">					    <span class="keyword">dma_cookie_t</span> cookie,</span></span></span><br><span class="line"><span class="params"><span class="function">					    struct dma_tx_state *txstate)</span></span>;</span><br><span class="line">	<span class="comment">/* 启动dma传输的接口 */</span></span><br><span class="line">	<span class="keyword">void</span> (*device_issue_pending)(struct dma_chan *chan);</span><br><span class="line">	<span class="keyword">void</span> (*device_release)(struct dma_device *dev);</span><br><span class="line">	<span class="comment">/* debugfs support */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_FS</span></span><br><span class="line">	<span class="keyword">void</span> (*dbg_summary_show)(struct seq_file *s, struct dma_device *dev);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">dbg_dev_root</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>struct dma_chan</code>用于抽象物理dma channel</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* include/linux/dmaengine.h */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dma_chan</span> &#123;</span></span><br><span class="line">	<span class="comment">/* 指向所在的dma device */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dma_device</span> *<span class="title">device</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">slave</span>;</span></span><br><span class="line">	<span class="keyword">dma_cookie_t</span> cookie;</span><br><span class="line">	<span class="comment">/* 在这个channel上最后一次完成的传输的cookie */</span></span><br><span class="line">	<span class="comment">/* dma controller driver可以调用dma_cookie_complete设置它的value */</span></span><br><span class="line">	<span class="keyword">dma_cookie_t</span> completed_cookie;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* sysfs */</span></span><br><span class="line">	<span class="keyword">int</span> chan_id;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dma_chan_dev</span> *<span class="title">dev</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_FS</span></span><br><span class="line">	<span class="keyword">char</span> *dbg_client_name;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 用于将该channel添加到dma_device的channels列表中 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">device_node</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dma_chan_percpu</span> __<span class="title">percpu</span> *<span class="title">local</span>;</span></span><br><span class="line">	<span class="keyword">int</span> client_count;</span><br><span class="line">	<span class="keyword">int</span> table_count;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* DMA router */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dma_router</span> *<span class="title">router</span>;</span></span><br><span class="line">	<span class="keyword">void</span> *route_data;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">void</span> *<span class="keyword">private</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>struct virt_dma_chan</code>用于抽象一个虚拟的dma_channel，多个虚拟channel可以共用一个物理channel，并由软件调度多个传输请求，将多个虚拟channel的传输串行地在物理channel上完成</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* drivers/dma/virt_dma.h */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* struct virt_dma_desc 对请求描述符做了一个简单的封装 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">virt_dma_desc</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dma_async_tx_descriptor</span> <span class="title">tx</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dmaengine_result</span> <span class="title">tx_result</span>;</span></span><br><span class="line">	<span class="comment">/* protected by vc.lock */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">node</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">virt_dma_chan</span> &#123;</span></span><br><span class="line">	<span class="comment">/* 指向一个物理通道 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dma_chan</span>	<span class="title">chan</span>;</span></span><br><span class="line">	<span class="comment">/* 用于等待该虚拟channel上传输的完成，完成后会调度该task */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> <span class="title">task</span>;</span></span><br><span class="line">	<span class="comment">/* 用于传输完成或终止传输后释放描述符内存 */</span></span><br><span class="line">	<span class="keyword">void</span> (*desc_free)(struct virt_dma_desc *);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">spinlock_t</span> lock;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* protected by vc.lock */</span></span><br><span class="line">	<span class="comment">/* 链表用于保存不同状态下的虚拟channel描述符 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">desc_allocated</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">desc_submitted</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">desc_issued</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">desc_completed</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">desc_terminated</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">virt_dma_desc</span> *<span class="title">cyclic</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>struct dma_slave_config</code>，DMA client对DMA channel的配置结构体</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dma_slave_config</span> &#123;</span></span><br><span class="line">	<span class="comment">/* 传输方向 DMA_MEM_TO_DEV DMA_DEV_TO_MEM */</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">dma_transfer_direction</span> <span class="title">direction</span>;</span></span><br><span class="line">	<span class="comment">/* 设备物理地址，dev_to_mem的时候才起作用，通常是固定的外设fifo地址 */</span></span><br><span class="line">	<span class="keyword">phys_addr_t</span> src_addr;</span><br><span class="line">	<span class="comment">/* 设备物理地址，mem_to_dev的时候才起作用，通常是固定的外设fifo地址 */</span></span><br><span class="line">	<span class="keyword">phys_addr_t</span> dst_addr;</span><br><span class="line">	<span class="comment">/* 读取DMA数据源寄存器的的地址宽度 */</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">dma_slave_buswidth</span> <span class="title">src_addr_width</span>;</span></span><br><span class="line">	<span class="comment">/* 读取DMA目标地址寄存器的的地址宽度 */</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">dma_slave_buswidth</span> <span class="title">dst_addr_width</span>;</span></span><br><span class="line">	u32 src_maxburst;</span><br><span class="line">	u32 dst_maxburst;</span><br><span class="line">	u32 src_port_window_size;</span><br><span class="line">	u32 dst_port_window_size;</span><br><span class="line">	<span class="keyword">bool</span> device_fc;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> slave_id;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>struct dma_async_tx_descriptor</code>，用于描述一次DMA传输，类似一个文件句柄，controller driver返回给client driver一个描述符</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dma_async_tx_descriptor</span> &#123;</span></span><br><span class="line">	<span class="comment">/* 用于追踪本次传输 */</span></span><br><span class="line">	<span class="keyword">dma_cookie_t</span> cookie;</span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">dma_ctrl_flags</span> <span class="title">flags</span>;</span> <span class="comment">/* not a &#x27;long&#x27; to pack with cookie */</span></span><br><span class="line">	<span class="keyword">dma_addr_t</span> phys;</span><br><span class="line">	<span class="comment">/* 对应的dma channel */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dma_chan</span> *<span class="title">chan</span>;</span></span><br><span class="line">	<span class="comment">/* controller driver提供的回调函数，用于把该描述符提交到传输列表，由dmaengine调用 */</span></span><br><span class="line">	<span class="keyword">dma_cookie_t</span> (*tx_submit)(struct dma_async_tx_descriptor *tx);</span><br><span class="line">	<span class="comment">/* 用于释放该描述符的回调函数，dmaengine调用 */</span></span><br><span class="line">	<span class="keyword">int</span> (*desc_free)(struct dma_async_tx_descriptor *tx);</span><br><span class="line">	<span class="comment">/* 传输完成的callback函数，client driver提供 */</span></span><br><span class="line">	dma_async_tx_callback callback;</span><br><span class="line">	dma_async_tx_callback_result callback_result;</span><br><span class="line">	<span class="keyword">void</span> *callback_param;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dmaengine_unmap_data</span> *<span class="title">unmap</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">dma_desc_metadata_mode</span> <span class="title">desc_metadata_mode</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dma_descriptor_metadata_ops</span> *<span class="title">metadata_ops</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_ASYNC_TX_ENABLE_CHANNEL_SWITCH</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dma_async_tx_descriptor</span> *<span class="title">next</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dma_async_tx_descriptor</span> *<span class="title">parent</span>;</span></span><br><span class="line">	<span class="keyword">spinlock_t</span> lock;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="DMA-API使用"><a href="#DMA-API使用" class="headerlink" title="DMA API使用"></a>DMA API使用</h4><h5 id="从CPU角度看到的地址和从DMA控制器看到的地址"><a href="#从CPU角度看到的地址和从DMA控制器看到的地址" class="headerlink" title="从CPU角度看到的地址和从DMA控制器看到的地址"></a>从CPU角度看到的地址和从DMA控制器看到的地址</h5><p>在DMA API中涉及到好几个地址的概念（物理地址、虚拟地址、总线地址）</p>
<p>内核通常使用的地址是虚拟地址，我们调用<code>kmalloc()</code>、<code>vmalloc()</code>或者类似的接口返回的地址都是虚拟地址</p>
<p>虚拟内存系统（TLB 页表等）将虚拟地址翻译成物理地址，物理地址保存在<code>phys_addr_t</code>或<code>resource_size_t</code>的变量中，对于一个硬件设备上的寄存器等设备资源，内核是按照物理地址来管理的，通过<code>/proc/iomem</code>可以看到这些和设备IO相关的物理地址，驱动不能直接使用这些物理地址，必须首先通过<code>ioremap()</code>接口将这些物理地址映射到内核虚拟地址空间上去</p>
<p>I&#x2F;O设备使用第三种地址：总线地址。如果设备在MMIO地址空间中有若干的寄存器，或者该设备可以通过DMA执行读写系统内存的操作，这种情况下，设备使用的地址就是总线地址</p>
<p>各种地址概念关系图<br><img src="https://raw.githubusercontent.com/JackHuang021/images/master/20230512103247.png"></p>
<p>DMA使用的内存地址：在驱动中可以通过<code>kmalloc</code>或者其他类似接口分配一个DMA buffer，并且返回了虚拟地址X，MMU将X地址映射成了物理地址Y，从而定位了DMA buffer在系统内存中的位置，因此驱动可以通过地址X来操作DMA buffer，但是设备并不能通过X地址来访问DMA buffer，因为MMU对设备不可见</p>
<p>驱动在调用<code>dma_map_single()</code>这样的接口函数的时候会传递一个虚拟地址X，在这个函数中会设定IOMMU的页表，将地址X映射到Z，并且将返回Z这个总线地址，驱动可以把Z这个总线地址设定到设备上的DMA相关的寄存器中，这样当设备发起对地址Z开始的DMA操作的时候，IOMMU可以进行地址映射，并将DMA操作定位到Y地址开始的DMA buffer</p>
<h5 id="DMA内存映射"><a href="#DMA内存映射" class="headerlink" title="DMA内存映射"></a>DMA内存映射</h5><p>一致性映射（coherent DMA mappings）是使用专门的接口分配一块DMA缓冲区，这块DMA缓冲区是关闭了cache机制的。也就是数据直接写入内存，这样就不存在一致性问题。</p>
<p>一致性dma映射接口：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">dma_alloc_coherent</span><span class="params">(struct device *dev, <span class="keyword">size_t</span> size,<span class="keyword">dma_addr_t</span> *dma_handle, <span class="keyword">gfp_t</span> flag)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">dma_addr_t</span> dma_handle</span>;</span><br><span class="line">cpu_addr = dma_alloc_coherent(dev, size, &amp;dma_handle, gfp);</span><br></pre></td></tr></table></figure>
<p>dma_alloc_coherent函数返回两个值，一个是从CPU角度访问DMA buffer的虚拟地址，另外一个是从设备（DMA controller）角度看到的bus address：dma_handle，驱动可以将这个bus address传递给DMA控制器。</p>
<h5 id="设备驱动使用dmaengine"><a href="#设备驱动使用dmaengine" class="headerlink" title="设备驱动使用dmaengine"></a>设备驱动使用dmaengine</h5><p>对于设备驱动，要基于dmaengine提供的Slave-DMA API进行DMA传输的话，需要如下的操作步骤</p>
<ol>
<li>申请一个DMA channel</li>
<li>根据设备的特性，配置dma channel的参数</li>
<li>要进行DMA传输的时候，获取一个用于识别本次传输的描述符（descriptor）</li>
<li>将本次传输提交给dma engine并启动传输</li>
<li>等待传输结束</li>
</ol>
<h5 id="传输描述符"><a href="#传输描述符" class="headerlink" title="传输描述符"></a>传输描述符</h5><p>DMA属于异步传输，在启动传输之前，slave driver需要将此次传输的一些信息（src dst的地址，传输的方向）提交给dmaengine，dma controller驱动确认后会返回一个描述符（由<code>struct dma_async_tx_escriptor</code>抽象），slave driver就以该描述符为单位，控制并跟踪此次传输</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @chan: 本次传输所用到的channel</span></span><br><span class="line"><span class="comment"> * @sgl: scatter gather buffers 数组地址</span></span><br><span class="line"><span class="comment"> * @sg_len: scatter gather buffers 数组的长度</span></span><br><span class="line"><span class="comment"> * @direction: 数据传输的方向</span></span><br><span class="line"><span class="comment"> * @flags: 一些额外的标志位</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dma_async_tx_descriptor</span> *(*<span class="title">device_prep_slave_sg</span>)(<span class="keyword">struct</span> <span class="title">dma_chan</span> *<span class="title">chan</span>,</span></span><br><span class="line"><span class="class">			<span class="keyword">struct</span> <span class="title">scatterlist</span> *<span class="title">sgl</span>, <span class="title">unsigned</span> <span class="title">int</span> <span class="title">sg_len</span>,</span></span><br><span class="line"><span class="class">			<span class="title">enum</span> <span class="title">dma_transfer_direction</span> <span class="title">direction</span>,</span></span><br><span class="line"><span class="class">			<span class="title">unsigned</span> <span class="title">long</span> <span class="title">flags</span>, <span class="title">void</span> *<span class="title">context</span>);</span></span><br></pre></td></tr></table></figure>

<h4 id="Phytium-DDMA驱动"><a href="#Phytium-DDMA驱动" class="headerlink" title="Phytium DDMA驱动"></a>Phytium DDMA驱动</h4><h5 id="设备树描述"><a href="#设备树描述" class="headerlink" title="设备树描述"></a>设备树描述</h5><ul>
<li><p>dma controller设备树描述</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ddma0: ddma@<span class="number">28003000</span> &#123;</span><br><span class="line">	compatible = <span class="string">&quot;phytium,ddma&quot;</span>;</span><br><span class="line">	reg = &lt;<span class="number">0x0</span> <span class="number">0x28003000</span> <span class="number">0x0</span> <span class="number">0x1000</span>&gt;;</span><br><span class="line">	interrupts = &lt;GIC_SPI <span class="number">75</span> IRQ_TYPE_LEVEL_HIGH&gt;;</span><br><span class="line">	<span class="meta">#dma-cells = <span class="meta-string">&lt;2&gt;</span>;			<span class="comment">// 用来表示dma client设备树dmas中属性的个数</span></span></span><br><span class="line">	dma-channels = &lt;<span class="number">8</span>&gt;;			<span class="comment">// dma 通道个数</span></span><br><span class="line">	clocks = &lt;&amp;sysclk_50mhz&gt;;</span><br><span class="line">	clock-names = <span class="string">&quot;core_clk&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ddma1: ddma@<span class="number">28004000</span> &#123;</span><br><span class="line">	compatible = <span class="string">&quot;phytium,ddma&quot;</span>;</span><br><span class="line">	reg = &lt;<span class="number">0x0</span> <span class="number">0x28004000</span> <span class="number">0x0</span> <span class="number">0x1000</span>&gt;;</span><br><span class="line">	interrupts = &lt;GIC_SPI <span class="number">76</span> IRQ_TYPE_LEVEL_HIGH&gt;;</span><br><span class="line">	<span class="meta">#dma-cells = <span class="meta-string">&lt;2&gt;</span>;</span></span><br><span class="line">	dma-channels = &lt;<span class="number">8</span>&gt;;</span><br><span class="line">	clocks = &lt;&amp;sysclk_50mhz&gt;;</span><br><span class="line">	clock-names = <span class="string">&quot;core_clk&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>dma client设备树描述</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">spi2: spi@2803c000 &#123;</span><br><span class="line">	compatible = <span class="string">&quot;phytium,spi&quot;</span>;</span><br><span class="line">	reg = &lt;0x0 0x2803c000 0x0 0x1000&gt;;</span><br><span class="line">	interrupts = &lt;GIC_SPI 161 IRQ_TYPE_LEVEL_HIGH&gt;;</span><br><span class="line">	clocks = &lt;&amp;sysclk_48mhz&gt;;</span><br><span class="line">	num-cs = &lt;4&gt;;</span><br><span class="line">	<span class="comment">#address-cells = &lt;1&gt;;</span></span><br><span class="line">	<span class="comment">#size-cells = &lt;0&gt;;</span></span><br><span class="line">	dmas = &lt;&amp;ddma0 0 8&gt;,</span><br><span class="line">			&lt;&amp;ddma0 1 21&gt;;</span><br><span class="line">	dma-names = <span class="string">&quot;tx&quot;</span>, <span class="string">&quot;rx&quot;</span>;</span><br><span class="line">	status = <span class="string">&quot;disabled&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="ddma驱动相关结构体"><a href="#ddma驱动相关结构体" class="headerlink" title="ddma驱动相关结构体"></a>ddma驱动相关结构体</h5><p><code>struct phytium_ddma_device</code>用于描述ddma控制器</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct phytium_ddma_device - the struct holding info describing DDMA device</span></span><br><span class="line"><span class="comment"> * @dma_dev: an instance for struct dma_device</span></span><br><span class="line"><span class="comment"> * @irq: the irq that DDMA using</span></span><br><span class="line"><span class="comment"> * @base: the mapped register I/O base of this DDMA</span></span><br><span class="line"><span class="comment"> * @core_clk: DDMA clock</span></span><br><span class="line"><span class="comment"> * @dma_channels: the number of DDMA physical channels</span></span><br><span class="line"><span class="comment"> * @chan: the phyical channels of DDMA</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">phytium_ddma_device</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dma_device</span> <span class="title">dma_dev</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span></span><br><span class="line">	<span class="keyword">int</span>	irq;</span><br><span class="line">	<span class="keyword">void</span> __iomem *base;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">clk</span> *<span class="title">core_clk</span>;</span></span><br><span class="line">	u32 dma_channels;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">phytium_ddma_chan</span> *<span class="title">chan</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>phytium_ddma_chan</code>用于描述一个ddma 物理通道</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct phytium_ddma_chan - the struct holding info describing dma channel</span></span><br><span class="line"><span class="comment"> * @vchan: virtual dma channel</span></span><br><span class="line"><span class="comment"> * @base: the mapped register I/O of dma physical channel</span></span><br><span class="line"><span class="comment"> * @id: the id of ddma physical channel</span></span><br><span class="line"><span class="comment"> * @desc: the transform request descriptor</span></span><br><span class="line"><span class="comment"> * @dma_config: config parameters for dma channel</span></span><br><span class="line"><span class="comment"> * @busy: the channel busy flag, this flag set when channel is tansferring</span></span><br><span class="line"><span class="comment"> * @is_used: the channel bind flag, this flag set when channel binded</span></span><br><span class="line"><span class="comment"> * @next_sg: the index of next scatter-gatter</span></span><br><span class="line"><span class="comment"> * @paddr: used to align data between dma provider and consumer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">phytium_ddma_chan</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">virt_dma_chan</span> <span class="title">vchan</span>;</span></span><br><span class="line">	<span class="keyword">void</span> __iomem *base;</span><br><span class="line">	u32 id;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">phytium_ddma_desc</span> *<span class="title">desc</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dma_slave_config</span> <span class="title">dma_config</span>;</span></span><br><span class="line">	<span class="keyword">bool</span> busy;</span><br><span class="line">	<span class="keyword">bool</span> is_used;</span><br><span class="line">	u32 next_sg;</span><br><span class="line">	<span class="keyword">dma_addr_t</span> paddr;</span><br><span class="line">	<span class="keyword">char</span> *buf;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>struct phytium_ddma_desc</code>dma传输时使用的描述符，里面记录了本次传输的数据</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct phytium_ddma_desc - the struct holding info describing ddma request</span></span><br><span class="line"><span class="comment"> * descriptor</span></span><br><span class="line"><span class="comment"> * @vdesc: ddma request descriptor</span></span><br><span class="line"><span class="comment"> * @num_sgs: the size of scatter-gather list</span></span><br><span class="line"><span class="comment"> * @sg_req: use to save scatter-gather list info</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">phytium_ddma_desc</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">virt_dma_desc</span> <span class="title">vdesc</span>;</span></span><br><span class="line">	u32 num_sgs;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">phytium_ddma_sg_req</span> <span class="title">sg_req</span>[];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>struct phytium_ddma_sg_req</code>用于记录当前传输的scatter-gather信息，源数据地址、设备数据寄存器地址、传输长度等</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct phytium_ddma_sg_req - scatter-gatter list data info</span></span><br><span class="line"><span class="comment"> * @len: number of bytes to transform</span></span><br><span class="line"><span class="comment"> * @mem_addr_l: bus address low 32bit</span></span><br><span class="line"><span class="comment"> * @mem_addr_h: bus address high 32bit</span></span><br><span class="line"><span class="comment"> * @dev_addr: dma cousumer data reg addr</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">phytium_ddma_sg_req</span> &#123;</span></span><br><span class="line">	u32 len;</span><br><span class="line">	u32 mem_addr_l;</span><br><span class="line">	u32 mem_addr_h;</span><br><span class="line">	u32 dev_addr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="pl011-DMA-device驱动"><a href="#pl011-DMA-device驱动" class="headerlink" title="pl011 DMA device驱动"></a>pl011 DMA device驱动</h4><h5 id="pl011-uart-rx逻辑"><a href="#pl011-uart-rx逻辑" class="headerlink" title="pl011 uart rx逻辑"></a>pl011 uart rx逻辑</h5><p>pl011 串口RX逻辑主要借助pl011的串口接收超时中断来进行数据接收，如pl011的手册描述，当rx fifo中不为空且连续32个bit的时间内没收到任何数据则产生接收超时中断，在超时中断中先对dma rx通道进行暂停，并检查dma实际传输了多少长度的数据，将实际传输的数据存入tty缓冲区，再把fifo中剩下的数据读出来，也存入tty缓冲区，这样完成了一次接收，具体代码位于<code>pl011_dma_rx_irq()</code><br><img src="https://raw.githubusercontent.com/JackHuang021/images/master/20230615143556.png"></p>
<h5 id="pl011-uart-tx逻辑"><a href="#pl011-uart-tx逻辑" class="headerlink" title="pl011 uart tx逻辑"></a>pl011 uart tx逻辑</h5><p>当串口发送中断触发时（发送fifo中的数据低于设定的触发值）就会进入发送逻辑，dma模式下uart有数据需要发送时会调用<code>pl011_dma_tx_irq()</code>走dma的一套数据发送流程进行发送，位于<code>pl011_dma_tx_refill()</code>中</p>
<h4 id="SPI功能测试"><a href="#SPI功能测试" class="headerlink" title="SPI功能测试"></a>SPI功能测试</h4><p>使用spidev-test进行spi硬件回环测试</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@Ubuntu:~<span class="comment"># spidev_test -D /dev/spidev0.0 -v</span></span><br><span class="line">spi mode: 0x0</span><br><span class="line">bits per word: 8</span><br><span class="line">max speed: 500000 Hz (500 kHz)</span><br><span class="line">TX | FF FF FF FF FF FF 40 00 00 00 00 95 FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF F0 0D  |......@.........................|</span><br><span class="line">RX | FF FF FF FF FF FF 40 00 00 00 00 95 FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF F0 0D  |......@.........................|</span><br></pre></td></tr></table></figure>

<h5 id="spidev-test测试"><a href="#spidev-test测试" class="headerlink" title="spidev_test测试"></a>spidev_test测试</h5><p>测试命令：<code>spidev_test -s &lt;speed&gt; -D /dev/spidev0.0 -S &lt;length&gt; -I &lt;iterations&gt;</code></p>
<ul>
<li><p>E2000D demo板测试数据</p>
<table>
<thead>
<tr>
<th align="center">单次传输字节长度</th>
<th align="center">DMA传输速度</th>
<th align="center">中断传输速度</th>
</tr>
</thead>
<tbody><tr>
<td align="center">64KB</td>
<td align="center">15.8Mbps</td>
<td align="center">10.6Mbps</td>
</tr>
<tr>
<td align="center">1KB</td>
<td align="center">15.2Mbps</td>
<td align="center">12Mbps</td>
</tr>
<tr>
<td align="center">512B</td>
<td align="center">14.4Mbps</td>
<td align="center">11.8Mbps</td>
</tr>
<tr>
<td align="center">128B</td>
<td align="center">11.1Mbps</td>
<td align="center">10.8Mbps</td>
</tr>
<tr>
<td align="center">8B</td>
<td align="center">3.1Mbps</td>
<td align="center">3.5Mbps</td>
</tr>
</tbody></table>
</li>
<li><p>树莓派4测试数据</p>
<table>
<thead>
<tr>
<th align="center">测试用例</th>
<th align="center">DMA传输速度</th>
<th align="center">中断传输速度</th>
</tr>
</thead>
<tbody><tr>
<td align="center">25MHz 单次64KB</td>
<td align="center">24.6Mbps</td>
<td align="center">22.6Mbps</td>
</tr>
<tr>
<td align="center">250MHz 单次64KB</td>
<td align="center">90.2Mbps</td>
<td align="center">29.1Mbps</td>
</tr>
</tbody></table>
</li>
</ul>
<h5 id="外接flash-mtd-speedtest速度测试"><a href="#外接flash-mtd-speedtest速度测试" class="headerlink" title="外接flash mtd_speedtest速度测试"></a>外接flash mtd_speedtest速度测试</h5><ul>
<li>spi中断传输模式<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@Ubuntu:~<span class="comment"># echo 7 &gt; /proc/sys/kernel/printk</span></span><br><span class="line">root@Ubuntu:~<span class="comment"># modprobe mtd_speedtest dev=0 count=100</span></span><br><span class="line">[ 1393.267903] </span><br><span class="line">[ 1393.269405] =================================================</span><br><span class="line">[ 1393.275203] mtd_speedtest: MTD device: 0    count: 100</span><br><span class="line">[ 1393.280379] mtd_speedtest: not NAND flash, assume page size is 512 bytes.</span><br><span class="line">[ 1393.287182] mtd_speedtest: MTD device size 16777216, eraseblock size 4096, page size 512, count of er0</span><br><span class="line">[ 1406.236226] mtd_speedtest: testing eraseblock write speed</span><br><span class="line">[ 1407.918432] mtd_speedtest: eraseblock write speed is 238 KiB/s</span><br><span class="line">[ 1407.924276] mtd_speedtest: testing eraseblock <span class="built_in">read</span> speed</span><br><span class="line">[ 1408.224498] mtd_speedtest: eraseblock <span class="built_in">read</span> speed is 1360 KiB/s</span><br><span class="line">[ 1420.949754] mtd_speedtest: testing page write speed</span><br><span class="line">[ 1422.628841] mtd_speedtest: page write speed is 238 KiB/s</span><br><span class="line">[ 1422.634163] mtd_speedtest: testing page <span class="built_in">read</span> speed</span><br><span class="line">[ 1422.955827] mtd_speedtest: page <span class="built_in">read</span> speed is 1265 KiB/s</span><br><span class="line">[ 1435.536738] mtd_speedtest: testing 2 page write speed</span><br><span class="line">[ 1437.265931] mtd_speedtest: 2 page write speed is 232 KiB/s</span><br><span class="line">[ 1437.271429] mtd_speedtest: testing 2 page <span class="built_in">read</span> speed</span><br><span class="line">[ 1437.585886] mtd_speedtest: 2 page <span class="built_in">read</span> speed is 1294 KiB/s</span><br><span class="line">[ 1437.591385] mtd_speedtest: Testing erase speed</span><br><span class="line">[ 1450.136398] mtd_speedtest: erase speed is 31 KiB/s</span><br><span class="line">[ 1450.141203] mtd_speedtest: Testing 2x multi-block erase speed</span><br><span class="line">[ 1462.805642] mtd_speedtest: 2x multi-block erase speed is 31 KiB/s</span><br><span class="line">[ 1462.811747] mtd_speedtest: Testing 4x multi-block erase speed</span><br><span class="line">[ 1475.535328] mtd_speedtest: 4x multi-block erase speed is 31 KiB/s</span><br><span class="line">[ 1475.541432] mtd_speedtest: Testing 8x multi-block erase speed</span><br><span class="line">[ 1488.202989] mtd_speedtest: 8x multi-block erase speed is 31 KiB/s</span><br><span class="line">[ 1488.209098] mtd_speedtest: Testing 16x multi-block erase speed</span><br><span class="line">[ 1500.921395] mtd_speedtest: 16x multi-block erase speed is 31 KiB/s</span><br><span class="line">[ 1500.927592] mtd_speedtest: Testing 32x multi-block erase speed</span><br><span class="line">[ 1513.647523] mtd_speedtest: 32x multi-block erase speed is 31 KiB/s</span><br><span class="line">[ 1513.653714] mtd_speedtest: Testing 64x multi-block erase speed</span><br><span class="line">[ 1526.322498] mtd_speedtest: 64x multi-block erase speed is 31 KiB/s</span><br><span class="line">[ 1526.328691] mtd_speedtest: finished</span><br><span class="line">[ 1526.332216] =================================================</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="外接flash-dd读写测试"><a href="#外接flash-dd读写测试" class="headerlink" title="外接flash dd读写测试"></a>外接flash dd读写测试</h5><ul>
<li>spi中断传输模式<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 写入测试</span></span><br><span class="line"><span class="attribute">root</span>@Ubuntu:~# time dd if=/dev/zero of=/dev/mtd<span class="number">0</span> bs=<span class="number">1024</span>k count=<span class="number">10</span></span><br><span class="line"><span class="attribute">10</span>+<span class="number">0</span> records in</span><br><span class="line"><span class="attribute">10</span>+<span class="number">0</span> records out</span><br><span class="line"><span class="attribute">10485760</span> bytes (<span class="number">10</span> MB, <span class="number">10</span> MiB) copied, <span class="number">43</span>.<span class="number">2331</span> s, <span class="number">243</span> kB/s</span><br><span class="line"></span><br><span class="line"><span class="attribute">real</span>    <span class="number">0</span>m<span class="number">43</span>.<span class="number">247</span>s</span><br><span class="line"><span class="attribute">user</span>    <span class="number">0</span>m<span class="number">0</span>.<span class="number">001</span>s</span><br><span class="line"><span class="attribute">sys</span>     <span class="number">0</span>m<span class="number">22</span>.<span class="number">231</span>s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读测试</span></span><br><span class="line"><span class="attribute">root</span>@Ubuntu:~# time dd if=/dev/mtd<span class="number">0</span> of=/dev/null bs=<span class="number">1024</span>k count=<span class="number">10</span></span><br><span class="line"><span class="attribute">10</span>+<span class="number">0</span> records in</span><br><span class="line"><span class="attribute">10</span>+<span class="number">0</span> records out</span><br><span class="line"><span class="attribute">10485760</span> bytes (<span class="number">10</span> MB, <span class="number">10</span> MiB) copied, <span class="number">8</span>.<span class="number">76685</span> s, <span class="number">1</span>.<span class="number">2</span> MB/s</span><br><span class="line"></span><br><span class="line"><span class="attribute">real</span>    <span class="number">0</span>m<span class="number">8</span>.<span class="number">773</span>s</span><br><span class="line"><span class="attribute">user</span>    <span class="number">0</span>m<span class="number">0</span>.<span class="number">004</span>s</span><br><span class="line"><span class="attribute">sys</span>     <span class="number">0</span>m<span class="number">0</span>.<span class="number">011</span>s</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="串口功能测试"><a href="#串口功能测试" class="headerlink" title="串口功能测试"></a>串口功能测试</h4><p>测试工具： </p>
<ul>
<li><a href="https://github.com/carloscn/tinyserial.git">tinyserial v1.4</a></li>
<li><a href="https://github.com/cbrake/linux-serial-test.git">linux-serial-test</a></li>
</ul>
<p>4Mbps波特率回环测试，tx和rx数据能对齐<br><img src="https://raw.githubusercontent.com/JackHuang021/images/master/%E4%B8%B2%E5%8F%A3DMA%204Mbps%E4%BC%A0%E8%BE%93.png"></p>
<p>4Mbps发送单个字节（0x55）波形<br><img src="https://raw.githubusercontent.com/JackHuang021/images/master/002.BMP"></p>
<h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><blockquote>
<p><a href="http://www.wowotech.net/tag/dma">http://www.wowotech.net/tag/dma</a><br><a href="https://www.jianshu.com/p/e1b622234d13">https://www.jianshu.com/p/e1b622234d13</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>DMA</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux Cpufreq框架</title>
    <url>/archives/fbf46cf3.html</url>
    <content><![CDATA[<h3 id="cpufreq动态调频"><a href="#cpufreq动态调频" class="headerlink" title="cpufreq动态调频"></a>cpufreq动态调频</h3><h4 id="cpufreq概述"><a href="#cpufreq概述" class="headerlink" title="cpufreq概述"></a>cpufreq概述</h4><p>Linux Kernel主要通过三类机制来实现SMP（Symmetric Multiprocessing，对称多核）系统CPU core的电源管理：</p>
<ul>
<li>cpu hotplug: 根据应用场景来up&#x2F;down CPU</li>
<li>cpuidle framework: 当cpu上没有可执行任务时，就会进入空闲状态</li>
<li>cpufreq framework: 根据使用场景和系统负荷来调整CPU的电压和频率</li>
</ul>
<span id="more"></span>
<p>cpufreq framework的核心功能，是通过调整CPU core的电压或频率，兼顾系统的性能和功耗。在不需要高性能时，降低电压或频率，以降低功耗；在需要高性能时，提高电压或频率，以提高性能。</p>
<p>cpufreq framework中的几个重要概念：</p>
<ol>
<li>policy（策略）：同一个簇的CPU动态调频的一个集合结构体，包含了当前使用的governor和cpufreq driver</li>
<li>governor（调节器）：决定如何计算合适的频率或电压</li>
<li>cpufreq driver：来实现真正的调频执行工作（与平台相关）</li>
</ol>
<p>除此之外，cpufreq还包含cpufreq stats, cpufreq qos, cpufreq notifier等辅助模块，其主要功能如下：</p>
<ol>
<li>cpufreq stats：用于搜集cpufreq的一些统计数据，如CPU在每个频点下的运行时间，总的频率切换次数等</li>
<li>cpufreq qos：用于cpufreq频率限制值发生改变时，向cpufreq模块发送一个通知，将频率限制值调整到新的值</li>
<li>cpufreq notifer：对CPU频率切换或policy对应governor发生改变感兴趣的模块，可以向cpufreq注册一个通知，当以上事件发生时，cpufreq将会向其发送相关通知</li>
</ol>
<p>常用的governor类型</p>
<ol>
<li>Performance：总是将CPU置于最高性能的状态，即硬件所支持的最高频率、电压</li>
<li>Powersaving：总是将CPU置于最节能的状态，即硬件所支持的最低频率、电压</li>
<li>Ondemand：设置CPU负载的阈值T，当负载低于T时，调节至一个刚好能够满足当前负载需求的最低频&#x2F;最低压；当负载高于T时，立即提升到最高性能状态</li>
<li>Conservative：跟Ondemand策略类似，设置CPU负载的阈值T，当负载低于T时，调节至一个刚好能够满足当前负载需求的最低频&#x2F;最低压；但当负载高于T时，不是立即设置为最高性能状态，而是逐级升高主频&#x2F;电压</li>
<li>Userspace：将控制接口通过sysfs开放给用户，由用户进行自定义策略</li>
<li>Schedutil：这是从Linux-4.7版本开始才引入的策略，其原理是根据调度器所提供的CPU利用率信息进行电压&#x2F;频率调节，EAS使用schedutil进行调频</li>
</ol>
<p>sysfs用户层接口，目录位于<code>/sys/devices/system/cpu/cpufreq/policy</code><br><img src="https://raw.githubusercontent.com/JackHuang021/images/master/20221124110212.png"></p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">cpuinfo_max_freq</td>
<td align="left">硬件所支持的最高频率</td>
</tr>
<tr>
<td align="left">cpuinfo_min_freq</td>
<td align="left">硬件所支持的最低频率</td>
</tr>
<tr>
<td align="left">affected_cpus</td>
<td align="left">该policy影响到哪些cpu（没显示offline状态的cpu）</td>
</tr>
<tr>
<td align="left">related_cpus</td>
<td align="left">该policy影响到的所有cpu，包括offline状态的cpu</td>
</tr>
<tr>
<td align="left">scaling_max_freq</td>
<td align="left">该policy支持调整的最高频率</td>
</tr>
<tr>
<td align="left">scaling_min_freq</td>
<td align="left">该policy支持调整的最低频率</td>
</tr>
<tr>
<td align="left">scaling_cur_freq</td>
<td align="left">policy当前设置的频率</td>
</tr>
<tr>
<td align="left">scaling_available_governors</td>
<td align="left">当前系统支持的governor</td>
</tr>
<tr>
<td align="left">scaling_available_frequencies</td>
<td align="left">支持的调频频率</td>
</tr>
<tr>
<td align="left">scaling_driver</td>
<td align="left">当前使用的调频驱动</td>
</tr>
<tr>
<td align="left">scaling_governor</td>
<td align="left">当前使用的governor</td>
</tr>
<tr>
<td align="left">scaling_setspeed</td>
<td align="left">在userspace模式下才能使用，手动设置频率</td>
</tr>
</tbody></table>
<h4 id="cpufreq软件架构"><a href="#cpufreq软件架构" class="headerlink" title="cpufreq软件架构"></a>cpufreq软件架构</h4><p><img src="https://raw.githubusercontent.com/JackHuang021/images/master/20230103092146.png"><br>cpufreq core（可以理解为对policy的操作）：把一些公共的逻辑和接口代码抽象出来</p>
<ul>
<li><code>cpufreq</code>作为所有cpu设备的一个功能，注册到了<code>cpu_subsys</code>总线上</li>
<li>对上以sysfs的形式向用户空间提供统一的接口，以notifier的形式向其他driver提供频率变化的通知</li>
<li>对下提供CPU频率和电压控制的驱动框架，方便底层driver的开发，同时提供governor框架，用于实现不同的频率调整机制</li>
<li>内部封装各种逻辑，主要围绕<code>struct cpufreq_policy</code> <code>struct cpufreq_driver</code> <code>struct cpufreq_governor</code>三个数据结构进行</li>
</ul>
<p>kernel使用<code>struct cpufreq_policy</code>用来抽象cpufreq，它代表了一个CPU簇的cpufreq的属性</p>
<p><code>cpufreq_policy</code>结构体</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cpufreq_cpuinfo</span> &#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		max_freq;			<span class="comment">// cpu最大频率</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		min_freq;			<span class="comment">// cpu最小频率</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* in 10^(-9) s = nanoseconds */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		transition_latency;	<span class="comment">// cpu频率转换时间 单位：ns</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cpufreq_policy</span> &#123;</span></span><br><span class="line">	<span class="comment">/* CPUs sharing clock, require sw coordination */</span></span><br><span class="line">	<span class="keyword">cpumask_var_t</span>		cpus;	<span class="comment">/* Online CPUs only */</span></span><br><span class="line">	<span class="keyword">cpumask_var_t</span>		related_cpus; <span class="comment">/* Online + Offline CPUs */</span></span><br><span class="line">	<span class="keyword">cpumask_var_t</span>		real_cpus; <span class="comment">/* Related and present */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		shared_type; <span class="comment">/* ACPI: ANY or ALL affected CPUs</span></span><br><span class="line"><span class="comment">						should set cpufreq */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		cpu;    <span class="comment">/* cpu managing this policy, must be online */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">clk</span>		*<span class="title">clk</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cpufreq_cpuinfo</span>	<span class="title">cpuinfo</span>;</span><span class="comment">/* see above */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		min;    <span class="comment">/* in kHz */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		max;    <span class="comment">/* in kHz */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		cur;    <span class="comment">/* in kHz, only needed if cpufreq</span></span><br><span class="line"><span class="comment">					 * governors are used */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cpufreq_governor</span>	*<span class="title">governor</span>;</span> <span class="comment">/* see below */</span></span><br><span class="line">	<span class="keyword">void</span>			*governor_data;</span><br><span class="line">	<span class="keyword">char</span>			last_governor[CPUFREQ_NAME_LEN]; <span class="comment">/* last governor used */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span>	<span class="title">update</span>;</span> <span class="comment">/* if update_policy() needs to be</span></span><br><span class="line"><span class="comment">					 * called, but you&#x27;re in IRQ context */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cpufreq_user_policy</span> <span class="title">user_policy</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cpufreq_frequency_table</span>	*<span class="title">freq_table</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">cpufreq_table_sorting</span> <span class="title">freq_table_sorted</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>        <span class="title">policy_list</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kobject</span>		<span class="title">kobj</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">completion</span>	<span class="title">kobj_unregister</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Preferred average time interval between consecutive invocations of</span></span><br><span class="line"><span class="comment">	 * the driver to set the frequency for this policy.  To be set by the</span></span><br><span class="line"><span class="comment">	 * scaling driver (0, which is the default, means no preference).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		transition_delay_us;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Remote DVFS flag (Not added to the driver structure as we don&#x27;t want</span></span><br><span class="line"><span class="comment">	 * to access another structure from scheduler hotpath).</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Should be set if CPUs can do DVFS on behalf of other CPUs from</span></span><br><span class="line"><span class="comment">	 * different cpufreq policies.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">bool</span>			dvfs_possible_from_any_cpu;</span><br><span class="line"></span><br><span class="line">	 <span class="comment">/* Cached frequency lookup from cpufreq_driver_resolve_freq. */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> cached_target_freq;</span><br><span class="line">	<span class="keyword">int</span> cached_resolved_idx;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* cpufreq-stats */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cpufreq_stats</span>	*<span class="title">stats</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* For cpufreq driver&#x27;s internal use */</span></span><br><span class="line">	<span class="keyword">void</span>			*driver_data;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>driver/cpufreq/cpufreq.c</code>中定义了一个全局的percpu变量</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">DEFINE_PER_CPU</span><span class="params">(struct cpufreq_policy *, cpufreq_cpu_data)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这里对应E2000 sysfs中3个policy文件夹，两个小核在一个簇中，使用1个policy，另外两个大核分别对应1个policy<br><img src="https://raw.githubusercontent.com/JackHuang021/images/master/20230103094857.png"></p>
<blockquote>
<p>per-CPU变量是linux系统一个非常重要的特性，它为系统中的每个处理器都分配了该变量的副本。这样做的好处是，在多处理器系统中，当处理器操作属于它的变量副本时，不需要考虑与其他处理器的竞争的问题，同时该副本还可以充分利用处理器本地的硬件缓冲cache来提供访问速度</p>
</blockquote>
<h4 id="cpufreq初始化"><a href="#cpufreq初始化" class="headerlink" title="cpufreq初始化"></a>cpufreq初始化</h4><h5 id="内核配置"><a href="#内核配置" class="headerlink" title="内核配置"></a>内核配置</h5><p>在kconfig中(CPU Power Management -&gt; CPU Frequency scaling)可以对cpufreq进行配置，可以配置支持的governor及系统默认的governor，以及cpufreq调频driver，例如Phytium E2000 5.10内核的配置如下，默认使用schedutil governor，根据调度器所提供的CPU利用率信息进行电压&#x2F;频率调节，EAS能源感知依赖该governor工作：<br><img src="https://raw.githubusercontent.com/JackHuang021/images/master/20230105110139.png"></p>
<h5 id="OPP表初始化"><a href="#OPP表初始化" class="headerlink" title="OPP表初始化"></a>OPP表初始化</h5><p>OPP表的定义：域中每个设备支持的电压和频率的离散元组的集合称为Operating Performance Points（OPP）,内核设备树opp文档<code>Documentation/devicetree/bindings/opp/opp.txt</code>  </p>
<p>假设一个CPU设备支持如下的电压和频率关系：<br>{300MHz at minimum voltage of 1V}<br>{800MHz at minimum voltage of 1.2V}<br>{1GHz at minimum voltage of 1.3V}<br>用OPP表示就可以用{Hz,  uV}方式表示如下:<br>{300000000, 1000000}<br>{800000000, 1200000}<br>{1000000000, 1300000}</p>
<p>Linux内核使用opp layer库来管理opp table，具体的结构如下：</p>
<p>Linux内核使用<code>struct dev_pm_opp</code>结构表示设备的一OPP</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// drivers/opp/opp.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dev_pm_opp</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">node</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kref</span> <span class="title">kref</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">bool</span> available;</span><br><span class="line">	<span class="keyword">bool</span> dynamic;</span><br><span class="line">	<span class="keyword">bool</span> turbo;</span><br><span class="line">	<span class="keyword">bool</span> suspend;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> pstate;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> rate;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> level;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dev_pm_opp_supply</span> *<span class="title">supplies</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dev_pm_opp_icc_bw</span> *<span class="title">bandwidth</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> clock_latency_ns;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dev_pm_opp</span> **<span class="title">required_opps</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">opp_table</span> *<span class="title">opp_table</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">np</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_FS</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">dentry</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Linux内核opp layer库的结构如下<br><img src="https://raw.githubusercontent.com/JackHuang021/images/master/20230307162438.png"></p>
<p>这里初始化的就是各个性能域（即不同cluster）的OPP表，在E2000平台中是通过SCMI的Performace domain management protocol协议获取PERFORMANCE_DESCRIBE_LEVELS这个参数表，具体的协议实现源码在<code>drivers/firmware/arm_scmi/perf.c</code>里面，<code>perf.c</code>实现了SCMI的Performance domain managment protocol，scmi cpufreq_drvier也是通过<code>perf_ops</code>函数集进行调频</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/linux/scmi_protocol.h</span></span><br><span class="line"><span class="comment">// 抽象描述scmi协议的结构体，相应的ops操作集对应scmi的一个协议</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">scmi_handle</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">scmi_revision_info</span> *<span class="title">version</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">scmi_perf_ops</span> *<span class="title">perf_ops</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">scmi_clk_ops</span> *<span class="title">clk_ops</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">scmi_power_ops</span> *<span class="title">power_ops</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">scmi_sensor_ops</span> *<span class="title">sensor_ops</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">scmi_reset_ops</span> *<span class="title">reset_ops</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">scmi_notify_ops</span> *<span class="title">notify_ops</span>;</span></span><br><span class="line">	<span class="comment">/* for protocol internal use */</span></span><br><span class="line">	<span class="comment">// perf_priv存放括performance domain数据，包含opp表等</span></span><br><span class="line">	<span class="keyword">void</span> *perf_priv;</span><br><span class="line">	<span class="keyword">void</span> *clk_priv;</span><br><span class="line">	<span class="keyword">void</span> *power_priv;</span><br><span class="line">	<span class="keyword">void</span> *sensor_priv;</span><br><span class="line">	<span class="keyword">void</span> *reset_priv;</span><br><span class="line">	<span class="keyword">void</span> *notify_priv;</span><br><span class="line">	<span class="keyword">void</span> *system_priv;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// include/linux/scmi_protocol.h</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct scmi_perf_ops - represents the various operations provided</span></span><br><span class="line"><span class="comment"> *	by SCMI Performance Protocol</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @limits_set: sets limits on the performance level of a domain</span></span><br><span class="line"><span class="comment"> * @limits_get: gets limits on the performance level of a domain</span></span><br><span class="line"><span class="comment"> * @level_set: sets the performance level of a domain</span></span><br><span class="line"><span class="comment"> * @level_get: gets the performance level of a domain</span></span><br><span class="line"><span class="comment"> * @device_domain_id: gets the scmi domain id for a given device</span></span><br><span class="line"><span class="comment"> * @transition_latency_get: gets the DVFS transition latency for a given device</span></span><br><span class="line"><span class="comment"> * @device_opps_add: adds all the OPPs for a given device</span></span><br><span class="line"><span class="comment"> * @freq_set: sets the frequency for a given device using sustained frequency</span></span><br><span class="line"><span class="comment"> *	to sustained performance level mapping</span></span><br><span class="line"><span class="comment"> * @freq_get: gets the frequency for a given device using sustained frequency</span></span><br><span class="line"><span class="comment"> *	to sustained performance level mapping</span></span><br><span class="line"><span class="comment"> * @est_power_get: gets the estimated power cost for a given performance domain</span></span><br><span class="line"><span class="comment"> *	at a given frequency</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">scmi_perf_ops</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> (*limits_set)(<span class="keyword">const</span> struct scmi_handle *handle, u32 domain,</span><br><span class="line">			  u32 max_perf, u32 min_perf);</span><br><span class="line">	<span class="keyword">int</span> (*limits_get)(<span class="keyword">const</span> struct scmi_handle *handle, u32 domain,</span><br><span class="line">			  u32 *max_perf, u32 *min_perf);</span><br><span class="line">	<span class="keyword">int</span> (*level_set)(<span class="keyword">const</span> struct scmi_handle *handle, u32 domain,</span><br><span class="line">			 u32 level, <span class="keyword">bool</span> poll);</span><br><span class="line">	<span class="keyword">int</span> (*level_get)(<span class="keyword">const</span> struct scmi_handle *handle, u32 domain,</span><br><span class="line">			 u32 *level, <span class="keyword">bool</span> poll);</span><br><span class="line">	<span class="keyword">int</span> (*device_domain_id)(struct device *dev);</span><br><span class="line">	<span class="keyword">int</span> (*transition_latency_get)(<span class="keyword">const</span> struct scmi_handle *handle,</span><br><span class="line">				      struct device *dev);</span><br><span class="line">	<span class="keyword">int</span> (*device_opps_add)(<span class="keyword">const</span> struct scmi_handle *handle,</span><br><span class="line">			       struct device *dev);</span><br><span class="line">	<span class="keyword">int</span> (*freq_set)(<span class="keyword">const</span> struct scmi_handle *handle, u32 domain,</span><br><span class="line">			<span class="keyword">unsigned</span> <span class="keyword">long</span> rate, <span class="keyword">bool</span> poll);</span><br><span class="line">	<span class="keyword">int</span> (*freq_get)(<span class="keyword">const</span> struct scmi_handle *handle, u32 domain,</span><br><span class="line">			<span class="keyword">unsigned</span> <span class="keyword">long</span> *rate, <span class="keyword">bool</span> poll);</span><br><span class="line">	<span class="keyword">int</span> (*est_power_get)(<span class="keyword">const</span> struct scmi_handle *handle, u32 domain,</span><br><span class="line">			     <span class="keyword">unsigned</span> <span class="keyword">long</span> *rate, <span class="keyword">unsigned</span> <span class="keyword">long</span> *power);</span><br><span class="line">	<span class="keyword">bool</span> (*fast_switch_possible)(<span class="keyword">const</span> struct scmi_handle *handle,</span><br><span class="line">				     struct device *dev);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// scmi performance domain management protocol(性能域管理相关协议 0x13), messageid: 0x03</span></span><br><span class="line"><span class="comment">// scmi opp结构体定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">scmi_opp</span> &#123;</span></span><br><span class="line">	u32 perf;		<span class="comment">// 性能级别，单位KHz</span></span><br><span class="line">	u32 power;		<span class="comment">// 当前性能级别的功耗</span></span><br><span class="line">	u32 trans_latency_us;	<span class="comment">// 切换延时</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// drivers/firmware/arm_scmi/perf.c</span></span><br><span class="line"><span class="comment">// scmi performance domain management protocol(性能域管理相关协议 0x13)对应操作函数集</span></span><br><span class="line"><span class="comment">// scmi cpufreq_driver 主要利用这个函数集进行调频相关操作</span></span><br><span class="line"><span class="comment">// 对应Performace domain management protocol各个message_id</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">scmi_perf_ops</span> <span class="title">perf_ops</span> =</span> &#123;</span><br><span class="line">	.limits_set = scmi_perf_limits_set,</span><br><span class="line">	.limits_get = scmi_perf_limits_get,</span><br><span class="line">	.level_set = scmi_perf_level_set,</span><br><span class="line">	.level_get = scmi_perf_level_get,</span><br><span class="line">	.device_domain_id = scmi_dev_domain_id,</span><br><span class="line">	.transition_latency_get = scmi_dvfs_transition_latency_get,</span><br><span class="line">	.device_opps_add = scmi_dvfs_device_opps_add,</span><br><span class="line">	.freq_set = scmi_dvfs_freq_set,</span><br><span class="line">	.freq_get = scmi_dvfs_freq_get,</span><br><span class="line">	.est_power_get = scmi_dvfs_est_power_get,</span><br><span class="line">	.fast_switch_possible = scmi_fast_switch_possible,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在这个宏进行SCMI performance domain management protocol协议的初始化</span></span><br><span class="line">DEFINE_SCMI_PROTOCOL_REGISTER_UNREGISTER(SCMI_PROTOCOL_PERF, perf)</span><br><span class="line"></span><br><span class="line"><span class="comment">// drivers/firmware/arm_scmi/common.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFINE_SCMI_PROTOCOL_REGISTER_UNREGISTER(id, name) \</span></span><br><span class="line"><span class="meta">int __init scmi_##name##_register(void) \</span></span><br><span class="line"><span class="meta">&#123; \</span></span><br><span class="line"><span class="meta">	return scmi_protocol_register((id), &amp;scmi_##name##_protocol_init); \</span></span><br><span class="line"><span class="meta">&#125; \</span></span><br><span class="line"><span class="meta">\</span></span><br><span class="line"><span class="meta">void __exit scmi_##name##_unregister(void) \</span></span><br><span class="line"><span class="meta">&#123; \</span></span><br><span class="line"><span class="meta">	scmi_protocol_unregister((id)); \</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="comment">// 展开该宏</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> __init <span class="title">scmi_perf_register</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> scmi_protocol_register(SCMI_PROTOCOL_PER, &amp;scmi_perf_protocol_init);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化过程中调用了scmi_perf_protocol_init();</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">scmi_perf_protocol_init</span><span class="params">(struct scmi_handle *handle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> domain;</span><br><span class="line">	u32 version;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">scmi_perf_info</span> *<span class="title">pinfo</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取当前perf domain management协议版本</span></span><br><span class="line">	scmi_version_get(handle, SCMI_PROTOCOL_PERF, &amp;version);</span><br><span class="line"></span><br><span class="line">	dev_dbg(handle-&gt;dev, <span class="string">&quot;Performance Version %d.%d\n&quot;</span>,</span><br><span class="line">		PROTOCOL_REV_MAJOR(version), PROTOCOL_REV_MINOR(version));</span><br><span class="line"></span><br><span class="line">	pinfo = devm_kzalloc(handle-&gt;dev, <span class="keyword">sizeof</span>(*pinfo), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!pinfo)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	<span class="comment">// 通过PROTOCOL_ATTRIBUTES(0x01)这个命令获取domain id个数</span></span><br><span class="line">	<span class="comment">// 还有share memory的地址和长度</span></span><br><span class="line">	scmi_perf_attributes_get(handle, pinfo);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 分配perf_dom_info结构体内存，这里面的opp成员会存放OPP表</span></span><br><span class="line">	<span class="comment">// 对于E2000Q这里会分配3个大小的dom_info</span></span><br><span class="line">	pinfo-&gt;dom_info = devm_kcalloc(handle-&gt;dev, pinfo-&gt;num_domains,</span><br><span class="line">				       <span class="keyword">sizeof</span>(*pinfo-&gt;dom_info), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!pinfo-&gt;dom_info) </span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 遍历每个performance_domain，获取performance domain的属性和performance level参数</span></span><br><span class="line">	<span class="keyword">for</span> (domain = <span class="number">0</span>; domain &lt; pinfo-&gt;num_domains; domain++) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">perf_dom_info</span> *<span class="title">dom</span> =</span> pinfo-&gt;dom_info + domain;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 获取performance domain属性</span></span><br><span class="line">		scmi_perf_domain_attributes_get(handle, domain, dom);</span><br><span class="line">		<span class="comment">// 获取performance level参数即opp表</span></span><br><span class="line">		<span class="comment">// 填充perf_dom_info内的opp结构体</span></span><br><span class="line">		scmi_perf_describe_levels_get(handle, domain, dom);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (dom-&gt;perf_fastchannels)</span><br><span class="line">			scmi_perf_domain_init_fc(handle, domain, &amp;dom-&gt;fc_info);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	scmi_register_protocol_events(handle,</span><br><span class="line">				      SCMI_PROTOCOL_PERF, SCMI_PROTO_QUEUE_SZ,</span><br><span class="line">				      &amp;perf_event_ops, perf_events,</span><br><span class="line">				      ARRAY_SIZE(perf_events),</span><br><span class="line">				      pinfo-&gt;num_domains);</span><br><span class="line"></span><br><span class="line">	pinfo-&gt;version = version;</span><br><span class="line">	handle-&gt;perf_ops = &amp;perf_ops;</span><br><span class="line">	<span class="comment">// perf_priv保存performance domain信息，后续会用到perf_priv</span></span><br><span class="line">	handle-&gt;perf_priv = pinfo;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在初始化阶段，<code>scmi_perf_protocol_init</code>只会将固件里面的perf domains信息保存到handle-&gt;perf_priv里面，此时还并没有将opp表注册到cpu设备上</p>
<p>接下来在scmi调频驱动初始化的过程中，会调用scmi的device_opps_add()接口初始化，即调用<code>scmi_dvfs_device_opps_add()</code>，在这个里面才会生成cpu的opp_table</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">scmi_dvfs_device_opps_add</span><span class="params">(<span class="keyword">const</span> struct scmi_handle *handle,</span></span></span><br><span class="line"><span class="params"><span class="function">				     struct device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> idx, ret, domain;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> freq;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">scmi_opp</span> *<span class="title">opp</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">perf_dom_info</span> *<span class="title">dom</span>;</span></span><br><span class="line">	<span class="comment">// 获取pref_priv地址，在这里面取opp数据</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">scmi_perf_info</span> *<span class="title">pi</span> =</span> handle-&gt;perf_priv;</span><br><span class="line">	<span class="comment">// 这个domain是从设备树里面取到的，设备树cpu节点的clock属性会带一个domain编号</span></span><br><span class="line">	domain = scmi_dev_domain_id(dev);</span><br><span class="line">	<span class="keyword">if</span> (domain &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> domain;</span><br><span class="line">	<span class="comment">// 取当前CPU的perf domain信息</span></span><br><span class="line">	dom = pi-&gt;dom_info + domain;</span><br><span class="line">	<span class="comment">// struct perf_dom_info结构体里面一共16个opp表</span></span><br><span class="line">	<span class="comment">// 这里没对opp进行限制，可能有数组越界的问题</span></span><br><span class="line">	<span class="keyword">for</span> (opp = dom-&gt;opp, idx = <span class="number">0</span>; idx &lt; dom-&gt;opp_count; idx++, opp++) &#123;</span><br><span class="line">		freq = opp-&gt;perf * dom-&gt;mult_factor;</span><br><span class="line">		<span class="comment">// 这里面第一次会为opp_table分配内存，这里只将频率加进opp table里了</span></span><br><span class="line">		ret = dev_pm_opp_add(dev, freq, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">			dev_warn(dev, <span class="string">&quot;failed to add opp %luHz\n&quot;</span>, freq);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">while</span> (idx-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">				freq = (--opp)-&gt;perf * dom-&gt;mult_factor;</span><br><span class="line">				dev_pm_opp_remove(dev, freq);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> ret;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>详细看一下<code>dev_pm_opp_add()</code>的过程</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// drviers/opp/opp.h</span></span><br><span class="line"><span class="comment">// opp_table结构体的定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">opp_table</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">node</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">blocking_notifier_head</span> <span class="title">head</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">dev_list</span>;</span>			<span class="comment">// 共享该opp表的设备链表</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">opp_list</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kref</span> <span class="title">kref</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">lock</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">np</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> clock_latency_ns_max;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* For backward compatibility with v1 bindings */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> voltage_tolerance_v1;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> parsed_static_opps;</span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">opp_table_access</span> <span class="title">shared_opp</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dev_pm_opp</span> *<span class="title">suspend_opp</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">genpd_virt_dev_lock</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> **<span class="title">genpd_virt_devs</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">opp_table</span> **<span class="title">required_opp_tables</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> required_opp_count;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> *supported_hw;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> supported_hw_count;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *prop_name;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">clk</span> *<span class="title">clk</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">regulator</span> **<span class="title">regulators</span>;</span></span><br><span class="line">	<span class="keyword">int</span> regulator_count;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">icc_path</span> **<span class="title">paths</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> path_count;</span><br><span class="line">	<span class="keyword">bool</span> enabled;</span><br><span class="line">	<span class="keyword">bool</span> genpd_performance_state;</span><br><span class="line">	<span class="keyword">bool</span> is_genpd;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> (*set_opp)(struct dev_pm_set_opp_data *data);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dev_pm_set_opp_data</span> *<span class="title">set_opp_data</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_FS</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">dentry</span>;</span></span><br><span class="line">	<span class="keyword">char</span> dentry_name[NAME_MAX];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// drivers/opp/core.c</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The root of the list of all opp-tables. All opp_table structures branch off</span></span><br><span class="line"><span class="comment"> * from here, with each opp_table containing the list of opps it supports in</span></span><br><span class="line"><span class="comment"> * various states of availability.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// opp_tables是opp_table链表的头节点</span></span><br><span class="line">LIST_HEAD(opp_tables);</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">opp_device</span> *_<span class="title">find_opp_dev</span>(<span class="title">const</span> <span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>,</span></span><br><span class="line"><span class="class">							<span class="keyword">struct</span> <span class="title">opp_table</span> *<span class="title">opp_table</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">opp_device</span> *<span class="title">opp_dev</span>;</span></span><br><span class="line">	<span class="comment">// 从opp_table的dev_list中的dev与当前dev进行对比</span></span><br><span class="line">	list_for_each_entry(opp_dev, &amp;opp_table-&gt;dev_list, node)</span><br><span class="line">		<span class="keyword">if</span> (opp_dev-&gt;dev == dev)</span><br><span class="line">			<span class="keyword">return</span> opp_dev;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">opp_table</span> *_<span class="title">find_opp_table_unlocked</span>(<span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">opp_table</span> *<span class="title">opp_table</span>;</span></span><br><span class="line">	<span class="keyword">bool</span> found;</span><br><span class="line">	<span class="comment">// 在opp_tables中进行遍历查找当前设备对应的opp_table</span></span><br><span class="line">	list_for_each_entry(opp_table, &amp;opp_tables, node) &#123;</span><br><span class="line">		mutex_lock(&amp;opp_table-&gt;lock);</span><br><span class="line">		found = !!_find_opp_dev(dev, opp_table);</span><br><span class="line">		mutex_unlock(&amp;opp_table-&gt;lock);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (found) &#123;</span><br><span class="line">			<span class="comment">// opp_table的引用计数加一</span></span><br><span class="line">			_get_opp_table_kref(opp_table);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> opp_table;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ERR_PTR(-ENODEV);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">opp_table</span> *_<span class="title">opp_get_opp_table</span>(<span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>, <span class="title">int</span> <span class="title">index</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">opp_table</span> *<span class="title">opp_table</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Hold our table modification lock here */</span></span><br><span class="line">	mutex_lock(&amp;opp_table_lock);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 第一次运行到这里的时候，应该是找不到opp_table的，需要进行创建</span></span><br><span class="line">	opp_table = _find_opp_table_unlocked(dev);</span><br><span class="line">	<span class="keyword">if</span> (!IS_ERR(opp_table))</span><br><span class="line">		<span class="keyword">goto</span> unlock;</span><br><span class="line"></span><br><span class="line">	opp_table = _managed_opp(dev, index);</span><br><span class="line">	<span class="keyword">if</span> (opp_table) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!_add_opp_dev_unlocked(dev, opp_table)) &#123;</span><br><span class="line">			dev_pm_opp_put_opp_table(opp_table);</span><br><span class="line">			opp_table = ERR_PTR(-ENOMEM);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">goto</span> unlock;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 对该设备创建opp表</span></span><br><span class="line">	opp_table = _allocate_opp_table(dev, index);</span><br><span class="line"></span><br><span class="line">unlock:</span><br><span class="line">	mutex_unlock(&amp;opp_table_lock);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> opp_table;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">struct opp_table *<span class="title">dev_pm_opp_get_opp_table</span><span class="params">(struct device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> _opp_get_opp_table(dev, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dev_pm_opp_add</span><span class="params">(struct device *dev, <span class="keyword">unsigned</span> <span class="keyword">long</span> freq, <span class="keyword">unsigned</span> <span class="keyword">long</span> u_volt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">opp_table</span> *<span class="title">opp_table</span>;</span></span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">	opp_table = dev_pm_opp_get_opp_table(dev);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(opp_table)) </span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(opp_table);</span><br><span class="line">	</span><br><span class="line">	opp_table-&gt;regulator_count = <span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">	ret = _opp_add_v1(opp_table, dev, freq, u_volt, <span class="literal">true</span>);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		dev_pm_opp_put_opp_table(opp_table);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终获取得到的OPP表如下<br><img src="https://raw.githubusercontent.com/JackHuang021/images/master/20230222105334.png"></p>
<h5 id="cpufreq初始化过程"><a href="#cpufreq初始化过程" class="headerlink" title="cpufreq初始化过程"></a>cpufreq初始化过程</h5><p>cpufreq被注册cpu_subsys总线上</p>
<p>cpufreq的初始化从cpufreq_drvier注册开始，<code>cpufreq_register_driver()</code>函数为cpufreq驱动注册的入口，驱动程序通过调用该函数进行初始化，传入相关的<code>struct cpufreq_driver</code>，<code>cpufreq_register_driver()</code>会调用<code>subsys_interface_register()</code>最终执行回调函数<code>cpufreq_add_dev</code>，然后调用<code>cpufreq_online()</code>走初始化流程</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cpufreq_drvier结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cpufreq_driver</span> &#123;</span></span><br><span class="line">	<span class="keyword">char</span>		name[CPUFREQ_NAME_LEN];</span><br><span class="line">	u16		    flags;</span><br><span class="line">	<span class="keyword">void</span>		*driver_data;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* needed by all drivers */</span></span><br><span class="line">	<span class="keyword">int</span>		(*init)(struct cpufreq_policy *policy);</span><br><span class="line">	<span class="keyword">int</span>		(*verify)(struct cpufreq_policy_data *policy);</span><br><span class="line">	<span class="comment">// 调频接口</span></span><br><span class="line">	<span class="keyword">int</span>		(*target_index)(struct cpufreq_policy *policy,</span><br><span class="line">					<span class="keyword">unsigned</span> <span class="keyword">int</span> index);</span><br><span class="line">	<span class="function"><span class="keyword">unsigned</span> <span class="title">int</span>	<span class="params">(*fast_switch)</span><span class="params">(struct cpufreq_policy *policy,</span></span></span><br><span class="line"><span class="params"><span class="function">				       <span class="keyword">unsigned</span> <span class="keyword">int</span> target_freq)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* should be defined, if possible */</span></span><br><span class="line">	<span class="comment">// 获取频率接口</span></span><br><span class="line">	<span class="function"><span class="keyword">unsigned</span> <span class="title">int</span>	<span class="params">(*get)</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> cpu)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Called to update policy limits on firmware notifications. */</span></span><br><span class="line">	<span class="keyword">void</span>		(*update_limits)(<span class="keyword">unsigned</span> <span class="keyword">int</span> cpu);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span>		(*online)(struct cpufreq_policy *policy);</span><br><span class="line">	<span class="keyword">int</span>		(*offline)(struct cpufreq_policy *policy);</span><br><span class="line">	<span class="keyword">int</span>		(*<span class="built_in">exit</span>)(struct cpufreq_policy *policy);</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">freq_attr</span> **<span class="title">attr</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// driver/base/cpu.c</span></span><br><span class="line"><span class="comment">// cpu subsys总线，cpufreq就是以subsys_interface挂在该总线下</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> <span class="title">cpu_subsys</span> =</span> &#123;</span><br><span class="line">	.name = <span class="string">&quot;cpu&quot;</span>,</span><br><span class="line">	.dev_name = <span class="string">&quot;cpu&quot;</span>,</span><br><span class="line">	.match = cpu_subsys_match,</span><br><span class="line">	.online = cpu_subsys_online,</span><br><span class="line">	.offline = cpu_subsys_offline,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// driver/cpufreq/cpufreq.c</span></span><br><span class="line"><span class="comment">// 指向当前使用的cpufreq_driver</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">cpufreq_driver</span> *<span class="title">cpufreq_driver</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// cpufreq subsys接口，用来挂到CPU subsys总线上</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">subsys_interface</span> <span class="title">cpufreq_interface</span> =</span> &#123;</span><br><span class="line">	.name		= <span class="string">&quot;cpufreq&quot;</span>,</span><br><span class="line">	.subsys		= &amp;cpu_subsys,</span><br><span class="line">	.add_dev	= cpufreq_add_dev,</span><br><span class="line">	.remove_dev	= cpufreq_remove_dev,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// scmi cpufreq_driver结构体定义</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">cpufreq_driver</span> <span class="title">scmi_cpufreq_driver</span> =</span> &#123;</span><br><span class="line">	.name	= <span class="string">&quot;scmi&quot;</span>,</span><br><span class="line">	.flags	= CPUFREQ_STICKY | CPUFREQ_HAVE_GOVERNOR_PER_POLICY |</span><br><span class="line">		  CPUFREQ_NEED_INITIAL_FREQ_CHECK,</span><br><span class="line">	.verify	= cpufreq_generic_frequency_table_verify,</span><br><span class="line">	.attr	= cpufreq_generic_attr,</span><br><span class="line">	.target_index	= scmi_cpufreq_set_target,</span><br><span class="line">	.fast_switch	= scmi_cpufreq_fast_switch,</span><br><span class="line">	.get	= scmi_cpufreq_get_rate,</span><br><span class="line">	.init	= scmi_cpufreq_init,</span><br><span class="line">	.<span class="built_in">exit</span>	= scmi_cpufreq_exit,</span><br><span class="line">	.ready	= scmi_cpufreq_ready,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为每个cluster定义一个cpufreq_policy结构体，对每个cluster上的CPU进行调频管理</span></span><br><span class="line"><span class="comment">// 其中又分别进行cpufreq_driver的初始化和governor的初始化</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">DEFINE_PER_CPU</span><span class="params">(struct cpufreq_policy *, cpufreq_cpu_data)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指向当前注册的cpufreq driver</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">cpufreq_driver</span> *<span class="title">cpufreq_driver</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// cpufreq驱动框架初始化过程，整个过程都围绕着policy这个结构体进行，逐步进行初始化</span></span><br><span class="line">cpufreq_register_driver(&amp;scmi_cpufreq_driver);</span><br><span class="line">	subsys_interface_register(&amp;cpufreq_interface);</span><br><span class="line">		cpufreq_add_dev(dev, sif);</span><br><span class="line">			cpufreq_online(cpu);</span><br><span class="line">				<span class="comment">// 初步初始化policy</span></span><br><span class="line">				<span class="comment">// cpumask初始化</span></span><br><span class="line">				<span class="comment">// policy-&gt;kobj kobject初始化</span></span><br><span class="line">				<span class="comment">// policy-&gt;constraints 频率限制初始化</span></span><br><span class="line">				<span class="comment">// 注册频率限制通知接口，频率最大最小值变化时会调用接口</span></span><br><span class="line">				policy = cpufreq_policy_alloc(cpu);</span><br><span class="line">				<span class="comment">// 调用cpufreq_drvier init接口，完善policy结构体</span></span><br><span class="line">				<span class="comment">// 将opp表添加到对应的device，通过dev_pm_opp_add接口</span></span><br><span class="line">				<span class="comment">// 生成频率表 freq_table</span></span><br><span class="line">				cpufreq_driver-&gt;init(policy) -&gt; scmi_cpufreq_init(policy)</span><br><span class="line">				cpufreq_table_validate_and_sort(policy);</span><br><span class="line">				<span class="comment">// 创建/sys/device/system/cpu/cpux目录下的cpufreq符号链接</span></span><br><span class="line">				add_cpu_dev_symlink();</span><br><span class="line">				freq_qos_and_request();</span><br><span class="line">				blocking_notifier_call_chain();</span><br><span class="line">				<span class="comment">// CPU进行频率调整，使当前运行频率在频率表中</span></span><br><span class="line">				<span class="comment">// 初始化的时候会进行一次调整</span></span><br><span class="line">				__cpufreq_driver_target();</span><br><span class="line">				<span class="comment">// 创建sys节点，/sys/device/system/cpu/cpufreq/policyx目录下的一些可选属性</span></span><br><span class="line">				cpufreq_add_dev_interface(policy);</span><br><span class="line">				cpufreq_stats_create_table(policy);</span><br><span class="line">				list_add(&amp;policy-&gt;polic_list, &amp;cpufreq_policy_list);</span><br><span class="line">				<span class="comment">// 使用默认governor初始化policy</span></span><br><span class="line">				cpufreq_init_policy();</span><br></pre></td></tr></table></figure>

<p>来看一下<code>subsys_interface_register()</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// drivers/base/bus.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">subsys_interface_register</span><span class="params">(struct subsystem_interface *sif)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> *<span class="title">subsys</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">subsys_dev_iter</span> <span class="title">iter</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!sif || !sif-&gt;subsys)</span><br><span class="line">		<span class="keyword">return</span> -ENODEV;</span><br><span class="line"></span><br><span class="line">	subsys = bus_get(sif-&gt;subsys);</span><br><span class="line">	<span class="keyword">if</span> (!subsys)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	mutex_lock(&amp;subsys-&gt;p-&gt;mutex);</span><br><span class="line">	<span class="comment">// 将cpufreq_interface添加到cpu_subsys总线的interfaces上</span></span><br><span class="line">	<span class="comment">// interfaces是一个list_head链表</span></span><br><span class="line">	list_add_tail(&amp;sif-&gt;node, &amp;subsys-&gt;p-&gt;interfaces);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 遍历cpu_subsys总线</span></span><br><span class="line">	<span class="comment">// subsys_dev_iter是对klist 迭代器的一个封装</span></span><br><span class="line">	<span class="comment">// 这里遍历的对象是struct device私有数据的knode_bus</span></span><br><span class="line">	<span class="comment">// knode_bus节点是挂载到klist_device这个链表上</span></span><br><span class="line">	<span class="keyword">if</span> (sif-&gt;add_dev) &#123;</span><br><span class="line">		subsys_dev_iter_init(&amp;iter, subsys, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">		<span class="comment">// 从knode_bus取得device指针</span></span><br><span class="line">		<span class="keyword">while</span> ((dev = subsys_dev_iter_next(&amp;iter)))</span><br><span class="line">			sif-&gt;add_dev(dev, sif);</span><br><span class="line">		subsys_dev_iter_exit(&amp;iter);</span><br><span class="line">	&#125;</span><br><span class="line">	mutex_unlock(&amp;subsys-&gt;p-&gt;mutex);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再来看看cpufreq_online()</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">cpufreq_online</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> cpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cpufreq_policy</span> *<span class="title">policy</span>;</span></span><br><span class="line">	<span class="keyword">bool</span> new_policy;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> j;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">	pr_debug(<span class="string">&quot;%s: bringing CPU%u online\n&quot;</span>, __func__, cpu);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Check if this CPU already has a policy to manage it */</span></span><br><span class="line">	<span class="comment">// cpufreq_cpu_data是类型为policy指针的precpu变量</span></span><br><span class="line">	<span class="comment">// 这是是取得policy指针</span></span><br><span class="line">	policy = per_cpu(cpufreq_cpu_data, cpu);</span><br><span class="line">	<span class="keyword">if</span> (policy) &#123;</span><br><span class="line">		<span class="comment">// 假如该cpu不在该policy的related_cpus里面则是有问题的</span></span><br><span class="line">		WARN_ON(!cpumask_test_cpu(cpu, policy-&gt;related_cpus));</span><br><span class="line">		<span class="comment">// 判断当前policy还有没有online CPU</span></span><br><span class="line">		<span class="keyword">if</span> (!policy_is_inactive(policy))</span><br><span class="line">			<span class="comment">// 将当前cpu加入到policy-&gt;cpu online CPU里面</span></span><br><span class="line">			<span class="keyword">return</span> cpufreq_add_policy_cpu(policy, cpu);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* This is the only online CPU for the policy.  Start over. */</span></span><br><span class="line">		new_policy = <span class="literal">false</span>;</span><br><span class="line">		down_write(&amp;policy-&gt;rwsem);</span><br><span class="line">		policy-&gt;cpu = cpu;</span><br><span class="line">		policy-&gt;governor = <span class="literal">NULL</span>;</span><br><span class="line">		up_write(&amp;policy-&gt;rwsem);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 第一次开机的时候需要分配policy内存</span></span><br><span class="line">		new_policy = <span class="literal">true</span>;</span><br><span class="line">		policy = cpufreq_policy_alloc(cpu);</span><br><span class="line">		<span class="keyword">if</span> (!policy)</span><br><span class="line">			<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// scmi调频驱动没有实现online接口</span></span><br><span class="line">	<span class="keyword">if</span> (!new_policy &amp;&amp; cpufreq_driver-&gt;online) &#123;</span><br><span class="line">		ret = cpufreq_driver-&gt;online(policy);</span><br><span class="line">		<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">			pr_debug(<span class="string">&quot;%s: %d: initialization failed\n&quot;</span>, __func__,</span><br><span class="line">				 __LINE__);</span><br><span class="line">			<span class="keyword">goto</span> out_exit_policy;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Recover policy-&gt;cpus using related_cpus */</span></span><br><span class="line">		cpumask_copy(policy-&gt;cpus, policy-&gt;related_cpus);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		cpumask_copy(policy-&gt;cpus, cpumask_of(cpu));</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Call driver. From then on the cpufreq must be able</span></span><br><span class="line"><span class="comment">		 * to accept all calls to -&gt;verify and -&gt;setpolicy for this CPU.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="comment">// cpufreq_driver是在cpufreq_register_driver()中进行赋值的</span></span><br><span class="line">		<span class="comment">// 调频驱动初始化</span></span><br><span class="line">		ret = cpufreq_driver-&gt;init(policy);</span><br><span class="line">		<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">			pr_debug(<span class="string">&quot;%s: %d: initialization failed\n&quot;</span>, __func__,</span><br><span class="line">				 __LINE__);</span><br><span class="line">			<span class="keyword">goto</span> out_free_policy;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		ret = cpufreq_table_validate_and_sort(policy);</span><br><span class="line">		<span class="keyword">if</span> (ret)</span><br><span class="line">			<span class="keyword">goto</span> out_exit_policy;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* related_cpus should at least include policy-&gt;cpus. */</span></span><br><span class="line">		cpumask_copy(policy-&gt;related_cpus, policy-&gt;cpus);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	down_write(&amp;policy-&gt;rwsem);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * affected cpus must always be the one, which are online. We aren&#x27;t</span></span><br><span class="line"><span class="comment">	 * managing offline cpus here.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	cpumask_and(policy-&gt;cpus, policy-&gt;cpus, cpu_online_mask);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (new_policy) &#123;</span><br><span class="line">		for_each_cpu(j, policy-&gt;related_cpus) &#123;</span><br><span class="line">			per_cpu(cpufreq_cpu_data, j) = policy;</span><br><span class="line">			add_cpu_dev_symlink(policy, j);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		policy-&gt;min_freq_req = kzalloc(<span class="number">2</span> * <span class="keyword">sizeof</span>(*policy-&gt;min_freq_req),</span><br><span class="line">					       GFP_KERNEL);</span><br><span class="line">		<span class="keyword">if</span> (!policy-&gt;min_freq_req)</span><br><span class="line">			<span class="keyword">goto</span> out_destroy_policy;</span><br><span class="line"></span><br><span class="line">		ret = freq_qos_add_request(&amp;policy-&gt;constraints,</span><br><span class="line">					   policy-&gt;min_freq_req, FREQ_QOS_MIN,</span><br><span class="line">					   policy-&gt;min);</span><br><span class="line">		<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * So we don&#x27;t call freq_qos_remove_request() for an</span></span><br><span class="line"><span class="comment">			 * uninitialized request.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			kfree(policy-&gt;min_freq_req);</span><br><span class="line">			policy-&gt;min_freq_req = <span class="literal">NULL</span>;</span><br><span class="line">			<span class="keyword">goto</span> out_destroy_policy;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * This must be initialized right here to avoid calling</span></span><br><span class="line"><span class="comment">		 * freq_qos_remove_request() on uninitialized request in case</span></span><br><span class="line"><span class="comment">		 * of errors.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		policy-&gt;max_freq_req = policy-&gt;min_freq_req + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		ret = freq_qos_add_request(&amp;policy-&gt;constraints,</span><br><span class="line">					   policy-&gt;max_freq_req, FREQ_QOS_MAX,</span><br><span class="line">					   policy-&gt;max);</span><br><span class="line">		<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			policy-&gt;max_freq_req = <span class="literal">NULL</span>;</span><br><span class="line">			<span class="keyword">goto</span> out_destroy_policy;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		blocking_notifier_call_chain(&amp;cpufreq_policy_notifier_list,</span><br><span class="line">				CPUFREQ_CREATE_POLICY, policy);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (cpufreq_driver-&gt;get &amp;&amp; has_target()) &#123;</span><br><span class="line">		policy-&gt;cur = cpufreq_driver-&gt;get(policy-&gt;cpu);</span><br><span class="line">		<span class="keyword">if</span> (!policy-&gt;cur) &#123;</span><br><span class="line">			pr_err(<span class="string">&quot;%s: -&gt;get() failed\n&quot;</span>, __func__);</span><br><span class="line">			<span class="keyword">goto</span> out_destroy_policy;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Sometimes boot loaders set CPU frequency to a value outside of</span></span><br><span class="line"><span class="comment">	 * frequency table present with cpufreq core. In such cases CPU might be</span></span><br><span class="line"><span class="comment">	 * unstable if it has to run on that frequency for long duration of time</span></span><br><span class="line"><span class="comment">	 * and so its better to set it to a frequency which is specified in</span></span><br><span class="line"><span class="comment">	 * freq-table. This also makes cpufreq stats inconsistent as</span></span><br><span class="line"><span class="comment">	 * cpufreq-stats would fail to register because current frequency of CPU</span></span><br><span class="line"><span class="comment">	 * isn&#x27;t found in freq-table.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Because we don&#x27;t want this change to effect boot process badly, we go</span></span><br><span class="line"><span class="comment">	 * for the next freq which is &gt;= policy-&gt;cur (&#x27;cur&#x27; must be set by now,</span></span><br><span class="line"><span class="comment">	 * otherwise we will end up setting freq to lowest of the table as &#x27;cur&#x27;</span></span><br><span class="line"><span class="comment">	 * is initialized to zero).</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * We are passing target-freq as &quot;policy-&gt;cur - 1&quot; otherwise</span></span><br><span class="line"><span class="comment">	 * __cpufreq_driver_target() would simply fail, as policy-&gt;cur will be</span></span><br><span class="line"><span class="comment">	 * equal to target-freq.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> ((cpufreq_driver-&gt;flags &amp; CPUFREQ_NEED_INITIAL_FREQ_CHECK)</span><br><span class="line">	    &amp;&amp; has_target()) &#123;</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">int</span> old_freq = policy-&gt;cur;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Are we running at unknown frequency ? */</span></span><br><span class="line">		ret = cpufreq_frequency_table_get_index(policy, old_freq);</span><br><span class="line">		<span class="keyword">if</span> (ret == -EINVAL) &#123;</span><br><span class="line">			ret = __cpufreq_driver_target(policy, old_freq - <span class="number">1</span>,</span><br><span class="line">						      CPUFREQ_RELATION_L);</span><br><span class="line"></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * Reaching here after boot in a few seconds may not</span></span><br><span class="line"><span class="comment">			 * mean that system will remain stable at &quot;unknown&quot;</span></span><br><span class="line"><span class="comment">			 * frequency for longer duration. Hence, a BUG_ON().</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			BUG_ON(ret);</span><br><span class="line">			pr_info(<span class="string">&quot;%s: CPU%d: Running at unlisted initial frequency: %u KHz, changing to: %u KHz\n&quot;</span>,</span><br><span class="line">				__func__, policy-&gt;cpu, old_freq, policy-&gt;cur);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (new_policy) &#123;</span><br><span class="line">		ret = cpufreq_add_dev_interface(policy);</span><br><span class="line">		<span class="keyword">if</span> (ret)</span><br><span class="line">			<span class="keyword">goto</span> out_destroy_policy;</span><br><span class="line"></span><br><span class="line">		cpufreq_stats_create_table(policy);</span><br><span class="line"></span><br><span class="line">		write_lock_irqsave(&amp;cpufreq_driver_lock, flags);</span><br><span class="line">		list_add(&amp;policy-&gt;policy_list, &amp;cpufreq_policy_list);</span><br><span class="line">		write_unlock_irqrestore(&amp;cpufreq_driver_lock, flags);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ret = cpufreq_init_policy(policy);</span><br><span class="line">	<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">		pr_err(<span class="string">&quot;%s: Failed to initialize policy for cpu: %d (%d)\n&quot;</span>,</span><br><span class="line">		       __func__, cpu, ret);</span><br><span class="line">		<span class="keyword">goto</span> out_destroy_policy;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	up_write(&amp;policy-&gt;rwsem);</span><br><span class="line"></span><br><span class="line">	kobject_uevent(&amp;policy-&gt;kobj, KOBJ_ADD);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Callback for handling stuff after policy is ready */</span></span><br><span class="line">	<span class="keyword">if</span> (cpufreq_driver-&gt;ready)</span><br><span class="line">		cpufreq_driver-&gt;ready(policy);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (cpufreq_thermal_control_enabled(cpufreq_driver))</span><br><span class="line">		policy-&gt;cdev = of_cpufreq_cooling_register(policy);</span><br><span class="line"></span><br><span class="line">	pr_debug(<span class="string">&quot;initialization complete\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">out_destroy_policy:</span><br><span class="line">	for_each_cpu(j, policy-&gt;real_cpus)</span><br><span class="line">		remove_cpu_dev_symlink(policy, get_cpu_device(j));</span><br><span class="line"></span><br><span class="line">	up_write(&amp;policy-&gt;rwsem);</span><br><span class="line"></span><br><span class="line">out_exit_policy:</span><br><span class="line">	<span class="keyword">if</span> (cpufreq_driver-&gt;<span class="built_in">exit</span>)</span><br><span class="line">		cpufreq_driver-&gt;<span class="built_in">exit</span>(policy);</span><br><span class="line"></span><br><span class="line">out_free_policy:</span><br><span class="line">	cpufreq_policy_free(policy);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="cpufreq-drviver初始化"><a href="#cpufreq-drviver初始化" class="headerlink" title="cpufreq drviver初始化"></a>cpufreq drviver初始化</h5><p>在cpufreq_online()中调用全局变量cpufreq_driver-&gt;init(policy)进行调频驱动的初始化，下面是scmi调频驱动的初始化过程</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">scmi_cpufreq_init</span><span class="params">(struct cpufreq_policy *policy)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret, nr_opp;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> latency;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">cpu_dev</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">scmi_data</span> *<span class="title">priv</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cpufreq_frequency_table</span> *<span class="title">freq_table</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">em_data_callback</span> <span class="title">em_cb</span> =</span> EM_DATA_CB(scmi_get_cpu_power);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取CPU device结构体即对应percpu变量cpu_sys_devices</span></span><br><span class="line">	cpu_dev = get_cpu_device(policy-&gt;cpu);</span><br><span class="line">	<span class="keyword">if</span> (!cpu_dev) &#123;</span><br><span class="line">		pr_err(<span class="string">&quot;failed to get cpu%d device\n&quot;</span>, policy-&gt;cpu);</span><br><span class="line">		<span class="keyword">return</span> -ENODEV;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 调用scmi_dvfs_device_opps_add()生成opp表</span></span><br><span class="line">	ret = handle-&gt;perf_ops-&gt;device_opps_add(handle, cpu_dev);</span><br><span class="line">	<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">		dev_warn(cpu_dev, <span class="string">&quot;failed to add opps to the device\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 遍历可用的cpu，对比cpu_dev的domain_id，若是相同的话加入到policy-&gt;cpus里面</span></span><br><span class="line">	ret = scmi_get_sharing_cpus(cpu_dev, policy-&gt;cpus);</span><br><span class="line">	<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">		dev_warn(cpu_dev, <span class="string">&quot;failed to get sharing cpumask\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 将opp表添加到sharing cpus里面</span></span><br><span class="line">	ret = dev_pm_opp_set_sharing_cpus(cpu_dev, policy-&gt;cpus);</span><br><span class="line">	<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">		dev_err(cpu_dev, <span class="string">&quot;%s: failed to mark OPPs as shared: %d\n&quot;</span>,</span><br><span class="line">			__func__, ret);</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	nr_opp = dev_pm_opp_get_opp_count(cpu_dev);</span><br><span class="line">	<span class="keyword">if</span> (nr_opp &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">		dev_dbg(cpu_dev, <span class="string">&quot;OPP table is not ready, deferring probe\n&quot;</span>);</span><br><span class="line">		ret = -EPROBE_DEFER;</span><br><span class="line">		<span class="keyword">goto</span> out_free_opp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	priv = kzalloc(<span class="keyword">sizeof</span>(*priv), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!priv) &#123;</span><br><span class="line">		ret = -ENOMEM;</span><br><span class="line">		<span class="keyword">goto</span> out_free_opp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// cpufreq</span></span><br><span class="line">	ret = dev_pm_opp_init_cpufreq_table(cpu_dev, &amp;freq_table);</span><br><span class="line">	<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">		dev_err(cpu_dev, <span class="string">&quot;failed to init cpufreq table: %d\n&quot;</span>, ret);</span><br><span class="line">		<span class="keyword">goto</span> out_free_priv;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	priv-&gt;cpu_dev = cpu_dev;</span><br><span class="line">	priv-&gt;domain_id = handle-&gt;perf_ops-&gt;device_domain_id(cpu_dev);</span><br><span class="line">	<span class="comment">// driver_data保存了调频驱动的一些数据，这里只有cpu编号和domain id号</span></span><br><span class="line">	policy-&gt;driver_data = priv;</span><br><span class="line">	policy-&gt;freq_table = freq_table;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* SCMI allows DVFS request for any domain from any CPU */</span></span><br><span class="line">	policy-&gt;dvfs_possible_from_any_cpu = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	latency = handle-&gt;perf_ops-&gt;transition_latency_get(handle, cpu_dev);</span><br><span class="line">	<span class="keyword">if</span> (!latency)</span><br><span class="line">		latency = CPUFREQ_ETERNAL;</span><br><span class="line"></span><br><span class="line">	policy-&gt;cpuinfo.transition_latency = latency;</span><br><span class="line"></span><br><span class="line">	policy-&gt;fast_switch_possible =</span><br><span class="line">		handle-&gt;perf_ops-&gt;fast_switch_possible(handle, cpu_dev);</span><br><span class="line"></span><br><span class="line">	em_dev_register_perf_domain(cpu_dev, nr_opp, &amp;em_cb, policy-&gt;cpus);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">out_free_priv:</span><br><span class="line">	kfree(priv);</span><br><span class="line">out_free_opp:</span><br><span class="line">	dev_pm_opp_remove_all_dynamic(cpu_dev);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>频率表初始化过程</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cpufreq_frequency_table</span> &#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> flags;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> driver_data;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> frequency;		<span class="comment">/* KHz */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// drivers/opp/cpu.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dev_pm_opp_init_cpufreq_table</span><span class="params">(struct device *dev,</span></span></span><br><span class="line"><span class="params"><span class="function">				  struct cpufreq_frequency_table **table)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dev_pm_opp</span> *<span class="title">opp</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cpufreq_frequency_table</span> *<span class="title">freq_table</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">int</span> i, max_opps, ret = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> rate;</span><br><span class="line"></span><br><span class="line">	max_opps = dev_pm_opp_get_opp_count(dev);</span><br><span class="line">	<span class="keyword">if</span> (max_opps &lt;= <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> max_opps ? max_opps : -ENODATA;</span><br><span class="line"></span><br><span class="line">	freq_table = kcalloc((max_opps + <span class="number">1</span>), <span class="keyword">sizeof</span>(*freq_table), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!freq_table)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>, rate = <span class="number">0</span>; i &lt; max_opps; i++, rate++) &#123;</span><br><span class="line">		<span class="comment">/* find next rate */</span></span><br><span class="line">		opp = dev_pm_opp_find_freq_ceil(dev, &amp;rate);</span><br><span class="line">		<span class="keyword">if</span> (IS_ERR(opp)) &#123;</span><br><span class="line">			ret = PTR_ERR(opp);</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">		&#125;</span><br><span class="line">		freq_table[i].driver_data = i;</span><br><span class="line">		freq_table[i].frequency = rate / <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Is Boost/turbo opp ? */</span></span><br><span class="line">		<span class="keyword">if</span> (dev_pm_opp_is_turbo(opp))</span><br><span class="line">			freq_table[i].flags = CPUFREQ_BOOST_FREQ;</span><br><span class="line"></span><br><span class="line">		dev_pm_opp_put(opp);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	freq_table[i].driver_data = i;</span><br><span class="line">	freq_table[i].frequency = CPUFREQ_TABLE_END;</span><br><span class="line"></span><br><span class="line">	*table = &amp;freq_table[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		kfree(freq_table);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="governor初始化过程"><a href="#governor初始化过程" class="headerlink" title="governor初始化过程"></a>governor初始化过程</h5><p>cpufreq governor的初始化过程，在cpufreq_init_policy(policy)中进行，这里以ondemand为例进行分析</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/linux/cpufreq.h</span></span><br><span class="line"><span class="comment">// 内核governor描述结构体，形成链表</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cpufreq_governor</span> &#123;</span></span><br><span class="line">	<span class="keyword">char</span>	name[CPUFREQ_NAME_LEN];</span><br><span class="line">	<span class="keyword">int</span>	(*init)(struct cpufreq_policy *policy);</span><br><span class="line">	<span class="keyword">void</span>	(*<span class="built_in">exit</span>)(struct cpufreq_policy *policy);</span><br><span class="line">	<span class="keyword">int</span>	(*start)(struct cpufreq_policy *policy);</span><br><span class="line">	<span class="keyword">void</span>	(*stop)(struct cpufreq_policy *policy);</span><br><span class="line">	<span class="keyword">void</span>	(*limits)(struct cpufreq_policy *policy);</span><br><span class="line">	<span class="keyword">ssize_t</span>	(*show_setspeed)	(struct cpufreq_policy *policy,</span><br><span class="line">					 <span class="keyword">char</span> *buf);</span><br><span class="line">	<span class="keyword">int</span>	(*store_setspeed)	(struct cpufreq_policy *policy,</span><br><span class="line">					 <span class="keyword">unsigned</span> <span class="keyword">int</span> freq);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">governor_list</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">module</span>		*<span class="title">owner</span>;</span></span><br><span class="line">	u8			flags;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Common Governor data across policies */</span></span><br><span class="line"><span class="comment">// 抽象出的ondemand governor结构体</span></span><br><span class="line"><span class="comment">// drivers/cpufreq/cpufreq_governor.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dbs_governor</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cpufreq_governor</span> <span class="title">gov</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kobj_type</span> <span class="title">kobj_type</span>;</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Common data for platforms that don&#x27;t set</span></span><br><span class="line"><span class="comment">	 * CPUFREQ_HAVE_GOVERNOR_PER_POLICY</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dbs_data</span> *<span class="title">gdbs_data</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">unsigned</span> <span class="title">int</span> <span class="params">(*gov_dbs_update)</span><span class="params">(struct cpufreq_policy *policy)</span></span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">policy_dbs_info</span> *(*<span class="title">alloc</span>)(<span class="title">void</span>);</span></span><br><span class="line">	<span class="keyword">void</span> (*<span class="built_in">free</span>)(struct policy_dbs_info *policy_dbs);</span><br><span class="line">	<span class="keyword">int</span> (*init)(struct dbs_data *dbs_data);</span><br><span class="line">	<span class="keyword">void</span> (*<span class="built_in">exit</span>)(struct dbs_data *dbs_data);</span><br><span class="line">	<span class="keyword">void</span> (*start)(struct cpufreq_policy *policy);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Governor demand based switching data (per-policy or global). */</span></span><br><span class="line"><span class="comment">// ondemand计算频率使用的相关参数，包括阈值 采样率等，默认阈值是负载的80%</span></span><br><span class="line"><span class="comment">// dbs(demand based switching)按需切换</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dbs_data</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gov_attr_set</span> <span class="title">attr_set</span>;</span></span><br><span class="line">	<span class="keyword">void</span> *tuners;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> ignore_nice_load;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> sampling_rate;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> sampling_down_factor;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> up_threshold;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> io_is_busy;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Common to all CPUs of a policy */</span></span><br><span class="line"><span class="comment">// driver/cpufreq/cpufreq_governor.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">policy_dbs_info</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cpufreq_policy</span> *<span class="title">policy</span>;</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Per policy mutex that serializes load evaluation from limit-change</span></span><br><span class="line"><span class="comment">	 * and work-handler.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">update_mutex</span>;</span></span><br><span class="line"></span><br><span class="line">	u64 last_sample_time;</span><br><span class="line">	s64 sample_delay_ns;</span><br><span class="line">	<span class="keyword">atomic_t</span> work_count;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_work</span> <span class="title">irq_work</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">work</span>;</span></span><br><span class="line">	<span class="comment">/* dbs_data may be shared between multiple policy objects */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dbs_data</span> *<span class="title">dbs_data</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">	<span class="comment">/* Multiplier for increasing sample delay temporarily. */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> rate_mult;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> idle_periods;	<span class="comment">/* For conservative */</span></span><br><span class="line">	<span class="comment">/* Status indicators */</span></span><br><span class="line">	<span class="keyword">bool</span> is_shared;		<span class="comment">/* This object is used by multiple CPUs */</span></span><br><span class="line">	<span class="keyword">bool</span> work_in_progress;	<span class="comment">/* Work is being queued up or in progress */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// drivers/cpufreq/cpufreq_governor.h</span></span><br><span class="line"><span class="comment">// governor初始化宏</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CPUFREQ_DBS_GOVERNOR_INITIALIZER(_name_)			\</span></span><br><span class="line"><span class="meta">	&#123;								\</span></span><br><span class="line"><span class="meta">		.name = _name_,						\</span></span><br><span class="line"><span class="meta">		.flags = CPUFREQ_GOV_DYNAMIC_SWITCHING,			\</span></span><br><span class="line"><span class="meta">		.owner = THIS_MODULE,					\</span></span><br><span class="line"><span class="meta">		.init = cpufreq_dbs_governor_init,			\</span></span><br><span class="line"><span class="meta">		.exit = cpufreq_dbs_governor_exit,			\</span></span><br><span class="line"><span class="meta">		.start = cpufreq_dbs_governor_start,			\</span></span><br><span class="line"><span class="meta">		.stop = cpufreq_dbs_governor_stop,			\</span></span><br><span class="line"><span class="meta">		.limits = cpufreq_dbs_governor_limits,			\</span></span><br><span class="line"><span class="meta">	&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ondemand governor定义</span></span><br><span class="line"><span class="comment">// driver/cpufreq/cpufreq_ondemand.c</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">dbs_governor</span> <span class="title">od_dbs_gov</span> =</span> &#123;</span><br><span class="line">	.gov = CPUFREQ_DBS_GOVERNOR_INITIALIZER(<span class="string">&quot;ondemand&quot;</span>),</span><br><span class="line">	.kobj_type = &#123; .default_attrs = od_attributes &#125;,</span><br><span class="line">	.gov_dbs_update = od_dbs_update,</span><br><span class="line">	.alloc = od_alloc,</span><br><span class="line">	.<span class="built_in">free</span> = od_free,</span><br><span class="line">	.init = od_init,</span><br><span class="line">	.<span class="built_in">exit</span> = od_exit,</span><br><span class="line">	.start = od_start,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化governor</span></span><br><span class="line"><span class="comment">// 该函数会在governor模块驱动的入口函数调用</span></span><br><span class="line"><span class="comment">// 只要编译该模块，就会注册到cpufreq framework中</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CPU_FREQ_GOV_ONDEMAND	(od_dbs_gov.gov)</span></span><br><span class="line">cpufreq_governor_init(CPU_FREQ_GOV_ONDEMAND);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> cpufreq_governor_init(__governor)			\</span></span><br><span class="line"><span class="meta">static int __init __governor##_init(void)			\</span></span><br><span class="line"><span class="meta">&#123;								\</span></span><br><span class="line"><span class="meta">	return cpufreq_register_governor(&amp;__governor);	\</span></span><br><span class="line"><span class="meta">&#125;								\</span></span><br><span class="line"><span class="meta">core_initcall(__governor##_init)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在cpufreq_online()中调用默认governor对policy进行完善，启动当前governor</span></span><br><span class="line">cpufreq_init_policy(policy);</span><br><span class="line">	gov = get_governor(default_governor);</span><br><span class="line">	<span class="comment">// 设置新的governor</span></span><br><span class="line">	cpufreq_set_policy(policy, gov, pol);</span><br><span class="line">		cpufreq_init_governor(policy);</span><br><span class="line">			policy-&gt;governor-&gt;init();  -&gt; cpufreq_dbs_governor_init(policy);</span><br><span class="line">				gov-&gt;init(dbs_data); -&gt; odinit(dbs_data);</span><br><span class="line">		cpufreq_start_governor(policy);</span><br><span class="line">			policy-&gt;governor-&gt;start(); -&gt; cpufreq_dbs_governor_start(policy);</span><br><span class="line">				<span class="comment">// 设置governor回调函数， 以ondemand为例</span></span><br><span class="line">				gov_set_update_util(policy_dbs, sampling_rate);</span><br><span class="line">					cpufreq_add_update_util_hook(cpu, &amp;cdbs-&gt;updata_util,</span><br><span class="line">									dbs_update_util_handler);</span><br></pre></td></tr></table></figure>
<p>启动governor中比较重要的是设置调频回调函数,该函数是真正调频时计算合适频率的函数</p>
<h4 id="ondemand调节器"><a href="#ondemand调节器" class="headerlink" title="ondemand调节器"></a>ondemand调节器</h4><p>ondemand调节器也会根据当前的CPU负载来进行CPU频率计算，ondemand工作过程如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/linux/sched/cpufreq.h</span></span><br><span class="line"><span class="comment">// CPU利用率变化时会调用func重新计算频率</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">update_util_data</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> (*func)(struct update_util_data *data, u64 time, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// drivers/cpufreq/cpufreq_governor.c</span></span><br><span class="line"><span class="comment">// 设置governor回调函数update_util_data-&gt;func = dbs_update_util_handler</span></span><br><span class="line">cpufreq_dbs_governor_start()</span><br><span class="line">    gov_set_update_util(policy_dbs, sampling_rate);</span><br><span class="line">		cpufreq_add_update_util_hook(cpu, &amp;cdbs-&gt;update_util,</span><br><span class="line">                                    dbs_update_util_handler);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * cpufreq_update_util - Take a note about CPU utilization changes.</span></span><br><span class="line"><span class="comment"> * @rq: Runqueue to carry out the update for.</span></span><br><span class="line"><span class="comment"> * @flags: Update reason flags.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function is called by the scheduler on the CPU whose utilization is</span></span><br><span class="line"><span class="comment"> * being updated.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * It can only be called from RCU-sched read-side critical sections.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The way cpufreq is currently arranged requires it to evaluate the CPU</span></span><br><span class="line"><span class="comment"> * performance state (frequency/voltage) on a regular basis to prevent it from</span></span><br><span class="line"><span class="comment"> * being stuck in a completely inadequate performance level for too long.</span></span><br><span class="line"><span class="comment"> * That is not guaranteed to happen if the updates are only triggered from CFS</span></span><br><span class="line"><span class="comment"> * and DL, though, because they may not be coming in if only RT tasks are</span></span><br><span class="line"><span class="comment"> * active all the time (or there are RT tasks only).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * As a workaround for that issue, this function is called periodically by the</span></span><br><span class="line"><span class="comment"> * RT sched class to trigger extra cpufreq updates to prevent it from stalling,</span></span><br><span class="line"><span class="comment"> * but that really is a band-aid.  Going forward it should be replaced with</span></span><br><span class="line"><span class="comment"> * solutions targeted more specifically at RT tasks.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// kernel/sched/sched.h</span></span><br><span class="line"><span class="comment">// 当cpufreq_update_util()被调用时执行上面设置的回调函数update_util_data-&gt;func</span></span><br><span class="line"><span class="comment">// 为了考虑RT任务的影响，目前在RT调度中会周期性调用该函数，避免CPU频率更新不及时</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">cpufreq_update_util</span><span class="params">(struct rq *rq, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">update_util_data</span> *<span class="title">data</span>;</span></span><br><span class="line">    data = rcu_dereference_sched(*per_cpu_ptr(&amp;cpufreq_update_util_data,</span><br><span class="line">                                cpu_of(rq)));</span><br><span class="line">    <span class="keyword">if</span> (data)</span><br><span class="line">        data-&gt;func(data, rq_clock(rq), flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// drivers/cpufreq/cpufreq_governor.c</span></span><br><span class="line"><span class="comment">// data: 为了后续计算过程能够使用container_of取到cpu_dbs_info地址</span></span><br><span class="line"><span class="comment">// time: 运行队列更新的时间</span></span><br><span class="line"><span class="comment">// flags: 更新的原因标志</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dbs_update_util_handler</span><span class="params">(struct update_util_data *data, u64 time,</span></span></span><br><span class="line"><span class="params"><span class="function">				    <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cpu_dbs_info</span> *<span class="title">cdbs</span> =</span> container_of(data, struct cpu_dbs_info, update_util);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">policy_dbs_info</span> *<span class="title">policy_dbs</span> =</span> cdbs-&gt;policy_dbs;</span><br><span class="line">	u64 delta_ns, lst;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查当前工作的CPU可否对该policy对应的CPU进行调频，E2000是支持的</span></span><br><span class="line">	<span class="keyword">if</span> (!cpufreq_this_cpu_can_update(policy_dbs-&gt;policy))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The work may not be allowed to be queued up right now.</span></span><br><span class="line"><span class="comment">	 * Possible reasons:</span></span><br><span class="line"><span class="comment">	 * - Work has already been queued up or is in progress.</span></span><br><span class="line"><span class="comment">	 * - It is too early (too little time from the previous sample).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (policy_dbs-&gt;work_in_progress)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If the reads below are reordered before the check above, the value</span></span><br><span class="line"><span class="comment">	 * of sample_delay_ns used in the computation may be stale.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">// 判断更新的时间间隔，假如小于smaple_delay_ns直接返回</span></span><br><span class="line">	smp_rmb();</span><br><span class="line">	lst = READ_ONCE(policy_dbs-&gt;last_sample_time);</span><br><span class="line">	delta_ns = time - lst;</span><br><span class="line">	<span class="keyword">if</span> ((s64)delta_ns &lt; policy_dbs-&gt;sample_delay_ns)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If the policy is not shared, the irq_work may be queued up right away</span></span><br><span class="line"><span class="comment">	 * at this point.  Otherwise, we need to ensure that only one of the</span></span><br><span class="line"><span class="comment">	 * CPUs sharing the policy will do that.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">// 若policy是被多个CPU共享的，那么要判断一下是不是已经有CPU对其进行处理过了</span></span><br><span class="line">	<span class="keyword">if</span> (policy_dbs-&gt;is_shared) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!atomic_add_unless(&amp;policy_dbs-&gt;work_count, <span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * If another CPU updated last_sample_time in the meantime, we</span></span><br><span class="line"><span class="comment">		 * shouldn&#x27;t be here, so clear the work counter and bail out.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (unlikely(lst != READ_ONCE(policy_dbs-&gt;last_sample_time))) &#123;</span><br><span class="line">			atomic_set(&amp;policy_dbs-&gt;work_count, <span class="number">0</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新标志位</span></span><br><span class="line">	policy_dbs-&gt;last_sample_time = time;</span><br><span class="line">	policy_dbs-&gt;work_in_progress = <span class="literal">true</span>;</span><br><span class="line">	irq_work_queue(&amp;policy_dbs-&gt;irq_work);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// drivers/cpufreq/cpufreq_governor.c</span></span><br><span class="line"><span class="comment">// init_irq_work(&amp;policy_dbs-&gt;irq_work, dbs_irq_work)</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dbs_irq_work</span><span class="params">(struct irq_work *irq_work)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">policy_dbs_info</span> *<span class="title">policy_dbs</span>;</span></span><br><span class="line"></span><br><span class="line">	policy_dbs = container_of(irq_work, struct policy_dbs_info, irq_work);</span><br><span class="line">    <span class="comment">// 调度policy_dbs-&gt;work执行</span></span><br><span class="line">	schedule_work_on(smp_processor_id(), &amp;policy_dbs-&gt;work);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// drivers/cpufreq/cpufreq_governor.c</span></span><br><span class="line"><span class="comment">// INIT_WORK(&amp;policy_dbs-&gt;work, dbs_work_handler)</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dbs_work_handler</span><span class="params">(struct work_struct *work)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">policy_dbs_info</span> *<span class="title">policy_dbs</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cpufreq_policy</span> *<span class="title">policy</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dbs_governor</span> *<span class="title">gov</span>;</span></span><br><span class="line"></span><br><span class="line">	policy_dbs = container_of(work, struct policy_dbs_info, work);</span><br><span class="line">	policy = policy_dbs-&gt;policy;</span><br><span class="line">	gov = dbs_governor_of(policy);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Make sure cpufreq_governor_limits() isn&#x27;t evaluating load or the</span></span><br><span class="line"><span class="comment">	 * ondemand governor isn&#x27;t updating the sampling rate in parallel.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">// 调用gov-&gt;gov_dbs_update()接口</span></span><br><span class="line">	mutex_lock(&amp;policy_dbs-&gt;update_mutex);</span><br><span class="line">	gov_update_sample_delay(policy_dbs, gov-&gt;gov_dbs_update(policy));</span><br><span class="line">	mutex_unlock(&amp;policy_dbs-&gt;update_mutex);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Allow the utilization update handler to queue up more work. */</span></span><br><span class="line">	atomic_set(&amp;policy_dbs-&gt;work_count, <span class="number">0</span>);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If the update below is reordered with respect to the sample delay</span></span><br><span class="line"><span class="comment">	 * modification, the utilization update handler may end up using a stale</span></span><br><span class="line"><span class="comment">	 * sample delay value.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	smp_wmb();</span><br><span class="line">	policy_dbs-&gt;work_in_progress = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// drivers/cpufreq/cpufreq_ondemand.c</span></span><br><span class="line"><span class="comment">// ondemand回调函数，按照CPU负载计算频率</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">od_dbs_update</span><span class="params">(struct cpufreq_policy *policy)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">policy_dbs_info</span> *<span class="title">policy_dbs</span> =</span> policy-&gt;governor_data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dbs_data</span> *<span class="title">dbs_data</span> =</span> policy_dbs-&gt;dbs_data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">od_policy_dbs_info</span> *<span class="title">dbs_info</span> =</span> to_dbs_info(policy_dbs);</span><br><span class="line">	<span class="keyword">int</span> sample_type = dbs_info-&gt;sample_type;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Common NORMAL_SAMPLE setup */</span></span><br><span class="line">	dbs_info-&gt;sample_type = OD_NORMAL_SAMPLE;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * OD_SUB_SAMPLE doesn&#x27;t make sense if sample_delay_ns is 0, so ignore</span></span><br><span class="line"><span class="comment">	 * it then.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (sample_type == OD_SUB_SAMPLE &amp;&amp; policy_dbs-&gt;sample_delay_ns &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		__cpufreq_driver_target(policy, dbs_info-&gt;freq_lo,</span><br><span class="line">					CPUFREQ_RELATION_H);</span><br><span class="line">		<span class="keyword">return</span> dbs_info-&gt;freq_lo_delay_us;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	od_update(policy);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dbs_info-&gt;freq_lo) &#123;</span><br><span class="line">		<span class="comment">/* Setup SUB_SAMPLE */</span></span><br><span class="line">		dbs_info-&gt;sample_type = OD_SUB_SAMPLE;</span><br><span class="line">		<span class="keyword">return</span> dbs_info-&gt;freq_hi_delay_us;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> dbs_data-&gt;sampling_rate * policy_dbs-&gt;rate_mult;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Every sampling_rate, we check, if current idle time is less than 20%</span></span><br><span class="line"><span class="comment"> * (default), then we try to increase frequency. Else, we adjust the frequency</span></span><br><span class="line"><span class="comment"> * proportional to load.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// drivers/cpufreq/cpufreq_ondemand.c</span></span><br><span class="line"><span class="comment">// 根据CPU负载，调整频率</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">od_update</span><span class="params">(struct cpufreq_policy *policy)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">policy_dbs_info</span> *<span class="title">policy_dbs</span> =</span> policy-&gt;governor_data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">od_policy_dbs_info</span> *<span class="title">dbs_info</span> =</span> to_dbs_info(policy_dbs);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dbs_data</span> *<span class="title">dbs_data</span> =</span> policy_dbs-&gt;dbs_data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">od_dbs_tuners</span> *<span class="title">od_tuners</span> =</span> dbs_data-&gt;tuners;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> load = dbs_update(policy);</span><br><span class="line"></span><br><span class="line">	dbs_info-&gt;freq_lo = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Check for frequency increase */</span></span><br><span class="line">    <span class="comment">// 检查当前的CPU负载，负载大于80%（也可以在sysfs中设置）</span></span><br><span class="line">	<span class="keyword">if</span> (load &gt; dbs_data-&gt;up_threshold) &#123;</span><br><span class="line">		<span class="comment">/* If switching to max speed, apply sampling_down_factor */</span></span><br><span class="line">		<span class="keyword">if</span> (policy-&gt;cur &lt; policy-&gt;max)</span><br><span class="line">			policy_dbs-&gt;rate_mult = dbs_data-&gt;sampling_down_factor;</span><br><span class="line">		dbs_freq_increase(policy, policy-&gt;max);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">/* Calculate the next frequency proportional to load */</span></span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">int</span> freq_next, min_f, max_f;</span><br><span class="line"></span><br><span class="line">		min_f = policy-&gt;cpuinfo.min_freq;</span><br><span class="line">		max_f = policy-&gt;cpuinfo.max_freq;</span><br><span class="line">        <span class="comment">// 按照CPU负载计算调频频率</span></span><br><span class="line">		freq_next = min_f + load * (max_f - min_f) / <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* No longer fully busy, reset rate_mult */</span></span><br><span class="line">		policy_dbs-&gt;rate_mult = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 为了进一步节省电力，在计算出的新频率上再乘以一个powersave_bias设定的百分比</span></span><br><span class="line">        <span class="comment">// powersave_bias的值从0-1000，每一步表示0.1%</span></span><br><span class="line">		<span class="keyword">if</span> (od_tuners-&gt;powersave_bias)</span><br><span class="line">			freq_next = od_ops.powersave_bias_target(policy,</span><br><span class="line">								 freq_next,</span><br><span class="line">								 CPUFREQ_RELATION_L);</span><br><span class="line">		<span class="comment">// 频率调整</span></span><br><span class="line">		__cpufreq_driver_target(policy, freq_next, CPUFREQ_RELATION_C);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// drivers/cpufreq/cpufreq_governor.c</span></span><br><span class="line"><span class="comment">// 计算当前域CPU负载 cpu_load = 100 * (time_elapsed - idle_time) / time_elapsed</span></span><br><span class="line"><span class="comment">// 返回当前域中最大的CPU负载</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">dbs_update</span><span class="params">(struct cpufreq_policy *policy)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">policy_dbs_info</span> *<span class="title">policy_dbs</span> =</span> policy-&gt;governor_data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dbs_data</span> *<span class="title">dbs_data</span> =</span> policy_dbs-&gt;dbs_data;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> ignore_nice = dbs_data-&gt;ignore_nice_load;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> max_load = <span class="number">0</span>, idle_periods = UINT_MAX;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> sampling_rate, io_busy, j;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Sometimes governors may use an additional multiplier to increase</span></span><br><span class="line"><span class="comment">	 * sample delays temporarily.  Apply that multiplier to sampling_rate</span></span><br><span class="line"><span class="comment">	 * so as to keep the wake-up-from-idle detection logic a bit</span></span><br><span class="line"><span class="comment">	 * conservative.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	sampling_rate = dbs_data-&gt;sampling_rate * policy_dbs-&gt;rate_mult;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * For the purpose of ondemand, waiting for disk IO is an indication</span></span><br><span class="line"><span class="comment">	 * that you&#x27;re performance critical, and not that the system is actually</span></span><br><span class="line"><span class="comment">	 * idle, so do not add the iowait time to the CPU idle time then.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	io_busy = dbs_data-&gt;io_is_busy;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Get Absolute Load */</span></span><br><span class="line">    <span class="comment">// 计算当前policy中CPU的最大负载</span></span><br><span class="line">	for_each_cpu(j, policy-&gt;cpus) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">cpu_dbs_info</span> *<span class="title">j_cdbs</span> =</span> &amp;per_cpu(cpu_dbs, j);</span><br><span class="line">		u64 update_time, cur_idle_time;</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">int</span> idle_time, time_elapsed;</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">int</span> load;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取当前idle时间</span></span><br><span class="line">		cur_idle_time = get_cpu_idle_time(j, &amp;update_time, io_busy);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// time_elapsed = 本次总运行时间 - 上次总运行时间</span></span><br><span class="line">		time_elapsed = update_time - j_cdbs-&gt;prev_update_time;</span><br><span class="line">		j_cdbs-&gt;prev_update_time = update_time;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 计算本次时间间隔内的idle_time</span></span><br><span class="line">        <span class="comment">// idle_time = 本次idle时间 - 上次idle时间</span></span><br><span class="line">		idle_time = cur_idle_time - j_cdbs-&gt;prev_cpu_idle;</span><br><span class="line">		j_cdbs-&gt;prev_cpu_idle = cur_idle_time;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (ignore_nice) &#123;</span><br><span class="line">			u64 cur_nice = kcpustat_field(&amp;kcpustat_cpu(j), CPUTIME_NICE, j);</span><br><span class="line"></span><br><span class="line">			idle_time += div_u64(cur_nice - j_cdbs-&gt;prev_cpu_nice, NSEC_PER_USEC);</span><br><span class="line">			j_cdbs-&gt;prev_cpu_nice = cur_nice;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 这里主要是对各种比较罕见的情况进行临时处理</span></span><br><span class="line">		<span class="keyword">if</span> (unlikely(!time_elapsed)) &#123;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * That can only happen when this function is called</span></span><br><span class="line"><span class="comment">			 * twice in a row with a very short interval between the</span></span><br><span class="line"><span class="comment">			 * calls, so the previous load value can be used then.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			load = j_cdbs-&gt;prev_load;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (unlikely((<span class="keyword">int</span>)idle_time &gt; <span class="number">2</span> * sampling_rate &amp;&amp;</span><br><span class="line">				    j_cdbs-&gt;prev_load)) &#123;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * If the CPU had gone completely idle and a task has</span></span><br><span class="line"><span class="comment">			 * just woken up on this CPU now, it would be unfair to</span></span><br><span class="line"><span class="comment">			 * calculate &#x27;load&#x27; the usual way for this elapsed</span></span><br><span class="line"><span class="comment">			 * time-window, because it would show near-zero load,</span></span><br><span class="line"><span class="comment">			 * irrespective of how CPU intensive that task actually</span></span><br><span class="line"><span class="comment">			 * was. This is undesirable for latency-sensitive bursty</span></span><br><span class="line"><span class="comment">			 * workloads.</span></span><br><span class="line"><span class="comment">			 *</span></span><br><span class="line"><span class="comment">			 * To avoid this, reuse the &#x27;load&#x27; from the previous</span></span><br><span class="line"><span class="comment">			 * time-window and give this task a chance to start with</span></span><br><span class="line"><span class="comment">			 * a reasonably high CPU frequency. However, that</span></span><br><span class="line"><span class="comment">			 * shouldn&#x27;t be over-done, lest we get stuck at a high</span></span><br><span class="line"><span class="comment">			 * load (high frequency) for too long, even when the</span></span><br><span class="line"><span class="comment">			 * current system load has actually dropped down, so</span></span><br><span class="line"><span class="comment">			 * clear prev_load to guarantee that the load will be</span></span><br><span class="line"><span class="comment">			 * computed again next time.</span></span><br><span class="line"><span class="comment">			 *</span></span><br><span class="line"><span class="comment">			 * Detecting this situation is easy: an unusually large</span></span><br><span class="line"><span class="comment">			 * &#x27;idle_time&#x27; (as compared to the sampling rate)</span></span><br><span class="line"><span class="comment">			 * indicates this scenario.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			load = j_cdbs-&gt;prev_load;</span><br><span class="line">			j_cdbs-&gt;prev_load = <span class="number">0</span>;</span><br><span class="line">		<span class="comment">// 程序正常会运行到这里进行负载计算</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (time_elapsed &gt;= idle_time) &#123;</span><br><span class="line">				load = <span class="number">100</span> * (time_elapsed - idle_time) / time_elapsed;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">/*</span></span><br><span class="line"><span class="comment">				 * That can happen if idle_time is returned by</span></span><br><span class="line"><span class="comment">				 * get_cpu_idle_time_jiffy().  In that case</span></span><br><span class="line"><span class="comment">				 * idle_time is roughly equal to the difference</span></span><br><span class="line"><span class="comment">				 * between time_elapsed and &quot;busy time&quot; obtained</span></span><br><span class="line"><span class="comment">				 * from CPU statistics.  Then, the &quot;busy time&quot;</span></span><br><span class="line"><span class="comment">				 * can end up being greater than time_elapsed</span></span><br><span class="line"><span class="comment">				 * (for example, if jiffies_64 and the CPU</span></span><br><span class="line"><span class="comment">				 * statistics are updated by different CPUs),</span></span><br><span class="line"><span class="comment">				 * so idle_time may in fact be negative.  That</span></span><br><span class="line"><span class="comment">				 * means, though, that the CPU was busy all</span></span><br><span class="line"><span class="comment">				 * the time (on the rough average) during the</span></span><br><span class="line"><span class="comment">				 * last sampling interval and 100 can be</span></span><br><span class="line"><span class="comment">				 * returned as the load.</span></span><br><span class="line"><span class="comment">				 */</span></span><br><span class="line">				load = (<span class="keyword">int</span>)idle_time &lt; <span class="number">0</span> ? <span class="number">100</span> : <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			j_cdbs-&gt;prev_load = load;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (unlikely((<span class="keyword">int</span>)idle_time &gt; <span class="number">2</span> * sampling_rate)) &#123;</span><br><span class="line">			<span class="keyword">unsigned</span> <span class="keyword">int</span> periods = idle_time / sampling_rate;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (periods &lt; idle_periods)</span><br><span class="line">				idle_periods = periods;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 取当前policy中CPU负载最大的值</span></span><br><span class="line">		<span class="keyword">if</span> (load &gt; max_load)</span><br><span class="line">			max_load = load;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	policy_dbs-&gt;idle_periods = idle_periods;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> max_load;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="schedutil调节器"><a href="#schedutil调节器" class="headerlink" title="schedutil调节器"></a>schedutil调节器</h4><p><img src="https://raw.githubusercontent.com/JackHuang021/images/master/20230103174117.png"><br>sugov（schedutil governor）作为一种内核调频策略模块，它主要是根据当前CPU的利用率进行调频。因此，sugov会注册一个callback函数（sugov_update_shared&#x2F;sugov_update_single)到调度器负载跟踪模块，当CPU util发生变化的时候就会调用该callback函数，检查一下当前CPU频率是否和当前的CPU util匹配，如果不匹配，那么就进行升频或者降频。</p>
<p><code>sugov_tunables</code>结构体，用来描述sugov的可调参数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sugov_tunables结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sugov_tunables</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gov_attr_set</span> <span class="title">attr_set</span>;</span></span><br><span class="line">	<span class="comment">// 目前sugov只有这一个可调参数，该参数用来限制连续调频的间隔时间</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> rate_limit_us;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>sugov_policy</code>结构体，sugov为每个cluster构建了该数据结构，记录每个cluster的调频数据信息</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sugov_policy结构体，为每个簇构建了该数据结构，记录每个簇的调频数据信息</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sugov_policy</span> &#123;</span></span><br><span class="line">	<span class="comment">// 指向cpufreq framework层的policy对象</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cpufreq_policy</span>	*<span class="title">policy</span>;</span></span><br><span class="line">	<span class="comment">// sugov的可调参数</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sugov_tunables</span>	*<span class="title">tunables</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">tunables_hook</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">raw_spinlock_t</span>		update_lock;	<span class="comment">/* For shared policies */</span></span><br><span class="line">	<span class="comment">// 记录上次进行频率调整的时间点</span></span><br><span class="line">	u64			last_freq_update_time;</span><br><span class="line">	<span class="comment">// 最小调频时间间隔</span></span><br><span class="line">	s64			freq_update_delay_ns;</span><br><span class="line">	<span class="comment">// 下一个需要调整到的频率值，回调函数主要是计算这个参数</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		next_freq;</span><br><span class="line">	<span class="comment">// 根据CPU util计算出来的原始频率，在频率表中向上找最接近的频率进行调整</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		cached_raw_freq;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* The next fields are only needed if fast switch cannot be used: */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span>			<span class="title">irq_work</span> <span class="title">irq_work</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span>			<span class="title">kthread_work</span> <span class="title">work</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span>			<span class="title">mutex</span> <span class="title">work_lock</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span>			<span class="title">kthread_worker</span> <span class="title">worker</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>	*<span class="title">thread</span>;</span></span><br><span class="line">	<span class="keyword">bool</span>			work_in_progress;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">bool</span>			limits_changed;</span><br><span class="line">	<span class="keyword">bool</span>			need_freq_update;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>sugov_cpu</code>结构体，sugov为每个cpu构建了该数据结构，记录每个CPU的调频数据信息</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sugov_cpu</span> &#123;</span></span><br><span class="line">	<span class="comment">// 保存了cpu util变化后的回调函数</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">update_util_data</span>	<span class="title">update_util</span>;</span></span><br><span class="line">	<span class="comment">// 该sugov_cpu对应的sugov_policy对象</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sugov_policy</span>	*<span class="title">sg_policy</span>;</span></span><br><span class="line">	<span class="comment">// 对应的CPU id</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		cpu;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">bool</span>			iowait_boost_pending;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		iowait_boost;</span><br><span class="line">	<span class="comment">// 上一次cpu负载变化驱动调频的时间点，util更新的时间点</span></span><br><span class="line">	u64			last_update;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		bw_dl;</span><br><span class="line">	<span class="comment">// 该CPU的最大算力，即最大utilities，归一化到1024</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		max;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* The field below is for single-CPU policies only: */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NO_HZ_COMMON</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		saved_idle_calls;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>sugov初始化过程和ondemand初始化过程相似，当内核设定默认governor为sugov时，在<code>cpufreq_init_governor(policy);</code>中会调用<code>sugov_init()</code>初始化sugov，然后调用<code>sugov_start()</code>设置调频回调函数，每当CPU利用率发生变化的时候，调度器都会调用<code>cpufreq_update_util()</code>通知sugov，在<code>cpufreq_update_util()</code>被调用时，即任务调度后CPU当前的util发生变化，会调用sugov的回调函数进行调频，<code>sugov_update_shared()</code>当一个簇中有多个CPU调用该回调，遍历簇上的CPU找到当前最大util的CPU，然后根据该util映射到频率；<code>sugov_update_single()</code>即一个簇上单个CPU的情况直接根据该CPU util计算频率</p>
<p>调度事件的发生还是非常密集的，特别是在重载的情况下，很多任务可能执行若干个us就切换出去了。如果每次都计算CPU util看看是否需要调整频率，那么本身sugov就给系统带来较重的负荷，因此并非每次调频时机都会真正执行调频检查，sugov设置了一个最小调频间隔，小于这个间隔的调频请求会被过滤掉。</p>
<h5 id="schedutil频率计算过程"><a href="#schedutil频率计算过程" class="headerlink" title="schedutil频率计算过程"></a>schedutil频率计算过程</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sugov_start会遍历该sugov policy（cluster）中的所有cpu</span></span><br><span class="line"><span class="comment">// 调用cpufreq_add_update_util_hook为sugov cpu注册调频回调函数，代码逻辑如下：</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sugov_start</span><span class="params">(struct cpufreq_policy *policy)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	...</span><br><span class="line">	for_each_cpu(cpu, policy-&gt;cpus) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">sugov_cpu</span> *<span class="title">sg_cpu</span> =</span> &amp;per_cpu(sugov_cpu, cpu);</span><br><span class="line">		<span class="comment">// 设置governor 计算回调函数，cpufreq_update_util()被调用时</span></span><br><span class="line">		<span class="comment">// 即任务调度后CPU当前的util发生变化，会调用sugov的回调函数进行调频计算</span></span><br><span class="line">		cpufreq_add_update_util_hook(cpu, &amp;sg_cpu-&gt;update_util,</span><br><span class="line">					     policy_is_shared(policy) ?</span><br><span class="line">							sugov_update_shared :</span><br><span class="line">							sugov_update_single);</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// schedutil频率计算过程</span></span><br><span class="line">sugov_update_single();</span><br><span class="line">	<span class="comment">// 调频最小间隔时间检查，小于设定时间，直接返回</span></span><br><span class="line">	sugov_should_update_freq();</span><br><span class="line">	util = sugov_get_util(sg_cpuu);</span><br><span class="line">		schedutil_cpu_util(sg_cpu-&gt;cpu, util, max, FREQUENCY_UTIL, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="comment">// 根据当前CPU的util映射到具体的频率上</span></span><br><span class="line">	next_f = get_next_freq(sg_policy, util, max);</span><br><span class="line">	<span class="comment">// 调用cpufreq_driver进行调频</span></span><br><span class="line">	sugov_deferred_update(sg_policy, time, next_f);</span><br><span class="line">		__cpufreq_driver_target()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算cpu当前的utility</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">schedutil_cpu_util</span><span class="params">(<span class="keyword">int</span> cpu, <span class="keyword">unsigned</span> <span class="keyword">long</span> util_cfs,</span></span></span><br><span class="line"><span class="params"><span class="function">					<span class="keyword">unsigned</span> <span class="keyword">long</span> max, <span class="keyword">enum</span> schedutil_type type,</span></span></span><br><span class="line"><span class="params"><span class="function">					struct task_struct *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> dl_util, util, irq;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span> =</span> cpu_rq(cpu);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!uclamp_is_used() &amp;&amp;</span><br><span class="line">	    type == FREQUENCY_UTIL &amp;&amp; rt_rq_is_runnable(&amp;rq-&gt;rt)) &#123;</span><br><span class="line">		<span class="keyword">return</span> max;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果CPU处理了过多的中断服务函数，irq负载已经高过CPU最大算力，直接返回最大算力</span></span><br><span class="line">	irq = cpu_util_irq(rq);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(irq &gt;= max))</span><br><span class="line">		<span class="keyword">return</span> max;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 累加了cfs和rt任务的utility</span></span><br><span class="line">	util = util_cfs + cpu_util_rt(rq);</span><br><span class="line">	<span class="keyword">if</span> (type == FREQUENCY_UTIL)</span><br><span class="line">		util = uclamp_rq_util_with(rq, util, p);</span><br><span class="line"></span><br><span class="line">	dl_util = cpu_util_dl(rq);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (util + dl_util &gt;= max)</span><br><span class="line">		<span class="keyword">return</span> max;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * OTOH, for energy computation we need the estimated running time, so</span></span><br><span class="line"><span class="comment">	 * include util_dl and ignore dl_bw.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (type == ENERGY_UTIL)</span><br><span class="line">		util += dl_util;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * There is still idle time; further improve the number by using the</span></span><br><span class="line"><span class="comment">	 * irq metric. Because IRQ/steal time is hidden from the task clock we</span></span><br><span class="line"><span class="comment">	 * need to scale the task numbers:</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 *              max - irq</span></span><br><span class="line"><span class="comment">	 *   U&#x27; = irq + --------- * U</span></span><br><span class="line"><span class="comment">	 *                 max</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">// irq会偷走一部分的cpu算力，从而让其capacity没有那么大。</span></span><br><span class="line">	<span class="comment">// 这里通过scale_irq_capacity对任务的utility进行调整</span></span><br><span class="line">	util = scale_irq_capacity(util, irq, max);</span><br><span class="line">	util += irq;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Bandwidth required by DEADLINE must always be granted while, for</span></span><br><span class="line"><span class="comment">	 * FAIR and RT, we use blocked utilization of IDLE CPUs as a mechanism</span></span><br><span class="line"><span class="comment">	 * to gracefully reduce the frequency when no tasks show up for longer</span></span><br><span class="line"><span class="comment">	 * periods of time.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Ideally we would like to set bw_dl as min/guaranteed freq and util +</span></span><br><span class="line"><span class="comment">	 * bw_dl as requested freq. However, cpufreq is not yet ready for such</span></span><br><span class="line"><span class="comment">	 * an interface. So, we only do the latter for now.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (type == FREQUENCY_UTIL)</span><br><span class="line">		util += cpu_bw_dl(rq);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> min(max, util);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据当前CPU计算的util映射对应频率</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">get_next_freq</span><span class="params">(struct sugov_policy *sg_policy,</span></span></span><br><span class="line"><span class="params"><span class="function">				  <span class="keyword">unsigned</span> <span class="keyword">long</span> util, <span class="keyword">unsigned</span> <span class="keyword">long</span> max)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cpufreq_policy</span> *<span class="title">policy</span> =</span> sg_policy-&gt;policy;</span><br><span class="line">	<span class="comment">// 先取得当前CPU的最大频率</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> freq = arch_scale_freq_invariant() ?</span><br><span class="line">				policy-&gt;cpuinfo.max_freq : policy-&gt;cur;</span><br><span class="line">	<span class="comment">// 计算当前util对应频率，计算公式: freq = (1.25) * freq * util / max</span></span><br><span class="line">	<span class="comment">// 这里冗余了25%的算力余量</span></span><br><span class="line">	freq = map_util_freq(util, freq, max);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 若计算出的freq和上次缓存的一样，则实际调整的next_freq计算后肯定也是一样的，直接返回</span></span><br><span class="line">	<span class="comment">// 上次记录的频率值</span></span><br><span class="line">	<span class="keyword">if</span> (freq == sg_policy-&gt;cached_raw_freq &amp;&amp; !sg_policy-&gt;need_freq_update)</span><br><span class="line">		<span class="keyword">return</span> sg_policy-&gt;next_freq;</span><br><span class="line"></span><br><span class="line">	sg_policy-&gt;cached_raw_freq = freq;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 根据当前算的freq，在CPU频率表上查找对应的频率</span></span><br><span class="line">	freq = cpufreq_driver_resolve_freq(policy, freq);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> freq;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="EAS能源感知调度"><a href="#EAS能源感知调度" class="headerlink" title="EAS能源感知调度"></a>EAS能源感知调度</h3><h4 id="EAS整体框架"><a href="#EAS整体框架" class="headerlink" title="EAS整体框架"></a>EAS整体框架</h4><p><img src="https://raw.githubusercontent.com/JackHuang021/images/master/20221216104706.png"></p>
<p>完全公平调度（Completely Fair Scheduler CFS）实现了面向吞吐量的的任务调度策略，EAS为这个调度器添加了一个基于能耗的调度策略，在优化CPU算力冗余的同时实现了节能，EAS在系统中、低度负载情况下工作，CFS在系统满负载情况下工作。</p>
<p>EAS在CPU调度领域，在为任务选核是起作用，目的是保证性能的情况下尽可能节省功耗，EAS涉及内核的几个子系统（任务调度、能源管理、CPU动态调频），EAS代码主要位于<code>kernel/sched/fair.c</code>，能源感知的任务调度需要调度器评估各个任务在CPU上运行带来的能耗影响</p>
<p>EAS全局控制开关<code>/proc/sys/kernel/sched_energy_aware</code></p>
<h4 id="CPU算力归一化过程"><a href="#CPU算力归一化过程" class="headerlink" title="CPU算力归一化过程"></a>CPU算力归一化过程</h4><p>当前，Linux无法凭自身算出CPU算力，因此必须要有把这个信息传递给Linux的方式，它是从<code>capacity-dmips-mhz</code> CPU 设备树binding中衍生计算出来的</p>
<p>归一化CPU capacity，<code>topology_normalize_cpu_scale()</code>定义在<code>drivers/base/arch_topology()</code>，这个capacity在schedutil调度中被<code>sugov_get_util()</code>函数读取</p>
<p><code>topology_normalize_cpu_scale()</code>在CPU初始化<code>parse_dt_topology()</code>中被调用，capacity归一化的前提条件是需要在设备树中CPU节点设置<code>capacity-dmips-mhz</code>属性，该属性表示不同CPU的计算能力，内核读取该属性设置CPU的<code>raw_capacity</code>为<code>capacity-dmips-mhz</code>，参考内核文档<code>Documentation/devicetree/bindings/arm/cpu-capacity.txt</code></p>
<blockquote>
<p>ARM推荐的测试CPU的性能工具：Dhrystone 2.1以上版本，可以通过单核跑分成绩作为<code>capacity-dmips-mhz</code>属性的参考，DMIPS： Dhrystone Million Instructions executed Per Second，表示了在Dhrystone这样一种测试方法下的MIPS，Dhrystone是一种整数运算测试程序。MIPS&#x2F;MHz，就是说每MHz频率能产生多大的MIPS，CPU性能通常由每秒百万指令（Millions of Instructions Per Second，MIPS）表示，设备树里表示为dmips&#x2F;mhz</p>
</blockquote>
<p>CPU算力归一化公式，并不是简单的将capacity-dmips-mhz归一化到capacity，CPU的频率也参与到了计算中<br><code> capacity = (own(capacity-dmips-mhz) * own(max_freq)) / (max(capacity-dmips-mhz) * max(max_freq)) * 1024</code></p>
<p>根据测试部测试的E2000QCPU单核性能数据，E2000Q的<code>capacity-dmips-mhz</code>属性值可以设置为如下，放大1000倍：<br><img src="https://raw.githubusercontent.com/JackHuang021/images/master/20230105152415.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 小核</span></span><br><span class="line">cpu_l0: cpu@<span class="number">0</span> &#123;</span><br><span class="line">	...</span><br><span class="line">	capacity-dmips-mhz = &lt;<span class="number">2850</span>&gt;;</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 大核</span></span><br><span class="line">cpu_b0: cpu@<span class="number">0</span> &#123;</span><br><span class="line">	...</span><br><span class="line">	capacity-dmips-mhz = &lt;<span class="number">5660</span>&gt;;</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>实际经过CPU算力归一化到1024之后，对应的小核CPU算力为386，大核为1024</p>
<h4 id="EAS代码相关结构体"><a href="#EAS代码相关结构体" class="headerlink" title="EAS代码相关结构体"></a>EAS代码相关结构体</h4><p>perf_domain结构表示一个CPU性能域，perf_domain和cpufreq_policy是一一对应的，性能域之间形成链，链表头存放在root_domian中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/sched/sched.h</span></span><br><span class="line"><span class="comment">// perf_comain 结构表示一个CPU性能域，perf_domain和cpufreq_policy是一一对应的</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">perf_domain</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">em_perf_domain</span> *<span class="title">em_pd</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">perf_domain</span> *<span class="title">next</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// cpumask_var_t解析</span></span><br><span class="line"><span class="comment">// include/uapi/linux/kernel.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __KERNEL_DIV_ROUND_UP(n, d) ((((n) + (d)) - 1) / (d))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// include/linux/kernel.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DIV_ROUND_UP	__KERNEL_DIV_ROUND_UP</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// include/linux/bits.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BITS_PER_BYTE 	8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// include/linux/bitops.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BITS_PER_TYPE(type) (sizeof(type) * BITS_PER_BYTE)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BITS_TO_LONGS(nr)	DIV_ROUND_UP(nr, BITS_PER_TYPE(long))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// include/linux/types.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DECLARE_BITMAP(name, bits) \</span></span><br><span class="line"><span class="meta">	unsigned long name[BITS_TO_LONGS(bits)]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// include/linux/threads.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_NR_CPUS 256</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NR_CPUS		CONFIG_NR_CPUS</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// include/linux/cpumask.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">cpumask</span> &#123;</span> DECLARE_BITMAP(bits, NR_CPUS); &#125; <span class="keyword">cpumask_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">cpumask</span> <span class="title">cpumask_var_t</span>[1];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 展开cpumask</span></span><br><span class="line"><span class="comment">// 该结构体用来表示当前系统中CPU的状态，每个CPU对应其中一位</span></span><br><span class="line"><span class="comment">// 这里内核配置最大支持256个CPU，所以定义了一个长度为4的long数组</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">cpumask</span> &#123;</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	unsigned long bits[BITS_TO_LONGS(256)];</span></span><br><span class="line"><span class="comment">	unsigned long bits[DIV_ROUND_UP(256, 64)];</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> bits[<span class="number">4</span>];</span><br><span class="line">&#125; <span class="keyword">cpumask_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// root_domain代表CPU性能域的一个总体数据结构，管理这些性能域</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">root_domain</span> &#123;</span></span><br><span class="line">	<span class="keyword">atomic_t</span>		refcount;</span><br><span class="line">	<span class="keyword">atomic_t</span>		rto_count;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span>		<span class="title">rcu</span>;</span></span><br><span class="line">	<span class="keyword">cpumask_var_t</span>		span;</span><br><span class="line">	<span class="keyword">cpumask_var_t</span>		online;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 该root_domain是否处于overload状态</span></span><br><span class="line">	<span class="keyword">int</span>			overload;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 该root_domain是否处于overutilized状态</span></span><br><span class="line">	<span class="keyword">int</span>			overutilized;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The bit corresponding to a CPU gets set here if such CPU has more</span></span><br><span class="line"><span class="comment">	 * than one runnable -deadline task (as it is below for RT tasks).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">cpumask_var_t</span>		dlo_mask;</span><br><span class="line">	<span class="keyword">atomic_t</span>		dlo_count;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dl_bw</span>		<span class="title">dl_bw</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cpudl</span>		<span class="title">cpudl</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_RT_PUSH_IPI</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * For IPI pull requests, loop across the rto_mask.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_work</span>		<span class="title">rto_push_work</span>;</span></span><br><span class="line">	<span class="keyword">raw_spinlock_t</span>		rto_lock;</span><br><span class="line">	<span class="comment">/* These are only updated and read within rto_lock */</span></span><br><span class="line">	<span class="keyword">int</span>			rto_loop;</span><br><span class="line">	<span class="keyword">int</span>			rto_cpu;</span><br><span class="line">	<span class="comment">/* These atomics are updated outside of a lock */</span></span><br><span class="line">	<span class="keyword">atomic_t</span>		rto_loop_next;</span><br><span class="line">	<span class="keyword">atomic_t</span>		rto_loop_start;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The &quot;RT overload&quot; flag: it gets set if a CPU has more than</span></span><br><span class="line"><span class="comment">	 * one runnable RT task.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">cpumask_var_t</span>		rto_mask;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cpupri</span>		<span class="title">cpupri</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 系统中算力最大的CPU的算力</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		max_cpu_capacity;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * NULL-terminated list of performance domains intersecting with the</span></span><br><span class="line"><span class="comment">	 * CPUs of the rd. Protected by RCU.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">// perf_domain单链表的表头</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">perf_domain</span> __<span class="title">rcu</span> *<span class="title">pd</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// include/linux/energy_model.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">em_perf_state</span> &#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> frequency;	<span class="comment">// CPU频点，单位KHz</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> power;		<span class="comment">// 此频点下的功耗</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> cost;			<span class="comment">// 此频点下的成本系数，等于 power * max_freq / freq</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">em_perf_domain</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">em_perf_state</span> *<span class="title">table</span>;</span>	<span class="comment">// CPU频点表</span></span><br><span class="line">	<span class="keyword">int</span> nr_perf_states;				<span class="comment">// 频点表中元素的个数</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> cpus[];			<span class="comment">// 此性能域中包括哪些CPU</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="perf-domain初始化"><a href="#perf-domain初始化" class="headerlink" title="perf_domain初始化"></a>perf_domain初始化</h4><p>start_kernel() -&gt; sched_init() -&gt; init_defrootdomain()</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/sched/core.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> __init <span class="title">sched_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">	<span class="comment">// 这里只是一些简单的初始化</span></span><br><span class="line">	init_defrootdmain();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// include/linux/bitmap.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> small_const_nbits(nbits) \</span></span><br><span class="line"><span class="meta">	(__builtin_constant_p(nbits) &amp;&amp; (nbits) <span class="meta-string">&lt;= BITS_PER_LONG &amp;&amp; (nbits) &gt;</span> 0)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> __always_inline <span class="keyword">int</span> <span class="title">bitmap_weight</span><span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> *src,</span></span></span><br><span class="line"><span class="params"><span class="function">								<span class="keyword">unsigned</span> <span class="keyword">int</span> nbits)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 这个条件不满足，直接执行下面的__bitmap_weight()</span></span><br><span class="line">	<span class="keyword">if</span> (small_const_nbits(nbits))</span><br><span class="line">		<span class="keyword">return</span> hweight_long(*src &amp; BITMAP_LAST_WORD_MASK(nbits));</span><br><span class="line">	<span class="comment">// 这里传入的src实际就是所有CPU状态位</span></span><br><span class="line">	<span class="keyword">return</span> __bitmap_weight(src, nbits);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// lib/bitmap.c</span></span><br><span class="line"><span class="keyword">int</span> __bitmap_weight(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> *bitmap, <span class="keyword">unsigned</span> <span class="keyword">int</span> bits)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> k, lim = bits/BITS_PER_LONG;</span><br><span class="line">	<span class="keyword">int</span> w = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; lim; k++)</span><br><span class="line">		w += hweight_long(bitmap[k]);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (bits % BITS_PER_LONG)</span><br><span class="line">		w += hweight_long(bitmap[k] &amp; BITMAP_LAST_WORD_MASK(bits));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// include/linux/bitops.h</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> __always_inline <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">hweight_long</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">sizeof</span>(w) == <span class="number">4</span> ? hweight32(w) : hweight64((__64)w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// include/asm-generic/bitops/const_hweight.h</span></span><br><span class="line"><span class="comment">// __builtin_constant_p(w) gcc的内建函数</span></span><br><span class="line"><span class="comment">// 如果w的值在编译时能确定，那么该函数返回值为1</span></span><br><span class="line"><span class="comment">// 这里传入的bitmap[k]不是常量，计算走__arch_hweight64()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> hweight64(w) (__builtin_constant_p(w) ? \</span></span><br><span class="line"><span class="meta">			__const_hweight64(w) : __arch_hweight64(w))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// include/asm-generic/bitops/arch_hweight.h</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> __arch_hweight64(u64 w)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> __sw_hweight64(w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// lib/weight.c</span></span><br><span class="line"><span class="comment">// 统计给定数字w中值为1的bit位个数</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> __sw_hweight64(__u64 w)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> BITS_PER_LONG == 32</span></span><br><span class="line">	<span class="keyword">return</span> __sw_hweight32((<span class="keyword">unsigned</span> <span class="keyword">int</span>)(w &gt;&gt; <span class="number">32</span>)) +</span><br><span class="line">	       __sw_hweight32((<span class="keyword">unsigned</span> <span class="keyword">int</span>)w);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> BITS_PER_LONG == 64</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_ARCH_HAS_FAST_MULTIPLIER</span></span><br><span class="line">	w -= (w &gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x5555555555555555</span>ul;</span><br><span class="line">	w =  (w &amp; <span class="number">0x3333333333333333</span>ul) + ((w &gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x3333333333333333</span>ul);</span><br><span class="line">	w =  (w + (w &gt;&gt; <span class="number">4</span>)) &amp; <span class="number">0x0f0f0f0f0f0f0f0f</span>ul;</span><br><span class="line">	<span class="keyword">return</span> (w * <span class="number">0x0101010101010101</span>ul) &gt;&gt; <span class="number">56</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	__u64 res = w - ((w &gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x5555555555555555</span>ul);</span><br><span class="line">	res = (res &amp; <span class="number">0x3333333333333333</span>ul) + ((res &gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x3333333333333333</span>ul);</span><br><span class="line">	res = (res + (res &gt;&gt; <span class="number">4</span>)) &amp; <span class="number">0x0F0F0F0F0F0F0F0F</span>ul;</span><br><span class="line">	res = res + (res &gt;&gt; <span class="number">8</span>);</span><br><span class="line">	res = res + (res &gt;&gt; <span class="number">16</span>);</span><br><span class="line">	<span class="keyword">return</span> (res + (res &gt;&gt; <span class="number">32</span>)) &amp; <span class="number">0x00000000000000FF</span>ul;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(__sw_hweight64);</span><br><span class="line"></span><br><span class="line"><span class="comment">// include/linux/cpumask.h</span></span><br><span class="line"><span class="comment">// cpumask_weight()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> nr_cpumask_bits		((unsigned int)NR_CPUS)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> cpumask_bits(maskp)	((maskp)-&gt;bits)							</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">cpumask_weight</span><span class="params">(<span class="keyword">const</span> struct cpumask *srcp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> bitmap_weight(cpumask_bits(srcp), nr_cpumask_bits);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// kernel/sched/topology.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">build_perf_domains</span><span class="params">(<span class="keyword">const</span> struct cpumask *cpu_map)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 这里nr_cpus即统计cpu_map里面当前CPU的个数</span></span><br><span class="line">	<span class="keyword">int</span> i, nr_pd = <span class="number">0</span>, nr_ps = <span class="number">0</span>, nr_cpus = cpumask_weight(cpu_map);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">perf_domain</span> *<span class="title">pd</span> =</span> <span class="literal">NULL</span>, *tmp;</span><br><span class="line">	<span class="keyword">int</span> cpu = cpumask_first(cpu_map);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">root_domain</span> *<span class="title">rd</span> =</span> cpu_rq(cpu)-&gt;rd;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cpufreq_policy</span> *<span class="title">policy</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cpufreq_governor</span> *<span class="title">gov</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!sysctl_sched_energy_aware)</span><br><span class="line">		<span class="keyword">goto</span> <span class="built_in">free</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* EAS is enabled for asymmetric CPU capacity topologies. */</span></span><br><span class="line">	<span class="keyword">if</span> (!per_cpu(sd_asym_cpucapacity, cpu)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (sched_debug()) &#123;</span><br><span class="line">			pr_info(<span class="string">&quot;rd %*pbl: CPUs do not have asymmetric capacities\n&quot;</span>,</span><br><span class="line">					cpumask_pr_args(cpu_map));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">goto</span> <span class="built_in">free</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* EAS definitely does *not* handle SMT */</span></span><br><span class="line">	<span class="keyword">if</span> (sched_smt_active()) &#123;</span><br><span class="line">		pr_warn(<span class="string">&quot;rd %*pbl: Disabling EAS, SMT is not supported\n&quot;</span>,</span><br><span class="line">			cpumask_pr_args(cpu_map));</span><br><span class="line">		<span class="keyword">goto</span> <span class="built_in">free</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	for_each_cpu(i, cpu_map) &#123;</span><br><span class="line">		<span class="comment">/* Skip already covered CPUs. */</span></span><br><span class="line">		<span class="keyword">if</span> (find_pd(pd, i))</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Do not attempt EAS if schedutil is not being used. */</span></span><br><span class="line">		policy = cpufreq_cpu_get(i);</span><br><span class="line">		<span class="keyword">if</span> (!policy)</span><br><span class="line">			<span class="keyword">goto</span> <span class="built_in">free</span>;</span><br><span class="line">		gov = policy-&gt;governor;</span><br><span class="line">		cpufreq_cpu_put(policy);</span><br><span class="line">		<span class="keyword">if</span> (gov != &amp;schedutil_gov) &#123;</span><br><span class="line">			<span class="keyword">if</span> (rd-&gt;pd)</span><br><span class="line">				pr_warn(<span class="string">&quot;rd %*pbl: Disabling EAS, schedutil is mandatory\n&quot;</span>,</span><br><span class="line">						cpumask_pr_args(cpu_map));</span><br><span class="line">			<span class="keyword">goto</span> <span class="built_in">free</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Create the new pd and add it to the local list. */</span></span><br><span class="line">		tmp = pd_init(i);</span><br><span class="line">		<span class="keyword">if</span> (!tmp)</span><br><span class="line">			<span class="keyword">goto</span> <span class="built_in">free</span>;</span><br><span class="line">		tmp-&gt;next = pd;</span><br><span class="line">		pd = tmp;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Count performance domains and performance states for the</span></span><br><span class="line"><span class="comment">		 * complexity check.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		nr_pd++;</span><br><span class="line">		nr_ps += em_pd_nr_perf_states(pd-&gt;em_pd);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Bail out if the Energy Model complexity is too high. */</span></span><br><span class="line">	<span class="keyword">if</span> (nr_pd * (nr_ps + nr_cpus) &gt; EM_MAX_COMPLEXITY) &#123;</span><br><span class="line">		WARN(<span class="number">1</span>, <span class="string">&quot;rd %*pbl: Failed to start EAS, EM complexity is too high\n&quot;</span>,</span><br><span class="line">						cpumask_pr_args(cpu_map));</span><br><span class="line">		<span class="keyword">goto</span> <span class="built_in">free</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	perf_domain_debug(cpu_map, pd);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Attach the new list of performance domains to the root domain. */</span></span><br><span class="line">	tmp = rd-&gt;pd;</span><br><span class="line">	rcu_assign_pointer(rd-&gt;pd, pd);</span><br><span class="line">	<span class="keyword">if</span> (tmp)</span><br><span class="line">		call_rcu(&amp;tmp-&gt;rcu, destroy_perf_domain_rcu);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> !!pd;</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>:</span><br><span class="line">	free_pd(pd);</span><br><span class="line">	tmp = rd-&gt;pd;</span><br><span class="line">	rcu_assign_pointer(rd-&gt;pd, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (tmp)</span><br><span class="line">		call_rcu(&amp;tmp-&gt;rcu, destroy_perf_domain_rcu);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>E2000Q 5.10内核，perf_domain_debug 打印信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[    2.574534] root_domain 0-3: pd3:&#123; cpus=3 nr_pstate=4 &#125;</span><br><span class="line">[    2.574540] freq: 250000, power: 79, cost: 632</span><br><span class="line">[    2.579072] freq: 500000, power: 197, cost: 788</span><br><span class="line">[    2.583690] freq: 1000000, power: 409, cost: 818</span><br><span class="line">[    2.588390] freq: 2000000, power: 839, cost: 839</span><br><span class="line">[    2.593094]  pd2:&#123; cpus=2 nr_pstate=4 &#125;</span><br><span class="line">[    2.593096] freq: 250000, power: 79, cost: 632</span><br><span class="line">[    2.601445] freq: 500000, power: 197, cost: 788</span><br><span class="line">[    2.606054] freq: 1000000, power: 409, cost: 818</span><br><span class="line">[    2.610749] freq: 2000000, power: 839, cost: 839</span><br><span class="line">[    2.615445]  pd0:&#123; cpus=0-1 nr_pstate=4 &#125;</span><br><span class="line">[    2.615447] freq: 187500, power: 1, cost: 8</span><br><span class="line">[    2.623709] freq: 375000, power: 9, cost: 36</span><br><span class="line">[    2.628058] freq: 750000, power: 55, cost: 110</span><br><span class="line">[    2.632579] freq: 1500000, power: 125, cost: 125</span><br></pre></td></tr></table></figure>

<p>root_domain的overload和overutilized说明：</p>
<ul>
<li>对于一个 CPU 而言，其处于 overload 状态则说明其 rq 上有大于等于2个任务，或者虽然只有一个任务，但是是 misfit task</li>
<li>对于一个 CPU 而言，其处于 overutilized 状态说明该 cpu 的 utility 超过其 capacity（缺省预留20%的算力，另外，这里的 capacity 是用于cfs任务的算力）</li>
<li>对于 root domain，overload 表示至少有一个 cpu 处于 overload 状态。overutilized 表示至少有一个 cpu 处于 overutilized 状态</li>
<li>overutilized 状态非常重要，它决定了调度器是否启用EAS，只有在系统没有 overutilized 的情况下EAS才会生效。overload和newidle balance的频次控制相关，当系统在overload的情况下，newidle balance才会启动进行均衡。</li>
</ul>
<h4 id="EAS能量计算方法"><a href="#EAS能量计算方法" class="headerlink" title="EAS能量计算方法"></a>EAS能量计算方法</h4><p>CPU在某个performance state(ps)下的计算能力：<br>ps-&gt;cap &#x3D; ps-&gt;freq * scale_cpu &#x2F; cpu_max_freq	（1）</p>
<p>CPU在该频点performace state(ps)下的能量消耗：<br>cpu_nrg &#x3D; ps-&gt;power * cpu_util &#x2F; ps-&gt;cap  （2）</p>
<p>结合(1) (2)可以得出CPU在该ps下的能量消耗<br>    cpu_nrg &#x3D; ps-&gt;power * cpu_max_freq * cpu_util &#x2F; ps-&gt;freq * scale_cpu (3)</p>
<p>其中 ps-&gt;power * cpu_max_freq &#x2F; ps-&gt;freq 是一个固定数据存放在频点表的cost成员中</p>
<p>一个pd内的CPU，拥有相同的cost，所以一个pd内所有CPU的能量消耗可以表示为<br>pd_nrg &#x3D; ps-&gt;cost * sum(cpu_util) &#x2F; scale_cpu</p>
<h4 id="EAS的调度过程"><a href="#EAS的调度过程" class="headerlink" title="EAS的调度过程"></a>EAS的调度过程</h4><p>在任务被重新唤醒或者fork新建时，会通过<code>select_task_rq_fair()</code>将任务进行balance，达到充分利用CPU的目的。在<code>select_task_rq_fair()</code>，若任务是被重新唤醒就会调用<code>find_energy_efficient_cpu()</code>进行选核执行</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Predicts what cpu_util(@cpu) would return if @p was migrated (and enqueued)</span></span><br><span class="line"><span class="comment"> * to @dst_cpu.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">cpu_util_next</span><span class="params">(<span class="keyword">int</span> cpu, struct task_struct *p, <span class="keyword">int</span> dst_cpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cfs_rq</span> *<span class="title">cfs_rq</span> =</span> &amp;cpu_rq(cpu)-&gt;cfs;</span><br><span class="line">	<span class="comment">// 计算cfs的util</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> util_est, util = READ_ONCE(cfs_rq-&gt;avg.util_avg);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If @p migrates from @cpu to another, remove its contribution. Or,</span></span><br><span class="line"><span class="comment">	 * if @p migrates from another CPU to @cpu, add its contribution. In</span></span><br><span class="line"><span class="comment">	 * the other cases, @cpu is not impacted by the migration, so the</span></span><br><span class="line"><span class="comment">	 * util_avg should already be correct.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">// 在dst_cpu为-1的情况下</span></span><br><span class="line">	<span class="comment">// 若任务p运行在传入的CPU util = cfs_util - task_util(p)</span></span><br><span class="line">	<span class="keyword">if</span> (task_cpu(p) == cpu &amp;&amp; dst_cpu != cpu)</span><br><span class="line">		sub_positive(&amp;util, task_util(p));</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (task_cpu(p) != cpu &amp;&amp; dst_cpu == cpu)</span><br><span class="line">		util += task_util(p);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (sched_feat(UTIL_EST)) &#123;</span><br><span class="line">		util_est = READ_ONCE(cfs_rq-&gt;avg.util_est.enqueued);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * During wake-up, the task isn&#x27;t enqueued yet and doesn&#x27;t</span></span><br><span class="line"><span class="comment">		 * appear in the cfs_rq-&gt;avg.util_est.enqueued of any rq,</span></span><br><span class="line"><span class="comment">		 * so just add it (if needed) to &quot;simulate&quot; what will be</span></span><br><span class="line"><span class="comment">		 * cpu_util() after the task has been enqueued.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (dst_cpu == cpu)</span><br><span class="line">			util_est += _task_util_est(p);</span><br><span class="line"></span><br><span class="line">		util = max(util, util_est);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> min(util, capacity_orig_of(cpu));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * compute_energy(): Estimates the energy that @pd would consume if @p was</span></span><br><span class="line"><span class="comment"> * migrated to @dst_cpu. compute_energy() predicts what will be the utilization</span></span><br><span class="line"><span class="comment"> * landscape of @pd&#x27;s CPUs after the task migration, and uses the Energy Model</span></span><br><span class="line"><span class="comment"> * to compute what would be the energy if we decided to actually migrate that</span></span><br><span class="line"><span class="comment"> * task.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 计算任务迁移到dst_cpu后，整个pd，即此cluster的energy</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span></span></span><br><span class="line"><span class="function"><span class="title">compute_energy</span><span class="params">(struct task_struct *p, <span class="keyword">int</span> dst_cpu, struct perf_domain *pd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cpumask</span> *<span class="title">pd_mask</span> =</span> perf_domain_span(pd);</span><br><span class="line">	<span class="comment">// 获取该CPU的算力，这里取得的是归一化到1024的算力</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> cpu_cap = arch_scale_cpu_capacity(cpumask_first(pd_mask));</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> max_util = <span class="number">0</span>, sum_util = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> cpu;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 对此pd中每个online cpu都执行计算</span></span><br><span class="line">	for_each_cpu_and(cpu, pd_mask, cpu_online_mask) &#123;</span><br><span class="line">		<span class="comment">// 这里计算util_cfs，当dst_cpu传入为-1时，这里是没将p的util计算进去的</span></span><br><span class="line">		<span class="comment">// 这个地方比较关键，p的util有没有算到cpu的util里面去是在这一步决定的</span></span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> cpu_util, util_cfs = cpu_util_next(cpu, p, dst_cpu);</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">tsk</span> =</span> cpu == dst_cpu ? p : <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 返回该CPU下cfs+irq+rt+dl使用掉的CPU算力总和</span></span><br><span class="line">		<span class="comment">// 这一步计算没将任务p的util加进去</span></span><br><span class="line">		sum_util += schedutil_cpu_util(cpu, util_cfs, cpu_cap,</span><br><span class="line">					       ENERGY_UTIL, <span class="literal">NULL</span>);</span><br><span class="line">		<span class="comment">// 这一步计算将任务p的util加进去了</span></span><br><span class="line">		<span class="comment">// 这里计算cpu_util的原因就是需要预测下一次该perf_domain的频率</span></span><br><span class="line">		<span class="comment">// 计算的cpu_util是略微放大了的，需要进一步分析这个放大的操作</span></span><br><span class="line">		cpu_util = schedutil_cpu_util(cpu, util_cfs, cpu_cap,</span><br><span class="line">					      FREQUENCY_UTIL, tsk);</span><br><span class="line">		max_util = max(max_util, cpu_util);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 计算该pd下所有CPU的功耗和</span></span><br><span class="line">	<span class="keyword">return</span> em_cpu_energy(pd-&gt;em_pd, max_util, sum_util);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算该pd下所有CPU的功耗和</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">em_cpu_energy</span><span class="params">(struct em_perf_domain *pd,</span></span></span><br><span class="line"><span class="params"><span class="function">				<span class="keyword">unsigned</span> <span class="keyword">long</span> max_util, <span class="keyword">unsigned</span> <span class="keyword">long</span> sum_util)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> freq, scale_cpu;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">em_perf_state</span> *<span class="title">ps</span>;</span></span><br><span class="line">	<span class="keyword">int</span> i, cpu;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * In order to predict the performance state, map the utilization of</span></span><br><span class="line"><span class="comment">	 * the most utilized CPU of the performance domain to a requested</span></span><br><span class="line"><span class="comment">	 * frequency, like schedutil.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	cpu = cpumask_first(to_cpumask(pd-&gt;cpus));</span><br><span class="line">	scale_cpu = arch_scale_cpu_capacity(cpu);</span><br><span class="line">	ps = &amp;pd-&gt;table[pd-&gt;nr_perf_states - <span class="number">1</span>];</span><br><span class="line">	<span class="comment">// 这里将perf_domai计算出来的最大的CPU利用率来推测CPU接下来需要调频的频率</span></span><br><span class="line">	<span class="comment">// 这里可以将freq称为推测频率</span></span><br><span class="line">	<span class="comment">// 计算公式 freq = 1.25 * max_f * max_util / scale_cpu</span></span><br><span class="line">	<span class="comment">// 这里是在最大频率1.25倍进行计算的</span></span><br><span class="line">	freq = map_util_freq(max_util, ps-&gt;frequency, scale_cpu);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Find the lowest performance state of the Energy Model above the</span></span><br><span class="line"><span class="comment">	 * requested frequency.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">// 将该频率映射到频率表上</span></span><br><span class="line">	<span class="comment">// 因为freq是在1.5倍最大频率计算的，算出来的推测频率可能大于最大频率</span></span><br><span class="line">	<span class="comment">// 假如大于最大频率的话，for循环执行后ps指向的就是最大频率了</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; pd-&gt;nr_perf_states; i++) &#123;</span><br><span class="line">		ps = &amp;pd-&gt;table[i];</span><br><span class="line">		<span class="keyword">if</span> (ps-&gt;frequency &gt;= freq)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The capacity of a CPU in the domain at the performance state (ps)</span></span><br><span class="line"><span class="comment">	 * can be computed as:</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 *             ps-&gt;freq * scale_cpu</span></span><br><span class="line"><span class="comment">	 *   ps-&gt;cap = --------------------                          (1)</span></span><br><span class="line"><span class="comment">	 *                 cpu_max_freq</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * So, ignoring the costs of idle states (which are not available in</span></span><br><span class="line"><span class="comment">	 * the EM), the energy consumed by this CPU at that performance state</span></span><br><span class="line"><span class="comment">	 * is estimated as:</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 *             ps-&gt;power * cpu_util</span></span><br><span class="line"><span class="comment">	 *   cpu_nrg = --------------------                          (2)</span></span><br><span class="line"><span class="comment">	 *                   ps-&gt;cap</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * since &#x27;cpu_util / ps-&gt;cap&#x27; represents its percentage of busy time.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 *   <span class="doctag">NOTE:</span> Although the result of this computation actually is in</span></span><br><span class="line"><span class="comment">	 *         units of power, it can be manipulated as an energy value</span></span><br><span class="line"><span class="comment">	 *         over a scheduling period, since it is assumed to be</span></span><br><span class="line"><span class="comment">	 *         constant during that interval.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * By injecting (1) in (2), &#x27;cpu_nrg&#x27; can be re-expressed as a product</span></span><br><span class="line"><span class="comment">	 * of two terms:</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 *             ps-&gt;power * cpu_max_freq   cpu_util</span></span><br><span class="line"><span class="comment">	 *   cpu_nrg = ------------------------ * ---------          (3)</span></span><br><span class="line"><span class="comment">	 *                    ps-&gt;freq            scale_cpu</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * The first term is static, and is stored in the em_perf_state struct</span></span><br><span class="line"><span class="comment">	 * as &#x27;ps-&gt;cost&#x27;.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Since all CPUs of the domain have the same micro-architecture, they</span></span><br><span class="line"><span class="comment">	 * share the same &#x27;ps-&gt;cost&#x27;, and the same CPU capacity. Hence, the</span></span><br><span class="line"><span class="comment">	 * total energy of the domain (which is the simple sum of the energy of</span></span><br><span class="line"><span class="comment">	 * all of its CPUs) can be factorized as:</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 *            ps-&gt;cost * \Sum cpu_util</span></span><br><span class="line"><span class="comment">	 *   pd_nrg = ------------------------                       (4)</span></span><br><span class="line"><span class="comment">	 *                  scale_cpu</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">// 根据推测频率在频点表上对应的cost来算energy</span></span><br><span class="line">	<span class="comment">// 不同频率的cost是常数，在初始化时就已经计算出来</span></span><br><span class="line">	<span class="comment">// 计算cost的时候需要将该perf_domain上的所有util拿出来进行计算</span></span><br><span class="line">	<span class="comment">// 一个perf_domain下的频率是一样的，所以这里计算能耗直接用了sum_util</span></span><br><span class="line">	<span class="keyword">return</span> ps-&gt;cost * sum_util / scale_cpu;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 寻找工作能耗最低的CPU</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">find_energy_efficient_cpu</span><span class="params">(struct task_struct *p, <span class="keyword">int</span> prev_cpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> prev_delta = ULONG_MAX, best_delta = ULONG_MAX;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">root_domain</span> *<span class="title">rd</span> =</span> cpu_rq(smp_processor_id())-&gt;rd;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> cpu_cap, util, base_energy = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> cpu, best_energy_cpu = prev_cpu;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sched_domain</span> *<span class="title">sd</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">perf_domain</span> *<span class="title">pd</span>;</span></span><br><span class="line"></span><br><span class="line">	rcu_read_lock();</span><br><span class="line">	<span class="comment">// 从rd取pd的指针</span></span><br><span class="line">	pd = rcu_dereference(rd-&gt;pd);</span><br><span class="line">	<span class="keyword">if</span> (!pd || READ_ONCE(rd-&gt;overutilized))</span><br><span class="line">		<span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Energy-aware wake-up happens on the lowest sched_domain starting</span></span><br><span class="line"><span class="comment">	 * from sd_asym_cpucapacity spanning over this_cpu and prev_cpu.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	sd = rcu_dereference(*this_cpu_ptr(&amp;sd_asym_cpucapacity));</span><br><span class="line">	<span class="keyword">while</span> (sd &amp;&amp; !cpumask_test_cpu(prev_cpu, sched_domain_span(sd)))</span><br><span class="line">		sd = sd-&gt;parent;</span><br><span class="line">	<span class="keyword">if</span> (!sd)</span><br><span class="line">		<span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">	sync_entity_load_avg(&amp;p-&gt;se);</span><br><span class="line">	<span class="comment">// p的util为0，直接返回prev_cpu</span></span><br><span class="line">	<span class="keyword">if</span> (!task_util_est(p))</span><br><span class="line">		<span class="keyword">goto</span> unlock;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 遍历整个pd链表，计算p在不同pd下的能耗</span></span><br><span class="line">	<span class="keyword">for</span> (; pd; pd = pd-&gt;next) &#123;</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> cur_delta, spare_cap, max_spare_cap = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> base_energy_pd;</span><br><span class="line">		<span class="keyword">int</span> max_spare_cap_cpu = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Compute the &#x27;base&#x27; energy of the pd, without @p */</span></span><br><span class="line">		<span class="comment">// 计算不包括p的情况下此pd当前的energy</span></span><br><span class="line">		<span class="comment">// 这里传入dst_cpu为-1，计算的就是该perf_domain不包括任务P的util</span></span><br><span class="line">		<span class="comment">// 来进行频率推测，然后用来计算能耗</span></span><br><span class="line">		base_energy_pd = compute_energy(p, <span class="number">-1</span>, pd);</span><br><span class="line">		<span class="comment">// 不包括p的情况下系统的总energy</span></span><br><span class="line">		base_energy += base_energy_pd;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 遍历整个pd中的CPU，计算p放在该CPU上的功耗</span></span><br><span class="line">		for_each_cpu_and(cpu, perf_domain_span(pd), sched_domain_span(sd)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!cpumask_test_cpu(cpu, p-&gt;cpus_ptr))</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="comment">// 计算p放到此CPU后该CPU总共消耗的算力</span></span><br><span class="line">			util = cpu_util_next(cpu, p, cpu);</span><br><span class="line">			<span class="comment">// 这里取的是归一化后的CPU算力</span></span><br><span class="line">			cpu_cap = capacity_of(cpu);</span><br><span class="line">			spare_cap = cpu_cap;</span><br><span class="line">			<span class="comment">// 计算p放到此CPU后剩余的算力</span></span><br><span class="line">			lsub_positive(&amp;spare_cap, util);</span><br><span class="line"></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * Skip CPUs that cannot satisfy the capacity request.</span></span><br><span class="line"><span class="comment">			 * IOW, placing the task there would make the CPU</span></span><br><span class="line"><span class="comment">			 * overutilized. Take uclamp into account to see how</span></span><br><span class="line"><span class="comment">			 * much capacity we can get out of the CPU; this is</span></span><br><span class="line"><span class="comment">			 * aligned with schedutil_cpu_util().</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			util = uclamp_rq_util_with(cpu_rq(cpu), util, p);</span><br><span class="line">			<span class="comment">// CPU需要保留20%左右的算力，不满足需求后进行下一个CPU的探测</span></span><br><span class="line">			<span class="keyword">if</span> (!fits_capacity(util, cpu_cap))</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* Always use prev_cpu as a candidate. */</span></span><br><span class="line">			<span class="comment">// 若对比的这个CPU就是任务之前运行的CPU</span></span><br><span class="line">			<span class="keyword">if</span> (cpu == prev_cpu) &#123;</span><br><span class="line">				<span class="comment">// 计算p放在该cpu后整个pd的能量消耗</span></span><br><span class="line">				<span class="comment">// 这里传入的dst_cpu为之前p运行的CPU</span></span><br><span class="line">				<span class="comment">// 推测频率是在之前运行CPU进行推测，同时把P的util也计算到了</span></span><br><span class="line">				prev_delta = compute_energy(p, prev_cpu, pd);</span><br><span class="line">				<span class="comment">// 计算p放在该CPU后整个pd增加的能量消耗</span></span><br><span class="line">				prev_delta -= base_energy_pd;</span><br><span class="line">				<span class="comment">// 更新best_delta，取最优能耗</span></span><br><span class="line">				best_delta = min(best_delta, prev_delta);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * Find the CPU with the maximum spare capacity in</span></span><br><span class="line"><span class="comment">			 * the performance domain</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="comment">// 记录p放上去后剩余算力最大的CPU和最大的剩余算力</span></span><br><span class="line">			<span class="keyword">if</span> (spare_cap &gt; max_spare_cap) &#123;</span><br><span class="line">				max_spare_cap = spare_cap;</span><br><span class="line">				max_spare_cap_cpu = cpu;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Evaluate the energy impact of using this CPU. */</span></span><br><span class="line">		<span class="comment">// 同一个簇上的CPU取最大余量算力的那个CPU与其他簇的CPU做能量消耗对比</span></span><br><span class="line">		<span class="keyword">if</span> (max_spare_cap_cpu &gt;= <span class="number">0</span> &amp;&amp; max_spare_cap_cpu != prev_cpu) &#123;</span><br><span class="line">			<span class="comment">// 计算p放在算力剩余最大的CPU后整个pd的能量消耗</span></span><br><span class="line">			<span class="comment">// 这里传进去的dst_cpu肯定不会和当前任务p运行的CPU相同</span></span><br><span class="line">			<span class="comment">// 所以在cpu_util_next()中会把p的util加到cpu util上</span></span><br><span class="line">			cur_delta = compute_energy(p, max_spare_cap_cpu, pd);</span><br><span class="line">			<span class="comment">// 计算能量消耗增量</span></span><br><span class="line">			cur_delta -= base_energy_pd;</span><br><span class="line">			<span class="comment">// 如果当前能量增量优于p放在prev_cpu运行的能量消耗，则取该cpu运行p</span></span><br><span class="line">			<span class="keyword">if</span> (cur_delta &lt; best_delta) &#123;</span><br><span class="line">				best_delta = cur_delta;</span><br><span class="line">				best_energy_cpu = max_spare_cap_cpu;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">unlock:</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Pick the best CPU if prev_cpu cannot be used, or if it saves at</span></span><br><span class="line"><span class="comment">	 * least 6% of the energy used by prev_cpu.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">// 若prev_cpu找不到，就直接返回最优能耗cpu</span></span><br><span class="line">	<span class="keyword">if</span> (prev_delta == ULONG_MAX)</span><br><span class="line">		<span class="keyword">return</span> best_energy_cpu;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 若最优能耗比放在prev_cpu上运行的能耗还要低6.25%以上，则取最优能耗cpu</span></span><br><span class="line">	<span class="keyword">if</span> ((prev_delta - best_delta) &gt; ((prev_delta + base_energy) &gt;&gt; <span class="number">4</span>))</span><br><span class="line">		<span class="keyword">return</span> best_energy_cpu;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 否则不做改变，直接使用prev_cpu运行p</span></span><br><span class="line">	<span class="keyword">return</span> prev_cpu;</span><br><span class="line"></span><br><span class="line">fail:</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Cpufreq</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux MMC子系统</title>
    <url>/archives/a0a95d0f.html</url>
    <content><![CDATA[<h3 id="Linux-MMC驱动子系统"><a href="#Linux-MMC驱动子系统" class="headerlink" title="Linux MMC驱动子系统"></a>Linux MMC驱动子系统</h3><p>块设备是Linux中的基础外设之一，而MMC&#x2F;SD存储设备是一种典型的块设备，Linux内核设计了MMC子系统，用于管理MMC&#x2F;SD设备</p>
<span id="more"></span>

<p>MMC驱动子系统包含三个部分：</p>
<ul>
<li>MMC总线(mmc_bus)</li>
<li>封装在platform_device下的host设备</li>
<li>依附在MMC总线的MMC驱动(mmc_driver)</li>
</ul>
<p>MMC子系统的框架结构如下图所示</p>
<p>core layer根据MMC&#x2F;SD协议标准实现了协议，card layer与Linux的块设备子系统对接，实现块设备驱动以及完成请求，具体协议经过core layer的接口，最终通过host layer完成传输，对MMC设备进行实际的操作</p>
<p>host和card可以理解为MMC device的MMC主设备和MMC从设备，其中host为集成于芯片内部的MMC controller，card为MMC设备内部实际的存储设备</p>
<p>Linux内核中，使用两个结构体<code>struct mmc_host</code>和<code>struct mmc_card</code>分别描述host和card，其中host设备被封装成platform_device注册到Linux驱动模型中</p>
<h4 id="MMC总线的注册"><a href="#MMC总线的注册" class="headerlink" title="MMC总线的注册"></a>MMC总线的注册</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// drivers/mmc/core/bus.c</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> <span class="title">mmc_bus_type</span> =</span> &#123;</span><br><span class="line">	.name = <span class="string">&quot;mmc&quot;</span>,</span><br><span class="line">	.dev_groups = mmc_dev_groups,</span><br><span class="line">	.match 		= mmc_bus_match,</span><br><span class="line">	.uevent		= mmc_bus_uevent,</span><br><span class="line">	.probe 		= mmc_bus_probe,</span><br><span class="line">	.remove 	= mmc_bus_remove,</span><br><span class="line">	.shutdown 	= mmc_bus_shutdown,</span><br><span class="line">	.pm			= &amp;mmc_bus_pm_ops,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// mmc总线注册</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mmc_register_bus</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> bus_register(&amp;mmc_bus_type);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// drivers/mmc/core/core.c</span></span><br><span class="line"><span class="comment">// MMC初始化</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">mmc_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// mmc总线注册，对应sysfs下的/sys/bus/mmc/目录</span></span><br><span class="line">	ret = mmc_register_bus();</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// mmc_host class注册，对应sysfs下的/sys/class/mmc_host目录</span></span><br><span class="line">	ret = mmc_register_host_class();</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">goto</span> unregister_bus;</span><br><span class="line"></span><br><span class="line">	ret = sdio_register_bus();</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">goto</span> unregister_host_class;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">unregister_host_class:</span><br><span class="line">	mmc_unregister_host_class();</span><br><span class="line">unregister_bus:</span><br><span class="line">	mmc_unregister_bus();</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="MMC驱动注册"><a href="#MMC驱动注册" class="headerlink" title="MMC驱动注册"></a>MMC驱动注册</h4><p>在<code>drivers/mmc/block.c</code>中，将<code>mmc_driver</code>注册到<code>mmc_bus</code>对应的总线系统里</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">mmc_driver</span> =</span> &#123;</span><br><span class="line">	.drv = &#123;</span><br><span class="line">		.name = <span class="string">&quot;mmcblk&quot;</span>,</span><br><span class="line">		.pm = &amp;mmc_blk_pm_ops,</span><br><span class="line">	&#125;,</span><br><span class="line">	.probe 		= mmc_blk_probe,</span><br><span class="line">	.remove 	= mmc_blk_remove,</span><br><span class="line">	.shutdown	= mmc_blk_shutdown,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="SDIO总线简介"><a href="#SDIO总线简介" class="headerlink" title="SDIO总线简介"></a>SDIO总线简介</h3><p>SDIO(Secure Digital Input and Output)，即安全数字输入输出接口，他是在SD卡接口的基础上发展而来的，可以兼容之前的SD卡，并可以链接SDIO接口设备，比如蓝牙、WiFi、GPS等</p>
<p><strong>SDIO卡类型</strong></p>
<ul>
<li>全速卡：传输速率超过100Mbps，时钟范围0-25MHz</li>
<li>低速卡：时钟范围0-400KHz</li>
</ul>
<p><strong>SDIO卡总线模式</strong></p>
<ul>
<li>SPI模式</li>
<li>1-bit SD传输模式</li>
<li>4-bit SD传输模式<br><img src="https://raw.githubusercontent.com/JackHuang021/images/master/20230129144326.png"></li>
</ul>
<h4 id="SDIO命令"><a href="#SDIO命令" class="headerlink" title="SDIO命令"></a>SDIO命令</h4><p>SDIO总线上的设置和控制都是通过命令来实现的，SDIO总线上都是HOST端发起请求，然后DEVICE端回应请求，其中请求和应答中会包含数据信息：</p>
<ul>
<li><strong>Command：</strong> 用于开始传输的命令，是由HOST端发往DEVICE端的，其中命令是通过CMD信号线传送的</li>
<li><strong>Response：</strong> DEVICE返回的应答，也是通过CMD信号线传送的</li>
<li><strong>Data：</strong> 数据是双向传送的，可以设置为1线模式，也可以设置为4线模式，数据是通过DAT0-DAT3信号线传输的</li>
</ul>
<p><strong>命令格式</strong><br><img src="https://raw.githubusercontent.com/JackHuang021/images/master/20230129145056.png"></p>
<ul>
<li>Start Bit：起始位，固定为0</li>
<li>Transmission：传输方向，值为1表示由host发出，0则表示由device发出</li>
<li>Command Index：代表命令索引，例如CMD5的值为5，范围为0-63</li>
<li>Argument：CMD所附带的一些参数，不同的CMD，这32bit每一位所代表的含义是不一样的</li>
<li>CRC7：7位CRC校验值</li>
<li>END：结束位，固定为1</li>
</ul>
<blockquote>
<p><a href="https://www.sdcard.org/downloads/pls/">官网文档下载地址</a></p>
</blockquote>
<h3 id="MMC子系统介绍"><a href="#MMC子系统介绍" class="headerlink" title="MMC子系统介绍"></a>MMC子系统介绍</h3><p>Linux内核中，MMC不仅仅是一个驱动，而是一个子系统，内核把mmc、sd以及sdio三者的驱动代码整合在一起，俗称MMC子系统，源码位于drivers&#x2F;mmc目录下，mmc目录下有core和host两个文件夹</p>
<ul>
<li>host：针对不同主机端的SDIO、MMC控制器的驱动，这部分需要由驱动工程师来完成</li>
<li>core：整个MMC的核心层，这部分实现了不通协议和规范，为HOST层和设备驱动层提供接口函数，还存放了块设备的相关驱动</li>
</ul>
<p>Linux内核中，使用两个结构体<code>struct mmc_host</code>和<code>struct mmc_card</code>分别描述host和card，其中host设备被封装成platform_device注册到Linux驱动模型中，整体而言，Linux驱动模型框架下，MMC驱动子系统包括三个部分：</p>
<ul>
<li>MMC总线（mmc_bus）</li>
<li>封装在<code>platform_device</code>下的host设备</li>
<li>依附于MMC总线的MMC驱动（mmc_driver）</li>
</ul>
<h4 id="MMC总线注册"><a href="#MMC总线注册" class="headerlink" title="MMC总线注册"></a>MMC总线注册</h4><p>MMC总线的注册和platform总线的注册方法相同，均是调用<code>bus_register()</code>函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// drivers/mmc/core/bus.c</span></span><br><span class="line"><span class="comment">// mmc总线定义</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> <span class="title">mmc_bus_type</span> =</span> &#123;</span><br><span class="line">    .name       = <span class="string">&quot;mmc&quot;</span>,</span><br><span class="line">    .dev_groups = mmc_dev_groups,</span><br><span class="line">    .match      = mmc_bus_match,</span><br><span class="line">    .uevent     = mmc_bus_uevent,</span><br><span class="line">    .probe      = mmc_bus_probe,</span><br><span class="line">    .remove     = mmc_bus_remove,</span><br><span class="line">    .shutdown   = mmc_bus_shutdown,</span><br><span class="line">    .pm         = &amp;mmc_bus_pm_ops,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// mmc总线注册</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mmc_register_bus</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bus_register(&amp;mmc_bus_type);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// drivers/mmc/core/core.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">mmc_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    </span><br><span class="line">    ret = mmc_register_bus();</span><br><span class="line">    <span class="keyword">if</span> (ret)</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">    ret = mmc_register_host_class();</span><br><span class="line">    <span class="keyword">if</span> (ret)</span><br><span class="line">        <span class="keyword">goto</span> unregister_bus;</span><br><span class="line"></span><br><span class="line">    ret = sdio_register_bus();</span><br><span class="line">    <span class="keyword">if</span> (ret)</span><br><span class="line">        <span class="keyword">goto</span> unregister_host_class;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">unregister_host_class:</span><br><span class="line">    mmc_unregister_host_class();</span><br><span class="line">unregister_bus:</span><br><span class="line">    mmc_unregister_bus();</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// drivers/mmc/core/host.c</span></span><br><span class="line"><span class="comment">// mmc_host_class注册</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> <span class="title">mmc_host_class</span> =</span> &#123;</span><br><span class="line">    .name = <span class="string">&quot;mmc_host&quot;</span>,</span><br><span class="line">    .dev_release = mmc_host_classdev_release,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mmc_register_host_class</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> class_register(&amp;mmc_host_class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要包括两个方面：</p>
<ul>
<li>利用<code>bus_register()</code>注册mmc_bus，对应sysfs下的<code>/sys/bus/mmc/</code>目录</li>
<li>利用<code>class_register()</code>注册mmc_host_class，对应<code>sysfs下的/sys/class/mmc_host</code>目录</li>
</ul>
<h4 id="MMC驱动注册-1"><a href="#MMC驱动注册-1" class="headerlink" title="MMC驱动注册"></a>MMC驱动注册</h4><p><code>drivers/mmc/core/block.c</code>中将<code>mmc_driver</code>注册到<code>mmc_bus</code>对应的总线系统里，主要步骤包括：</p>
<ul>
<li>通过<code>register_blkdev()</code>向内核注册块设备</li>
<li>通过<code>driver_register()</code>将<code>mmc_driver</code>注册到<code>mmc_bus</code>总线系统</li>
</ul>
<p><code>mmc_driver</code>注册完成之后，会在sysfs中建立目录<code>/sys/bus/mmc/drivers/mmcblk</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// drivers/mmc/core/block.c</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">mmc_driver</span> <span class="title">mmc_driver</span> =</span> &#123;</span><br><span class="line">    .drv = &#123;</span><br><span class="line">        .name = <span class="string">&quot;mmcblk&quot;</span>,</span><br><span class="line">        .pm = &amp;mmc_blk_pm_ops,</span><br><span class="line">    &#125;,</span><br><span class="line">    .probe      = mmc_blk_probe,</span><br><span class="line">    .remove     = mmc_blk_remove,</span><br><span class="line">    .shutdown   = mmc_blk_shutdown,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// drivers/mmc/core/bus.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mmc_driver</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_driver</span> <span class="title">drv</span>;</span></span><br><span class="line">    <span class="keyword">int</span> (*probe)(struct mmc_card *card);</span><br><span class="line">    <span class="keyword">void</span> (*remove)(struct mmc_card *card);</span><br><span class="line">    <span class="keyword">void</span> (*shutdown)(struct mmc_card *card);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// drivers/mmc/core/bus.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mmc_register_driver</span><span class="params">(struct mmc_driver *drv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    drv-&gt;drv.bus = &amp;mmc_bus_type;</span><br><span class="line">    <span class="keyword">return</span> driver_register(&amp;drv-&gt;drv);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">mmc_blk_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> res;</span><br><span class="line"></span><br><span class="line">	res  = bus_register(&amp;mmc_rpmb_bus_type);</span><br><span class="line">	<span class="keyword">if</span> (res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		pr_err(<span class="string">&quot;mmcblk: could not register RPMB bus type\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">	res = alloc_chrdev_region(&amp;mmc_rpmb_devt, <span class="number">0</span>, MAX_DEVICES, <span class="string">&quot;rpmb&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		pr_err(<span class="string">&quot;mmcblk: failed to allocate rpmb chrdev region\n&quot;</span>);</span><br><span class="line">		<span class="keyword">goto</span> out_bus_unreg;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (perdev_minors != CONFIG_MMC_BLOCK_MINORS)</span><br><span class="line">		pr_info(<span class="string">&quot;mmcblk: using %d minors per device\n&quot;</span>, perdev_minors);</span><br><span class="line"></span><br><span class="line">	max_devices = min(MAX_DEVICES, (<span class="number">1</span> &lt;&lt; MINORBITS) / perdev_minors);</span><br><span class="line"></span><br><span class="line">	res = register_blkdev(MMC_BLOCK_MAJOR, <span class="string">&quot;mmc&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (res)</span><br><span class="line">		<span class="keyword">goto</span> out_chrdev_unreg;</span><br><span class="line"></span><br><span class="line">	res = mmc_register_driver(&amp;mmc_driver);</span><br><span class="line">	<span class="keyword">if</span> (res)</span><br><span class="line">		<span class="keyword">goto</span> out_blkdev_unreg;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">out_blkdev_unreg:</span><br><span class="line">	unregister_blkdev(MMC_BLOCK_MAJOR, <span class="string">&quot;mmc&quot;</span>);</span><br><span class="line">out_chrdev_unreg:</span><br><span class="line">	unregister_chrdev_region(mmc_rpmb_devt, MAX_DEVICES);</span><br><span class="line">out_bus_unreg:</span><br><span class="line">	bus_unregister(&amp;mmc_rpmb_bus_type);</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="MMC设备的注册"><a href="#MMC设备的注册" class="headerlink" title="MMC设备的注册"></a>MMC设备的注册</h4><p>MMC设备主要包括主设备host和从设备card两部分，而主设备host将被封装在platform_device中注册到驱动模型中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/linux/mmc/host.h</span></span><br><span class="line"><span class="comment">// mmc_host结构体定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mmc_host</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span>		*<span class="title">parent</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span>		<span class="title">class_dev</span>;</span></span><br><span class="line">	<span class="keyword">int</span>			index;</span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">mmc_host_ops</span> *<span class="title">ops</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mmc_pwrseq</span>	*<span class="title">pwrseq</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		f_min;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		f_max;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		f_init;</span><br><span class="line">	u32			ocr_avail;</span><br><span class="line">	u32			ocr_avail_sdio;	<span class="comment">/* SDIO-specific OCR */</span></span><br><span class="line">	u32			ocr_avail_sd;	<span class="comment">/* SD-specific OCR */</span></span><br><span class="line">	u32			ocr_avail_mmc;	<span class="comment">/* MMC-specific OCR */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PM_SLEEP</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">notifier_block</span>	<span class="title">pm_notify</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">wakeup_source</span>	*<span class="title">ws</span>;</span>		<span class="comment">/* Enable consume of uevents */</span></span><br><span class="line">	u32			max_current_330;</span><br><span class="line">	u32			max_current_300;</span><br><span class="line">	u32			max_current_180;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MMC_VDD_165_195		0x00000080	<span class="comment">/* VDD voltage 1.65 - 1.95 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MMC_VDD_20_21		0x00000100	<span class="comment">/* VDD voltage 2.0 ~ 2.1 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MMC_VDD_21_22		0x00000200	<span class="comment">/* VDD voltage 2.1 ~ 2.2 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MMC_VDD_22_23		0x00000400	<span class="comment">/* VDD voltage 2.2 ~ 2.3 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MMC_VDD_23_24		0x00000800	<span class="comment">/* VDD voltage 2.3 ~ 2.4 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MMC_VDD_24_25		0x00001000	<span class="comment">/* VDD voltage 2.4 ~ 2.5 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MMC_VDD_25_26		0x00002000	<span class="comment">/* VDD voltage 2.5 ~ 2.6 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MMC_VDD_26_27		0x00004000	<span class="comment">/* VDD voltage 2.6 ~ 2.7 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MMC_VDD_27_28		0x00008000	<span class="comment">/* VDD voltage 2.7 ~ 2.8 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MMC_VDD_28_29		0x00010000	<span class="comment">/* VDD voltage 2.8 ~ 2.9 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MMC_VDD_29_30		0x00020000	<span class="comment">/* VDD voltage 2.9 ~ 3.0 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MMC_VDD_30_31		0x00040000	<span class="comment">/* VDD voltage 3.0 ~ 3.1 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MMC_VDD_31_32		0x00080000	<span class="comment">/* VDD voltage 3.1 ~ 3.2 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MMC_VDD_32_33		0x00100000	<span class="comment">/* VDD voltage 3.2 ~ 3.3 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MMC_VDD_33_34		0x00200000	<span class="comment">/* VDD voltage 3.3 ~ 3.4 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MMC_VDD_34_35		0x00400000	<span class="comment">/* VDD voltage 3.4 ~ 3.5 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MMC_VDD_35_36		0x00800000	<span class="comment">/* VDD voltage 3.5 ~ 3.6 */</span></span></span><br><span class="line"></span><br><span class="line">	u32			caps;		<span class="comment">/* Host capabilities */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MMC_CAP_4_BIT_DATA	(1 &lt;&lt; 0)	<span class="comment">/* Can the host do 4 bit transfers */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MMC_CAP_MMC_HIGHSPEED	(1 &lt;&lt; 1)	<span class="comment">/* Can do MMC high-speed timing */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MMC_CAP_SD_HIGHSPEED	(1 &lt;&lt; 2)	<span class="comment">/* Can do SD high-speed timing */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MMC_CAP_SDIO_IRQ	(1 &lt;&lt; 3)	<span class="comment">/* Can signal pending SDIO IRQs */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MMC_CAP_SPI		(1 &lt;&lt; 4)	<span class="comment">/* Talks only SPI protocols */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MMC_CAP_NEEDS_POLL	(1 &lt;&lt; 5)	<span class="comment">/* Needs polling for card-detection */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MMC_CAP_8_BIT_DATA	(1 &lt;&lt; 6)	<span class="comment">/* Can the host do 8 bit transfers */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MMC_CAP_AGGRESSIVE_PM	(1 &lt;&lt; 7)	<span class="comment">/* Suspend (e)MMC/SD at idle  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MMC_CAP_NONREMOVABLE	(1 &lt;&lt; 8)	<span class="comment">/* Nonremovable e.g. eMMC */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MMC_CAP_WAIT_WHILE_BUSY	(1 &lt;&lt; 9)	<span class="comment">/* Waits while card is busy */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MMC_CAP_3_3V_DDR	(1 &lt;&lt; 11)	<span class="comment">/* Host supports eMMC DDR 3.3V */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MMC_CAP_1_8V_DDR	(1 &lt;&lt; 12)	<span class="comment">/* Host supports eMMC DDR 1.8V */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MMC_CAP_1_2V_DDR	(1 &lt;&lt; 13)	<span class="comment">/* Host supports eMMC DDR 1.2V */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MMC_CAP_DDR		(MMC_CAP_3_3V_DDR | MMC_CAP_1_8V_DDR | \</span></span><br><span class="line"><span class="meta">				 MMC_CAP_1_2V_DDR)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MMC_CAP_POWER_OFF_CARD	(1 &lt;&lt; 14)	<span class="comment">/* Can power off after boot */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MMC_CAP_BUS_WIDTH_TEST	(1 &lt;&lt; 15)	<span class="comment">/* CMD14/CMD19 bus width ok */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MMC_CAP_UHS_SDR12	(1 &lt;&lt; 16)	<span class="comment">/* Host supports UHS SDR12 mode */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MMC_CAP_UHS_SDR25	(1 &lt;&lt; 17)	<span class="comment">/* Host supports UHS SDR25 mode */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MMC_CAP_UHS_SDR50	(1 &lt;&lt; 18)	<span class="comment">/* Host supports UHS SDR50 mode */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MMC_CAP_UHS_SDR104	(1 &lt;&lt; 19)	<span class="comment">/* Host supports UHS SDR104 mode */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MMC_CAP_UHS_DDR50	(1 &lt;&lt; 20)	<span class="comment">/* Host supports UHS DDR50 mode */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MMC_CAP_UHS		(MMC_CAP_UHS_SDR12 | MMC_CAP_UHS_SDR25 | \</span></span><br><span class="line"><span class="meta">				 MMC_CAP_UHS_SDR50 | MMC_CAP_UHS_SDR104 | \</span></span><br><span class="line"><span class="meta">				 MMC_CAP_UHS_DDR50)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MMC_CAP_SYNC_RUNTIME_PM	(1 &lt;&lt; 21)	<span class="comment">/* Synced runtime PM suspends. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MMC_CAP_NEED_RSP_BUSY	(1 &lt;&lt; 22)	<span class="comment">/* Commands with R1B can&#x27;t use R1. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MMC_CAP_DRIVER_TYPE_A	(1 &lt;&lt; 23)	<span class="comment">/* Host supports Driver Type A */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MMC_CAP_DRIVER_TYPE_C	(1 &lt;&lt; 24)	<span class="comment">/* Host supports Driver Type C */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MMC_CAP_DRIVER_TYPE_D	(1 &lt;&lt; 25)	<span class="comment">/* Host supports Driver Type D */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MMC_CAP_DONE_COMPLETE	(1 &lt;&lt; 27)	<span class="comment">/* RW reqs can be completed within mmc_request_done() */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MMC_CAP_CD_WAKE		(1 &lt;&lt; 28)	<span class="comment">/* Enable card detect wake */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MMC_CAP_CMD_DURING_TFR	(1 &lt;&lt; 29)	<span class="comment">/* Commands during data transfer */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MMC_CAP_CMD23		(1 &lt;&lt; 30)	<span class="comment">/* CMD23 supported. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MMC_CAP_HW_RESET	(1 &lt;&lt; 31)	<span class="comment">/* Reset the eMMC card via RST_n */</span></span></span><br><span class="line"></span><br><span class="line">	u32			caps2;		<span class="comment">/* More host capabilities */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MMC_CAP2_BOOTPART_NOACC	(1 &lt;&lt; 0)	<span class="comment">/* Boot partition no access */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MMC_CAP2_FULL_PWR_CYCLE	(1 &lt;&lt; 2)	<span class="comment">/* Can do full power cycle */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MMC_CAP2_FULL_PWR_CYCLE_IN_SUSPEND (1 &lt;&lt; 3) <span class="comment">/* Can do full power cycle in suspend */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MMC_CAP2_HS200_1_8V_SDR	(1 &lt;&lt; 5)        <span class="comment">/* can support */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MMC_CAP2_HS200_1_2V_SDR	(1 &lt;&lt; 6)        <span class="comment">/* can support */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MMC_CAP2_HS200		(MMC_CAP2_HS200_1_8V_SDR | \</span></span><br><span class="line"><span class="meta">				 MMC_CAP2_HS200_1_2V_SDR)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MMC_CAP2_CD_ACTIVE_HIGH	(1 &lt;&lt; 10)	<span class="comment">/* Card-detect signal active high */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MMC_CAP2_RO_ACTIVE_HIGH	(1 &lt;&lt; 11)	<span class="comment">/* Write-protect signal active high */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MMC_CAP2_NO_PRESCAN_POWERUP (1 &lt;&lt; 14)	<span class="comment">/* Don&#x27;t power up before scan */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MMC_CAP2_HS400_1_8V	(1 &lt;&lt; 15)	<span class="comment">/* Can support HS400 1.8V */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MMC_CAP2_HS400_1_2V	(1 &lt;&lt; 16)	<span class="comment">/* Can support HS400 1.2V */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MMC_CAP2_HS400		(MMC_CAP2_HS400_1_8V | \</span></span><br><span class="line"><span class="meta">				 MMC_CAP2_HS400_1_2V)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MMC_CAP2_HSX00_1_8V	(MMC_CAP2_HS200_1_8V_SDR | MMC_CAP2_HS400_1_8V)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MMC_CAP2_HSX00_1_2V	(MMC_CAP2_HS200_1_2V_SDR | MMC_CAP2_HS400_1_2V)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MMC_CAP2_SDIO_IRQ_NOTHREAD (1 &lt;&lt; 17)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MMC_CAP2_NO_WRITE_PROTECT (1 &lt;&lt; 18)	<span class="comment">/* No physical write protect pin, assume that card is always read-write */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MMC_CAP2_NO_SDIO	(1 &lt;&lt; 19)	<span class="comment">/* Do not send SDIO commands during initialization */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MMC_CAP2_HS400_ES	(1 &lt;&lt; 20)	<span class="comment">/* Host supports enhanced strobe */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MMC_CAP2_NO_SD		(1 &lt;&lt; 21)	<span class="comment">/* Do not send SD commands during initialization */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MMC_CAP2_NO_MMC		(1 &lt;&lt; 22)	<span class="comment">/* Do not send (e)MMC commands during initialization */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MMC_CAP2_CQE		(1 &lt;&lt; 23)	<span class="comment">/* Has eMMC command queue engine */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MMC_CAP2_CQE_DCMD	(1 &lt;&lt; 24)	<span class="comment">/* CQE can issue a direct command */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MMC_CAP2_AVOID_3_3V	(1 &lt;&lt; 25)	<span class="comment">/* Host must negotiate down from 3.3V */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MMC_CAP2_MERGE_CAPABLE	(1 &lt;&lt; 26)	<span class="comment">/* Host can merge a segment over the segment size */</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span>			fixed_drv_type;	<span class="comment">/* fixed driver type for non-removable media */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">mmc_pm_flag_t</span>		pm_caps;	<span class="comment">/* supported pm features */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* host specific block data */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		max_seg_size;	<span class="comment">/* see blk_queue_max_segment_size */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span>		max_segs;	<span class="comment">/* see blk_queue_max_segments */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span>		unused;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		max_req_size;	<span class="comment">/* maximum number of bytes in one req */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		max_blk_size;	<span class="comment">/* maximum size of one mmc block */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		max_blk_count;	<span class="comment">/* maximum number of blocks in one req */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		max_busy_timeout; <span class="comment">/* max busy timeout in ms */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* private data */</span></span><br><span class="line">	<span class="keyword">spinlock_t</span>		lock;		<span class="comment">/* lock for claim and bus ops */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mmc_ios</span>		<span class="title">ios</span>;</span>		<span class="comment">/* current io bus settings */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* group bitfields together to minimize padding */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		use_spi_crc:<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		claimed:<span class="number">1</span>;	<span class="comment">/* host exclusively claimed */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		bus_dead:<span class="number">1</span>;	<span class="comment">/* bus has been released */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		doing_init_tune:<span class="number">1</span>; <span class="comment">/* initial tuning in progress */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		can_retune:<span class="number">1</span>;	<span class="comment">/* re-tuning can be used */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		doing_retune:<span class="number">1</span>;	<span class="comment">/* re-tuning in progress */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		retune_now:<span class="number">1</span>;	<span class="comment">/* do re-tuning at next req */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		retune_paused:<span class="number">1</span>; <span class="comment">/* re-tuning is temporarily disabled */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		use_blk_mq:<span class="number">1</span>;	<span class="comment">/* use blk-mq */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		retune_crc_disable:<span class="number">1</span>; <span class="comment">/* don&#x27;t trigger retune upon crc */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		can_dma_map_merge:<span class="number">1</span>; <span class="comment">/* merging can be used */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span>			rescan_disable;	<span class="comment">/* disable card detection */</span></span><br><span class="line">	<span class="keyword">int</span>			rescan_entered;	<span class="comment">/* used with nonremovable devices */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span>			need_retune;	<span class="comment">/* re-tuning is needed */</span></span><br><span class="line">	<span class="keyword">int</span>			hold_retune;	<span class="comment">/* hold off re-tuning */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		retune_period;	<span class="comment">/* re-tuning period in secs */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span>	<span class="title">retune_timer</span>;</span>	<span class="comment">/* for periodic re-tuning */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">bool</span>			trigger_card_event; <span class="comment">/* card_event necessary */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mmc_card</span>		*<span class="title">card</span>;</span>		<span class="comment">/* device attached to this host */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">wait_queue_head_t</span>	wq;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mmc_ctx</span>		*<span class="title">claimer</span>;</span>	<span class="comment">/* context that has host claimed */</span></span><br><span class="line">	<span class="keyword">int</span>			claim_cnt;	<span class="comment">/* &quot;claim&quot; nesting count */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mmc_ctx</span>		<span class="title">default_ctx</span>;</span>	<span class="comment">/* default context */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">delayed_work</span>	<span class="title">detect</span>;</span></span><br><span class="line">	<span class="keyword">int</span>			detect_change;	<span class="comment">/* card detect flag */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mmc_slot</span>		<span class="title">slot</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">mmc_bus_ops</span> *<span class="title">bus_ops</span>;</span>	<span class="comment">/* current bus driver */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		bus_refs;	<span class="comment">/* reference counter */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		sdio_irqs;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>	*<span class="title">sdio_irq_thread</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">delayed_work</span>	<span class="title">sdio_irq_work</span>;</span></span><br><span class="line">	<span class="keyword">bool</span>			sdio_irq_pending;</span><br><span class="line">	<span class="keyword">atomic_t</span>		sdio_irq_thread_abort;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">mmc_pm_flag_t</span>		pm_flags;	<span class="comment">/* requested pm features */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">led_trigger</span>	*<span class="title">led</span>;</span>		<span class="comment">/* activity led */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_REGULATOR</span></span><br><span class="line">	<span class="keyword">bool</span>			regulator_enabled; <span class="comment">/* regulator state */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mmc_supply</span>	<span class="title">supply</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dentry</span>		*<span class="title">debugfs_root</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Ongoing data transfer that allows commands during transfer */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mmc_request</span>	*<span class="title">ongoing_mrq</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_FAIL_MMC_REQUEST</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fault_attr</span>	<span class="title">fail_mmc_request</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		actual_clock;	<span class="comment">/* Actual HC clock rate */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		slotno;	<span class="comment">/* used for sdio acpi binding */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span>			dsr_req;	<span class="comment">/* DSR value is valid */</span></span><br><span class="line">	u32			dsr;	<span class="comment">/* optional driver stage (DSR) value */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Command Queue Engine (CQE) support */</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">mmc_cqe_ops</span> *<span class="title">cqe_ops</span>;</span></span><br><span class="line">	<span class="keyword">void</span>			*cqe_private;</span><br><span class="line">	<span class="keyword">int</span>			cqe_qdepth;</span><br><span class="line">	<span class="keyword">bool</span>			cqe_enabled;</span><br><span class="line">	<span class="keyword">bool</span>			cqe_on;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Host Software Queue support */</span></span><br><span class="line">	<span class="keyword">bool</span>			hsq_enabled;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		<span class="keyword">private</span>[] ____cacheline_aligned;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>






]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>MMC</tag>
      </tags>
  </entry>
  <entry>
    <title>045_linux_top_cmd</title>
    <url>/archives/f4a20648.html</url>
    <content><![CDATA[<p>top能够实时显示系统中各个进程的资源占用情况，类似于windows的任务管理器<br>![](<a href="https://raw.githubusercontent.com/JackHuang021/images/master/">https://raw.githubusercontent.com/JackHuang021/images/master/</a></p>
<span id="more"></span>

<h3 id="1-top参数含义"><a href="#1-top参数含义" class="headerlink" title="1. top参数含义"></a>1. top参数含义</h3><p>20230719103527.png)<br>前5行是系统整体的统计信息：</p>
<ul>
<li><p>第1行是任务队列信息，同uptime的执行结果，其内容如下</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 当前时间          系统运行时间    当前登录用户数      系统负载</span></span><br><span class="line">top - 10:37:51 up  1:53,  1 user,  load average: 0.73, 0.96, 0.76</span><br></pre></td></tr></table></figure></li>
<li><p>第2 3行为进程和CPU的统计信息</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 总进程数      正在运行的进程数    睡眠的进程数    停止的进程数    僵尸进程数</span></span><br><span class="line">Tasks: 409 total,   1 running, 403 sleeping,   0 stopped,   5 zombie</span><br><span class="line"><span class="comment"># us 用户空间占用CPU百分比</span></span><br><span class="line"><span class="comment"># sy 内核空间占用CPU百分比</span></span><br><span class="line"><span class="comment"># ni 用户进程空间内改变过优先级的进程占用CPU百分比</span></span><br><span class="line"><span class="comment"># id CPU空闲百分比</span></span><br><span class="line"><span class="comment"># wa 等待输入输出的CPU时间占用百分比</span></span><br><span class="line"><span class="comment"># hi 硬件中断占用百分比</span></span><br><span class="line"><span class="comment"># si 软中断占用百分比</span></span><br><span class="line"><span class="comment"># st 虚拟机占用百分比</span></span><br><span class="line">%Cpu(s):  0.5 us,  0.2 sy,  0.0 ni, 99.2 id,  0.1 wa,  0.0 hi,  0.0 si,  0.0 st</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后两行为内存信息</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 物理内存总量      空闲的物理内存总量      已使用的物理内存总量        用作内核缓存的内存量</span></span><br><span class="line">MiB Mem :  15753.0 total,    276.8 free,   5090.9 used,  10385.4 buff/cache</span><br><span class="line"><span class="comment"># 交换分区内存总量      空闲交换分区总量        已使用交换分区内存总量</span></span><br><span class="line">MiB Swap:   4096.0 total,   4091.2 free,      4.8 used.   9469.2 avail Mem </span><br></pre></td></tr></table></figure></li>
</ul>
<p>进程信息统计区显示了各个进程的详细信息</p>
<ul>
<li>PID：进程ID</li>
<li>USER：进程所有者的用户id</li>
<li>PR：进程优先级</li>
<li>NI：nice值，负值表示高优先级，正值表示低优先级</li>
<li>VIRT：进程使用的虚拟内存总量，单位kb</li>
<li>RES：进程使用的，未被换出的物理内存大小，单位kb</li>
<li>SHR：共享内存大小，单位kb</li>
<li>S：进程状态(D&#x3D;不可中断的睡眠状态,R&#x3D;运行,S&#x3D;睡眠,T&#x3D;跟踪&#x2F;停止,Z&#x3D;僵尸进程)</li>
<li>%CPU：上次更新到本次的CPU时间占用百分比</li>
<li>%MEM：进程使用的物理内存百分比</li>
<li>TIME+：进程使用的CPU时间总计</li>
<li>COMMAND：进程名称</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>top</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux reboot流程</title>
    <url>/archives/3fca1565.html</url>
    <content><![CDATA[<p>kernel根据不同的表现方式，将reboot分为如下的几种方式：</p>
<span id="more"></span>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/uapi/linux/reboot.h</span></span><br><span class="line"><span class="comment">/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _UAPI_LINUX_REBOOT_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _UAPI_LINUX_REBOOT_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Magic values required to use _reboot() system call.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 重启的魔力数，会在系统调用时传入</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	LINUX_REBOOT_MAGIC1	0xfee1dead</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	LINUX_REBOOT_MAGIC2	672274793</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	LINUX_REBOOT_MAGIC2A	85072278</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	LINUX_REBOOT_MAGIC2B	369367448</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	LINUX_REBOOT_MAGIC2C	537993216</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Commands accepted by the _reboot() system call.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * RESTART     Restart system using default command and mode.</span></span><br><span class="line"><span class="comment"> * HALT        Stop OS and give system control to ROM monitor, if any.</span></span><br><span class="line"><span class="comment"> * CAD_ON      Ctrl-Alt-Del sequence causes RESTART command.</span></span><br><span class="line"><span class="comment"> * CAD_OFF     Ctrl-Alt-Del sequence sends SIGINT to init task.</span></span><br><span class="line"><span class="comment"> * POWER_OFF   Stop OS and remove all power from system, if possible.</span></span><br><span class="line"><span class="comment"> * RESTART2    Restart system using given command string.</span></span><br><span class="line"><span class="comment"> * SW_SUSPEND  Suspend system using software suspend if compiled in.</span></span><br><span class="line"><span class="comment"> * KEXEC       Restart system using a previously loaded Linux kernel</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	LINUX_REBOOT_CMD_RESTART	0x01234567</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	LINUX_REBOOT_CMD_HALT		0xCDEF0123</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	LINUX_REBOOT_CMD_CAD_ON		0x89ABCDEF</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	LINUX_REBOOT_CMD_CAD_OFF	0x00000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	LINUX_REBOOT_CMD_POWER_OFF	0x4321FEDC</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	LINUX_REBOOT_CMD_RESTART2	0xA1B2C3D4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	LINUX_REBOOT_CMD_SW_SUSPEND	0xD000FCE2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	LINUX_REBOOT_CMD_KEXEC		0x45584543</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* _UAPI_LINUX_REBOOT_H */</span></span></span><br></pre></td></tr></table></figure>

<ol>
<li>RESTART：正常的重启</li>
<li>HALT：停止操作系统</li>
<li>CAD_ON&#x2F;CAD_OFF：允许&#x2F;禁止通过Ctrl+Alt+Del组合按键触发重启动作</li>
<li>POWER_OFF：正常的关机</li>
</ol>
<p>reboot系统调用，magic1和magic2为两个魔力数，防止误操作，cmd重启的不同方式，如上所述</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Reboot system call: for obvious reasons only root may call it,</span></span><br><span class="line"><span class="comment"> * and even root needs to set up some magic numbers in the registers</span></span><br><span class="line"><span class="comment"> * so that some mistake won&#x27;t make this reboot the whole machine.</span></span><br><span class="line"><span class="comment"> * You can also set the meaning of the ctrl-alt-del-key here.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * reboot doesn&#x27;t sync: do that yourself before calling this.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SYSCALL_DEFINE4(reboot, <span class="keyword">int</span>, magic1, <span class="keyword">int</span>, magic2, <span class="keyword">unsigned</span> <span class="keyword">int</span>, cmd,</span><br><span class="line">		<span class="keyword">void</span> __user *, arg)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pid_namespace</span> *<span class="title">pid_ns</span> =</span> task_active_pid_ns(current);</span><br><span class="line">	<span class="keyword">char</span> buffer[<span class="number">256</span>];</span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* We only trust the superuser with rebooting the system. */</span></span><br><span class="line">	<span class="comment">// 判断当前用户是否为root用户</span></span><br><span class="line">	<span class="keyword">if</span> (!ns_capable(pid_ns-&gt;user_ns, CAP_SYS_BOOT))</span><br><span class="line">		<span class="keyword">return</span> -EPERM;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* For safety, we require &quot;magic&quot; arguments. */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 判断magic数，防止误操作</span></span><br><span class="line">	<span class="keyword">if</span> (magic1 != LINUX_REBOOT_MAGIC1 ||</span><br><span class="line">			(magic2 != LINUX_REBOOT_MAGIC2 &amp;&amp;</span><br><span class="line">			magic2 != LINUX_REBOOT_MAGIC2A &amp;&amp;</span><br><span class="line">			magic2 != LINUX_REBOOT_MAGIC2B &amp;&amp;</span><br><span class="line">			magic2 != LINUX_REBOOT_MAGIC2C))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If pid namespaces are enabled and the current task is in a child</span></span><br><span class="line"><span class="comment">	 * pid_namespace, the command is handled by reboot_pid_ns() which will</span></span><br><span class="line"><span class="comment">	 * call do_exit().</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ret = reboot_pid_ns(pid_ns, cmd);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Instead of trying to make the power_off code look like</span></span><br><span class="line"><span class="comment">	 * halt when pm_power_off is not set do it the easy way.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">// 如果是poweroff指令，且没有注册的pm_power_off处理函数，则把该命令转为HALT</span></span><br><span class="line">	<span class="keyword">if</span> ((cmd == LINUX_REBOOT_CMD_POWER_OFF) &amp;&amp; !kernel_can_power_off())</span><br><span class="line">		cmd = LINUX_REBOOT_CMD_HALT;</span><br><span class="line"></span><br><span class="line">	mutex_lock(&amp;system_transition_mutex);</span><br><span class="line">	<span class="comment">// 根据不同的命令，执行具体的处理</span></span><br><span class="line">	<span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">	<span class="keyword">case</span> LINUX_REBOOT_CMD_RESTART:</span><br><span class="line">		kernel_restart(<span class="literal">NULL</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> LINUX_REBOOT_CMD_CAD_ON:</span><br><span class="line">		C_A_D = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> LINUX_REBOOT_CMD_CAD_OFF:</span><br><span class="line">		C_A_D = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> LINUX_REBOOT_CMD_HALT:</span><br><span class="line">		kernel_halt();</span><br><span class="line">		do_exit(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> LINUX_REBOOT_CMD_POWER_OFF:</span><br><span class="line">		kernel_power_off();</span><br><span class="line">		do_exit(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> LINUX_REBOOT_CMD_RESTART2:</span><br><span class="line">		ret = strncpy_from_user(&amp;buffer[<span class="number">0</span>], arg, <span class="keyword">sizeof</span>(buffer) - <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			ret = -EFAULT;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		buffer[<span class="keyword">sizeof</span>(buffer) - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">		kernel_restart(buffer);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_KEXEC_CORE</span></span><br><span class="line">	<span class="keyword">case</span> LINUX_REBOOT_CMD_KEXEC:</span><br><span class="line">		ret = kernel_kexec();</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_HIBERNATION</span></span><br><span class="line">	<span class="keyword">case</span> LINUX_REBOOT_CMD_SW_SUSPEND:</span><br><span class="line">		ret = hibernate();</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		ret = -EINVAL;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	mutex_unlock(&amp;system_transition_mutex);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>kernel_restart()源码解析</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将task转移到一个CPU</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">migrate_to_reboot_cpu</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/* The boot cpu is always logical cpu 0 */</span></span><br><span class="line">	<span class="keyword">int</span> cpu = reboot_cpu;</span><br><span class="line"></span><br><span class="line">	cpu_hotplug_disable();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Make certain the cpu I&#x27;m about to reboot on is online */</span></span><br><span class="line">	<span class="keyword">if</span> (!cpu_online(cpu))</span><br><span class="line">		cpu = cpumask_first(cpu_online_mask);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Prevent races with other tasks migrating this task */</span></span><br><span class="line">	current-&gt;flags |= PF_NO_SETAFFINITY;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Make certain I only run on the appropriate processor */</span></span><br><span class="line">	set_cpus_allowed_ptr(current, cpumask_of(cpu));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// kernel/reboot.c</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *	kernel_restart - reboot the system</span></span><br><span class="line"><span class="comment"> *	@cmd: pointer to buffer containing command to execute for restart</span></span><br><span class="line"><span class="comment"> *		or %NULL</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *	Shutdown everything and perform a clean reboot.</span></span><br><span class="line"><span class="comment"> *	This is not safe to call in interrupt context.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kernel_restart</span><span class="params">(<span class="keyword">char</span> *cmd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 进行restart前的准备工作，发送reboot事件，更新system_state变量状态</span></span><br><span class="line">	kernel_restart_prepare(cmd);</span><br><span class="line">	<span class="comment">// 将当前的进程转移到一个CPU上</span></span><br><span class="line">	migrate_to_reboot_cpu();</span><br><span class="line">	syscore_shutdown();</span><br><span class="line">	<span class="keyword">if</span> (!cmd)</span><br><span class="line">		pr_emerg(<span class="string">&quot;Restarting system\n&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		pr_emerg(<span class="string">&quot;Restarting system with command &#x27;%s&#x27;\n&quot;</span>, cmd);</span><br><span class="line">	kmsg_dump(KMSG_DUMP_SHUTDOWN);</span><br><span class="line">	machine_restart(cmd);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(kernel_restart);</span><br></pre></td></tr></table></figure>


]]></content>
  </entry>
  <entry>
    <title>Linux中断子系统</title>
    <url>/archives/6ea84d7b.html</url>
    <content><![CDATA[<h3 id="中断子系统的一些概念"><a href="#中断子系统的一些概念" class="headerlink" title="中断子系统的一些概念"></a>中断子系统的一些概念</h3><h4 id="IRQ-Domain介绍"><a href="#IRQ-Domain介绍" class="headerlink" title="IRQ Domain介绍"></a>IRQ Domain介绍</h4><p>IRQ number： CPU需要为每一个外设中断编号，这里称之为IRQ Number，这个IRQ Number是一个虚拟的interrupt id，和硬件无关，仅仅是被CPU用来标识一个外设中断</p>
<span id="more"></span>

<p>HW interrupt ID：对于interrupt controller而言，它收集了多个外设的interrupt request line并向上传递，所以interrupt controller需要对外设中断进行编码，interrupt controller使用HW interrupt ID来标识外设的中断，</p>
<p>对于驱动工程师而言，我们只希望会得到一个IRQ number，而不关心具体是那个interrupt controller上的哪个HW Interrupt ID，因此linux kernel中的中断子系统需要提供一个将HW interrupt ID映射到IRQ number上来的机制</p>
<h4 id="为IRQ-domain创建映射"><a href="#为IRQ-domain创建映射" class="headerlink" title="为IRQ domain创建映射"></a>为IRQ domain创建映射</h4><h3 id="数据结构描述"><a href="#数据结构描述" class="headerlink" title="数据结构描述"></a>数据结构描述</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/linux/irqdomain.h</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct irq_domain - Hardware interrupt number translation object</span></span><br><span class="line"><span class="comment"> * @link: Element in global irq_domain list.</span></span><br><span class="line"><span class="comment"> * @name: Name of interrupt domain</span></span><br><span class="line"><span class="comment"> * @ops: pointer to irq_domain methods</span></span><br><span class="line"><span class="comment"> * @host_data: private data pointer for use by owner.  Not touched by irq_domain</span></span><br><span class="line"><span class="comment"> *             core code.</span></span><br><span class="line"><span class="comment"> * @flags: host per irq_domain flags</span></span><br><span class="line"><span class="comment"> * @mapcount: The number of mapped interrupts</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Optional elements</span></span><br><span class="line"><span class="comment"> * @fwnode: Pointer to firmware node associated with the irq_domain. Pretty easy</span></span><br><span class="line"><span class="comment"> *          to swap it for the of_node via the irq_domain_get_of_node accessor</span></span><br><span class="line"><span class="comment"> * @gc: Pointer to a list of generic chips. There is a helper function for</span></span><br><span class="line"><span class="comment"> *      setting up one or more generic chips for interrupt controllers</span></span><br><span class="line"><span class="comment"> *      drivers using the generic chip library which uses this pointer.</span></span><br><span class="line"><span class="comment"> * @parent: Pointer to parent irq_domain to support hierarchy irq_domains</span></span><br><span class="line"><span class="comment"> * @debugfs_file: dentry for the domain debugfs file</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Revmap data, used internally by irq_domain</span></span><br><span class="line"><span class="comment"> * @revmap_direct_max_irq: The largest hwirq that can be set for controllers that</span></span><br><span class="line"><span class="comment"> *                         support direct mapping</span></span><br><span class="line"><span class="comment"> * @revmap_size: Size of the linear map table @linear_revmap[]</span></span><br><span class="line"><span class="comment"> * @revmap_tree: Radix map tree for hwirqs that don&#x27;t fit in the linear map</span></span><br><span class="line"><span class="comment"> * @linear_revmap: Linear table of hwirq-&gt;virq reverse mappings</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irq_domain</span> &#123;</span></span><br><span class="line">    <span class="comment">// 所有irq domain会链接到内核irq_domain_list链表中</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">link</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="comment">// irq domain的回调函数</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">irq_domain_ops</span> *<span class="title">ops</span>;</span></span><br><span class="line">	<span class="comment">// host_data定义了中断控制器使用的私有数据</span></span><br><span class="line">	<span class="keyword">void</span> *host_data;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> flags;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> mapcount;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Optional data */</span></span><br><span class="line">    <span class="comment">// irq domain对应的中断控制器的device node</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fwnode_handle</span> *<span class="title">fwnode</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">irq_domain_bus_token</span> <span class="title">bus_token</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_domain_chip_generic</span> *<span class="title">gc</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span>	CONFIG_IRQ_DOMAIN_HIERARCHY</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_domain</span> *<span class="title">parent</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_GENERIC_IRQ_DEBUGFS</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dentry</span>		*<span class="title">debugfs_file</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* reverse map data. The linear map gets appended to the irq_domain */</span></span><br><span class="line">    <span class="comment">// domain中最大的hw irq ID</span></span><br><span class="line">	<span class="keyword">irq_hw_number_t</span> hwirq_max;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> revmap_direct_max_irq;</span><br><span class="line">    <span class="comment">// 线性映射表的大小</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> revmap_size;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">radix_tree_root</span> <span class="title">revmap_tree</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">revmap_tree_mutex</span>;</span></span><br><span class="line">	<span class="comment">// 线性表使用的查找表</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> linear_revmap[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/linux/irqdomain.h</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct irq_domain_ops - Methods for irq_domain objects</span></span><br><span class="line"><span class="comment"> * @match: Match an interrupt controller device node to a host, returns</span></span><br><span class="line"><span class="comment"> *         1 on a match</span></span><br><span class="line"><span class="comment"> * @map: Create or update a mapping between a virtual irq number and a hw</span></span><br><span class="line"><span class="comment"> *       irq number. This is called only once for a given mapping.</span></span><br><span class="line"><span class="comment"> * @unmap: Dispose of such a mapping</span></span><br><span class="line"><span class="comment"> * @xlate: Given a device tree node and interrupt specifier, decode</span></span><br><span class="line"><span class="comment"> *         the hardware irq number and linux irq type value.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Functions below are provided by the driver and called whenever a new mapping</span></span><br><span class="line"><span class="comment"> * is created or an old mapping is disposed. The driver can then proceed to</span></span><br><span class="line"><span class="comment"> * whatever internal data structures management is required. It also needs</span></span><br><span class="line"><span class="comment"> * to setup the irq_desc when returning from map().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irq_domain_ops</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> (*match)(struct irq_domain *d, struct device_node *node,</span><br><span class="line">		     <span class="keyword">enum</span> irq_domain_bus_token bus_token);</span><br><span class="line">	<span class="keyword">int</span> (*select)(struct irq_domain *d, struct irq_fwspec *fwspec,</span><br><span class="line">		      <span class="keyword">enum</span> irq_domain_bus_token bus_token);</span><br><span class="line">	<span class="keyword">int</span> (*<span class="built_in">map</span>)(struct irq_domain *d, <span class="keyword">unsigned</span> <span class="keyword">int</span> virq, <span class="keyword">irq_hw_number_t</span> hw);</span><br><span class="line">	<span class="keyword">void</span> (*unmap)(struct irq_domain *d, <span class="keyword">unsigned</span> <span class="keyword">int</span> virq);</span><br><span class="line">	<span class="keyword">int</span> (*xlate)(struct irq_domain *d, struct device_node *node,</span><br><span class="line">		     <span class="keyword">const</span> u32 *intspec, <span class="keyword">unsigned</span> <span class="keyword">int</span> intsize,</span><br><span class="line">		     <span class="keyword">unsigned</span> <span class="keyword">long</span> *out_hwirq, <span class="keyword">unsigned</span> <span class="keyword">int</span> *out_type);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span>	CONFIG_IRQ_DOMAIN_HIERARCHY</span></span><br><span class="line">	<span class="comment">/* extended V2 interfaces to support hierarchy irq_domains */</span></span><br><span class="line">	<span class="keyword">int</span> (*alloc)(struct irq_domain *d, <span class="keyword">unsigned</span> <span class="keyword">int</span> virq,</span><br><span class="line">		     <span class="keyword">unsigned</span> <span class="keyword">int</span> nr_irqs, <span class="keyword">void</span> *arg);</span><br><span class="line">	<span class="keyword">void</span> (*<span class="built_in">free</span>)(struct irq_domain *d, <span class="keyword">unsigned</span> <span class="keyword">int</span> virq,</span><br><span class="line">		     <span class="keyword">unsigned</span> <span class="keyword">int</span> nr_irqs);</span><br><span class="line">	<span class="keyword">int</span> (*activate)(struct irq_domain *d, struct irq_data *irqd, <span class="keyword">bool</span> reserve);</span><br><span class="line">	<span class="keyword">void</span> (*deactivate)(struct irq_domain *d, struct irq_data *irq_data);</span><br><span class="line">	<span class="keyword">int</span> (*translate)(struct irq_domain *d, struct irq_fwspec *fwspec,</span><br><span class="line">			 <span class="keyword">unsigned</span> <span class="keyword">long</span> *out_hwirq, <span class="keyword">unsigned</span> <span class="keyword">int</span> *out_type);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_GENERIC_IRQ_DEBUGFS</span></span><br><span class="line">	<span class="keyword">void</span> (*debug_show)(struct seq_file *m, struct irq_domain *d,</span><br><span class="line">			   struct irq_data *irqd, <span class="keyword">int</span> ind);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h3 id="设备树中中断控制器的描述"><a href="#设备树中中断控制器的描述" class="headerlink" title="设备树中中断控制器的描述"></a>设备树中中断控制器的描述</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设备树根节点interrupt-parent描述</span></span><br><span class="line">/ &#123;</span><br><span class="line">	compatible = <span class="string">&quot;phytium,pe220x&quot;</span>;</span><br><span class="line">	<span class="comment">// 表明外设的interrupt request lint物理连接到了gic中断控制器</span></span><br><span class="line">	<span class="comment">// 在device node中没有定义interrupt-parent属性的均使用这个中断控制器</span></span><br><span class="line">	interrupt-parent = &lt;&amp;gic&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pe220x系列gic中断控制器设备树节点</span></span><br><span class="line">gic: interrupt-controller@<span class="number">30800000</span> &#123;</span><br><span class="line">	compatible = <span class="string">&quot;arm,gic-v3&quot;</span>;</span><br><span class="line">	<span class="comment">// 该中断控制器用多少个cell描述一个外设的interrupt request line</span></span><br><span class="line">	<span class="meta">#interrupt-cells = <span class="meta-string">&lt;3&gt;</span>;</span></span><br><span class="line">	<span class="meta">#address-cells = <span class="meta-string">&lt;2&gt;</span>;</span></span><br><span class="line">	<span class="meta">#size-cells = <span class="meta-string">&lt;2&gt;</span>;</span></span><br><span class="line">	ranges;</span><br><span class="line">	<span class="comment">// 表明该device node是一个中断控制器</span></span><br><span class="line">	interrupt-controller;</span><br><span class="line">	reg = &lt;<span class="number">0x0</span> <span class="number">0x30800000</span> <span class="number">0</span> <span class="number">0x20000</span>&gt;,	<span class="comment">/* GICD */</span></span><br><span class="line">			&lt;<span class="number">0x0</span> <span class="number">0x30880000</span> <span class="number">0</span> <span class="number">0x80000</span>&gt;,	<span class="comment">/* GICR */</span></span><br><span class="line">			&lt;<span class="number">0x0</span> <span class="number">0x30840000</span> <span class="number">0</span> <span class="number">0x10000</span>&gt;,	<span class="comment">/* GICC */</span></span><br><span class="line">			&lt;<span class="number">0x0</span> <span class="number">0x30850000</span> <span class="number">0</span> <span class="number">0x10000</span>&gt;,	<span class="comment">/* GICH */</span></span><br><span class="line">			&lt;<span class="number">0x0</span> <span class="number">0x30860000</span> <span class="number">0</span> <span class="number">0x10000</span>&gt;;	<span class="comment">/* GICV */</span></span><br><span class="line">	interrupts = &lt;GIC_PPI <span class="number">9</span> IRQ_TYPE_LEVEL_LOW&gt;;</span><br><span class="line"></span><br><span class="line">	its: gic-its@<span class="number">30820000</span> &#123;</span><br><span class="line">		compatible = <span class="string">&quot;arm,gic-v3-its&quot;</span>;</span><br><span class="line">		msi-controller;</span><br><span class="line">		reg = &lt;<span class="number">0x0</span> <span class="number">0x30820000</span> <span class="number">0x0</span> <span class="number">0x20000</span>&gt;;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="中断映射的建立"><a href="#中断映射的建立" class="headerlink" title="中断映射的建立"></a>中断映射的建立</h3><p>中断映射建立过程如下：</p>
<ol>
<li>dts文件描述了系统中interrupt controller以及外设IRQ的拓扑结构</li>
<li>device tree初始化的时候，形成了系统内所有device node的树状结构</li>
<li>在初始化的时候会调用<code>of_irq_init()</code>扫描所有interrupt controller节点，并调用合适的interrupt controller driver进行初始化，并在driver的初始化过程中创建映射</li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Interrupt</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux notify机制</title>
    <url>/archives/2f609589.html</url>
    <content><![CDATA[<p>在linux内核中，各个子系统之间有很强的相互关系，某些子系统可能对其他子系统产生的事件比较感兴趣，因此内核引进了notifier机制。内核实现notifier机制的代码位于<code>kernel/notifier.c</code></p>
<span id="more"></span>
<p>内核使用<code>struct notifier_block</code>结构代表一个notifer</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/linux/notifier.h</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span>	<span class="title">int</span> <span class="params">(*<span class="keyword">notifier_fn_t</span>)</span><span class="params">(struct notifier_block *nb,</span></span></span><br><span class="line"><span class="params"><span class="function">			<span class="keyword">unsigned</span> <span class="keyword">long</span> action, <span class="keyword">void</span> *data)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">notifier_block</span> &#123;</span></span><br><span class="line">    <span class="comment">// 代表时间发生之后调用的回调函数</span></span><br><span class="line">	<span class="keyword">notifier_fn_t</span> notifier_call;</span><br><span class="line">    <span class="comment">// 用来链接同一个类型的notifier</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">notifier_block</span> __<span class="title">rcu</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="comment">// notifier chain的优先级，对应的数字越大优先级越高</span></span><br><span class="line">	<span class="keyword">int</span> priority;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>内核同时也提供了四种不同类型的notifier chain</p>
<ul>
<li><p>原子通知链（atomic notifier chains）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/linux/notifier.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">atomic_notifier_head</span> &#123;</span></span><br><span class="line">	<span class="keyword">spinlock_t</span> lock;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">notifier_block</span> __<span class="title">rcu</span> *<span class="title">head</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>可阻塞通知链（blocking notifier chains）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/linux/notifier.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">blocking_notifier_head</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rw_semaphore</span> <span class="title">rwsem</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">notifier_block</span> __<span class="title">rcu</span> *<span class="title">head</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>原始通知链（raw notifier chains）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/linux/notifier.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">raw_notifier_head</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">notifier_block</span> __<span class="title">rcu</span> *<span class="title">head</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>SRCU通知链（SRCU notifier chains）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/linux/notifier.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">srcu_notifier_head</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">mutex</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">srcu_struct</span> <span class="title">srcu</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">notifier_block</span> __<span class="title">rcu</span> *<span class="title">head</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>通知链和notifier之间的组织关系如下<br><img src="https://raw.githubusercontent.com/JackHuang021/images/master/20230907193526.png"></p>
<p>内核提供了一套宏来初始化各个类型的通知链</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/linux/notifier.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ATOMIC_INIT_NOTIFIER_HEAD(name) do &#123;	\</span></span><br><span class="line"><span class="meta">		spin_lock_init(&amp;(name)-&gt;lock);	\</span></span><br><span class="line"><span class="meta">		(name)-&gt;head = NULL;		\</span></span><br><span class="line"><span class="meta">	&#125; while (0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BLOCKING_INIT_NOTIFIER_HEAD(name) do &#123;	\</span></span><br><span class="line"><span class="meta">		init_rwsem(&amp;(name)-&gt;rwsem);	\</span></span><br><span class="line"><span class="meta">		(name)-&gt;head = NULL;		\</span></span><br><span class="line"><span class="meta">	&#125; while (0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RAW_INIT_NOTIFIER_HEAD(name) do &#123;	\</span></span><br><span class="line"><span class="meta">		(name)-&gt;head = NULL;		\</span></span><br><span class="line"><span class="meta">	&#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ATOMIC_NOTIFIER_INIT(name) &#123;				\</span></span><br><span class="line"><span class="meta">		.lock = __SPIN_LOCK_UNLOCKED(name.lock),	\</span></span><br><span class="line"><span class="meta">		.head = NULL &#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BLOCKING_NOTIFIER_INIT(name) &#123;				\</span></span><br><span class="line"><span class="meta">		.rwsem = __RWSEM_INITIALIZER((name).rwsem),	\</span></span><br><span class="line"><span class="meta">		.head = NULL &#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RAW_NOTIFIER_INIT(name)	&#123;				\</span></span><br><span class="line"><span class="meta">		.head = NULL &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SRCU_NOTIFIER_INIT(name, pcpu)				\</span></span><br><span class="line"><span class="meta">	&#123;							\</span></span><br><span class="line"><span class="meta">		.mutex = __MUTEX_INITIALIZER(name.mutex),	\</span></span><br><span class="line"><span class="meta">		.head = NULL,					\</span></span><br><span class="line"><span class="meta">		.srcu = __SRCU_STRUCT_INIT(name.srcu, pcpu),	\</span></span><br><span class="line"><span class="meta">	&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ATOMIC_NOTIFIER_HEAD(name)				\</span></span><br><span class="line"><span class="meta">	struct atomic_notifier_head name =			\</span></span><br><span class="line"><span class="meta">		ATOMIC_NOTIFIER_INIT(name)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BLOCKING_NOTIFIER_HEAD(name)				\</span></span><br><span class="line"><span class="meta">	struct blocking_notifier_head name =			\</span></span><br><span class="line"><span class="meta">		BLOCKING_NOTIFIER_INIT(name)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RAW_NOTIFIER_HEAD(name)					\</span></span><br><span class="line"><span class="meta">	struct raw_notifier_head name =				\</span></span><br><span class="line"><span class="meta">		RAW_NOTIFIER_INIT(name)</span></span><br></pre></td></tr></table></figure>

<p>内核提供了最基本的注册通知链的函数，四个不同类型的通知链初始化通过调用这个基本的注册函数来进行注册</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/notifier.c</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *	Notifier chain core routines.  The exported routines below</span></span><br><span class="line"><span class="comment"> *	are layered on top of these, with appropriate locking added.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">notifier_chain_register</span><span class="params">(struct notifier_block **nl,</span></span></span><br><span class="line"><span class="params"><span class="function">				   struct notifier_block *n,</span></span></span><br><span class="line"><span class="params"><span class="function">				   <span class="keyword">bool</span> unique_priority)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 遍历nl通知链表，根据优先级大小将n插入到通知链表中</span></span><br><span class="line">	<span class="keyword">while</span> ((*nl) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (unlikely((*nl) == n)) &#123;</span><br><span class="line">			WARN(<span class="number">1</span>, <span class="string">&quot;notifier callback %ps already registered&quot;</span>,</span><br><span class="line">			     n-&gt;notifier_call);</span><br><span class="line">			<span class="keyword">return</span> -EEXIST;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (n-&gt;priority &gt; (*nl)-&gt;priority)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">if</span> (n-&gt;priority == (*nl)-&gt;priority &amp;&amp; unique_priority)</span><br><span class="line">			<span class="keyword">return</span> -EBUSY;</span><br><span class="line">		nl = &amp;((*nl)-&gt;next);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 插入到</span></span><br><span class="line">	n-&gt;next = *nl;</span><br><span class="line">	rcu_assign_pointer(*nl, n);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">notifier_chain_unregister</span><span class="params">(struct notifier_block **nl,</span></span></span><br><span class="line"><span class="params"><span class="function">		struct notifier_block *n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> ((*nl) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((*nl) == n) &#123;</span><br><span class="line">			rcu_assign_pointer(*nl, n-&gt;next);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		nl = &amp;((*nl)-&gt;next);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> -ENOENT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来看一下如何发送一个事件到通知链上的notifier，内核提供了一个基本的实现<code>notifier_call_chain()</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * notifier_call_chain - Informs the registered notifiers about an event.</span></span><br><span class="line"><span class="comment"> *	@nl:		Pointer to head of the blocking notifier chain</span></span><br><span class="line"><span class="comment"> *	@val:		Value passed unmodified to notifier function</span></span><br><span class="line"><span class="comment"> *	@v:		Pointer passed unmodified to notifier function</span></span><br><span class="line"><span class="comment"> *	@nr_to_call:	Number of notifier functions to be called. Don&#x27;t care</span></span><br><span class="line"><span class="comment"> *			value of this parameter is -1.</span></span><br><span class="line"><span class="comment"> *	@nr_calls:	Records the number of notifications sent. Don&#x27;t care</span></span><br><span class="line"><span class="comment"> *			value of this field is NULL.</span></span><br><span class="line"><span class="comment"> *	@returns:	notifier_call_chain returns the value returned by the</span></span><br><span class="line"><span class="comment"> *			last notifier function called.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">notifier_call_chain</span><span class="params">(struct notifier_block **nl,</span></span></span><br><span class="line"><span class="params"><span class="function">			       <span class="keyword">unsigned</span> <span class="keyword">long</span> val, <span class="keyword">void</span> *v,</span></span></span><br><span class="line"><span class="params"><span class="function">			       <span class="keyword">int</span> nr_to_call, <span class="keyword">int</span> *nr_calls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret = NOTIFY_DONE;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">notifier_block</span> *<span class="title">nb</span>, *<span class="title">next_nb</span>;</span></span><br><span class="line"></span><br><span class="line">	nb = rcu_dereference_raw(*nl);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历整个通知链，让通知链上的notifier全部调用一次回调函数</span></span><br><span class="line">	<span class="keyword">while</span> (nb &amp;&amp; nr_to_call) &#123;</span><br><span class="line">		next_nb = rcu_dereference_raw(nb-&gt;next);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_NOTIFIERS</span></span><br><span class="line">		<span class="keyword">if</span> (unlikely(!func_ptr_is_kernel_text(nb-&gt;notifier_call))) &#123;</span><br><span class="line">			WARN(<span class="number">1</span>, <span class="string">&quot;Invalid notifier called!&quot;</span>);</span><br><span class="line">			nb = next_nb;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">		ret = nb-&gt;notifier_call(nb, val, v);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (nr_calls)</span><br><span class="line">			(*nr_calls)++;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (ret &amp; NOTIFY_STOP_MASK)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		nb = next_nb;</span><br><span class="line">		nr_to_call--;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">NOKPROBE_SYMBOL(notifier_call_chain);</span><br></pre></td></tr></table></figure>

<p>原子通知链相关API实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/notifier.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册一个notifier block到通知链</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *	atomic_notifier_chain_register - Add notifier to an atomic notifier chain</span></span><br><span class="line"><span class="comment"> *	@nh: Pointer to head of the atomic notifier chain</span></span><br><span class="line"><span class="comment"> *	@n: New entry in notifier chain</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *	Adds a notifier to an atomic notifier chain.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *	Returns 0 on success, %-EEXIST on error.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">atomic_notifier_chain_register</span><span class="params">(struct atomic_notifier_head *nh,</span></span></span><br><span class="line"><span class="params"><span class="function">		struct notifier_block *n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">	spin_lock_irqsave(&amp;nh-&gt;lock, flags);</span><br><span class="line">	ret = notifier_chain_register(&amp;nh-&gt;head, n, <span class="literal">false</span>);</span><br><span class="line">	spin_unlock_irqrestore(&amp;nh-&gt;lock, flags);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(atomic_notifier_chain_register);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从通知链删除一个notifier</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *	atomic_notifier_chain_unregister - Remove notifier from an atomic notifier chain</span></span><br><span class="line"><span class="comment"> *	@nh: Pointer to head of the atomic notifier chain</span></span><br><span class="line"><span class="comment"> *	@n: Entry to remove from notifier chain</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *	Removes a notifier from an atomic notifier chain.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *	Returns zero on success or %-ENOENT on failure.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">atomic_notifier_chain_unregister</span><span class="params">(struct atomic_notifier_head *nh,</span></span></span><br><span class="line"><span class="params"><span class="function">		struct notifier_block *n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">	spin_lock_irqsave(&amp;nh-&gt;lock, flags);</span><br><span class="line">	ret = notifier_chain_unregister(&amp;nh-&gt;head, n);</span><br><span class="line">	spin_unlock_irqrestore(&amp;nh-&gt;lock, flags);</span><br><span class="line">	synchronize_rcu();</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(atomic_notifier_chain_unregister);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *	atomic_notifier_call_chain - Call functions in an atomic notifier chain</span></span><br><span class="line"><span class="comment"> *	@nh: Pointer to head of the atomic notifier chain</span></span><br><span class="line"><span class="comment"> *	@val: Value passed unmodified to notifier function</span></span><br><span class="line"><span class="comment"> *	@v: Pointer passed unmodified to notifier function</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *	Calls each function in a notifier chain in turn.  The functions</span></span><br><span class="line"><span class="comment"> *	run in an atomic context, so they must not block.</span></span><br><span class="line"><span class="comment"> *	This routine uses RCU to synchronize with changes to the chain.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *	If the return value of the notifier can be and&#x27;ed</span></span><br><span class="line"><span class="comment"> *	with %NOTIFY_STOP_MASK then atomic_notifier_call_chain()</span></span><br><span class="line"><span class="comment"> *	will return immediately, with the return value of</span></span><br><span class="line"><span class="comment"> *	the notifier function which halted execution.</span></span><br><span class="line"><span class="comment"> *	Otherwise the return value is the return value</span></span><br><span class="line"><span class="comment"> *	of the last notifier function called.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">atomic_notifier_call_chain</span><span class="params">(struct atomic_notifier_head *nh,</span></span></span><br><span class="line"><span class="params"><span class="function">			       <span class="keyword">unsigned</span> <span class="keyword">long</span> val, <span class="keyword">void</span> *v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">	rcu_read_lock();</span><br><span class="line">	ret = notifier_call_chain(&amp;nh-&gt;head, val, v, <span class="number">-1</span>, <span class="literal">NULL</span>);</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(atomic_notifier_call_chain);</span><br><span class="line">NOKPROBE_SYMBOL(atomic_notifier_call_chain);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>notifier</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux workqueue实现</title>
    <url>/archives/c419f2e4.html</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>工作队列（workqueue）是除软中断softirq和tasklet以外最常用的一种中断下半部执行机制，由内核统一管理。<strong>工作队列把推迟执行的任务交给内核线程来执行，其运行在进程上下文，允许重新调度，睡眠，这个内核线程被称为worker thread</strong>工作队列解决了软中断和tasklet执行时间过长导致系统实时性下降的问题，同时避免了驱动模块自身创建线程导致内核线程过多的问题。</p>
<span id="more"></span>
<p>工作队列的设计思想：</p>
<ul>
<li>并行，多个work不要相互阻塞</li>
<li>节省资源，多个work尽量共享资源</li>
</ul>
<h3 id="CMWQ"><a href="#CMWQ" class="headerlink" title="CMWQ"></a>CMWQ</h3><p>为了实现设计思想，工作队列的设计实现也更新了很多版本，最新的workqueue实现叫做CMWQ（Concurrency Managed Workqueue），CMWQ提出了worker pool的概念，系统中存在若干worker pool，这些worker pool不和特定的workqueue关联，而是所有的workqueue共享</p>
<p>用户可以创建workqueue，但不创建worker pool，并通过flag来约束挂入该workqueue上的work的处理方式，workqueue会根据其flag将work交付给系统中的某个worker pool处理，根据<code>struct workqueue_struct</code>中的flags成员来判断work的去向</p>
<p>CMWQ的几个基本概念</p>
<ul>
<li>work：工作</li>
<li>workqueue：工作的集合，workqueue和work是一对多的关系</li>
<li>worker：工人，在代码中worker对应一个work_thread()内核线程</li>
<li>worker_pool：工人的集合，worker_pool和worker是一对多的关系</li>
<li>pwq（pool_workqueue）：中间人，负责建立起workqueue和worker_pool之间的关系，workqueue和pwq是一对多的关系，pwq和worker_pool是一对一的关系</li>
</ul>
<p>CMWQ创建线程池的策略，系统中的线程池thread pool包括两种，一种是和特定CPU绑定的线程池percpu thread pool，另一种是unbound thread pool：</p>
<ul>
<li>针对percpu thread pool，每个CPU包含两个这样的线程池，一个是普通优先级的normal thread pool，一个是高优先级的high priority pool</li>
<li>unbound thread pool，它可以运行在任意的CPU上，这种线程池是动态创建的，根据<code>struct workqueue_attrs *unbound_attrs;</code>这个属性来创建unbound thread pool</li>
</ul>
<p>CMWQ线程创建的策略：当thread pool中处于运行状态的worker thread等于0，并且有需要处理的work的时候，thread pool就会创建新的worker线程，当worker线程处于idle的时候，也不会立即销毁它，而是保持一段时间，如果这时候有创建新的worker需求的时候，那么直接wakeup idle的worker即可，一段时间过去仍然没有需要处理的work，那么该worker thread将会被销毁</p>
<h3 id="CMWQ相关结构体"><a href="#CMWQ相关结构体" class="headerlink" title="CMWQ相关结构体"></a>CMWQ相关结构体</h3><p>worker thread pool使用<code>struct worker_pool</code>结构体用来描述</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/workqueue.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Structure fields follow one of the following exclusion rules.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * I: Modifiable by initialization/destruction paths and read-only for</span></span><br><span class="line"><span class="comment"> *    everyone else.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * P: Preemption protected.  Disabling preemption is enough and should</span></span><br><span class="line"><span class="comment"> *    only be modified and accessed from the local cpu.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * L: pool-&gt;lock protected.  Access with pool-&gt;lock held.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * X: During normal operation, modification requires pool-&gt;lock and should</span></span><br><span class="line"><span class="comment"> *    be done only from local cpu.  Either disabling preemption on local</span></span><br><span class="line"><span class="comment"> *    cpu or grabbing pool-&gt;lock is enough for read access.  If</span></span><br><span class="line"><span class="comment"> *    POOL_DISASSOCIATED is set, it&#x27;s identical to L.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * A: wq_pool_attach_mutex protected.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * PL: wq_pool_mutex protected.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * PR: wq_pool_mutex protected for writes.  RCU protected for reads.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * PW: wq_pool_mutex and wq-&gt;mutex protected for writes.  Either for reads.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * PWR: wq_pool_mutex and wq-&gt;mutex protected for writes.  Either or</span></span><br><span class="line"><span class="comment"> *      RCU for reads.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * WQ: wq-&gt;mutex protected.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * WR: wq-&gt;mutex protected for writes.  RCU protected for reads.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * MD: wq_mayday_lock protected.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">worker_pool</span> &#123;</span></span><br><span class="line">	<span class="keyword">raw_spinlock_t</span>		lock;		<span class="comment">/* the pool lock */</span></span><br><span class="line">	<span class="keyword">int</span>			cpu;		<span class="comment">/* I: the associated cpu */</span></span><br><span class="line">	<span class="keyword">int</span>			node;		<span class="comment">/* I: the associated node ID */</span></span><br><span class="line">	<span class="keyword">int</span>			id;		<span class="comment">/* I: pool ID */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		flags;		<span class="comment">/* X: flags */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		watchdog_ts;	<span class="comment">/* L: watchdog timestamp */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The counter is incremented in a process context on the associated CPU</span></span><br><span class="line"><span class="comment">	 * w/ preemption disabled, and decremented or reset in the same context</span></span><br><span class="line"><span class="comment">	 * but w/ pool-&gt;lock held. The readers grab pool-&gt;lock and are</span></span><br><span class="line"><span class="comment">	 * guaranteed to see if the counter reached zero.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">int</span>			nr_running;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">worklist</span>;</span>	<span class="comment">/* L: list of pending works */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span>			nr_workers;	<span class="comment">/* L: total number of workers */</span></span><br><span class="line">	<span class="keyword">int</span>			nr_idle;	<span class="comment">/* L: currently idle workers */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">idle_list</span>;</span>	<span class="comment">/* L: list of idle workers */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span>	<span class="title">idle_timer</span>;</span>	<span class="comment">/* L: worker idle timeout */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span>	<span class="title">mayday_timer</span>;</span>	<span class="comment">/* L: SOS timer for workers */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* a workers is either on busy_hash or idle_list, or the manager */</span></span><br><span class="line">	DECLARE_HASHTABLE(busy_hash, BUSY_WORKER_HASH_ORDER);</span><br><span class="line">						<span class="comment">/* L: hash of busy workers */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">worker</span>		*<span class="title">manager</span>;</span>	<span class="comment">/* L: purely informational */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">workers</span>;</span>	<span class="comment">/* A: attached workers */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">completion</span>	*<span class="title">detach_completion</span>;</span> <span class="comment">/* all workers detached */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ida</span>		<span class="title">worker_ida</span>;</span>	<span class="comment">/* worker IDs for task name */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">workqueue_attrs</span>	*<span class="title">attrs</span>;</span>		<span class="comment">/* I: worker attributes */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span>	<span class="title">hash_node</span>;</span>	<span class="comment">/* PL: unbound_pool_hash node */</span></span><br><span class="line">	<span class="keyword">int</span>			refcnt;		<span class="comment">/* PL: refcnt for unbound pools */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Destruction of pool is RCU protected to allow dereferences</span></span><br><span class="line"><span class="comment">	 * from get_work_pool().</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span>		<span class="title">rcu</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>工作队列的工作任务是用<code>struct work_struct</code>描述的，是工作队列处理工作任务的最小单位</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 回调函数的定义</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">work_func_t</span>)</span><span class="params">(struct work_struct *work)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">atomic_long_t</span> data;</span><br><span class="line">  <span class="comment">// 将工作任务链接起来</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">entry</span>;</span></span><br><span class="line">  <span class="comment">// 处理工作任务的回调函数</span></span><br><span class="line">	<span class="keyword">work_func_t</span> func;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_LOCKDEP</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">lockdep_map</span> <span class="title">lockdep_map</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>pool_workqueue结构体，连接workqueue和worker pool的中介</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The per-pool workqueue.  While queued, the lower WORK_STRUCT_FLAG_BITS</span></span><br><span class="line"><span class="comment"> * of work_struct-&gt;data are used for flags and the remaining high bits</span></span><br><span class="line"><span class="comment"> * point to the pwq; thus, pwqs need to be aligned at two&#x27;s power of the</span></span><br><span class="line"><span class="comment"> * number of flag bits.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pool_workqueue</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">worker_pool</span>	*<span class="title">pool</span>;</span>		<span class="comment">/* I: the associated pool */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">workqueue_struct</span> *<span class="title">wq</span>;</span>		<span class="comment">/* I: the owning workqueue */</span></span><br><span class="line">	<span class="keyword">int</span>			work_color;	<span class="comment">/* L: current color */</span></span><br><span class="line">	<span class="keyword">int</span>			flush_color;	<span class="comment">/* L: flushing color */</span></span><br><span class="line">	<span class="keyword">int</span>			refcnt;		<span class="comment">/* L: reference count */</span></span><br><span class="line">	<span class="keyword">int</span>			nr_in_flight[WORK_NR_COLORS];</span><br><span class="line">						<span class="comment">/* L: nr of in_flight works */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * nr_active management and WORK_STRUCT_INACTIVE:</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * When pwq-&gt;nr_active &gt;= max_active, new work item is queued to</span></span><br><span class="line"><span class="comment">	 * pwq-&gt;inactive_works instead of pool-&gt;worklist and marked with</span></span><br><span class="line"><span class="comment">	 * WORK_STRUCT_INACTIVE.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * All work items marked with WORK_STRUCT_INACTIVE do not participate</span></span><br><span class="line"><span class="comment">	 * in pwq-&gt;nr_active and all work items in pwq-&gt;inactive_works are</span></span><br><span class="line"><span class="comment">	 * marked with WORK_STRUCT_INACTIVE.  But not all WORK_STRUCT_INACTIVE</span></span><br><span class="line"><span class="comment">	 * work items are in pwq-&gt;inactive_works.  Some of them are ready to</span></span><br><span class="line"><span class="comment">	 * run in pool-&gt;worklist or worker-&gt;scheduled.  Those work itmes are</span></span><br><span class="line"><span class="comment">	 * only struct wq_barrier which is used for flush_work() and should</span></span><br><span class="line"><span class="comment">	 * not participate in pwq-&gt;nr_active.  For non-barrier work item, it</span></span><br><span class="line"><span class="comment">	 * is marked with WORK_STRUCT_INACTIVE iff it is in pwq-&gt;inactive_works.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">int</span>			nr_active;	<span class="comment">/* L: nr of active works */</span></span><br><span class="line">	<span class="keyword">int</span>			max_active;	<span class="comment">/* L: max active works */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">inactive_works</span>;</span>	<span class="comment">/* L: inactive works */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">pwqs_node</span>;</span>	<span class="comment">/* WR: node on wq-&gt;pwqs */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">mayday_node</span>;</span>	<span class="comment">/* MD: node on wq-&gt;maydays */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Release of unbound pwq is punted to system_wq.  See put_pwq()</span></span><br><span class="line"><span class="comment">	 * and pwq_unbound_release_workfn() for details.  pool_workqueue</span></span><br><span class="line"><span class="comment">	 * itself is also RCU protected so that the first pwq can be</span></span><br><span class="line"><span class="comment">	 * determined without grabbing wq-&gt;mutex.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span>	<span class="title">unbound_release_work</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span>		<span class="title">rcu</span>;</span></span><br><span class="line">&#125; __aligned(<span class="number">1</span> &lt;&lt; WORK_STRUCT_FLAG_BITS);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>workqueue使用workqueue_struct结构体来实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The externally visible workqueue.  It relays the issued work items to</span></span><br><span class="line"><span class="comment"> * the appropriate worker_pool through its pool_workqueues.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">workqueue_struct</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">pwqs</span>;</span>		<span class="comment">/* WR: all pwqs of this wq */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">list</span>;</span>		<span class="comment">/* PR: list of all workqueues */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>		<span class="title">mutex</span>;</span>		<span class="comment">/* protects this wq */</span></span><br><span class="line">	<span class="keyword">int</span>			work_color;	<span class="comment">/* WQ: current work color */</span></span><br><span class="line">	<span class="keyword">int</span>			flush_color;	<span class="comment">/* WQ: current flush color */</span></span><br><span class="line">	<span class="keyword">atomic_t</span>		nr_pwqs_to_flush; <span class="comment">/* flush in progress */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">wq_flusher</span>	*<span class="title">first_flusher</span>;</span>	<span class="comment">/* WQ: first flusher */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">flusher_queue</span>;</span>	<span class="comment">/* WQ: flush waiters */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">flusher_overflow</span>;</span> <span class="comment">/* WQ: flush overflow list */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">maydays</span>;</span>	<span class="comment">/* MD: pwqs requesting rescue */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">worker</span>		*<span class="title">rescuer</span>;</span>	<span class="comment">/* MD: rescue worker */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span>			nr_drainers;	<span class="comment">/* WQ: drain in progress */</span></span><br><span class="line">	<span class="keyword">int</span>			saved_max_active; <span class="comment">/* WQ: saved pwq max_active */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">workqueue_attrs</span>	*<span class="title">unbound_attrs</span>;</span>	<span class="comment">/* PW: only for unbound wqs */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pool_workqueue</span>	*<span class="title">dfl_pwq</span>;</span>	<span class="comment">/* PW: only for unbound wqs */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SYSFS</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">wq_device</span>	*<span class="title">wq_dev</span>;</span>	<span class="comment">/* I: for sysfs interface */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_LOCKDEP</span></span><br><span class="line">	<span class="keyword">char</span>			*lock_name;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span>	<span class="title">key</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">lockdep_map</span>	<span class="title">lockdep_map</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">char</span>			name[WQ_NAME_LEN]; <span class="comment">/* I: workqueue name */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Destruction of workqueue_struct is RCU protected to allow walking</span></span><br><span class="line"><span class="comment">	 * the workqueues list without grabbing wq_pool_mutex.</span></span><br><span class="line"><span class="comment">	 * This is used to dump all workqueues from sysrq.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span>		<span class="title">rcu</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* hot fields used during command issue, aligned to cacheline */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		flags ____cacheline_aligned; <span class="comment">/* WQ: WQ_* flags */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pool_workqueue</span> __<span class="title">percpu</span> *<span class="title">cpu_pwqs</span>;</span> <span class="comment">/* I: per-cpu pwqs */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pool_workqueue</span> __<span class="title">rcu</span> *<span class="title">numa_pwq_tbl</span>[];</span> <span class="comment">/* PWR: unbound pwqs indexed by node */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>list: 系统中所有的workqueue会挂入到一个全局链表<code>static LIST_HEAD(workqueues);</code></li>
<li>cpu_pwqs：percpu workqueue指向percpu的pool_workqueue数据结构，用来维护workqueue和percpu thread pool之间的关系，每个CPU都有两个thread pool，normal和高优先级的线程池，cpu_pwqs指向哪一个pool_workqueue是和workqueue的flags相关的，如果标记有WQ_HIGHPRI，那么cpu_pwqs指向高优先级的线程池</li>
</ul>
<h3 id="woker-pool初始化"><a href="#woker-pool初始化" class="headerlink" title="woker pool初始化"></a>woker pool初始化</h3><p>CMWQ对worker pool分成了两类：</p>
<ul>
<li>percpu worker pool，给通用的workqueue使用，系统的规划是每个CPU创建两个worker pool，一个普通优先级(nice &#x3D; 0)，一个高优先级(nice &#x3D; HIGHPRI_NICE_LEVEL)，对应创建出来的worker线程nice值不一样</li>
<li>unbound woker pool，给WQ_UNBOUND类型的workqueue使用，unbound worker pool中的worer可以在多个CPU上调度，</li>
</ul>
<p>workqueue子系统的初始化分为两个阶段，<code>workqueue_init_early()</code>在<code>start_kernel()</code>中调用，在这个阶段主要是做一些基本的初始化工作，例如对percpu worker thread pool的一些基本初始化</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/workqueue.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里给定义了一个长度为2的worker_pool数组，即percpu worker pool</span></span><br><span class="line"><span class="comment">// 普通优先级的worker pool为worker_pool[0]</span></span><br><span class="line"><span class="comment">// 高优先级的worker pool为worker_pool[1]</span></span><br><span class="line"><span class="comment">/* the per-cpu worker pools */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">DEFINE_PER_CPU_SHARED_ALIGNED</span><span class="params">(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在workqueue_init_early()中会对percpu worker pool进行初始化工作</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * workqueue_init_early - early init for workqueue subsystem</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This is the first half of two-staged workqueue subsystem initialization</span></span><br><span class="line"><span class="comment"> * and invoked as soon as the bare basics - memory allocation, cpumasks and</span></span><br><span class="line"><span class="comment"> * idr are up.  It sets up all the data structures and system workqueues</span></span><br><span class="line"><span class="comment"> * and allows early boot code to create workqueues and queue/cancel work</span></span><br><span class="line"><span class="comment"> * items.  Actual work item execution starts only after kthreads can be</span></span><br><span class="line"><span class="comment"> * created and scheduled right before early initcalls.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> __init <span class="title">workqueue_init_early</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> std_nice[NR_STD_WORKER_POOLS] = &#123; <span class="number">0</span>, HIGHPRI_NICE_LEVEL &#125;;</span><br><span class="line">	<span class="keyword">int</span> i, cpu;</span><br><span class="line"></span><br><span class="line">	BUILD_BUG_ON(__alignof__(struct pool_workqueue) &lt; __alignof__(<span class="keyword">long</span> <span class="keyword">long</span>));</span><br><span class="line"></span><br><span class="line">	BUG_ON(!alloc_cpumask_var(&amp;wq_unbound_cpumask, GFP_KERNEL));</span><br><span class="line">	cpumask_copy(wq_unbound_cpumask, housekeeping_cpumask(HK_TYPE_WQ));</span><br><span class="line">	cpumask_and(wq_unbound_cpumask, wq_unbound_cpumask, housekeeping_cpumask(HK_TYPE_DOMAIN));</span><br><span class="line"></span><br><span class="line">	pwq_cache = KMEM_CACHE(pool_workqueue, SLAB_PANIC);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* initialize CPU pools */</span></span><br><span class="line">	for_each_possible_cpu(cpu) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">worker_pool</span> *<span class="title">pool</span>;</span></span><br><span class="line"></span><br><span class="line">		i = <span class="number">0</span>;</span><br><span class="line">		for_each_cpu_worker_pool(pool, cpu) &#123;</span><br><span class="line">			<span class="comment">// init_worker_pool()主要是对percpu worker_pool的成员进行初步初始化</span></span><br><span class="line">			BUG_ON(init_worker_pool(pool));</span><br><span class="line">			pool-&gt;cpu = cpu;</span><br><span class="line">			cpumask_copy(pool-&gt;attrs-&gt;cpumask, cpumask_of(cpu));</span><br><span class="line">			pool-&gt;attrs-&gt;nice = std_nice[i++];</span><br><span class="line">			pool-&gt;node = cpu_to_node(cpu);</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* alloc pool ID */</span></span><br><span class="line">			mutex_lock(&amp;wq_pool_mutex);</span><br><span class="line">			BUG_ON(worker_pool_assign_id(pool));</span><br><span class="line">			mutex_unlock(&amp;wq_pool_mutex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* create default unbound and ordered wq attrs */</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NR_STD_WORKER_POOLS; i++) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">workqueue_attrs</span> *<span class="title">attrs</span>;</span></span><br><span class="line"></span><br><span class="line">		BUG_ON(!(attrs = alloc_workqueue_attrs()));</span><br><span class="line">		<span class="comment">// 默认普通优先级worker pool的nice值为0</span></span><br><span class="line">		<span class="comment">// 高优先级的worker pool的nice值为-20</span></span><br><span class="line">		attrs-&gt;nice = std_nice[i];</span><br><span class="line">		unbound_std_wq_attrs[i] = attrs;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * An ordered wq should have only one pwq as ordering is</span></span><br><span class="line"><span class="comment">		 * guaranteed by max_active which is enforced by pwqs.</span></span><br><span class="line"><span class="comment">		 * Turn off NUMA so that dfl_pwq is used for all nodes.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		BUG_ON(!(attrs = alloc_workqueue_attrs()));</span><br><span class="line">		attrs-&gt;nice = std_nice[i];</span><br><span class="line">		attrs-&gt;no_numa = <span class="literal">true</span>;</span><br><span class="line">		ordered_wq_attrs[i] = attrs;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 系统创建了一些默认的workqueue以供使用</span></span><br><span class="line">	system_wq = alloc_workqueue(<span class="string">&quot;events&quot;</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	system_highpri_wq = alloc_workqueue(<span class="string">&quot;events_highpri&quot;</span>, WQ_HIGHPRI, <span class="number">0</span>);</span><br><span class="line">	system_long_wq = alloc_workqueue(<span class="string">&quot;events_long&quot;</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	system_unbound_wq = alloc_workqueue(<span class="string">&quot;events_unbound&quot;</span>, WQ_UNBOUND,</span><br><span class="line">					    WQ_UNBOUND_MAX_ACTIVE);</span><br><span class="line">	system_freezable_wq = alloc_workqueue(<span class="string">&quot;events_freezable&quot;</span>,</span><br><span class="line">					      WQ_FREEZABLE, <span class="number">0</span>);</span><br><span class="line">	system_power_efficient_wq = alloc_workqueue(<span class="string">&quot;events_power_efficient&quot;</span>,</span><br><span class="line">					      WQ_POWER_EFFICIENT, <span class="number">0</span>);</span><br><span class="line">	system_freezable_power_efficient_wq = alloc_workqueue(<span class="string">&quot;events_freezable_power_efficient&quot;</span>,</span><br><span class="line">					      WQ_FREEZABLE | WQ_POWER_EFFICIENT,</span><br><span class="line">					      <span class="number">0</span>);</span><br><span class="line">	BUG_ON(!system_wq || !system_highpri_wq || !system_long_wq ||</span><br><span class="line">	       !system_unbound_wq || !system_freezable_wq ||</span><br><span class="line">	       !system_power_efficient_wq ||</span><br><span class="line">	       !system_freezable_power_efficient_wq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>workqueue第二阶段的初始化，经过这一阶段的初始化，workqueue就能正常使用了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * workqueue_init - bring workqueue subsystem fully online</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This is the latter half of two-staged workqueue subsystem initialization</span></span><br><span class="line"><span class="comment"> * and invoked as soon as kthreads can be created and scheduled.</span></span><br><span class="line"><span class="comment"> * Workqueues have been created and work items queued on them, but there</span></span><br><span class="line"><span class="comment"> * are no kworkers executing the work items yet.  Populate the worker pools</span></span><br><span class="line"><span class="comment"> * with the initial workers and enable future kworker creations.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> __init <span class="title">workqueue_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">workqueue_struct</span> *<span class="title">wq</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">worker_pool</span> *<span class="title">pool</span>;</span></span><br><span class="line">	<span class="keyword">int</span> cpu, bkt;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * It&#x27;d be simpler to initialize NUMA in workqueue_init_early() but</span></span><br><span class="line"><span class="comment">	 * CPU to node mapping may not be available that early on some</span></span><br><span class="line"><span class="comment">	 * archs such as power and arm64.  As per-cpu pools created</span></span><br><span class="line"><span class="comment">	 * previously could be missing node hint and unbound pools NUMA</span></span><br><span class="line"><span class="comment">	 * affinity, fix them up.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Also, while iterating workqueues, create rescuers if requested.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	wq_numa_init();</span><br><span class="line"></span><br><span class="line">	mutex_lock(&amp;wq_pool_mutex);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 对于非NUMA架构的CPU这个node固定为0</span></span><br><span class="line">	for_each_possible_cpu(cpu) &#123;</span><br><span class="line">		for_each_cpu_worker_pool(pool, cpu) &#123;</span><br><span class="line">			pool-&gt;node = cpu_to_node(cpu);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	list_for_each_entry(wq, &amp;workqueues, <span class="built_in">list</span>) &#123;</span><br><span class="line">		wq_update_unbound_numa(wq, smp_processor_id(), <span class="literal">true</span>);</span><br><span class="line">		WARN(init_rescuer(wq),</span><br><span class="line">		     <span class="string">&quot;workqueue: failed to create early rescuer for %s&quot;</span>,</span><br><span class="line">		     wq-&gt;name);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	mutex_unlock(&amp;wq_pool_mutex);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* create the initial workers */</span></span><br><span class="line">	<span class="comment">// 针对percpu worker thread pool创建一个worker</span></span><br><span class="line">	for_each_online_cpu(cpu) &#123;</span><br><span class="line">		for_each_cpu_worker_pool(pool, cpu) &#123;</span><br><span class="line">			pool-&gt;flags &amp;= ~POOL_DISASSOCIATED;</span><br><span class="line">			BUG_ON(!create_worker(pool));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// unbound woker pool也需要创建一个worker</span></span><br><span class="line">	hash_for_each(unbound_pool_hash, bkt, pool, hash_node)</span><br><span class="line">		BUG_ON(!create_worker(pool));</span><br><span class="line"></span><br><span class="line">	wq_online = <span class="literal">true</span>;</span><br><span class="line">	wq_watchdog_init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来分析一下worker的创建过程</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * create_worker - create a new workqueue worker</span></span><br><span class="line"><span class="comment"> * @pool: pool the new worker will belong to</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Create and start a new worker which is attached to @pool.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * CONTEXT:</span></span><br><span class="line"><span class="comment"> * Might sleep.  Does GFP_KERNEL allocations.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return:</span></span><br><span class="line"><span class="comment"> * Pointer to the newly created worker.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct worker *<span class="title">create_worker</span><span class="params">(struct worker_pool *pool)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">worker</span> *<span class="title">worker</span>;</span></span><br><span class="line">	<span class="keyword">int</span> id;</span><br><span class="line">	<span class="keyword">char</span> id_buf[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* ID is needed to determine kthread name */</span></span><br><span class="line">	<span class="comment">// 这里用到了ida的分配机制</span></span><br><span class="line">	id = ida_alloc(&amp;pool-&gt;worker_ida, GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (id &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 为worker分配内存，进行一些成员的初始化</span></span><br><span class="line">	<span class="comment">// 这里分配内存使用到了kzalloc_node()实际也是为numa考虑的</span></span><br><span class="line">	worker = alloc_worker(pool-&gt;node);</span><br><span class="line">	<span class="keyword">if</span> (!worker)</span><br><span class="line">		<span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">	worker-&gt;id = id;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 线程名</span></span><br><span class="line">	<span class="keyword">if</span> (pool-&gt;cpu &gt;= <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">snprintf</span>(id_buf, <span class="keyword">sizeof</span>(id_buf), <span class="string">&quot;%d:%d%s&quot;</span>, pool-&gt;cpu, id,</span><br><span class="line">			 pool-&gt;attrs-&gt;nice &lt; <span class="number">0</span>  ? <span class="string">&quot;H&quot;</span> : <span class="string">&quot;&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">snprintf</span>(id_buf, <span class="keyword">sizeof</span>(id_buf), <span class="string">&quot;u%d:%d&quot;</span>, pool-&gt;id, id);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建线程，线程函数worker_thread</span></span><br><span class="line">	worker-&gt;task = kthread_create_on_node(worker_thread, worker, pool-&gt;node,</span><br><span class="line">					      <span class="string">&quot;kworker/%s&quot;</span>, id_buf);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(worker-&gt;task))</span><br><span class="line">		<span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">	set_user_nice(worker-&gt;task, pool-&gt;attrs-&gt;nice);</span><br><span class="line">	kthread_bind_mask(worker-&gt;task, pool-&gt;attrs-&gt;cpumask);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* successful, attach the worker to the pool */</span></span><br><span class="line">	<span class="comment">// 将worker挂到worker pool的workers链表下</span></span><br><span class="line">	worker_attach_to_pool(worker, pool);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* start the newly created worker */</span></span><br><span class="line">	raw_spin_lock_irq(&amp;pool-&gt;lock);</span><br><span class="line">	worker-&gt;pool-&gt;nr_workers++;</span><br><span class="line">	worker_enter_idle(worker);</span><br><span class="line">	wake_up_process(worker-&gt;task);</span><br><span class="line">	raw_spin_unlock_irq(&amp;pool-&gt;lock);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> worker;</span><br><span class="line"></span><br><span class="line">fail:</span><br><span class="line">	ida_free(&amp;pool-&gt;worker_ida, id);</span><br><span class="line">	kfree(worker);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于unbind workqueue的功耗节省：当workqueue收到一个要处理的work，如果该workqueue是unbound类型的话，那么该work由unbound thread pool处理并调度执行的策略交给系统的调度器模块来完成，对于scheduler而言，它会考虑CPU的idle状态，从而尽可能让CPU保持在idle状态，从而节省能耗。因此，如果一个workqueue有WQ_UNBOUND这样的flag，则说明该workqueue上挂入的work处理是考虑到power saving的。如果workqueue没有WQ_UNBOUND flag，则说明该workqueue是percpu的，这时候，调度哪一个CPU运行worker thread来处理work已经不是scheduler可以控制的了，这样，也就间接影响了功耗。</p>
<h3 id="workqueue创建过程"><a href="#workqueue创建过程" class="headerlink" title="workqueue创建过程"></a>workqueue创建过程</h3><p>workqueue的创建过程<code>alloc_workqueue()</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/workqueue.c</span></span><br><span class="line"><span class="function">struct workqueue_struct *<span class="title">alloc_workqueue</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *fmt,</span></span></span><br><span class="line"><span class="params"><span class="function">					 <span class="keyword">unsigned</span> <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">					 <span class="keyword">int</span> max_active, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">size_t</span> tbl_size = <span class="number">0</span>;</span><br><span class="line">	va_list args;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">workqueue_struct</span> *<span class="title">wq</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pool_workqueue</span> *<span class="title">pwq</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Unbound &amp;&amp; max_active == 1 used to imply ordered, which is no</span></span><br><span class="line"><span class="comment">	 * longer the case on NUMA machines due to per-node pools.  While</span></span><br><span class="line"><span class="comment">	 * alloc_ordered_workqueue() is the right way to create an ordered</span></span><br><span class="line"><span class="comment">	 * workqueue, keep the previous behavior to avoid subtle breakages</span></span><br><span class="line"><span class="comment">	 * on NUMA.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> ((flags &amp; WQ_UNBOUND) &amp;&amp; max_active == <span class="number">1</span>)</span><br><span class="line">		flags |= __WQ_ORDERED;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* see the comment above the definition of WQ_POWER_EFFICIENT */</span></span><br><span class="line">	<span class="comment">// 这里WQ_POWER_EFFICIENT标志和workqueue.power_efficient这个内核参数都可以让</span></span><br><span class="line">	<span class="comment">// workqueue编程unbind workqueue从而降低能耗</span></span><br><span class="line">	<span class="keyword">if</span> ((flags &amp; WQ_POWER_EFFICIENT) &amp;&amp; wq_power_efficient)</span><br><span class="line">		flags |= WQ_UNBOUND;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* allocate wq and format name */</span></span><br><span class="line">	<span class="comment">// 这里涉及到在NUMA中unbound workqueue的work thread在不同node之间迁移的问题</span></span><br><span class="line">	<span class="comment">// 在NUMA中，CPU访问不同node中的内存，访问速度是相差很大的</span></span><br><span class="line">	<span class="comment">// 实际上unbound workqueue实际上是创建了per node的pool_workqueue</span></span><br><span class="line">	<span class="keyword">if</span> (flags &amp; WQ_UNBOUND)</span><br><span class="line">		tbl_size = nr_node_ids * <span class="keyword">sizeof</span>(wq-&gt;numa_pwq_tbl[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">	wq = kzalloc(<span class="keyword">sizeof</span>(*wq) + tbl_size, GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!wq)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// unbound_attrs属性是给unbound workqueue来决定work的的分配的</span></span><br><span class="line">	<span class="keyword">if</span> (flags &amp; WQ_UNBOUND) &#123;</span><br><span class="line">		wq-&gt;unbound_attrs = alloc_workqueue_attrs();</span><br><span class="line">		<span class="keyword">if</span> (!wq-&gt;unbound_attrs)</span><br><span class="line">			<span class="keyword">goto</span> err_free_wq;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 这里是取max_active后面的参数用来给workqueue取名字</span></span><br><span class="line">	va_start(args, max_active);</span><br><span class="line">	vsnprintf(wq-&gt;name, <span class="keyword">sizeof</span>(wq-&gt;name), fmt, args);</span><br><span class="line">	va_end(args);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// max_active限制最大可以创建的worker thread的数目</span></span><br><span class="line">	<span class="comment">// 对于percpu workqueue最大可创建的worker thread是WQ_MAX_ACTIVE（512）</span></span><br><span class="line">	<span class="comment">// 对于unbound workqueue最大可创建的worker thread是CPU核心数的4倍WQ_UNBOUND_MAX_ACTIVE</span></span><br><span class="line">	max_active = max_active ?: WQ_DFL_ACTIVE;</span><br><span class="line">	max_active = wq_clamp_max_active(max_active, flags, wq-&gt;name);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* init wq */</span></span><br><span class="line">	<span class="comment">// 初始化workqueue的其他成员</span></span><br><span class="line">	wq-&gt;flags = flags;</span><br><span class="line">	wq-&gt;saved_max_active = max_active;</span><br><span class="line">	mutex_init(&amp;wq-&gt;mutex);</span><br><span class="line">	atomic_set(&amp;wq-&gt;nr_pwqs_to_flush, <span class="number">0</span>);</span><br><span class="line">	INIT_LIST_HEAD(&amp;wq-&gt;pwqs);</span><br><span class="line">	INIT_LIST_HEAD(&amp;wq-&gt;flusher_queue);</span><br><span class="line">	INIT_LIST_HEAD(&amp;wq-&gt;flusher_overflow);</span><br><span class="line">	INIT_LIST_HEAD(&amp;wq-&gt;maydays);</span><br><span class="line"></span><br><span class="line">	wq_init_lockdep(wq);</span><br><span class="line">	INIT_LIST_HEAD(&amp;wq-&gt;<span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (alloc_and_link_pwqs(wq) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> err_unreg_lockdep;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (wq_online &amp;&amp; init_rescuer(wq) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> err_destroy;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((wq-&gt;flags &amp; WQ_SYSFS) &amp;&amp; workqueue_sysfs_register(wq))</span><br><span class="line">		<span class="keyword">goto</span> err_destroy;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * wq_pool_mutex protects global freeze state and workqueues list.</span></span><br><span class="line"><span class="comment">	 * Grab it, adjust max_active and add the new @wq to workqueues</span></span><br><span class="line"><span class="comment">	 * list.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	mutex_lock(&amp;wq_pool_mutex);</span><br><span class="line"></span><br><span class="line">	mutex_lock(&amp;wq-&gt;mutex);</span><br><span class="line">	for_each_pwq(pwq, wq)</span><br><span class="line">		pwq_adjust_max_active(pwq);</span><br><span class="line">	mutex_unlock(&amp;wq-&gt;mutex);</span><br><span class="line"></span><br><span class="line">	list_add_tail_rcu(&amp;wq-&gt;<span class="built_in">list</span>, &amp;workqueues);</span><br><span class="line"></span><br><span class="line">	mutex_unlock(&amp;wq_pool_mutex);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> wq;</span><br><span class="line"></span><br><span class="line">err_unreg_lockdep:</span><br><span class="line">	wq_unregister_lockdep(wq);</span><br><span class="line">	wq_free_lockdep(wq);</span><br><span class="line">err_free_wq:</span><br><span class="line">	free_workqueue_attrs(wq-&gt;unbound_attrs);</span><br><span class="line">	kfree(wq);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">err_destroy:</span><br><span class="line">	destroy_workqueue(wq);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(alloc_workqueue);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 分配pool workqueue的内存，建立workqueue和pool workqueue的关系</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">alloc_and_link_pwqs</span><span class="params">(struct workqueue_struct *wq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">bool</span> highpri = wq-&gt;flags &amp; WQ_HIGHPRI;</span><br><span class="line">	<span class="keyword">int</span> cpu, ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// percpu workqueue的处理</span></span><br><span class="line">	<span class="keyword">if</span> (!(wq-&gt;flags &amp; WQ_UNBOUND)) &#123;</span><br><span class="line">		<span class="comment">// 为percpu workqueue分配一个pool_workqueue(用来连接worker pool和workqueue)</span></span><br><span class="line">		wq-&gt;cpu_pwqs = alloc_percpu(struct pool_workqueue);</span><br><span class="line">		<span class="keyword">if</span> (!wq-&gt;cpu_pwqs)</span><br><span class="line">			<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">		for_each_possible_cpu(cpu) &#123;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">pool_workqueue</span> *<span class="title">pwq</span> =</span></span><br><span class="line">				per_cpu_ptr(wq-&gt;cpu_pwqs, cpu);</span><br><span class="line">			<span class="comment">// 每个pool_workqueue都有一个对应的worker thread pool</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">worker_pool</span> *<span class="title">cpu_pools</span> =</span></span><br><span class="line">				per_cpu(cpu_worker_pools, cpu);</span><br><span class="line">			<span class="comment">// 初始化pool_workqueue</span></span><br><span class="line">			<span class="comment">// 最重要的是设置其对应的workqueue和woker_pool</span></span><br><span class="line">			<span class="comment">// 在这里pool_workqueue和woker pool，workqueue关联上了</span></span><br><span class="line">			init_pwq(pwq, wq, &amp;cpu_pools[highpri]);</span><br><span class="line"></span><br><span class="line">			mutex_lock(&amp;wq-&gt;mutex);</span><br><span class="line">			<span class="comment">// link_pwq主要是将pool_workqueue挂入它所属的workqueue链表中</span></span><br><span class="line">			link_pwq(pwq);</span><br><span class="line">			mutex_unlock(&amp;wq-&gt;mutex);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cpus_read_lock();</span><br><span class="line">	<span class="keyword">if</span> (wq-&gt;flags &amp; __WQ_ORDERED) &#123;</span><br><span class="line">		ret = apply_workqueue_attrs(wq, ordered_wq_attrs[highpri]);</span><br><span class="line">		<span class="comment">/* there should only be single pwq for ordering guarantee */</span></span><br><span class="line">		WARN(!ret &amp;&amp; (wq-&gt;pwqs.next != &amp;wq-&gt;dfl_pwq-&gt;pwqs_node ||</span><br><span class="line">			      wq-&gt;pwqs.prev != &amp;wq-&gt;dfl_pwq-&gt;pwqs_node),</span><br><span class="line">		     <span class="string">&quot;ordering guarantee broken for workqueue %s\n&quot;</span>, wq-&gt;name);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		ret = apply_workqueue_attrs(wq, unbound_std_wq_attrs[highpri]);</span><br><span class="line">	&#125;</span><br><span class="line">	cpus_read_unlock();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每个pool_workqueue都有一个对应的worker thread pool</span></span><br><span class="line"><span class="comment">// 对于percpu workqueue这里静态定义了如下的cpu_worker_pools</span></span><br><span class="line"><span class="comment">/* the per-cpu worker pools */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">DEFINE_PER_CPU_SHARED_ALIGNED</span><span class="params">(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools)</span></span>;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>变参函数宏</p>
<ul>
<li>va_list：定义在编译器的头文件中</li>
<li>va_start(args, fmt)：根据参数fmt的地址，获取fmt后面的参数地址，并保存在args指针变量中</li>
<li>va_end(args)：释放args指针，将其值赋为NULL</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>workqueue</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux睡眠唤醒调试方法</title>
    <url>/archives/f183bd8.html</url>
    <content><![CDATA[<p>Linux中的挂起、休眠，一般是指以下四种状态：</p>
<ol>
<li>STI(suspend to idle)：是一种通用的、纯软件、轻量级系统睡眠状态</li>
<li>Standby(power-on suspend)：是一种适度的功耗节省状态，同时系统也可以比较快的唤醒</li>
<li>STR(suspend to ram)：提供了比较显著的功耗节省，系统中除了内存之外的部件都进入了低功耗状态</li>
<li>STD(suspend to disk)：提供最大程度的功耗节省<span id="more"></span></li>
</ol>
<table>
<thead>
<tr>
<th align="center">State</th>
<th align="center">ACPI state</th>
<th align="center">Label</th>
</tr>
</thead>
<tbody><tr>
<td align="center">STI</td>
<td align="center">S0</td>
<td align="center">s2idle&#x2F;freeze</td>
</tr>
<tr>
<td align="center">standby</td>
<td align="center">S1</td>
<td align="center">shallow&#x2F;standby</td>
</tr>
<tr>
<td align="center">STR</td>
<td align="center">S3</td>
<td align="center">deep</td>
</tr>
<tr>
<td align="center">STD</td>
<td align="center">S4</td>
<td align="center">disk</td>
</tr>
</tbody></table>
<blockquote>
<p>具体的状态描述可以参考内核文档<a href="https://www.kernel.org/doc/Documentation/power/states.txt">Documentation&#x2F;power&#x2F;states.txt</a></p>
</blockquote>
<h3 id="基础调试方法"><a href="#基础调试方法" class="headerlink" title="基础调试方法"></a>基础调试方法</h3><ol>
<li><p>关闭串口睡眠：在启动参数中增加<code>no_console_suspend ignore_loglevel</code>，S3调试日志如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@Ubuntu:~<span class="comment"># echo mem &gt; /sys/power/state</span></span><br><span class="line">[   74.403728] PM: <span class="built_in">suspend</span> entry (deep)</span><br><span class="line">[   74.411597] Filesystems sync: 0.004 seconds</span><br><span class="line">[   74.576746] Freezing user space processes ... (elapsed 0.003 seconds) <span class="keyword">done</span>.</span><br><span class="line">[   74.586948] OOM killer disabled.</span><br><span class="line">[   74.590196] Freezing remaining freezable tasks ... (elapsed 0.001 seconds) <span class="keyword">done</span>.</span><br><span class="line">[   74.604967] pcieport 0000:00:04.0: pciehp: Timeout on hotplug <span class="built_in">command</span> 0x1438 (issued 71912 msec ago)</span><br><span class="line">[   74.605025] pcieport 0000:00:05.0: pciehp: Timeout on hotplug <span class="built_in">command</span> 0x1438 (issued 71884 msec ago)</span><br><span class="line">[   74.617628] macb 3200c000.ethernet eth0: Link is Down</span><br><span class="line">[   74.629279] macb 3200c000.ethernet: gem-ptp-timer ptp clock unregistered.</span><br><span class="line">[   74.752892] pcieport 0000:00:01.0: pciehp: Timeout on hotplug <span class="built_in">command</span> 0x1438 (issued 72084 msec ago)</span><br><span class="line">[   76.636865] pcieport 0000:00:04.0: pciehp: Timeout on hotplug <span class="built_in">command</span> 0x0418 (issued 2020 msec ago)</span><br><span class="line">[   76.644855] pcieport 0000:00:05.0: pciehp: Timeout on hotplug <span class="built_in">command</span> 0x0418 (issued 2024 msec ago)</span><br><span class="line">[   76.784854] pcieport 0000:00:01.0: pciehp: Timeout on hotplug <span class="built_in">command</span> 0x0418 (issued 2024 msec ago)</span><br><span class="line">[   76.917236] Disabling non-boot CPUs ...</span><br></pre></td></tr></table></figure>
</li>
<li><p>在启动参数中加入<code>initcall_debug</code>，打印init函数的进入和返回log，可以定位哪个init函数运行失败或运行时间过长，S3调试日志如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@Ubuntu:~<span class="comment"># echo mem &gt; /sys/power/state</span></span><br><span class="line">[  409.072355] PM: <span class="built_in">suspend</span> entry (deep)</span><br><span class="line">[  409.087412] Filesystems sync: 0.011 seconds</span><br><span class="line">[  409.260860] Freezing user space processes ... (elapsed 0.003 seconds) <span class="keyword">done</span>.</span><br><span class="line">[  409.271298] OOM killer disabled.</span><br><span class="line">[  409.274561] Freezing remaining freezable tasks ... (elapsed 0.001 seconds) <span class="keyword">done</span>.</span><br><span class="line">[  409.284345] rtc rtc0: calling rtc_suspend+0x0/0x138 @ 840, parent: 0-0068</span><br><span class="line">[  409.291569] rtc rtc0: rtc_suspend+0x0/0x138 returned 0 after 317 usecs</span><br><span class="line">[  409.298209] mtd mtd1ro: calling mtd_cls_suspend+0x0/0x78 @ 840, parent: 10000000.lbc_nor</span><br><span class="line">[  409.306323] mtd mtd1ro: mtd_cls_suspend+0x0/0x78 returned 0 after 1 usecs</span><br><span class="line">[  409.313140] mtd mtd1: calling mtd_cls_suspend+0x0/0x78 @ 840, parent: 10000000.lbc_nor</span><br><span class="line">[  409.321075] mtd mtd1: mtd_cls_suspend+0x0/0x78 returned 0 after 1 usecs</span><br><span class="line">...</span><br><span class="line">[  412.886230] Disabling non-boot CPUs ...</span><br></pre></td></tr></table></figure>
</li>
<li><p>禁用异步suspend resume设备，排除设备驱动的pm问题<code>echo 0 &gt; /sys/power/pm_async</code>，在Linux异步对设备进行suspend resume时出现问题的情况下，可以禁用异步suspend resume来排查设备驱动pm问题</p>
</li>
</ol>
<h3 id="PM-DEBUG选项调试休眠唤醒"><a href="#PM-DEBUG选项调试休眠唤醒" class="headerlink" title="PM_DEBUG选项调试休眠唤醒"></a>PM_DEBUG选项调试休眠唤醒</h3><p>打开CONFIG_PM_DEBUG选项，使用<code>/sys/power/pm_test</code>来测试休眠、唤醒，pm_test里面一共有5种测试模式</p>
<ul>
<li>freezer：测试进程冻结</li>
<li>devices：测试进程冻结和设备驱动suspend和resume</li>
<li>platform：测试进程冻结、设备驱动suspend和resume、suspending platform global control methods</li>
<li>processors：测试进程冻结、设备驱动suspend resume、suspending platform global control methods、关闭nonboot CPU</li>
<li>core：测试进程冻结、设备驱动suspend resume、关闭nonboot CPU、suspending platform&#x2F;system devices</li>
</ul>
<p>使用该方法进行调试时，需要往<code>/sys/power/pm_test</code>中写入对应的测试模式，然后进行S3 S4休眠操作，休眠流程走完后，5秒后会自动唤醒系统，测试的时候可以从freezer devices platform…逐步进行测试</p>
<blockquote>
<p>详细描述可参考内核文档<a href="https://www.kernel.org/doc/Documentation/power/basic-pm-debugging.txt">basic-pm-debugging.txt</a></p>
</blockquote>
<p>freezer休眠唤醒调试日志</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@Ubuntu:/sys/power<span class="comment"># cat /proc/cmdline </span></span><br><span class="line">console=ttyAMA1,115200 audit=0 earlycon=pl011,0x2800d000 root=/dev/nvme0n1p2 rw no_console_suspend initcall_debug ignore_loglevel</span><br><span class="line">root@Ubuntu:/sys/power<span class="comment"># echo freezer &gt; pm_test</span></span><br><span class="line">root@Ubuntu:/sys/power<span class="comment"># echo mem &gt; state </span></span><br><span class="line">[ 1341.488023] PM: <span class="built_in">suspend</span> entry (deep)</span><br><span class="line">[ 1341.501723] Filesystems sync: 0.009 seconds</span><br><span class="line">[ 1341.624379] [drm] can not get n_m <span class="keyword">for</span> link_rate(270000) and sample_rate(0)</span><br><span class="line">[ 1341.779698] Freezing user space processes ... (elapsed 0.003 seconds) <span class="keyword">done</span>.</span><br><span class="line">[ 1341.790421] OOM killer disabled.</span><br><span class="line">[ 1341.793664] Freezing remaining freezable tasks ... (elapsed 0.001 seconds) <span class="keyword">done</span>.</span><br><span class="line">[ 1341.802539] PM: <span class="built_in">suspend</span> debug: Waiting <span class="keyword">for</span> 5 second(s).</span><br><span class="line">[ 1346.808159] OOM killer enabled.</span><br><span class="line">[ 1346.811304] Restarting tasks ... <span class="keyword">done</span>.</span><br><span class="line">[ 1346.817354] PM: <span class="built_in">suspend</span> <span class="built_in">exit</span></span><br><span class="line">root@Ubuntu:/sys/power<span class="comment"># </span></span><br></pre></td></tr></table></figure>

<p>devices休眠唤醒调试日志</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@Ubuntu:/sys/power<span class="comment"># cat /proc/cmdline </span></span><br><span class="line">console=ttyAMA1,115200 audit=0 earlycon=pl011,0x2800d000 root=/dev/nvme0n1p2 rw no_console_suspend initcall_debug loglevel=7</span><br><span class="line">root@Ubuntu:/sys/power<span class="comment"># echo devices &gt; pm_test</span></span><br><span class="line">root@Ubuntu:/sys/power<span class="comment"># echo mem &gt; state </span></span><br><span class="line"></span><br><span class="line">[ 1628.921417] PM: <span class="built_in">suspend</span> entry (deep)</span><br><span class="line">[ 1628.934839] Filesystems sync: 0.009 seconds</span><br><span class="line">[ 1629.066342] Freezing user space processes ... (elapsed 0.003 seconds) <span class="keyword">done</span>.</span><br><span class="line">[ 1629.076995] OOM killer disabled.</span><br><span class="line">[ 1629.080260] Freezing remaining freezable tasks ... (elapsed 0.001 seconds) <span class="keyword">done</span>.</span><br><span class="line">[ 1629.090074] rtc rtc0: calling rtc_suspend+0x0/0x138 @ 998, parent: 0-0068</span><br><span class="line">[ 1629.097263] rtc rtc0: rtc_suspend+0x0/0x138 returned 0 after 309 usecs</span><br><span class="line">[ 1629.103874] mtd mtd1ro: calling mtd_cls_suspend+0x0/0x78 @ 998, parent: 10000000.lbc_nor</span><br><span class="line">[ 1629.111983] mtd mtd1ro: mtd_cls_suspend+0x0/0x78 returned 0 after 0 usecs</span><br><span class="line">[ 1629.118818] mtd mtd1: calling mtd_cls_suspend+0x0/0x78 @ 998, parent: 10000000.lbc_nor</span><br><span class="line">[ 1629.126754] mtd mtd1: mtd_cls_suspend+0x0/0x78 returned 0 after 2 usecs</span><br><span class="line">...</span><br><span class="line">[ 1632.473232] PM: <span class="built_in">suspend</span> debug: Waiting <span class="keyword">for</span> 5 second(s).</span><br><span class="line">[ 1637.479347] reg-dummy reg-dummy: calling platform_pm_resume+0x0/0x60 @ 998, parent: platform</span><br><span class="line">[ 1637.487835] reg-dummy reg-dummy: platform_pm_resume+0x0/0x60 returned 0 after 0 usecs</span><br><span class="line">[ 1637.495697] regulator regulator.0: calling regulator_resume+0x0/0x190 @ 998, parent: reg-dummy</span><br><span class="line">[ 1637.504334] regulator regulator.0: regulator_resume+0x0/0x190 returned 0 after 1 usecs</span><br><span class="line">...</span><br><span class="line">[ 1639.619802] nvme 0000:01:00.0: pci_pm_resume+0x0/0xb8 returned 0 after 12 usecs</span><br><span class="line">[ 1639.628076] OOM killer enabled.</span><br><span class="line">[ 1639.631235] Restarting tasks ... <span class="keyword">done</span>.</span><br><span class="line">[ 1639.651582] PM: <span class="built_in">suspend</span> <span class="built_in">exit</span></span><br><span class="line">[ 1639.665907] nvme nvme0: Shutdown timeout <span class="built_in">set</span> to 8 seconds</span><br><span class="line">[ 1639.769959] nvme nvme0: 2/0/0 default/<span class="built_in">read</span>/poll queues</span><br><span class="line">[ 1641.640767] macb 3200c000.ethernet eth0: yt8521_read_status, phy addr: 0, link up, media: UTP, mii reg 0x11 = 0xbc00</span><br><span class="line">[ 1641.651931] macb 3200c000.ethernet eth0: unable to generate target frequency: 125000000 Hz</span><br><span class="line">[ 1641.661478] macb 3200c000.ethernet eth0: Link is Up - 1Gbps/Full - flow control off</span><br></pre></td></tr></table></figure>


<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>调试休眠和唤醒首先配置启动参数<code>no_console_suspend initcall_debug ignore_loglevel</code>，通过打印的日志信息基本上可以排查出问题原因</li>
<li>通过上面步骤无法排查出阻碍休眠的原因时，可以打开<code>CONFIG_PM_DEBUG</code>选项，往<code>/sys/power/pm_test</code>中写入freezer devices platform…逐步进行测试，观察哪个测试无法通过，可以对应查找问题</li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>suspend</tag>
      </tags>
  </entry>
</search>
